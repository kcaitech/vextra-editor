(function() {
    "use strict";
    try {
        if (typeof document != "undefined") {
            var elementStyle = document.createElement("style");
            elementStyle.appendChild(document.createTextNode('svg[data-v-9f4c1242] {\n  position: absolute;\n  transform-origin: top left;\n}.preview_container[data-v-d97f6210] {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  background-color: black;\n}\n.preview_container #proto_overflow[data-v-d97f6210] {\n  overflow: hidden;\n  transform-origin: top left;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n.preview_container .symref_animate[data-v-d97f6210] {\n  transform-origin: top left;\n  position: absolute;\n  overflow: visible;\n  left: 0;\n  top: 0;\n  opacity: 0;\n  pointer-events: none;\n  z-index: 19;\n}\n.preview_container .toggle[data-v-d97f6210] {\n  position: absolute;\n  left: 50%;\n  bottom: 10px;\n  transform: translateX(-50%);\n  display: flex;\n  align-items: center;\n  height: 24px;\n  box-sizing: border-box;\n  padding: 9px;\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, 0.9);\n  color: hsla(0, 0%, 100%, 0.9);\n  z-index: 100;\n}\n.preview_container .toggle .last[data-v-d97f6210] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 18px;\n  height: 18px;\n  cursor: pointer;\n}\n.preview_container .toggle .page[data-v-d97f6210] {\n  line-height: 16px;\n  font-size: 11px;\n  margin: 0 8px;\n  opacity: 0.7;\n}\n.preview_container .toggle .next[data-v-d97f6210] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 18px;\n  height: 18px;\n  cursor: pointer;\n}\n.preview_container .toggle svg[data-v-d97f6210] {\n  width: 14px;\n  height: 14px;\n}\n.disable[data-v-d97f6210] {\n  opacity: 0.5;\n  cursor: not-allowed !important;\n}\n.overlay[data-v-d97f6210] {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n.preview_overlay[data-v-d97f6210] {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  background-color: black;\n  pointer-events: none;\n  z-index: 20;\n}html,\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: var(--font-family);\n  position: relative;\n  overflow: hidden;\n  width: 100%;\n  height: 100vh;\n}\nhtml::-webkit-scrollbar,\nbody::-webkit-scrollbar {\n  height: 0;\n  width: 0;\n}\n#app {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n.main {\n  min-width: 460px;\n  width: 100%;\n  overflow-x: auto;\n}\n@media (max-width: 460px) {\n.main {\n    overflow-x: scroll;\n}\n}\n.main::-webkit-scrollbar {\n  display: none;\n}\n.main::-webkit-scrollbar-track {\n  display: none;\n}\n.main::-webkit-scrollbar-thumb {\n  display: none;\n}\n.main::-webkit-scrollbar-thumb:hover {\n  display: none;\n}\n.main::-webkit-scrollbar-thumb:active {\n  display: none;\n}\n.main #content {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}:root {\n  --default-padding: 16px;\n  --default-padding-half: 8px;\n  --default-padding-quarter: 4px;\n  --default-margin: 16px;\n  --default-margin-half: 8px;\n  --default-margin-quarter: 4px;\n  --default-input-height: 30px;\n  --font-family: BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, PingFang SC, Microsoft Yahei, Hiragino Sans GB, sans-serif, apple color emoji, Noto Color Emoji, segoe ui emoji, segoe ui symbol;\n  --font-default-bold: 500;\n  --font-default-fontsize: 12px;\n  --el-border-width: 1px;\n  --el-border-style: solid;\n  --el-component-size-large: 32px;\n  --el-component-size: 24px;\n  --el-component-size-small: 16px;\n  --default-radius: 6px;\n  color-scheme: light;\n  --left-font-color: #595959;\n  --overlay-bg-color: rgba(0, 0, 0, 0.25);\n  --title-color: #3D3D3D;\n  --title-weight: 600;\n  --grey-light: #efefef;\n  --grey: #e6e6e6;\n  --grey-dark: #e0e0e0;\n  --theme-color-line: #f0f0f0;\n  --theme-color: #2c2c2c;\n  --theme-color-anti: #ffffff;\n  --input-background: #F4F5F5;\n  --active-color: #3387f5;\n  --component-color: #7F58F9;\n  --el-color-white: #ffffff;\n  --el-color-black: #000000;\n  --el-color-primary: #73767a;\n  --el-color-primary-light-3: #73767a;\n  --el-color-primary-light-5: #73767a;\n  --el-color-primary-light-7: #73767a;\n  --el-color-primary-light-8: #73767a;\n  --el-color-primary-light-9: #73767a;\n  --el-color-primary-dark-2: #73767a;\n  --el-color-success: #67c23a;\n  --el-color-success-light-3: #95d475;\n  --el-color-success-light-5: #b3e19d;\n  --el-color-success-light-7: #d1edc4;\n  --el-color-success-light-8: #e1f3d8;\n  --el-color-success-light-9: #f0f9eb;\n  --el-color-success-dark-2: #529b2e;\n  --el-color-warning: #e6a23c;\n  --el-color-warning-light-3: #eebe77;\n  --el-color-warning-light-5: #f3d19e;\n  --el-color-warning-light-7: #f8e3c5;\n  --el-color-warning-light-8: #faecd8;\n  --el-color-warning-light-9: #fdf6ec;\n  --el-color-warning-dark-2: #b88230;\n  --el-color-danger: #f56c6c;\n  --el-color-danger-light-3: #f89898;\n  --el-color-danger-light-5: #fab6b6;\n  --el-color-danger-light-7: #fcd3d3;\n  --el-color-danger-light-8: #fde2e2;\n  --el-color-danger-light-9: #fef0f0;\n  --el-color-danger-dark-2: #c45656;\n  --el-color-error: #f56c6c;\n  --el-color-error-light-3: #f89898;\n  --el-color-error-light-5: #fab6b6;\n  --el-color-error-light-7: #fcd3d3;\n  --el-color-error-light-8: #fde2e2;\n  --el-color-error-light-9: #fef0f0;\n  --el-color-error-dark-2: #c45656;\n  --el-color-info: #909399;\n  --el-color-info-light-3: #b1b3b8;\n  --el-color-info-light-5: #c8c9cc;\n  --el-color-info-light-7: #dedfe0;\n  --el-color-info-light-8: #e9e9eb;\n  --el-color-info-light-9: #f4f4f5;\n  --el-color-info-dark-2: #73767a;\n  --el-bg-color: #ffffff;\n  --el-bg-color-page: #f2f3f5;\n  --el-bg-color-overlay: #ffffff;\n  --el-text-color-primary: #303133;\n  --el-text-color-regular: #606266;\n  --el-text-color-secondary: #909399;\n  --el-text-color-placeholder: #a8abb2;\n  --el-text-color-disabled: #c0c4cc;\n  --el-border-color: #dcdfe6;\n  --el-border-color-light: #e4e7ed;\n  --el-border-color-lighter: #ebeef5;\n  --el-border-color-extra-light: #f2f6fc;\n  --el-border-color-dark: #d4d7de;\n  --el-border-color-darker: #cdd0d6;\n  --el-fill-color: #f0f2f5;\n  --el-fill-color-light: #f5f7fa;\n  --el-fill-color-lighter: #fafafa;\n  --el-fill-color-extra-light: #fafcff;\n  --el-fill-color-dark: #ebedf0;\n  --el-fill-color-darker: #e6e8eb;\n  --el-fill-color-blank: #ffffff;\n  --el-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, 0.04), 0px 8px 20px rgba(0, 0, 0, 0.08);\n  --el-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, 0.12);\n  --el-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, 0.12);\n  --el-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, 0.08), 0px 12px 32px rgba(0, 0, 0, 0.12), 0px 8px 16px -8px rgba(0, 0, 0, 0.16);\n  --el-disabled-bg-color: var(--el-fill-color-light);\n  --el-disabled-text-color: var(--el-text-color-placeholder);\n  --el-disabled-border-color: var(--el-border-color-light);\n  --el-overlay-color: rgba(0, 0, 0, 0.8);\n  --el-overlay-color-light: rgba(0, 0, 0, 0.7);\n  --el-overlay-color-lighter: rgba(0, 0, 0, 0.5);\n  --el-mask-color: rgba(255, 255, 255, 0.9);\n  --el-mask-color-extra-light: rgba(255, 255, 255, 0.3);\n  --el-border-color-hover: var(--el-text-color-disabled);\n  --el-border: var(--el-border-width) var(--el-border-style) var(--el-border-color);\n  --el-svg-monochrome-grey: var(--el-border-color);\n  --el-font-size-base: 10px;\n}\n\n.network_error_message {\n  position: fixed;\n  font-size: var(--font-default-fontsize);\n  display: flex;\n  align-items: center;\n  top: 120px;\n  left: 50%;\n  transform: translateX(-50%);\n  color: #f1f1f1;\n  background-color: var(--active-color);\n  padding: 7px 30px;\n  border: 1px solid var(--active-color);\n  border-radius: 4px;\n}\n.network_error_message .loading-spinner > div {\n  border: 2px solid transparent;\n  border-top: 2px solid #000;\n  border-left: 2px solid #000;\n  border-bottom: 2px solid #000;\n  border-radius: 50%;\n  width: 12px;\n  height: 12px;\n  color: #000;\n}\n.network_error_message .loading-spinner {\n  animation: spin 1s linear infinite;\n}\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}.transition-400 {\n  transition: 0.4s;\n}\n\n.active-box-shadow {\n  box-shadow: 0px 0px 4px var(--active-color);\n}\n\n.hard-shadow {\n  box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.18);\n}\n\n.cursor-copy {\n  cursor: -webkit-image-set(url("data:image/png;base64,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") 2x) 9 12, auto;\n}'));
            document.head.appendChild(elementStyle);
        }
    } catch (e) {
        console.error("vite-plugin-css-injected-by-js", e);
    }
})();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var define_process_env_default$3 = { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\Zrx\\AppData\\Roaming", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133219334407372012", COLOR: "1", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-PQMEM4M", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EFC_6852: "1", FIG_JETBRAINS_SHELL_INTEGRATION: "1", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", HOME: "C:\\Users\\Zrx", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Zrx", IDEA_INITIAL_DIRECTORY: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin", INIT_CWD: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", LOCALAPPDATA: "C:\\Users\\Zrx\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-PQMEM4M", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\Zrx\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\Zrx\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", npm_config_node_gyp: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.7.0", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_registry: "https://packages.aliyun.com/6393d698d690c872dceedcc0/npm/npm-registry/", npm_config_userconfig: "C:\\Users\\Zrx\\.npmrc", npm_config_user_agent: "npm/10.7.0 node/v20.14.0 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_json: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\package.json", npm_package_name: "@kcdesign/editor", npm_package_version: "1.0.24", NPM_PREFIX_JS: "C:\\Program Files\\nodejs\\\\node_modules\\npm\\bin\\npm-prefix.js", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "16", NVM_HOME: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OneDrive: "C:\\Users\\Zrx\\OneDrive", OS: "Windows_NT", Path: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\node_modules\\.bin;C:\\Users\\Zrx\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Program Files\\Graphviz\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Zrx\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 154 Stepping 3, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9a03", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", SESSIONNAME: "Console", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", TERMINAL_EMULATOR: "JetBrains-JediTerm", TERM_SESSION_ID: "62b27859-8773-4ef0-b702-7493e22b8459", TMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-PQMEM4M", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-PQMEM4M", USERNAME: "Zrx", USERPROFILE: "C:\\Users\\Zrx", WebStorm: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
/**
 * @vue/shared v3.4.38
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str, expectsLowerCase) {
    const set2 = new Set(str.split(","));
    return (val) => set2.has(val);
}
const EMPTY_OBJ = !!(define_process_env_default$3.NODE_ENV !== "production") ? Object.freeze({}) : {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el2) => {
    const i = arr.indexOf(el2);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
    return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
    return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
    }
};
const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
    });
};
const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
    return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {});
};
function normalizeStyle(value) {
    if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    } else if (isString$2(value) || isObject$2(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString$2(value)) {
        res = value;
    } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + " ";
            }
        }
    } else if (isObject$2(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + " ";
            }
        }
    }
    return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
                this
            ) - 1;
        }
    }
    get active() {
        return this._active;
    }
    run(fn2) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn2();
            } finally {
                activeEffectScope = currentEffectScope;
            }
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l2;
            for (i = 0, l2 = this.effects.length; i < l2; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                    this.scopes[i].stop(true);
                }
            }
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect2);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
let activeEffect;
class ReactiveEffect {
    constructor(fn2, trigger2, scheduler, scope) {
        this.fn = fn2;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1;
            pauseTracking();
            for (let i = 0; i < this._depsLength; i++) {
                const dep = this.deps[i];
                if (dep.computed) {
                    triggerComputed(dep.computed);
                    if (this._dirtyLevel >= 4) {
                        break;
                    }
                }
            }
            if (this._dirtyLevel === 1) {
                this._dirtyLevel = 0;
            }
            resetTracking();
        }
        return this._dirtyLevel >= 4;
    }
    set dirty(v2) {
        this._dirtyLevel = v2 ? 4 : 0;
    }
    run() {
        this._dirtyLevel = 0;
        if (!this.active) {
            return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
        } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
        }
    }
    stop() {
        if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            this.onStop && this.onStop();
            this.active = false;
        }
    }
}
function triggerComputed(computed2) {
    return computed2.value;
}
function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
}
function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
            cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
    }
}
function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
            dep.cleanup();
        }
    }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
    pauseScheduleStack++;
}
function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
    }
}
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
            if (oldDep) {
                cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
        } else {
            effect2._depsLength++;
        }
    }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    pauseScheduling();
    for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
            effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2.trigger();
            if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
                effect2._shouldSchedule = false;
                if (effect2.scheduler) {
                    queueEffectSchedulers.push(effect2.scheduler);
                }
            }
        }
    }
    resetScheduling();
}
const createDep = (cleanup, computed2) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed2;
    return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
            activeEffect,
            dep
        );
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        return;
    }
    let deps = [];
    if (type === "clear") {
        deps = [...depsMap.values()];
    } else if (key === "length" && isArray$1(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
            if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
                deps.push(dep);
            }
        });
    } else {
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        switch (type) {
            case "add":
                if (!isArray$1(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                } else if (isIntegerKey(key)) {
                    deps.push(depsMap.get("length"));
                }
                break;
            case "delete":
                if (!isArray$1(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set":
                if (isMap(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    pauseScheduling();
    for (const dep of deps) {
        if (dep) {
            triggerEffects(
                dep,
                4
            );
        }
    }
    resetScheduling();
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i = 0, l2 = this.length; i < l2; i++) {
                track(arr, "get", i + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                return arr[key](...args.map(toRaw));
            } else {
                return res;
            }
        };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
            pauseTracking();
            pauseScheduling();
            const res = toRaw(this)[key].apply(this, args);
            resetScheduling();
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty$1(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
            return !isReadonly2;
        } else if (key === "__v_isReadonly") {
            return isReadonly2;
        } else if (key === "__v_isShallow") {
            return isShallow2;
        } else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
                // this means the receiver is a user proxy of the reactive proxy
                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
                return target;
            }
            return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
            if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
                return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
                return hasOwnProperty$1;
            }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly2) {
            track(target, "get", key);
        }
        if (isShallow2) {
            return res;
        }
        if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$2(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
    }
}
class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
        super(false, isShallow2);
    }
    set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
                if (isOldValueReadonly) {
                    return false;
                } else {
                    oldValue.value = value;
                    return true;
                }
            }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
                trigger(target, "set", key, value);
            }
        }
        return result;
    }
    deleteProperty(target, key) {
        const hadKey = hasOwn$1(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
            trigger(target, "delete", key, void 0);
        }
        return result;
    }
    has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
            track(target, "has", key);
        }
        return result;
    }
    ownKeys(target) {
        track(
            target,
            "iterate",
            isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
    }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
        super(true, isShallow2);
    }
    set(target, key) {
        return true;
    }
    deleteProperty(target, key) {
        return true;
    }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
        target.get(key);
    }
}
function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
    }
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value, _isShallow = false) {
    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
        value = toRaw(value);
    }
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete", key, void 0);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear", void 0, void 0);
    }
    return result;
}
function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done ? { value, done } : {
                    value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get(key) {
            return get(this, key);
        },
        get size() {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get(key) {
            return get(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has,
        add(value) {
            return add.call(this, value, true);
        },
        set(key, value) {
            return set.call(this, key, value, true);
        },
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get(key) {
            return get(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get(key) {
            return get(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            true
        );
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive") {
            return !isReadonly2;
        } else if (key === "__v_isReadonly") {
            return isReadonly2;
        } else if (key === "__v_raw") {
            return target;
        }
        return Reflect.get(
            hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
        );
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
    );
}
function shallowReactive(target) {
    return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
    );
}
function readonly(target) {
    return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
    );
}
function shallowReadonly(target) {
    return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
    );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$2(target)) {
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
        return target;
    }
    const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    if (Object.isExtensible(value)) {
        def(value, "__v_skip", true);
    }
    return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly2, isSSR) {
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(
                this,
                this.effect._dirtyLevel === 2 ? 2 : 3
            )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
            triggerRefValue(self2, 2);
        }
        return self2._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
        return this.effect.dirty;
    }
    set _dirty(v2) {
        this.effect.dirty = v2;
    }
    // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$1(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    return cRef;
}
function trackRefValue(ref2) {
    var _a2;
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
            activeEffect,
            (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
                () => ref2.dep = void 0,
                ref2 instanceof ComputedRefImpl ? ref2 : void 0
            )
        );
    }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
        triggerEffects(
            dep,
            dirtyLevel
        );
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
            this._rawValue;
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, 4);
        }
    }
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var define_process_env_default$2 = { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\Zrx\\AppData\\Roaming", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133219334407372012", COLOR: "1", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-PQMEM4M", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EFC_6852: "1", FIG_JETBRAINS_SHELL_INTEGRATION: "1", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", HOME: "C:\\Users\\Zrx", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Zrx", IDEA_INITIAL_DIRECTORY: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin", INIT_CWD: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", LOCALAPPDATA: "C:\\Users\\Zrx\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-PQMEM4M", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\Zrx\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\Zrx\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", npm_config_node_gyp: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.7.0", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_registry: "https://packages.aliyun.com/6393d698d690c872dceedcc0/npm/npm-registry/", npm_config_userconfig: "C:\\Users\\Zrx\\.npmrc", npm_config_user_agent: "npm/10.7.0 node/v20.14.0 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_json: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\package.json", npm_package_name: "@kcdesign/editor", npm_package_version: "1.0.24", NPM_PREFIX_JS: "C:\\Program Files\\nodejs\\\\node_modules\\npm\\bin\\npm-prefix.js", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "16", NVM_HOME: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OneDrive: "C:\\Users\\Zrx\\OneDrive", OS: "Windows_NT", Path: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\node_modules\\.bin;C:\\Users\\Zrx\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Program Files\\Graphviz\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Zrx\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 154 Stepping 3, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9a03", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", SESSIONNAME: "Console", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", TERMINAL_EMULATOR: "JetBrains-JediTerm", TERM_SESSION_ID: "62b27859-8773-4ef0-b702-7493e22b8459", TMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-PQMEM4M", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-PQMEM4M", USERNAME: "Zrx", USERPROFILE: "C:\\Users\\Zrx", WebStorm: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
                // eslint-disable-next-line no-restricted-syntax
                msg + args.map((a2) => {
                    var _a2, _b;
                    return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
                }).join(""),
                instance && instance.proxy,
                trace.map(
                    ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
                ).join("\n"),
                trace
            ]
        );
    } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
            true) {
            warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        } else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
function formatProp(key, value, raw) {
    if (isString$2(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
    }
}
function callWithErrorHandling(fn2, instance, type, args) {
    try {
        return args ? fn2(...args) : fn2();
    } catch (err) {
        handleError(err, instance, type);
    }
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
    if (isFunction$1(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise$1(res)) {
            res.catch((err) => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    if (isArray$1(fn2)) {
        const values = [];
        for (let i = 0; i < fn2.length; i++) {
            values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
        }
        return values;
    }
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            pauseTracking();
            callWithErrorHandling(
                appErrorHandler,
                null,
                10,
                [err, exposedInstance, errorInfo]
            );
            resetTracking();
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
    let start2 = flushIndex + 1;
    let end2 = queue.length;
    while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
            start2 = middle + 1;
        } else {
            end2 = middle;
        }
    }
    return start2;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
        if (job.id == null) {
            queue.push(job);
        } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
            pendingPostFlushCbs.push(cb);
        }
    } else {
        pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
}
function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
            if (instance && cb.id !== instance.uid) {
                continue;
            }
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
            (a2, b2) => getId(a2) - getId(b2)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            const cb = activePostFlushCbs[postFlushIndex];
            if (cb.active !== false) cb();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
    const diff = getId(a2) - getId(b2);
    if (diff === 0) {
        if (a2.pre && !b2.pre) return -1;
        if (b2.pre && !a2.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    queue.sort(comparator);
    const check = NOOP;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (!!(define_process_env_default$2.NODE_ENV !== "production") && check(job)) ;
                callWithErrorHandling(
                    job,
                    job.i,
                    job.i ? 15 : 14
                );
            }
        }
    } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
        }
    }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn2;
    if (fn2._n) {
        return fn2;
    }
    const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn2(...args);
        } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
                setBlockTracking(1);
            }
        }
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            resetTracking();
        }
    }
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
        vnode.transition = hooks;
    }
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
            if (current.isDeactivated) {
                return;
            }
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
    );
    onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
    }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            pauseTracking();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            resetTracking();
            return res;
        });
        if (prepend) {
            hooks.unshift(wrappedHook);
        } else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
    }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
    "rtg"
);
const onRenderTracked = createHook(
    "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function renderList(source, renderItem, cache2, index2) {
    let ret;
    const cached = cache2;
    if (isArray$1(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i = 0, l2 = source.length; i < l2; i++) {
            ret[i] = renderItem(source[i], i, void 0, cached);
        }
    } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached);
        }
    } else if (isObject$2(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(
                source,
                (item, i) => renderItem(item, i, void 0, cached)
            );
        } else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l2 = keys.length; i < l2; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached);
            }
        }
    } else {
        ret = [];
    }
    return ret;
}
const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
            i.effect.dirty = true;
            queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
    })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        if (key === "__v_skip") {
            return true;
        }
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
            const n2 = accessCache[key];
            if (n2 !== void 0) {
                switch (n2) {
                    case 1:
                        return setupState[key];
                    case 2:
                        return data[key];
                    case 4:
                        return ctx[key];
                    case 3:
                        return props[key];
                }
            } else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1;
                return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
                accessCache[key] = 2;
                return data[key];
            } else if (
                // only cache other properties when instance has declared (thus stable)
                // props
                (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
            ) {
                accessCache[key] = 3;
                return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
                accessCache[key] = 4;
                return ctx[key];
            } else if (shouldCacheAccess) {
                accessCache[key] = 0;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                track(instance.attrs, "get", "");
            }
            return publicGetter(instance);
        } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
            return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
        } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
        ) {
            {
                return globalProperties[key];
            }
        } else ;
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
            data[key] = value;
            return true;
        } else if (hasOwn$1(instance.props, key)) {
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            return false;
        } else {
            {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({
            _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            target._.accessCache[key] = 0;
        } else if (hasOwn$1(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
    ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc");
    }
    const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$1(methodHandler)) {
                {
                    ctx[key] = methodHandler.bind(publicThis);
                }
            }
        }
    }
    if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$2(data)) ;
        else {
            instance.data = reactive(data);
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c2 = computed({
                get: get2,
                set: set2
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c2.value,
                set: (v2) => c2.value = v2
            });
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: (val) => publicThis[key] = val
                });
            });
        } else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    if (render && instance.render === NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$2(opt)) {
            if ("default" in opt) {
                injected = inject(
                    opt.from || key,
                    opt.default,
                    true
                );
            } else {
                injected = inject(opt.from || key);
            }
        } else {
            injected = inject(opt);
        }
        if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => injected.value,
                set: (v2) => injected.value = v2
            });
        } else {
            ctx[key] = injected;
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
    );
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
            watch(getter, handler);
        }
    } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
    } else if (isObject$2(raw)) {
        if (isArray$1(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
            const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$1(handler)) {
                watch(getter, handler, raw);
            }
        }
    } else ;
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    } else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(
                (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
            );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$2(base)) {
        cache2.set(base, resolved);
    }
    return resolved;
}
function mergeOptions(to2, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach(
            (m2) => mergeOptions(to2, m2, strats, true)
        );
    }
    for (const key in from) {
        if (asMixin && key === "expose") ;
        else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to2[key] = strat ? strat(to2[key], from[key]) : from[key];
        }
    }
    return to2;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to2, from) {
    if (!from) {
        return to2;
    }
    if (!to2) {
        return from;
    }
    return function mergedDataFn() {
        return extend(
            isFunction$1(to2) ? to2.call(this, this) : to2,
            isFunction$1(from) ? from.call(this, this) : from
        );
    };
}
function mergeInject(to2, from) {
    return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
    if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to2, from) {
    return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
    return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
}
function mergeEmitsOrPropsOptions(to2, from) {
    if (to2) {
        if (isArray$1(to2) && isArray$1(from)) {
            return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to2),
            normalizePropsOrEmits(from != null ? from : {})
        );
    } else {
        return from;
    }
}
function mergeWatchOptions(to2, from) {
    if (!to2) return from;
    if (!from) return to2;
    const merged = extend(/* @__PURE__ */ Object.create(null), to2);
    for (const key in from) {
        merged[key] = mergeAsArray(to2[key], from[key]);
    }
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
            rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$2(rootProps)) {
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app2 = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v2) {
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) ;
                else if (plugin && isFunction$1(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app2, ...options);
                } else if (isFunction$1(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app2, ...options);
                } else ;
                return app2;
            },
            mixin(mixin) {
                {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                }
                return app2;
            },
            component(name, component) {
                if (!component) {
                    return context.components[name];
                }
                context.components[name] = component;
                return app2;
            },
            directive(name, directive) {
                if (!directive) {
                    return context.directives[name];
                }
                context.directives[name] = directive;
                return app2;
            },
            mount(rootContainer, isHydrate, namespace) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    if (namespace === true) {
                        namespace = "svg";
                    } else if (namespace === false) {
                        namespace = void 0;
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    } else {
                        render(vnode, rootContainer, namespace);
                    }
                    isMounted = true;
                    app2._container = rootContainer;
                    rootContainer.__vue_app__ = app2;
                    return getComponentPublicInstance(vnode.component);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app2._container);
                    delete app2._container.__vue_app__;
                }
            },
            provide(key, value) {
                context.provides[key] = value;
                return app2;
            },
            runWithContext(fn2) {
                const lastApp = currentApp;
                currentApp = app2;
                try {
                    return fn2();
                } finally {
                    currentApp = lastApp;
                }
            }
        };
        return app2;
    };
}
let currentApp = null;
function provide(key, value) {
    if (!currentInstance) ;
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
        if (provides && key in provides) {
            return provides[key];
        } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else ;
    }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = void 0;
        }
    }
    if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
    } else {
        if (!instance.type.props) {
            instance.props = attrs;
        } else {
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
        props,
        attrs,
        vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) {
                    continue;
                }
                const value = rawProps[key];
                if (options) {
                    if (hasOwn$1(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = camelize(key);
                        props[camelizedKey] = resolvePropValue(
                            options,
                            rawCurrentProps,
                            camelizedKey,
                            value,
                            instance,
                            false
                        );
                    }
                } else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
                !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
                // and converted to camelCase (#955)
                ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
                if (options) {
                    if (rawPrevProps && // for camelCase
                        (rawPrevProps[key] !== void 0 || // for kebab-case
                            rawPrevProps[kebabKey] !== void 0)) {
                        props[key] = resolvePropValue(
                            options,
                            rawCurrentProps,
                            key,
                            void 0,
                            instance,
                            true
                        );
                    }
                } else {
                    delete props[key];
                }
            }
        }
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps || !hasOwn$1(rawProps, key) && true) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (hasAttrsChanged) {
        trigger(instance.attrs, "set", "");
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            if (isReservedProp(key)) {
                continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn$1(options, camelKey = camelize(key))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                } else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                castValues[key],
                instance,
                !hasOwn$1(castValues, key)
            );
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = hasOwn$1(opt, "default");
        if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                } else {
                    const reset = setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(
                        null,
                        props
                    );
                    reset();
                }
            } else {
                value = defaultValue;
            }
        }
        if (opt[
            0
            /* shouldCast */
            ]) {
            if (isAbsent && !hasDefault) {
                value = false;
            } else if (opt[
                1
                /* shouldCastTrue */
                ] && (value === "" || value === hyphenate(key))) {
                value = true;
            }
        }
    }
    return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
            cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = EMPTY_OBJ;
            }
        }
    } else if (raw) {
        for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
                const propType = prop.type;
                let shouldCast = false;
                let shouldCastTrue = true;
                if (isArray$1(propType)) {
                    for (let index2 = 0; index2 < propType.length; ++index2) {
                        const type = propType[index2];
                        const typeName = isFunction$1(type) && type.name;
                        if (typeName === "Boolean") {
                            shouldCast = true;
                            break;
                        } else if (typeName === "String") {
                            shouldCastTrue = false;
                        }
                    }
                } else {
                    shouldCast = isFunction$1(propType) && propType.name === "Boolean";
                }
                prop[
                    0
                    /* shouldCast */
                    ] = shouldCast;
                prop[
                    1
                    /* shouldCastTrue */
                    ] = shouldCastTrue;
                if (shouldCast || hasOwn$1(prop, "default")) {
                    needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    if (isObject$2(comp)) {
        cache2.set(comp, res);
    }
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
    }
    return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
        return rawSlot;
    }
    const normalized = withCtx((...args) => {
        if (!!(define_process_env_default$2.NODE_ENV !== "production") && currentInstance && (!ctx || ctx.root === currentInstance.root)) ;
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key)) continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
        if (optimized || key !== "_") {
            slots[key] = children[key];
        }
    }
};
const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            assignSlots(slots, children, optimized);
            if (optimized) {
                def(slots, "_", type, true);
            }
        } else {
            normalizeObjectSlots(children, slots);
        }
    } else if (children) {
        normalizeVNodeSlots(instance, children);
    }
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (optimized && type === 1) {
                needDeletionCheck = false;
            } else {
                assignSlots(slots, children, optimized);
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
                delete slots[key];
            }
        }
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
        rawRef.forEach(
            (r, i) => setRef(
                r,
                oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
                parentSuspense,
                vnode,
                isUnmount
            )
        );
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn$1(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        } else if (isRef(oldRef)) {
            oldRef.value = null;
        }
    }
    if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
        const _isString = isString$2(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                    if (isUnmount) {
                        isArray$1(existing) && remove(existing, refValue);
                    } else {
                        if (!isArray$1(existing)) {
                            if (_isString) {
                                refs[ref3] = [refValue];
                                if (hasOwn$1(setupState, ref3)) {
                                    setupState[ref3] = refs[ref3];
                                }
                            } else {
                                ref3.value = [refValue];
                                if (rawRef.k) refs[rawRef.k] = ref3.value;
                            }
                        } else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                } else if (_isString) {
                    refs[ref3] = value;
                    if (hasOwn$1(setupState, ref3)) {
                        setupState[ref3] = value;
                    }
                } else if (_isRef) {
                    ref3.value = value;
                    if (rawRef.k) refs[rawRef.k] = value;
                } else ;
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else {
                doSet();
            }
        }
    }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis$1();
    target.__VUE__ = true;
    const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, namespace);
                }
                break;
            case Fragment:
                processFragment(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
                break;
            default:
                if (shapeFlag & 1) {
                    processElement(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                } else if (shapeFlag & 6) {
                    processComponent(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                } else if (shapeFlag & 64) {
                    type.process(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized,
                        internals
                    );
                } else if (shapeFlag & 128) {
                    type.process(
                        n1,
                        n2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized,
                        internals
                    );
                } else ;
        }
        if (ref3 != null && parentComponent) {
            setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert(
                n2.el = hostCreateText(n2.children),
                container,
                anchor
            );
        } else {
            const el2 = n2.el = n1.el;
            if (n2.children !== n1.children) {
                hostSetText(el2, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert(
                n2.el = hostCreateComment(n2.children || ""),
                container,
                anchor
            );
        } else {
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace,
            n2.el,
            n2.anchor
        );
    };
    const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
        let next;
        while (el2 && el2 !== anchor) {
            next = hostNextSibling(el2);
            hostInsert(el2, container, nextSibling);
            el2 = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el: el2, anchor }) => {
        let next;
        while (el2 && el2 !== anchor) {
            next = hostNextSibling(el2);
            hostRemove(el2);
            el2 = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
            namespace = "svg";
        } else if (n2.type === "math") {
            namespace = "mathml";
        }
        if (n1 == null) {
            mountElement(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
            );
        } else {
            patchElement(
                n1,
                n2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
            );
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el2;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el2 = vnode.el = hostCreateElement(
            vnode.type,
            namespace,
            props && props.is,
            props
        );
        if (shapeFlag & 8) {
            hostSetElementText(el2, vnode.children);
        } else if (shapeFlag & 16) {
            mountChildren(
                vnode.children,
                el2,
                null,
                parentComponent,
                parentSuspense,
                resolveChildrenNamespace(vnode, namespace),
                slotScopeIds,
                optimized
            );
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for (const key in props) {
                if (key !== "value" && !isReservedProp(key)) {
                    hostPatchProp(el2, key, null, props[key], namespace, parentComponent);
                }
            }
            if ("value" in props) {
                hostPatchProp(el2, "value", null, props.value, namespace);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
            transition.beforeEnter(el2);
        }
        hostInsert(el2, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el2);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
        }
    };
    const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el2, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el2, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(
                    el2,
                    parentVNode,
                    parentVNode.scopeId,
                    parentVNode.slotScopeIds,
                    parentComponent.parent
                );
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
        for (let i = start2; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
                null,
                child,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
            );
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el2 = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
            hostSetElementText(el2, "");
        }
        if (dynamicChildren) {
            patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                el2,
                parentComponent,
                parentSuspense,
                resolveChildrenNamespace(n2, namespace),
                slotScopeIds
            );
        } else if (!optimized) {
            patchChildren(
                n1,
                n2,
                el2,
                null,
                parentComponent,
                parentSuspense,
                resolveChildrenNamespace(n2, namespace),
                slotScopeIds,
                false
            );
        }
        if (patchFlag > 0) {
            if (patchFlag & 16) {
                patchProps(el2, oldProps, newProps, parentComponent, namespace);
            } else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el2, "class", null, newProps.class, namespace);
                    }
                }
                if (patchFlag & 4) {
                    hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace);
                }
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") {
                            hostPatchProp(el2, key, prev, next, namespace, parentComponent);
                        }
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el2, n2.children);
                }
            }
        } else if (!optimized && dynamicChildren == null) {
            patchProps(el2, oldProps, newProps, parentComponent, namespace);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
        }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
                // oldVNode may be an errored async setup() component inside Suspense
                // which will not have a mounted element
                oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                    // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer
                )
            );
            patch(
                oldVNode,
                newVNode,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                true
            );
        }
    };
    const patchProps = (el2, oldProps, newProps, parentComponent, namespace) => {
        if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!isReservedProp(key) && !(key in newProps)) {
                        hostPatchProp(
                            el2,
                            key,
                            oldProps[key],
                            null,
                            namespace,
                            parentComponent
                        );
                    }
                }
            }
            for (const key in newProps) {
                if (isReservedProp(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") {
                    hostPatchProp(el2, key, prev, next, namespace, parentComponent);
                }
            }
            if ("value" in newProps) {
                hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
                // #10007
                // such fragment like `<></>` will be compiled into
                // a fragment which doesn't have a children.
                // In this case fallback to an empty array
                n2.children || [],
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
            );
        } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                patchBlockChildren(
                    n1.dynamicChildren,
                    dynamicChildren,
                    container,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds
                );
                if (
                    // #2080 if the stable fragment has a key, it's a <template v-for> that may
                    //  get moved around. Make sure all root level vnodes inherit el.
                    // #2134 or if it's a component root, it may also get moved around
                    // as the component is being moved.
                    n2.key != null || parentComponent && n2 === parentComponent.subTree
                ) {
                    traverseStaticChildren(
                        n1,
                        n2,
                        true
                        /* shallow */
                    );
                }
            } else {
                patchChildren(
                    n1,
                    n2,
                    container,
                    fragmentEndAnchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) {
                parentComponent.ctx.activate(
                    n2,
                    container,
                    anchor,
                    namespace,
                    optimized
                );
            } else {
                mountComponent(
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    optimized
                );
            }
        } else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        {
            setupComponent(instance, false, optimized);
        }
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
        } else {
            setupRenderEffect(
                instance,
                initialVNode,
                container,
                anchor,
                parentSuspense,
                namespace,
                optimized
            );
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                updateComponentPreRender(instance, n2, optimized);
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.effect.dirty = true;
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el: el2, props } = initialVNode;
                const { bm, m: m2, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) {
                    invokeArrayFns(bm);
                }
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                toggleRecurse(instance, true);
                if (el2 && hydrateNode) {
                    const hydrateSubTree = () => {
                        instance.subTree = renderComponentRoot(instance);
                        hydrateNode(
                            el2,
                            instance.subTree,
                            instance,
                            parentSuspense,
                            null
                        );
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                            // note: we are moving the render call into an async callback,
                            // which means it won't track dependencies - but it's ok because
                            // a server-rendered async wrapper is already in resolved state
                            // and it will never need to change.
                            () => !instance.isUnmounted && hydrateSubTree()
                        );
                    } else {
                        hydrateSubTree();
                    }
                } else {
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    patch(
                        null,
                        subTree,
                        container,
                        anchor,
                        instance,
                        parentSuspense,
                        namespace
                    );
                    initialVNode.el = subTree.el;
                }
                if (m2) {
                    queuePostRenderEffect(m2, parentSuspense);
                }
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(
                        () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                        parentSuspense
                    );
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                initialVNode = container = anchor = null;
            } else {
                let { next, bu: bu2, u, parent, vnode } = instance;
                {
                    const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                    if (nonHydratedAsyncRoot) {
                        if (next) {
                            next.el = vnode.el;
                            updateComponentPreRender(instance, next, optimized);
                        }
                        nonHydratedAsyncRoot.asyncDep.then(() => {
                            if (!instance.isUnmounted) {
                                componentUpdateFn();
                            }
                        });
                        return;
                    }
                }
                let originNext = next;
                let vnodeHook;
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else {
                    next = vnode;
                }
                if (bu2) {
                    invokeArrayFns(bu2);
                }
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                toggleRecurse(instance, true);
                const nextTree = renderComponentRoot(instance);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                patch(
                    prevTree,
                    nextTree,
                    // parent may have changed if it's in a teleport
                    hostParentNode(prevTree.el),
                    // anchor may have changed if it's in a fragment
                    getNextHostNode(prevTree),
                    instance,
                    parentSuspense,
                    namespace
                );
                next.el = nextTree.el;
                if (originNext === null) {
                    updateHOCHostEl(instance, nextTree.el);
                }
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                    queuePostRenderEffect(
                        () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                        parentSuspense
                    );
                }
            }
        };
        const effect2 = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            NOOP,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
        );
        const update = instance.update = () => {
            if (effect2.dirty) {
                effect2.run();
            }
        };
        update.i = instance;
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        } else {
            if (prevShapeFlag & 16) {
                if (shapeFlag & 16) {
                    patchKeyedChildren(
                        c1,
                        c2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                } else {
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            } else {
                if (prevShapeFlag & 8) {
                    hostSetElementText(container, "");
                }
                if (shapeFlag & 16) {
                    mountChildren(
                        c2,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
                c1[i],
                nextChild,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
            );
        }
        if (oldLength > newLength) {
            unmountChildren(
                c1,
                parentComponent,
                parentSuspense,
                true,
                false,
                commonLength
            );
        } else {
            mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                commonLength
            );
        }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
                patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
            } else {
                break;
            }
            i++;
        }
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
                patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                );
            } else {
                break;
            }
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(
                        null,
                        c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                    i++;
                }
            }
        } else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j2;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                } else {
                    for (j2 = s2; j2 <= e2; j2++) {
                        if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                            newIndex = j2;
                            break;
                        }
                    }
                }
                if (newIndex === void 0) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                } else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    } else {
                        moved = true;
                    }
                    patch(
                        prevChild,
                        c2[newIndex],
                        container,
                        null,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j2 = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    patch(
                        null,
                        nextChild,
                        container,
                        anchor,
                        parentComponent,
                        parentSuspense,
                        namespace,
                        slotScopeIds,
                        optimized
                    );
                } else if (moved) {
                    if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
                        move(nextChild, container, anchor, 2);
                    } else {
                        j2--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el: el2, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el2, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
            if (moveType === 0) {
                transition.beforeEnter(el2);
                hostInsert(el2, container, anchor);
                queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove22 = () => hostInsert(el2, container, anchor);
                const performLeave = () => {
                    leave(el2, () => {
                        remove22();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el2, remove22, performLeave);
                } else {
                    performLeave();
                }
            }
        } else {
            hostInsert(el2, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
            type,
            props,
            ref: ref3,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs,
            cacheIndex
        } = vnode;
        if (patchFlag === -2) {
            optimized = false;
        }
        if (ref3 != null) {
            setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (cacheIndex != null) {
            parentComponent.renderCache[cacheIndex] = void 0;
        }
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
                vnode.type.remove(
                    vnode,
                    parentComponent,
                    parentSuspense,
                    internals,
                    doRemove
                );
            } else if (dynamicChildren && // #5154
                // when v-once is used inside a block, setBlockTracking(-1) marks the
                // parent block with hasOnce: true
                // so that it doesn't take the fast path during unmount - otherwise
                // components nested in v-once are never unmounted.
                !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
                unmountChildren(
                    dynamicChildren,
                    parentComponent,
                    parentSuspense,
                    false,
                    true
                );
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove2(vnode);
            }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
        }
    };
    const remove2 = (vnode) => {
        const { type, el: el2, anchor, transition } = vnode;
        if (type === Fragment) {
            {
                removeFragment(el2, anchor);
            }
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el2);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el2, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            } else {
                performLeave();
            }
        } else {
            performRemove();
        }
    };
    const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end2);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um, m: m2, a: a2 } = instance;
        invalidateMount(m2);
        invalidateMount(a2);
        if (bum) {
            invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i = start2; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
        }
        const el2 = hostNextSibling(vnode.anchor || vnode.el);
        const teleportEnd = el2 && el2[TeleportEndKey];
        return teleportEnd ? hostNextSibling(teleportEnd) : el2;
    };
    let isFlushing2 = false;
    const render = (vnode, container, namespace) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        } else {
            patch(
                container._vnode || null,
                vnode,
                container,
                null,
                null,
                null,
                namespace
            );
        }
        container._vnode = vnode;
        if (!isFlushing2) {
            isFlushing2 = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing2 = false;
        }
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow && c2.patchFlag !== -2)
                    traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
                c2.el = c1.el;
            }
        }
    }
}
function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j2, u, v2, c2;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j2 = result[result.length - 1];
            if (arr[j2] < arrI) {
                p2[i] = j2;
                result.push(i);
                continue;
            }
            u = 0;
            v2 = result.length - 1;
            while (u < v2) {
                c2 = u + v2 >> 1;
                if (arr[result[c2]] < arrI) {
                    u = c2 + 1;
                } else {
                    v2 = c2;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p2[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v2 = result[u - 1];
    while (u-- > 0) {
        result[u] = v2;
        v2 = p2[v2];
    }
    return result;
}
function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
            return subComponent;
        } else {
            return locateNonHydratedAsyncRoot(subComponent);
        }
    }
}
function invalidateMount(hooks) {
    if (hooks) {
        for (let i = 0; i < hooks.length; i++) hooks[i].active = false;
    }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        return ctx;
    }
};
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    return doWatch(source, cb, options);
}
function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
} = EMPTY_OBJ) {
    if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
            _cb(...args);
            unwatch();
        };
    }
    const instance = currentInstance;
    const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
    );
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
    } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
            if (isRef(s)) {
                return s.value;
            } else if (isReactive(s)) {
                return reactiveGetter(s);
            } else if (isFunction$1(s)) {
                return callWithErrorHandling(s, instance, 2);
            } else ;
        });
    } else if (isFunction$1(source)) {
        if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
        } else {
            getter = () => {
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(
                    source,
                    instance,
                    3,
                    [onCleanup]
                );
            };
        }
    } else {
        getter = NOOP;
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
            cleanup = effect2.onStop = void 0;
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
            getter();
        } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
                getter(),
                isMultiSource ? [] : void 0,
                onCleanup
            ]);
        }
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
            return NOOP;
        }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect2.active || !effect2.dirty) {
            return;
        }
        if (cb) {
            const newValue = effect2.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else {
            effect2.run();
        }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
        scheduler = job;
    } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = () => queueJob(job);
    }
    const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
    const scope = getCurrentScope();
    const unwatch = () => {
        effect2.stop();
        if (scope) {
            remove(scope.effects, effect2);
        }
    };
    if (cb) {
        if (immediate) {
            job();
        } else {
            oldValue = effect2.run();
        }
    } else if (flush === "post") {
        queuePostRenderEffect(
            effect2.run.bind(effect2),
            instance && instance.suspense
        );
    } else {
        effect2.run();
    }
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
        cb = value;
    } else {
        cb = value.handler;
        options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
        return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
        traverse(value.value, depth, seen);
    } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], depth, seen);
        }
    } else if (isSet(value) || isMap(value)) {
        value.forEach((v2) => {
            traverse(v2, depth, seen);
        });
    } else if (isPlainObject$1(value)) {
        for (const key in value) {
            traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
            if (Object.prototype.propertyIsEnumerable.call(value, key)) {
                traverse(value[key], depth, seen);
            }
        }
    }
    return value;
}
const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
        if (modifiers.trim) {
            args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
        }
        if (modifiers.number) {
            args = rawArgs.map(looseToNumber);
        }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
        callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
        );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
        );
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                extend(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
            cache2.set(comp, null);
        }
        return null;
    }
    if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
    } else {
        extend(normalized, raw);
    }
    if (isObject$2(comp)) {
        cache2.set(comp, normalized);
    }
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
    const {
        type: Component2,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = !!(define_process_env_default$2.NODE_ENV !== "production") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
                get(target, key, receiver) {
                    warn$1(
                        `Property '${String(
                            key
                        )}' was accessed via 'this'. Avoid using 'this' in templates.`
                    );
                    return Reflect.get(target, key, receiver);
                }
            }) : proxyToUse;
            result = normalizeVNode(
                render.call(
                    thisProxy,
                    proxyToUse,
                    renderCache,
                    !!(define_process_env_default$2.NODE_ENV !== "production") ? shallowReadonly(props) : props,
                    setupState,
                    data,
                    ctx
                )
            );
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component2;
            if (!!(define_process_env_default$2.NODE_ENV !== "production") && attrs === props) ;
            result = normalizeVNode(
                render2.length > 1 ? render2(
                    !!(define_process_env_default$2.NODE_ENV !== "production") ? shallowReadonly(props) : props,
                    !!(define_process_env_default$2.NODE_ENV !== "production") ? {
                        get attrs() {
                            markAttrsAccessed();
                            return shallowReadonly(attrs);
                        },
                        slots,
                        emit: emit2
                    } : { attrs, slots, emit: emit2 }
                ) : render2(
                    !!(define_process_env_default$2.NODE_ENV !== "production") ? shallowReadonly(props) : props,
                    null
                )
            );
            fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 | 6)) {
                if (propsOptions && keys.some(isModelListener)) {
                    fallthroughAttrs = filterModelListeners(
                        fallthroughAttrs,
                        propsOptions
                    );
                }
                root = cloneVNode(root, fallthroughAttrs, false, true);
            }
        }
    }
    if (vnode.dirs) {
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        root.transition = vnode.transition;
    }
    {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
            return true;
        }
        if (patchFlag & 16) {
            if (!prevProps) {
                return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
    while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
            root.el = vnode.el;
        }
        if (root === vnode) {
            (vnode = parent.vnode).el = el2;
            parent = parent.parent;
        } else {
            break;
        }
    }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
    if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn2)) {
            suspense.effects.push(...fn2);
        } else {
            suspense.effects.push(fn2);
        }
    } else {
        queuePostFlushCb(fn2);
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
        currentBlock.hasOnce = true;
    }
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
        createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
        )
    );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
        createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
        )
    );
}
function isVNode$1(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
                          ref: ref3,
                          ref_key,
                          ref_for
                      }) => {
    if (typeof ref3 === "number") {
        ref3 = "" + ref3;
    }
    return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
            type.normalize(vnode);
        }
    } else if (children) {
        vnode.shapeFlag |= isString$2(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
    }
    return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
    }
    if (isVNode$1(type)) {
        const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
        );
        if (children) {
            normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
                currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
                currentBlock.push(cloned);
            }
        }
        cloned.patchFlag = -2;
        return cloned;
    }
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
            props.class = normalizeClass(klass);
        }
        if (isObject$2(style)) {
            if (isProxy(style) && !isArray$1(style)) {
                style = extend({}, style);
            }
            props.style = normalizeStyle(style);
        }
    }
    const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
    return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
    );
}
function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetStart: vnode.targetStart,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    if (transition && cloneTransition) {
        setTransitionHooks(
            cloned,
            transition.clone(cloned)
        );
    }
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
    } else if (isArray$1(child)) {
        return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
        );
    } else if (typeof child === "object") {
        return cloneIfMounted(child);
    } else {
        return createVNode(Text, null, String(child));
    }
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    } else if (isArray$1(children)) {
        type = 16;
    } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !isInternalObject(children)) {
                children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) {
                    children._ = 1;
                } else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
        } else {
            type = 8;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === "class") {
                if (ret.class !== toMerge.class) {
                    ret.class = normalizeClass([ret.class, toMerge.class]);
                }
            } else if (key === "style") {
                ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
                    ret[key] = existing ? [].concat(existing, incoming) : incoming;
                }
            } else if (key !== "") {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
            true
            /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    {
        instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
    const g2 = getGlobalThis$1();
    const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g2[key])) setters = g2[key] = [];
        setters.push(setter);
        return (v2) => {
            if (setters.length > 1) setters.forEach((set2) => set2(v2));
            else setters[0](v2);
        };
    };
    internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v2) => isInSSRComponentSetup = v2
    );
}
const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
    };
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component2 = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component2;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
                instance.props,
                setupContext
            ]
        );
        resetTracking();
        reset();
        if (isPromise$1(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                }).catch((e) => {
                    handleError(e, instance, 0);
                });
            } else {
                instance.asyncDep = setupResult;
            }
        } else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    } else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
        } else {
            instance.render = setupResult;
        }
    } else if (isObject$2(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
}
let compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component2 = instance.type;
    if (!instance.render) {
        if (!isSSR && compile$1 && !Component2.render) {
            const template = Component2.template || resolveMergedOptions(instance).template;
            if (template) {
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
                const finalCompilerOptions = extend(
                    extend(
                        {
                            isCustomElement,
                            delimiters
                        },
                        compilerOptions
                    ),
                    componentCompilerOptions
                );
                Component2.render = compile$1(template, finalCompilerOptions);
            }
        }
        instance.render = Component2.render || NOOP;
    }
    {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
            applyOptions(instance);
        } finally {
            resetTracking();
            reset();
        }
    }
}
const attrsProxyHandlers = {
    get(target, key) {
        track(target, "get", "");
        return target[key];
    }
};
function createSetupContext(instance) {
    const expose = (exposed) => {
        instance.exposed = exposed || {};
    };
    {
        return {
            attrs: new Proxy(instance.attrs, attrsProxyHandlers),
            slots: instance.slots,
            emit: instance.emit,
            expose
        };
    }
}
function getComponentPublicInstance(instance) {
    if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
                if (key in target) {
                    return target[key];
                } else if (key in publicPropertiesMap) {
                    return publicPropertiesMap[key](instance);
                }
            },
            has(target, key) {
                return key in target || key in publicPropertiesMap;
            }
        }));
    } else {
        return instance.proxy;
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
    return isFunction$1(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance, Component2, isRoot = false) {
    let name = getComponentName(Component2);
    if (!name && Component2.__file) {
        const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component2) {
                    return key;
                }
            }
        };
        name = inferFromRegistry(
            instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c2;
};
function h$1(type, propsOrChildren, children) {
    const l2 = arguments.length;
    if (l2 === 2) {
        if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
            if (isVNode$1(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
        } else {
            return createVNode(type, null, propsOrChildren);
        }
    } else {
        if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode$1(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}
const version = "3.4.38";
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, namespace, is2, props) => {
        const el2 = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
            el2.setAttribute("multiple", props.multiple);
        }
        return el2;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el2, text) => {
        el2.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el2, id) {
        el2.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start2, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
            while (true) {
                parent.insertBefore(start2.cloneNode(true), anchor);
                if (start2 === end2 || !(start2 = start2.nextSibling)) break;
            }
        } else {
            templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
const vtcKey = Symbol("_vtc");
function patchClass(el2, value, isSVG) {
    const transitionClasses = el2[vtcKey];
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
        el2.removeAttribute("class");
    } else if (isSVG) {
        el2.setAttribute("class", value);
    } else {
        el2.className = value;
    }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el2, prev, next) {
    const style = el2.style;
    const isCssString = isString$2(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
        if (prev) {
            if (!isString$2(prev)) {
                for (const key in prev) {
                    if (next[key] == null) {
                        setStyle(style, key, "");
                    }
                }
            } else {
                for (const prevStyle of prev.split(";")) {
                    const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                    if (next[key] == null) {
                        setStyle(style, key, "");
                    }
                }
            }
        }
        for (const key in next) {
            if (key === "display") {
                hasControlledDisplay = true;
            }
            setStyle(style, key, next[key]);
        }
    } else {
        if (isCssString) {
            if (prev !== next) {
                const cssVarText = style[CSS_VAR_TEXT];
                if (cssVarText) {
                    next += ";" + cssVarText;
                }
                style.cssText = next;
                hasControlledDisplay = displayRE.test(next);
            }
        } else if (prev) {
            el2.removeAttribute("style");
        }
    }
    if (vShowOriginalDisplay in el2) {
        el2[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el2[vShowHidden]) {
            style.display = "none";
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if (isArray$1(val)) {
        val.forEach((v2) => setStyle(style, name, v2));
    } else {
        if (val == null) val = "";
        if (name.startsWith("--")) {
            style.setProperty(name, val);
        } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                style.setProperty(
                    hyphenate(prefixed),
                    val.replace(importantRE, ""),
                    "important"
                );
            } else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
        }
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
            el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
            el2.setAttributeNS(xlinkNS, key, value);
        }
    } else {
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el2.removeAttribute(key);
        } else {
            el2.setAttribute(
                key,
                isBoolean2 ? "" : isSymbol(value) ? String(value) : value
            );
        }
    }
}
function patchDOMProp(el2, key, value, parentComponent) {
    if (key === "innerHTML" || key === "textContent") {
        if (value == null) return;
        el2[key] = value;
        return;
    }
    const tag = el2.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
        const newValue = value == null ? "" : String(value);
        if (oldValue !== newValue || !("_value" in el2)) {
            el2.value = newValue;
        }
        if (value == null) {
            el2.removeAttribute(key);
        }
        el2._value = value;
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el2[key];
        if (type === "boolean") {
            value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el2[key] = value;
    } catch (e) {
    }
    needRemove && el2.removeAttribute(key);
}
function addEventListener(el2, event, handler, options) {
    el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
    el2.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
    const invokers = el2[veiKey] || (el2[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
    } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(
                nextValue,
                instance
            );
            addEventListener(el2, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el2, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m2;
        while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
}
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        if (!e._vts) {
            e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
            return;
        }
        callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
        );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(
            (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
        );
    } else {
        return value;
    }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el2, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
        patchClass(el2, nextValue, isSVG);
    } else if (key === "style") {
        patchStyle(el2, prevValue, nextValue);
    } else if (isOn(key)) {
        if (!isModelListener(key)) {
            patchEvent(el2, key, prevValue, nextValue, parentComponent);
        }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
        patchDOMProp(el2, key, nextValue);
        if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
            patchAttr(el2, key, nextValue, isSVG, parentComponent, key !== "value");
        }
    } else {
        if (key === "true-value") {
            el2._trueValue = nextValue;
        } else if (key === "false-value") {
            el2._falseValue = nextValue;
        }
        patchAttr(el2, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el2, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
            return true;
        }
        if (key in el2 && isNativeOn(key) && isFunction$1(value)) {
            return true;
        }
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
    }
    if (key === "form") {
        return false;
    }
    if (key === "list" && el2.tagName === "INPUT") {
        return false;
    }
    if (key === "type" && el2.tagName === "TEXTAREA") {
        return false;
    }
    if (key === "width" || key === "height") {
        const tag = el2.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
            return false;
        }
    }
    if (isNativeOn(key) && isString$2(value)) {
        return false;
    }
    return key in el2;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
    const app2 = ensureRenderer().createApp(...args);
    const { mount } = app2;
    app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app2._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app2;
};
function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
        return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
    }
}
function normalizeContainer(container) {
    if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
    }
    return container;
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
    }
    return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
    randomUUID
};
function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
}
var int32 = new Int32Array(1);
new Float32Array(int32.buffer);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
    if (n2.__esModule) return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
        var a2 = function a22() {
            if (this instanceof a22) {
                return Reflect.construct(f2, arguments, this.constructor);
            }
            return f2.apply(this, arguments);
        };
        a2.prototype = f2.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k);
        Object.defineProperty(a2, k, d2.get ? d2 : {
            enumerable: true,
            get: function() {
                return n2[k];
            }
        });
    });
    return a2;
}
var UZIP = { exports: {} };
(function(module) {
    var UZIP2 = {};
    module.exports = UZIP2;
    UZIP2["parse"] = function(buf, onlyNames) {
        var rUs = UZIP2.bin.readUshort, rUi = UZIP2.bin.readUint, o2 = 0, out = {};
        var data = new Uint8Array(buf);
        var eocd = data.length - 4;
        while (rUi(data, eocd) != 101010256) eocd--;
        var o2 = eocd;
        o2 += 4;
        o2 += 4;
        var cnu = rUs(data, o2);
        o2 += 2;
        rUs(data, o2);
        o2 += 2;
        var csize = rUi(data, o2);
        o2 += 4;
        var coffs = rUi(data, o2);
        o2 += 4;
        o2 = coffs;
        for (var i = 0; i < cnu; i++) {
            rUi(data, o2);
            o2 += 4;
            o2 += 4;
            o2 += 4;
            o2 += 4;
            rUi(data, o2);
            o2 += 4;
            var csize = rUi(data, o2);
            o2 += 4;
            var usize = rUi(data, o2);
            o2 += 4;
            var nl2 = rUs(data, o2), el2 = rUs(data, o2 + 2), cl2 = rUs(data, o2 + 4);
            o2 += 6;
            o2 += 8;
            var roff = rUi(data, o2);
            o2 += 4;
            o2 += nl2 + el2 + cl2;
            UZIP2._readLocal(data, roff, out, csize, usize, onlyNames);
        }
        return out;
    };
    UZIP2._readLocal = function(data, o2, out, csize, usize, onlyNames) {
        var rUs = UZIP2.bin.readUshort, rUi = UZIP2.bin.readUint;
        rUi(data, o2);
        o2 += 4;
        rUs(data, o2);
        o2 += 2;
        rUs(data, o2);
        o2 += 2;
        var cmpr = rUs(data, o2);
        o2 += 2;
        rUi(data, o2);
        o2 += 4;
        rUi(data, o2);
        o2 += 4;
        o2 += 8;
        var nlen = rUs(data, o2);
        o2 += 2;
        var elen = rUs(data, o2);
        o2 += 2;
        var name = UZIP2.bin.readUTF8(data, o2, nlen);
        o2 += nlen;
        o2 += elen;
        if (onlyNames) {
            out[name] = { size: usize, csize };
            return;
        }
        var file = new Uint8Array(data.buffer, o2);
        if (cmpr == 0) out[name] = new Uint8Array(file.buffer.slice(o2, o2 + csize));
        else if (cmpr == 8) {
            var buf = new Uint8Array(usize);
            UZIP2.inflateRaw(file, buf);
            out[name] = buf;
        } else throw "unknown compression method: " + cmpr;
    };
    UZIP2.inflateRaw = function(file, buf) {
        return UZIP2.F.inflate(file, buf);
    };
    UZIP2.inflate = function(file, buf) {
        file[0];
        file[1];
        return UZIP2.inflateRaw(new Uint8Array(file.buffer, file.byteOffset + 2, file.length - 6), buf);
    };
    UZIP2.deflate = function(data, opts) {
        if (opts == null) opts = { level: 6 };
        var off = 0, buf = new Uint8Array(50 + Math.floor(data.length * 1.1));
        buf[off] = 120;
        buf[off + 1] = 156;
        off += 2;
        off = UZIP2.F.deflateRaw(data, buf, off, opts.level);
        var crc = UZIP2.adler(data, 0, data.length);
        buf[off + 0] = crc >>> 24 & 255;
        buf[off + 1] = crc >>> 16 & 255;
        buf[off + 2] = crc >>> 8 & 255;
        buf[off + 3] = crc >>> 0 & 255;
        return new Uint8Array(buf.buffer, 0, off + 4);
    };
    UZIP2.deflateRaw = function(data, opts) {
        if (opts == null) opts = { level: 6 };
        var buf = new Uint8Array(50 + Math.floor(data.length * 1.1));
        var off = UZIP2.F.deflateRaw(data, buf, off, opts.level);
        return new Uint8Array(buf.buffer, 0, off);
    };
    UZIP2.encode = function(obj, noCmpr) {
        if (noCmpr == null) noCmpr = false;
        var tot = 0, wUi = UZIP2.bin.writeUint, wUs = UZIP2.bin.writeUshort;
        var zpd = {};
        for (var p2 in obj) {
            var cpr = !UZIP2._noNeed(p2) && !noCmpr, buf = obj[p2], crc = UZIP2.crc.crc(buf, 0, buf.length);
            zpd[p2] = { cpr, usize: buf.length, crc, file: cpr ? UZIP2.deflateRaw(buf) : buf };
        }
        for (var p2 in zpd) tot += zpd[p2].file.length + 30 + 46 + 2 * UZIP2.bin.sizeUTF8(p2);
        tot += 22;
        var data = new Uint8Array(tot), o2 = 0;
        var fof = [];
        for (var p2 in zpd) {
            var file = zpd[p2];
            fof.push(o2);
            o2 = UZIP2._writeHeader(data, o2, p2, file, 0);
        }
        var i = 0, ioff = o2;
        for (var p2 in zpd) {
            var file = zpd[p2];
            fof.push(o2);
            o2 = UZIP2._writeHeader(data, o2, p2, file, 1, fof[i++]);
        }
        var csize = o2 - ioff;
        wUi(data, o2, 101010256);
        o2 += 4;
        o2 += 4;
        wUs(data, o2, i);
        o2 += 2;
        wUs(data, o2, i);
        o2 += 2;
        wUi(data, o2, csize);
        o2 += 4;
        wUi(data, o2, ioff);
        o2 += 4;
        o2 += 2;
        return data.buffer;
    };
    UZIP2._noNeed = function(fn2) {
        var ext = fn2.split(".").pop().toLowerCase();
        return "png,jpg,jpeg,zip".indexOf(ext) != -1;
    };
    UZIP2._writeHeader = function(data, o2, p2, obj, t4, roff) {
        var wUi = UZIP2.bin.writeUint, wUs = UZIP2.bin.writeUshort;
        var file = obj.file;
        wUi(data, o2, t4 == 0 ? 67324752 : 33639248);
        o2 += 4;
        if (t4 == 1) o2 += 2;
        wUs(data, o2, 20);
        o2 += 2;
        wUs(data, o2, 0);
        o2 += 2;
        wUs(data, o2, obj.cpr ? 8 : 0);
        o2 += 2;
        wUi(data, o2, 0);
        o2 += 4;
        wUi(data, o2, obj.crc);
        o2 += 4;
        wUi(data, o2, file.length);
        o2 += 4;
        wUi(data, o2, obj.usize);
        o2 += 4;
        wUs(data, o2, UZIP2.bin.sizeUTF8(p2));
        o2 += 2;
        wUs(data, o2, 0);
        o2 += 2;
        if (t4 == 1) {
            o2 += 2;
            o2 += 2;
            o2 += 6;
            wUi(data, o2, roff);
            o2 += 4;
        }
        var nlen = UZIP2.bin.writeUTF8(data, o2, p2);
        o2 += nlen;
        if (t4 == 0) {
            data.set(file, o2);
            o2 += file.length;
        }
        return o2;
    };
    UZIP2.crc = {
        table: function() {
            var tab = new Uint32Array(256);
            for (var n2 = 0; n2 < 256; n2++) {
                var c2 = n2;
                for (var k = 0; k < 8; k++) {
                    if (c2 & 1) c2 = 3988292384 ^ c2 >>> 1;
                    else c2 = c2 >>> 1;
                }
                tab[n2] = c2;
            }
            return tab;
        }(),
        update: function(c2, buf, off, len) {
            for (var i = 0; i < len; i++) c2 = UZIP2.crc.table[(c2 ^ buf[off + i]) & 255] ^ c2 >>> 8;
            return c2;
        },
        crc: function(b2, o2, l2) {
            return UZIP2.crc.update(4294967295, b2, o2, l2) ^ 4294967295;
        }
    };
    UZIP2.adler = function(data, o2, len) {
        var a2 = 1, b2 = 0;
        var off = o2, end2 = o2 + len;
        while (off < end2) {
            var eend = Math.min(off + 5552, end2);
            while (off < eend) {
                a2 += data[off++];
                b2 += a2;
            }
            a2 = a2 % 65521;
            b2 = b2 % 65521;
        }
        return b2 << 16 | a2;
    };
    UZIP2.bin = {
        readUshort: function(buff, p2) {
            return buff[p2] | buff[p2 + 1] << 8;
        },
        writeUshort: function(buff, p2, n2) {
            buff[p2] = n2 & 255;
            buff[p2 + 1] = n2 >> 8 & 255;
        },
        readUint: function(buff, p2) {
            return buff[p2 + 3] * (256 * 256 * 256) + (buff[p2 + 2] << 16 | buff[p2 + 1] << 8 | buff[p2]);
        },
        writeUint: function(buff, p2, n2) {
            buff[p2] = n2 & 255;
            buff[p2 + 1] = n2 >> 8 & 255;
            buff[p2 + 2] = n2 >> 16 & 255;
            buff[p2 + 3] = n2 >> 24 & 255;
        },
        readASCII: function(buff, p2, l2) {
            var s = "";
            for (var i = 0; i < l2; i++) s += String.fromCharCode(buff[p2 + i]);
            return s;
        },
        writeASCII: function(data, p2, s) {
            for (var i = 0; i < s.length; i++) data[p2 + i] = s.charCodeAt(i);
        },
        pad: function(n2) {
            return n2.length < 2 ? "0" + n2 : n2;
        },
        readUTF8: function(buff, p2, l2) {
            var s = "", ns2;
            for (var i = 0; i < l2; i++) s += "%" + UZIP2.bin.pad(buff[p2 + i].toString(16));
            try {
                ns2 = decodeURIComponent(s);
            } catch (e) {
                return UZIP2.bin.readASCII(buff, p2, l2);
            }
            return ns2;
        },
        writeUTF8: function(buff, p2, str) {
            var strl = str.length, i = 0;
            for (var ci2 = 0; ci2 < strl; ci2++) {
                var code2 = str.charCodeAt(ci2);
                if ((code2 & 4294967295 - (1 << 7) + 1) == 0) {
                    buff[p2 + i] = code2;
                    i++;
                } else if ((code2 & 4294967295 - (1 << 11) + 1) == 0) {
                    buff[p2 + i] = 192 | code2 >> 6;
                    buff[p2 + i + 1] = 128 | code2 >> 0 & 63;
                    i += 2;
                } else if ((code2 & 4294967295 - (1 << 16) + 1) == 0) {
                    buff[p2 + i] = 224 | code2 >> 12;
                    buff[p2 + i + 1] = 128 | code2 >> 6 & 63;
                    buff[p2 + i + 2] = 128 | code2 >> 0 & 63;
                    i += 3;
                } else if ((code2 & 4294967295 - (1 << 21) + 1) == 0) {
                    buff[p2 + i] = 240 | code2 >> 18;
                    buff[p2 + i + 1] = 128 | code2 >> 12 & 63;
                    buff[p2 + i + 2] = 128 | code2 >> 6 & 63;
                    buff[p2 + i + 3] = 128 | code2 >> 0 & 63;
                    i += 4;
                } else throw "e";
            }
            return i;
        },
        sizeUTF8: function(str) {
            var strl = str.length, i = 0;
            for (var ci2 = 0; ci2 < strl; ci2++) {
                var code2 = str.charCodeAt(ci2);
                if ((code2 & 4294967295 - (1 << 7) + 1) == 0) {
                    i++;
                } else if ((code2 & 4294967295 - (1 << 11) + 1) == 0) {
                    i += 2;
                } else if ((code2 & 4294967295 - (1 << 16) + 1) == 0) {
                    i += 3;
                } else if ((code2 & 4294967295 - (1 << 21) + 1) == 0) {
                    i += 4;
                } else throw "e";
            }
            return i;
        }
    };
    UZIP2.F = {};
    UZIP2.F.deflateRaw = function(data, out, opos, lvl) {
        var opts = [
            /*
      	 ush good_length; /* reduce lazy search above this match length
      	 ush max_lazy;    /* do not perform lazy search above this match length
              ush nice_length; /* quit search above this match length
      */
            /*      good lazy nice chain */
            /* 0 */
            [0, 0, 0, 0, 0],
            /* store only */
            /* 1 */
            [4, 4, 8, 4, 0],
            /* max speed, no lazy matches */
            /* 2 */
            [4, 5, 16, 8, 0],
            /* 3 */
            [4, 6, 16, 16, 0],
            /* 4 */
            [4, 10, 16, 32, 0],
            /* lazy matches */
            /* 5 */
            [8, 16, 32, 32, 0],
            /* 6 */
            [8, 16, 128, 128, 0],
            /* 7 */
            [8, 32, 128, 256, 0],
            /* 8 */
            [32, 128, 258, 1024, 1],
            /* 9 */
            [32, 258, 258, 4096, 1]
        ];
        var opt = opts[lvl];
        var U2 = UZIP2.F.U, goodIndex = UZIP2.F._goodIndex;
        UZIP2.F._hash;
        var putsE = UZIP2.F._putsE;
        var i = 0, pos = opos << 3, cvrd = 0, dlen = data.length;
        if (lvl == 0) {
            while (i < dlen) {
                var len = Math.min(65535, dlen - i);
                putsE(out, pos, i + len == dlen ? 1 : 0);
                pos = UZIP2.F._copyExact(data, i, len, out, pos + 8);
                i += len;
            }
            return pos >>> 3;
        }
        var lits = U2.lits, strt = U2.strt, prev = U2.prev, li2 = 0, lc2 = 0, bs2 = 0, ebits = 0, c2 = 0, nc2 = 0;
        if (dlen > 2) {
            nc2 = UZIP2.F._hash(data, 0);
            strt[nc2] = 0;
        }
        for (i = 0; i < dlen; i++) {
            c2 = nc2;
            if (i + 1 < dlen - 2) {
                nc2 = UZIP2.F._hash(data, i + 1);
                var ii2 = i + 1 & 32767;
                prev[ii2] = strt[nc2];
                strt[nc2] = ii2;
            }
            if (cvrd <= i) {
                if ((li2 > 14e3 || lc2 > 26697) && dlen - i > 100) {
                    if (cvrd < i) {
                        lits[li2] = i - cvrd;
                        li2 += 2;
                        cvrd = i;
                    }
                    pos = UZIP2.F._writeBlock(i == dlen - 1 || cvrd == dlen ? 1 : 0, lits, li2, ebits, data, bs2, i - bs2, out, pos);
                    li2 = lc2 = ebits = 0;
                    bs2 = i;
                }
                var mch = 0;
                if (i < dlen - 2) mch = UZIP2.F._bestMatch(data, i, prev, c2, Math.min(opt[2], dlen - i), opt[3]);
                var len = mch >>> 16, dst = mch & 65535;
                if (mch != 0) {
                    var len = mch >>> 16, dst = mch & 65535;
                    var lgi = goodIndex(len, U2.of0);
                    U2.lhst[257 + lgi]++;
                    var dgi = goodIndex(dst, U2.df0);
                    U2.dhst[dgi]++;
                    ebits += U2.exb[lgi] + U2.dxb[dgi];
                    lits[li2] = len << 23 | i - cvrd;
                    lits[li2 + 1] = dst << 16 | lgi << 8 | dgi;
                    li2 += 2;
                    cvrd = i + len;
                } else {
                    U2.lhst[data[i]]++;
                }
                lc2++;
            }
        }
        if (bs2 != i || data.length == 0) {
            if (cvrd < i) {
                lits[li2] = i - cvrd;
                li2 += 2;
                cvrd = i;
            }
            pos = UZIP2.F._writeBlock(1, lits, li2, ebits, data, bs2, i - bs2, out, pos);
            li2 = 0;
            lc2 = 0;
            li2 = lc2 = ebits = 0;
            bs2 = i;
        }
        while ((pos & 7) != 0) pos++;
        return pos >>> 3;
    };
    UZIP2.F._bestMatch = function(data, i, prev, c2, nice, chain) {
        var ci2 = i & 32767, pi2 = prev[ci2];
        var dif = ci2 - pi2 + (1 << 15) & 32767;
        if (pi2 == ci2 || c2 != UZIP2.F._hash(data, i - dif)) return 0;
        var tl2 = 0, td = 0;
        var dlim = Math.min(32767, i);
        while (dif <= dlim && --chain != 0 && pi2 != ci2) {
            if (tl2 == 0 || data[i + tl2] == data[i + tl2 - dif]) {
                var cl2 = UZIP2.F._howLong(data, i, dif);
                if (cl2 > tl2) {
                    tl2 = cl2;
                    td = dif;
                    if (tl2 >= nice) break;
                    if (dif + 2 < cl2) cl2 = dif + 2;
                    var maxd = 0;
                    for (var j2 = 0; j2 < cl2 - 2; j2++) {
                        var ei2 = i - dif + j2 + (1 << 15) & 32767;
                        var li2 = prev[ei2];
                        var curd = ei2 - li2 + (1 << 15) & 32767;
                        if (curd > maxd) {
                            maxd = curd;
                            pi2 = ei2;
                        }
                    }
                }
            }
            ci2 = pi2;
            pi2 = prev[ci2];
            dif += ci2 - pi2 + (1 << 15) & 32767;
        }
        return tl2 << 16 | td;
    };
    UZIP2.F._howLong = function(data, i, dif) {
        if (data[i] != data[i - dif] || data[i + 1] != data[i + 1 - dif] || data[i + 2] != data[i + 2 - dif]) return 0;
        var oi2 = i, l2 = Math.min(data.length, i + 258);
        i += 3;
        while (i < l2 && data[i] == data[i - dif]) i++;
        return i - oi2;
    };
    UZIP2.F._hash = function(data, i) {
        return (data[i] << 8 | data[i + 1]) + (data[i + 2] << 4) & 65535;
    };
    UZIP2.saved = 0;
    UZIP2.F._writeBlock = function(BFINAL, lits, li2, ebits, data, o0, l0, out, pos) {
        var U2 = UZIP2.F.U, putsF = UZIP2.F._putsF, putsE = UZIP2.F._putsE;
        var T2, ML, MD, MH, numl, numd, numh, lset, dset;
        U2.lhst[256]++;
        T2 = UZIP2.F.getTrees();
        ML = T2[0];
        MD = T2[1];
        MH = T2[2];
        numl = T2[3];
        numd = T2[4];
        numh = T2[5];
        lset = T2[6];
        dset = T2[7];
        var cstSize = ((pos + 3 & 7) == 0 ? 0 : 8 - (pos + 3 & 7)) + 32 + (l0 << 3);
        var fxdSize = ebits + UZIP2.F.contSize(U2.fltree, U2.lhst) + UZIP2.F.contSize(U2.fdtree, U2.dhst);
        var dynSize = ebits + UZIP2.F.contSize(U2.ltree, U2.lhst) + UZIP2.F.contSize(U2.dtree, U2.dhst);
        dynSize += 14 + 3 * numh + UZIP2.F.contSize(U2.itree, U2.ihst) + (U2.ihst[16] * 2 + U2.ihst[17] * 3 + U2.ihst[18] * 7);
        for (var j2 = 0; j2 < 286; j2++) U2.lhst[j2] = 0;
        for (var j2 = 0; j2 < 30; j2++) U2.dhst[j2] = 0;
        for (var j2 = 0; j2 < 19; j2++) U2.ihst[j2] = 0;
        var BTYPE = cstSize < fxdSize && cstSize < dynSize ? 0 : fxdSize < dynSize ? 1 : 2;
        putsF(out, pos, BFINAL);
        putsF(out, pos + 1, BTYPE);
        pos += 3;
        if (BTYPE == 0) {
            while ((pos & 7) != 0) pos++;
            pos = UZIP2.F._copyExact(data, o0, l0, out, pos);
        } else {
            var ltree, dtree;
            if (BTYPE == 1) {
                ltree = U2.fltree;
                dtree = U2.fdtree;
            }
            if (BTYPE == 2) {
                UZIP2.F.makeCodes(U2.ltree, ML);
                UZIP2.F.revCodes(U2.ltree, ML);
                UZIP2.F.makeCodes(U2.dtree, MD);
                UZIP2.F.revCodes(U2.dtree, MD);
                UZIP2.F.makeCodes(U2.itree, MH);
                UZIP2.F.revCodes(U2.itree, MH);
                ltree = U2.ltree;
                dtree = U2.dtree;
                putsE(out, pos, numl - 257);
                pos += 5;
                putsE(out, pos, numd - 1);
                pos += 5;
                putsE(out, pos, numh - 4);
                pos += 4;
                for (var i = 0; i < numh; i++) putsE(out, pos + i * 3, U2.itree[(U2.ordr[i] << 1) + 1]);
                pos += 3 * numh;
                pos = UZIP2.F._codeTiny(lset, U2.itree, out, pos);
                pos = UZIP2.F._codeTiny(dset, U2.itree, out, pos);
            }
            var off = o0;
            for (var si2 = 0; si2 < li2; si2 += 2) {
                var qb = lits[si2], len = qb >>> 23, end2 = off + (qb & (1 << 23) - 1);
                while (off < end2) pos = UZIP2.F._writeLit(data[off++], ltree, out, pos);
                if (len != 0) {
                    var qc2 = lits[si2 + 1], dst = qc2 >> 16, lgi = qc2 >> 8 & 255, dgi = qc2 & 255;
                    pos = UZIP2.F._writeLit(257 + lgi, ltree, out, pos);
                    putsE(out, pos, len - U2.of0[lgi]);
                    pos += U2.exb[lgi];
                    pos = UZIP2.F._writeLit(dgi, dtree, out, pos);
                    putsF(out, pos, dst - U2.df0[dgi]);
                    pos += U2.dxb[dgi];
                    off += len;
                }
            }
            pos = UZIP2.F._writeLit(256, ltree, out, pos);
        }
        return pos;
    };
    UZIP2.F._copyExact = function(data, off, len, out, pos) {
        var p8 = pos >>> 3;
        out[p8] = len;
        out[p8 + 1] = len >>> 8;
        out[p8 + 2] = 255 - out[p8];
        out[p8 + 3] = 255 - out[p8 + 1];
        p8 += 4;
        out.set(new Uint8Array(data.buffer, off, len), p8);
        return pos + (len + 4 << 3);
    };
    UZIP2.F.getTrees = function() {
        var U2 = UZIP2.F.U;
        var ML = UZIP2.F._hufTree(U2.lhst, U2.ltree, 15);
        var MD = UZIP2.F._hufTree(U2.dhst, U2.dtree, 15);
        var lset = [], numl = UZIP2.F._lenCodes(U2.ltree, lset);
        var dset = [], numd = UZIP2.F._lenCodes(U2.dtree, dset);
        for (var i = 0; i < lset.length; i += 2) U2.ihst[lset[i]]++;
        for (var i = 0; i < dset.length; i += 2) U2.ihst[dset[i]]++;
        var MH = UZIP2.F._hufTree(U2.ihst, U2.itree, 7);
        var numh = 19;
        while (numh > 4 && U2.itree[(U2.ordr[numh - 1] << 1) + 1] == 0) numh--;
        return [ML, MD, MH, numl, numd, numh, lset, dset];
    };
    UZIP2.F.getSecond = function(a2) {
        var b2 = [];
        for (var i = 0; i < a2.length; i += 2) b2.push(a2[i + 1]);
        return b2;
    };
    UZIP2.F.nonZero = function(a2) {
        var b2 = "";
        for (var i = 0; i < a2.length; i += 2) if (a2[i + 1] != 0) b2 += (i >> 1) + ",";
        return b2;
    };
    UZIP2.F.contSize = function(tree, hst) {
        var s = 0;
        for (var i = 0; i < hst.length; i++) s += hst[i] * tree[(i << 1) + 1];
        return s;
    };
    UZIP2.F._codeTiny = function(set2, tree, out, pos) {
        for (var i = 0; i < set2.length; i += 2) {
            var l2 = set2[i], rst = set2[i + 1];
            pos = UZIP2.F._writeLit(l2, tree, out, pos);
            var rsl = l2 == 16 ? 2 : l2 == 17 ? 3 : 7;
            if (l2 > 15) {
                UZIP2.F._putsE(out, pos, rst, rsl);
                pos += rsl;
            }
        }
        return pos;
    };
    UZIP2.F._lenCodes = function(tree, set2) {
        var len = tree.length;
        while (len != 2 && tree[len - 1] == 0) len -= 2;
        for (var i = 0; i < len; i += 2) {
            var l2 = tree[i + 1], nxt = i + 3 < len ? tree[i + 3] : -1, nnxt = i + 5 < len ? tree[i + 5] : -1, prv = i == 0 ? -1 : tree[i - 1];
            if (l2 == 0 && nxt == l2 && nnxt == l2) {
                var lz = i + 5;
                while (lz + 2 < len && tree[lz + 2] == l2) lz += 2;
                var zc2 = Math.min(lz + 1 - i >>> 1, 138);
                if (zc2 < 11) set2.push(17, zc2 - 3);
                else set2.push(18, zc2 - 11);
                i += zc2 * 2 - 2;
            } else if (l2 == prv && nxt == l2 && nnxt == l2) {
                var lz = i + 5;
                while (lz + 2 < len && tree[lz + 2] == l2) lz += 2;
                var zc2 = Math.min(lz + 1 - i >>> 1, 6);
                set2.push(16, zc2 - 3);
                i += zc2 * 2 - 2;
            } else set2.push(l2, 0);
        }
        return len >>> 1;
    };
    UZIP2.F._hufTree = function(hst, tree, MAXL) {
        var list = [], hl2 = hst.length, tl2 = tree.length, i = 0;
        for (i = 0; i < tl2; i += 2) {
            tree[i] = 0;
            tree[i + 1] = 0;
        }
        for (i = 0; i < hl2; i++) if (hst[i] != 0) list.push({ lit: i, f: hst[i] });
        var end2 = list.length, l2 = list.slice(0);
        if (end2 == 0) return 0;
        if (end2 == 1) {
            var lit = list[0].lit, l2 = lit == 0 ? 1 : 0;
            tree[(lit << 1) + 1] = 1;
            tree[(l2 << 1) + 1] = 1;
            return 1;
        }
        list.sort(function(a3, b3) {
            return a3.f - b3.f;
        });
        var a2 = list[0], b2 = list[1], i0 = 0, i1 = 1, i2 = 2;
        list[0] = { lit: -1, f: a2.f + b2.f, l: a2, r: b2, d: 0 };
        while (i1 != end2 - 1) {
            if (i0 != i1 && (i2 == end2 || list[i0].f < list[i2].f)) {
                a2 = list[i0++];
            } else {
                a2 = list[i2++];
            }
            if (i0 != i1 && (i2 == end2 || list[i0].f < list[i2].f)) {
                b2 = list[i0++];
            } else {
                b2 = list[i2++];
            }
            list[i1++] = { lit: -1, f: a2.f + b2.f, l: a2, r: b2 };
        }
        var maxl = UZIP2.F.setDepth(list[i1 - 1], 0);
        if (maxl > MAXL) {
            UZIP2.F.restrictDepth(l2, MAXL, maxl);
            maxl = MAXL;
        }
        for (i = 0; i < end2; i++) tree[(l2[i].lit << 1) + 1] = l2[i].d;
        return maxl;
    };
    UZIP2.F.setDepth = function(t4, d2) {
        if (t4.lit != -1) {
            t4.d = d2;
            return d2;
        }
        return Math.max(UZIP2.F.setDepth(t4.l, d2 + 1), UZIP2.F.setDepth(t4.r, d2 + 1));
    };
    UZIP2.F.restrictDepth = function(dps, MD, maxl) {
        var i = 0, bCost = 1 << maxl - MD, dbt = 0;
        dps.sort(function(a2, b2) {
            return b2.d == a2.d ? a2.f - b2.f : b2.d - a2.d;
        });
        for (i = 0; i < dps.length; i++) if (dps[i].d > MD) {
            var od = dps[i].d;
            dps[i].d = MD;
            dbt += bCost - (1 << maxl - od);
        } else break;
        dbt = dbt >>> maxl - MD;
        while (dbt > 0) {
            var od = dps[i].d;
            if (od < MD) {
                dps[i].d++;
                dbt -= 1 << MD - od - 1;
            } else i++;
        }
        for (; i >= 0; i--) if (dps[i].d == MD && dbt < 0) {
            dps[i].d--;
            dbt++;
        }
        if (dbt != 0) console.log("debt left");
    };
    UZIP2.F._goodIndex = function(v2, arr) {
        var i = 0;
        if (arr[i | 16] <= v2) i |= 16;
        if (arr[i | 8] <= v2) i |= 8;
        if (arr[i | 4] <= v2) i |= 4;
        if (arr[i | 2] <= v2) i |= 2;
        if (arr[i | 1] <= v2) i |= 1;
        return i;
    };
    UZIP2.F._writeLit = function(ch2, ltree, out, pos) {
        UZIP2.F._putsF(out, pos, ltree[ch2 << 1]);
        return pos + ltree[(ch2 << 1) + 1];
    };
    UZIP2.F.inflate = function(data, buf) {
        var u8 = Uint8Array;
        if (data[0] == 3 && data[1] == 0) return buf ? buf : new u8(0);
        var F2 = UZIP2.F, bitsF = F2._bitsF, bitsE = F2._bitsE, decodeTiny = F2._decodeTiny, makeCodes = F2.makeCodes, codes2map = F2.codes2map, get17 = F2._get17;
        var U2 = F2.U;
        var noBuf = buf == null;
        if (noBuf) buf = new u8(data.length >>> 2 << 3);
        var BFINAL = 0, BTYPE = 0, HLIT = 0, HDIST = 0, HCLEN = 0, ML = 0, MD = 0;
        var off = 0, pos = 0;
        var lmap, dmap;
        while (BFINAL == 0) {
            BFINAL = bitsF(data, pos, 1);
            BTYPE = bitsF(data, pos + 1, 2);
            pos += 3;
            if (BTYPE == 0) {
                if ((pos & 7) != 0) pos += 8 - (pos & 7);
                var p8 = (pos >>> 3) + 4, len = data[p8 - 4] | data[p8 - 3] << 8;
                if (noBuf) buf = UZIP2.F._check(buf, off + len);
                buf.set(new u8(data.buffer, data.byteOffset + p8, len), off);
                pos = p8 + len << 3;
                off += len;
                continue;
            }
            if (noBuf) buf = UZIP2.F._check(buf, off + (1 << 17));
            if (BTYPE == 1) {
                lmap = U2.flmap;
                dmap = U2.fdmap;
                ML = (1 << 9) - 1;
                MD = (1 << 5) - 1;
            }
            if (BTYPE == 2) {
                HLIT = bitsE(data, pos, 5) + 257;
                HDIST = bitsE(data, pos + 5, 5) + 1;
                HCLEN = bitsE(data, pos + 10, 4) + 4;
                pos += 14;
                for (var i = 0; i < 38; i += 2) {
                    U2.itree[i] = 0;
                    U2.itree[i + 1] = 0;
                }
                var tl2 = 1;
                for (var i = 0; i < HCLEN; i++) {
                    var l2 = bitsE(data, pos + i * 3, 3);
                    U2.itree[(U2.ordr[i] << 1) + 1] = l2;
                    if (l2 > tl2) tl2 = l2;
                }
                pos += 3 * HCLEN;
                makeCodes(U2.itree, tl2);
                codes2map(U2.itree, tl2, U2.imap);
                lmap = U2.lmap;
                dmap = U2.dmap;
                pos = decodeTiny(U2.imap, (1 << tl2) - 1, HLIT + HDIST, data, pos, U2.ttree);
                var mx0 = F2._copyOut(U2.ttree, 0, HLIT, U2.ltree);
                ML = (1 << mx0) - 1;
                var mx1 = F2._copyOut(U2.ttree, HLIT, HDIST, U2.dtree);
                MD = (1 << mx1) - 1;
                makeCodes(U2.ltree, mx0);
                codes2map(U2.ltree, mx0, lmap);
                makeCodes(U2.dtree, mx1);
                codes2map(U2.dtree, mx1, dmap);
            }
            while (true) {
                var code2 = lmap[get17(data, pos) & ML];
                pos += code2 & 15;
                var lit = code2 >>> 4;
                if (lit >>> 8 == 0) {
                    buf[off++] = lit;
                } else if (lit == 256) {
                    break;
                } else {
                    var end2 = off + lit - 254;
                    if (lit > 264) {
                        var ebs = U2.ldef[lit - 257];
                        end2 = off + (ebs >>> 3) + bitsE(data, pos, ebs & 7);
                        pos += ebs & 7;
                    }
                    var dcode = dmap[get17(data, pos) & MD];
                    pos += dcode & 15;
                    var dlit = dcode >>> 4;
                    var dbs = U2.ddef[dlit], dst = (dbs >>> 4) + bitsF(data, pos, dbs & 15);
                    pos += dbs & 15;
                    if (noBuf) buf = UZIP2.F._check(buf, off + (1 << 17));
                    while (off < end2) {
                        buf[off] = buf[off++ - dst];
                        buf[off] = buf[off++ - dst];
                        buf[off] = buf[off++ - dst];
                        buf[off] = buf[off++ - dst];
                    }
                    off = end2;
                }
            }
        }
        return buf.length == off ? buf : buf.slice(0, off);
    };
    UZIP2.F._check = function(buf, len) {
        var bl = buf.length;
        if (len <= bl) return buf;
        var nbuf = new Uint8Array(Math.max(bl << 1, len));
        nbuf.set(buf, 0);
        return nbuf;
    };
    UZIP2.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {
        var bitsE = UZIP2.F._bitsE, get17 = UZIP2.F._get17;
        var i = 0;
        while (i < len) {
            var code2 = lmap[get17(data, pos) & LL];
            pos += code2 & 15;
            var lit = code2 >>> 4;
            if (lit <= 15) {
                tree[i] = lit;
                i++;
            } else {
                var ll2 = 0, n2 = 0;
                if (lit == 16) {
                    n2 = 3 + bitsE(data, pos, 2);
                    pos += 2;
                    ll2 = tree[i - 1];
                } else if (lit == 17) {
                    n2 = 3 + bitsE(data, pos, 3);
                    pos += 3;
                } else if (lit == 18) {
                    n2 = 11 + bitsE(data, pos, 7);
                    pos += 7;
                }
                var ni2 = i + n2;
                while (i < ni2) {
                    tree[i] = ll2;
                    i++;
                }
            }
        }
        return pos;
    };
    UZIP2.F._copyOut = function(src, off, len, tree) {
        var mx = 0, i = 0, tl2 = tree.length >>> 1;
        while (i < len) {
            var v2 = src[i + off];
            tree[i << 1] = 0;
            tree[(i << 1) + 1] = v2;
            if (v2 > mx) mx = v2;
            i++;
        }
        while (i < tl2) {
            tree[i << 1] = 0;
            tree[(i << 1) + 1] = 0;
            i++;
        }
        return mx;
    };
    UZIP2.F.makeCodes = function(tree, MAX_BITS) {
        var U2 = UZIP2.F.U;
        var max_code = tree.length;
        var code2, bits, n2, i, len;
        var bl_count = U2.bl_count;
        for (var i = 0; i <= MAX_BITS; i++) bl_count[i] = 0;
        for (i = 1; i < max_code; i += 2) bl_count[tree[i]]++;
        var next_code = U2.next_code;
        code2 = 0;
        bl_count[0] = 0;
        for (bits = 1; bits <= MAX_BITS; bits++) {
            code2 = code2 + bl_count[bits - 1] << 1;
            next_code[bits] = code2;
        }
        for (n2 = 0; n2 < max_code; n2 += 2) {
            len = tree[n2 + 1];
            if (len != 0) {
                tree[n2] = next_code[len];
                next_code[len]++;
            }
        }
    };
    UZIP2.F.codes2map = function(tree, MAX_BITS, map) {
        var max_code = tree.length;
        var U2 = UZIP2.F.U, r15 = U2.rev15;
        for (var i = 0; i < max_code; i += 2) if (tree[i + 1] != 0) {
            var lit = i >> 1;
            var cl2 = tree[i + 1], val = lit << 4 | cl2;
            var rest = MAX_BITS - cl2, i0 = tree[i] << rest, i1 = i0 + (1 << rest);
            while (i0 != i1) {
                var p0 = r15[i0] >>> 15 - MAX_BITS;
                map[p0] = val;
                i0++;
            }
        }
    };
    UZIP2.F.revCodes = function(tree, MAX_BITS) {
        var r15 = UZIP2.F.U.rev15, imb = 15 - MAX_BITS;
        for (var i = 0; i < tree.length; i += 2) {
            var i0 = tree[i] << MAX_BITS - tree[i + 1];
            tree[i] = r15[i0] >>> imb;
        }
    };
    UZIP2.F._putsE = function(dt2, pos, val) {
        val = val << (pos & 7);
        var o2 = pos >>> 3;
        dt2[o2] |= val;
        dt2[o2 + 1] |= val >>> 8;
    };
    UZIP2.F._putsF = function(dt2, pos, val) {
        val = val << (pos & 7);
        var o2 = pos >>> 3;
        dt2[o2] |= val;
        dt2[o2 + 1] |= val >>> 8;
        dt2[o2 + 2] |= val >>> 16;
    };
    UZIP2.F._bitsE = function(dt2, pos, length) {
        return (dt2[pos >>> 3] | dt2[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;
    };
    UZIP2.F._bitsF = function(dt2, pos, length) {
        return (dt2[pos >>> 3] | dt2[(pos >>> 3) + 1] << 8 | dt2[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;
    };
    UZIP2.F._get17 = function(dt2, pos) {
        return (dt2[pos >>> 3] | dt2[(pos >>> 3) + 1] << 8 | dt2[(pos >>> 3) + 2] << 16) >>> (pos & 7);
    };
    UZIP2.F._get25 = function(dt2, pos) {
        return (dt2[pos >>> 3] | dt2[(pos >>> 3) + 1] << 8 | dt2[(pos >>> 3) + 2] << 16 | dt2[(pos >>> 3) + 3] << 24) >>> (pos & 7);
    };
    UZIP2.F.U = function() {
        var u16 = Uint16Array, u32 = Uint32Array;
        return {
            next_code: new u16(16),
            bl_count: new u16(16),
            ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
            exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
            ldef: new u16(32),
            df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
            dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
            ddef: new u32(32),
            flmap: new u16(512),
            fltree: [],
            fdmap: new u16(32),
            fdtree: [],
            lmap: new u16(32768),
            ltree: [],
            ttree: [],
            dmap: new u16(32768),
            dtree: [],
            imap: new u16(512),
            itree: [],
            //rev9 : new u16(  512)
            rev15: new u16(1 << 15),
            lhst: new u32(286),
            dhst: new u32(30),
            ihst: new u32(19),
            lits: new u32(15e3),
            strt: new u16(1 << 16),
            prev: new u16(1 << 15)
        };
    }();
    (function() {
        var U2 = UZIP2.F.U;
        var len = 1 << 15;
        for (var i = 0; i < len; i++) {
            var x2 = i;
            x2 = (x2 & 2863311530) >>> 1 | (x2 & 1431655765) << 1;
            x2 = (x2 & 3435973836) >>> 2 | (x2 & 858993459) << 2;
            x2 = (x2 & 4042322160) >>> 4 | (x2 & 252645135) << 4;
            x2 = (x2 & 4278255360) >>> 8 | (x2 & 16711935) << 8;
            U2.rev15[i] = (x2 >>> 16 | x2 << 16) >>> 17;
        }
        function pushV(tgt, n2, sv) {
            while (n2-- != 0) tgt.push(0, sv);
        }
        for (var i = 0; i < 32; i++) {
            U2.ldef[i] = U2.of0[i] << 3 | U2.exb[i];
            U2.ddef[i] = U2.df0[i] << 4 | U2.dxb[i];
        }
        pushV(U2.fltree, 144, 8);
        pushV(U2.fltree, 255 - 143, 9);
        pushV(U2.fltree, 279 - 255, 7);
        pushV(U2.fltree, 287 - 279, 8);
        UZIP2.F.makeCodes(U2.fltree, 9);
        UZIP2.F.codes2map(U2.fltree, 9, U2.flmap);
        UZIP2.F.revCodes(U2.fltree, 9);
        pushV(U2.fdtree, 32, 5);
        UZIP2.F.makeCodes(U2.fdtree, 5);
        UZIP2.F.codes2map(U2.fdtree, 5, U2.fdmap);
        UZIP2.F.revCodes(U2.fdtree, 5);
        pushV(U2.itree, 19, 0);
        pushV(U2.ltree, 286, 0);
        pushV(U2.dtree, 30, 0);
        pushV(U2.ttree, 320, 0);
    })();
})(UZIP);
function n(t4, e) {
    return [t4[0] * e[0] + t4[2] * e[1], t4[1] * e[0] + t4[3] * e[1], t4[0] * e[2] + t4[2] * e[3], t4[1] * e[2] + t4[3] * e[3], t4[0] * e[4] + t4[2] * e[5] + t4[4], t4[1] * e[4] + t4[3] * e[5] + t4[5]];
}
let o = class t {
    constructor(...e) {
        __publicField(this, "m_matrix");
        this.m_matrix = 0 === e.length ? [1, 0, 0, 1, 0, 0] : e[0] instanceof Array ? e[0] : e[0] instanceof t ? this.m_matrix = e[0].toArray() : [...e];
    }
    multiAtLeft(e) {
        const i = this.m_matrix, s = e instanceof t ? e.m_matrix : e;
        this.m_matrix = n(s, i);
    }
    multi(e) {
        const i = this.m_matrix, s = e instanceof t ? e.m_matrix : e;
        this.m_matrix = n(i, s);
    }
    trans(t4, e) {
        this.multiAtLeft([1, 0, 0, 1, t4, e]);
    }
    preTrans(t4, e) {
        this.multi([1, 0, 0, 1, t4, e]);
    }
    scale(t4, e) {
        this.multiAtLeft([t4, 0, 0, e ?? t4, 0, 0]);
    }
    preScale(t4, e) {
        this.multi([t4, 0, 0, e ?? t4, 0, 0]);
    }
    skewX(t4) {
        this.multiAtLeft([1, 0, Math.tan(t4), 1, 0, 0]);
    }
    scaleX(t4) {
        this.multiAtLeft([t4, 0, 0, 1, 0, 0]);
    }
    scaleY(t4) {
        this.multiAtLeft([1, 0, 0, t4, 0, 0]);
    }
    rotate(t4, e, i) {
        (e || i) && this.trans(-(e || 0), -(i || 0));
        const s = Math.cos(t4), r = Math.sin(t4);
        this.multiAtLeft([s, r, -r, s, 0, 0]), (e || i) && this.trans(e || 0, i || 0);
    }
    computeCoord(t4, e) {
        const i = "object" == typeof t4, s = i ? t4.x : t4, r = i ? t4.y : e, n2 = this.m_matrix;
        return { x: n2[0] * s + n2[2] * r + n2[4], y: n2[1] * s + n2[3] * r + n2[5] };
    }
    computeCoord2(t4, e) {
        const i = this.m_matrix;
        return { x: i[0] * t4 + i[2] * e + i[4], y: i[1] * t4 + i[3] * e + i[5] };
    }
    computeCoord3(t4) {
        const e = this.m_matrix, i = t4.x, s = t4.y;
        return { x: e[0] * i + e[2] * s + e[4], y: e[1] * i + e[3] * s + e[5] };
    }
    computeRef(t4, e) {
        const i = this.m_matrix;
        return { x: i[0] * t4 + i[2] * e, y: i[1] * t4 + i[3] * e };
    }
    get inverse() {
        const t4 = this.m_matrix, e = t4[0] * t4[3] - t4[1] * t4[2];
        return [t4[3] / e, -t4[1] / e, -t4[2] / e, t4[0] / e, (t4[2] * t4[5] - t4[4] * t4[3]) / e, (t4[1] * t4[4] - t4[5] * t4[0]) / e];
    }
    inverseCoord(t4, e) {
        const i = "object" == typeof t4, s = i ? t4.x : t4, r = i ? t4.y : e, n2 = this.inverse;
        return { x: n2[0] * s + n2[2] * r + n2[4], y: n2[1] * s + n2[3] * r + n2[5] };
    }
    inverseRef(t4, e) {
        const i = this.inverse;
        return { x: i[0] * t4 + i[2] * e, y: i[1] * t4 + i[3] * e };
    }
    equals(t4) {
        for (let e = 0; e < 6; e++) if (Math.abs(this.m_matrix[e] - t4.m_matrix[e]) > 1e-7) return false;
        return true;
    }
    reset(...e) {
        if (0 === e.length) {
            const t4 = this.m_matrix;
            t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 1, t4[4] = 0, t4[5] = 0;
        } else this.m_matrix = e[0] instanceof Array ? e[0] : e[0] instanceof t ? this.m_matrix = e[0].toArray() : [...e];
    }
    toString() {
        return "matrix(" + this.m_matrix.join(",") + ")";
    }
    toArray() {
        return this.m_matrix.slice(0);
    }
    get m00() {
        return this.m_matrix[0];
    }
    get m01() {
        return this.m_matrix[2];
    }
    get m02() {
        return this.m_matrix[4];
    }
    get m10() {
        return this.m_matrix[1];
    }
    get m11() {
        return this.m_matrix[3];
    }
    get m12() {
        return this.m_matrix[5];
    }
    flipVert(t4) {
        t4 && this.trans(0, -t4), this.multiAtLeft([1, 0, 0, -1, 0, 0]), t4 && this.trans(0, t4);
    }
    flipHoriz(t4) {
        t4 && this.trans(-t4, 0), this.multiAtLeft([-1, 0, 0, 1, 0, 0]), t4 && this.trans(t4, 0);
    }
    get identity() {
        return [1, 0, 0, 1, 0, 0];
    }
    isIdentity() {
        const t4 = this.identity, e = this.m_matrix;
        for (let i = 0, s = e.length; i < s; i++) if (Math.abs(e[i] - t4[i]) > 1e-7) return false;
        return true;
    }
    isValid() {
        const t4 = this.m_matrix;
        for (let e = 0, i = t4.length; e < i; e++) {
            const i2 = t4[e];
            if (Number.isNaN(i2) || !Number.isFinite(i2)) return false;
        }
        return true;
    }
    checkValid() {
        if (!this.isValid()) throw new Error("Wrong Matrix: " + this.m_matrix);
    }
    clone() {
        return new t(this);
    }
}, a = 0;
const h = "__object_id__";
function c(t4) {
    return t4[h] ?? (t4[h] = a++);
}
var l, d;
!function(t4) {
    t4[t4.MITER = 0] = "MITER", t4[t4.ROUND = 1] = "ROUND", t4[t4.BEVEL = 2] = "BEVEL";
}(l || (l = {})), function(t4) {
    t4[t4.BUTT = 0] = "BUTT", t4[t4.ROUND = 1] = "ROUND", t4[t4.SQUARE = 2] = "SQUARE";
}(d || (d = {}));
const p = { text: { textMeasure: (t4, e) => {
        }, getTextPath: (t4, e, i, s, r) => "" }, boolop: { difference: (t4, e) => "", intersection: (t4, e) => "", subtract: (t4, e) => "", union: (t4, e) => "", stroke: () => "" }, makePalPath: (t4) => {
        throw new Error("not implemented");
    } };
function f(t4) {
    const e = /* @__PURE__ */ new Map([["data:image/svg+xml", "svg"], ["data:image/gif", "gif"], ["data:image/jpeg", "jpeg"], ["data:image/png", "png"]]), i = t4.substring(0, t4.indexOf(";"));
    return e.get(i);
}
function g(t4, e) {
    return (/* @__PURE__ */ new Map([["svg", `data:image/svg+xml;base64,${e}`], ["gif", `data:image/gif;base64,${e}`], ["jpeg", `data:image/jpeg;base64,${e}`], ["png", `data:image/png;base64,${e}`]])).get(t4) || "";
}
function m(t4) {
    return "undefined" != typeof window ? window.btoa(t4) : Buffer.from(t4).toString("base64");
}
function _(t4, e, i) {
    const s = t4[e];
    if (s && s.length > 0) {
        const t5 = s.indexOf(i);
        t5 >= 0 && s.splice(t5, 1);
    }
}
class y {
    constructor() {
        __publicField(this, "_events", {});
        __publicField(this, "_onceEvents", {});
    }
    on(t4, e) {
        return (this._events[t4] || (this._events[t4] = [])).push(e), { remove: () => _(this._events, t4, e) };
    }
    once(t4, e) {
        return (this._onceEvents[t4] || (this._onceEvents[t4] = [])).push(e), { remove: () => _(this._onceEvents, t4, e) };
    }
    emit(t4, ...e) {
        const i = this._events[t4];
        i && i.length > 0 && Array.from(i).forEach((t5) => t5(...e));
        const s = this._onceEvents[t4];
        s && s.length > 0 && (Array.from(s).forEach((t5) => t5(...e)), delete this._onceEvents[t4]);
    }
    remove(t4, e, i = "all") {
        "once" !== i && _(this._events, t4, e), "on" !== i && _(this._onceEvents, t4, e);
    }
}
const x = 1e-7;
function w(t4, e) {
    return t4 === e || Math.abs(t4 - e) < x;
}
function b(t4) {
    return w(t4, 0);
}
function M(t4) {
    return w(t4, 1);
}
class v {
    constructor(t4, e = 0, i = false) {
        __publicField(this, "dimension");
        __publicField(this, "sizeForDimension");
        __publicField(this, "data");
        if (-1 !== t4.findIndex((t5) => t5 < 0)) throw new Error("各维度的大小不能为负数");
        this.dimension = t4.length, this.sizeForDimension = [...t4];
        const s = t4.reduce((t5, e2) => t5 * e2, 1);
        if (Array.isArray(e)) {
            if (e.length !== s) throw new Error("填充数组长度不匹配");
            if (!i && -1 !== e.findIndex((t5) => "number" != typeof t5)) throw new Error("填充数组元素类型不匹配");
            this.data = e;
        } else {
            if ("number" != typeof e) throw new Error("填充值类型不匹配");
            this.data = new Array(s).fill(e);
        }
    }
    getIndex(t4) {
        if (t4.length !== this.dimension) throw new Error("维数不匹配");
        let e = 0;
        for (let i = 0; i < t4.length; i++) {
            const s = t4[i];
            if (s < 0 || s >= this.sizeForDimension[i]) throw new Error("索引越界");
            e = e * this.sizeForDimension[i] + s;
        }
        return e;
    }
    get(t4) {
        return this.data[this.getIndex(t4)];
    }
    set(t4, e) {
        this.data[this.getIndex(t4)] = e;
    }
    clone() {
        const t4 = new this.constructor(this.sizeForDimension);
        return t4.data = this.data.slice(), t4;
    }
    resize(t4, e = 0) {
        if (-1 !== t4.findIndex((t5) => t5 < 0)) throw new Error("各维度的大小不能为负数");
        const i = t4.reduce((t5, e2) => t5 * e2, 1);
        return i < this.data.length ? this.data = this.data.slice(0, i) : i > this.data.length && (this.data = this.data.concat(new Array(i - this.data.length).fill(e))), this.dimension = t4.length, this.sizeForDimension = [...t4], this;
    }
    _toString(t4) {
        if (t4.length > this.dimension) throw new Error("维数不匹配");
        if (t4.length === this.dimension) return this.get(t4).toString();
        let e = "\n";
        return t4.length > 0 && (e += " ".repeat(2 * t4.length)), (0 === t4.length ? "" : e) + "[" + Array.from({ length: this.sizeForDimension[t4.length] }, (e2, i) => this._toString([...t4, i])).join("," + (t4.length === this.dimension - 1 ? " " : "")) + (t4.length === this.dimension - 1 ? "" : ",") + (t4.length === this.dimension - 1 ? "" : e) + "]";
    }
    toString() {
        return this._toString([]);
    }
}
class S extends v {
    constructor(t4, e = 0, i = false) {
        if (2 !== t4.length) throw new Error("必须为2维");
        super(t4, e, i);
    }
    getIndex(t4) {
        if (2 !== t4.length) throw new Error("维数不匹配");
        return t4[0] * this.sizeForDimension[1] + t4[1];
    }
    equals(t4) {
        if (this.sizeForDimension.length !== t4.sizeForDimension.length) return false;
        for (let e = 0; e < this.sizeForDimension.length; e++) if (this.sizeForDimension[e] !== t4.sizeForDimension[e]) return false;
        if (this.data.length !== t4.data.length) return false;
        for (let e = 0; e < this.data.length; e++) if (!w(this.data[e], t4.data[e])) return false;
        return true;
    }
    static FromNumberArray(t4) {
        if (t4 instanceof S) return t4;
        if (2 !== t4.dimension) throw new Error("numberArray必须是二维数组");
        return new S(t4.sizeForDimension, t4.data, true);
    }
    static BuildIdentity(t4) {
        const e = t4[0], i = t4[1];
        if (2 === e && 2 === i) return new S([2, 2], [1, 0, 0, 1], true);
        if (3 === e && 3 === i) return new S([3, 3], [1, 0, 0, 0, 1, 0, 0, 0, 1], true);
        if (4 === e && 4 === i) return new S([4, 4], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], true);
        const s = new S(t4, 0), r = Math.min(e, i);
        for (let t5 = 0; t5 < r; t5++) s.set([t5, t5], 1);
        return s;
    }
    get rowCount() {
        return this.sizeForDimension[0];
    }
    get colCount() {
        return this.sizeForDimension[1];
    }
    rows(t4, e) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        const [i, s] = this.sizeForDimension;
        if (void 0 === e && (e = i - t4), t4 < 0 || t4 + e > i) throw new Error("行索引越界");
        if (e < 0) throw new Error("行数范围错误");
        return this.data.slice(t4 * s, (t4 + e) * s);
    }
    row(t4) {
        return this.rows(t4, 1);
    }
    cols(t4, e) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        const [i, s] = this.sizeForDimension;
        if (void 0 === e && (e = s - t4), t4 < 0 || t4 + e > s) throw new Error("列索引越界");
        if (e < 0) throw new Error("列数范围错误");
        const r = [];
        for (let s2 = t4; s2 < t4 + e; s2++) for (let t5 = 0; t5 < i; t5++) r.push(this.get([t5, s2]));
        return r;
    }
    col(t4) {
        return this.cols(t4, 1);
    }
    insertRows(t4, e, i = false) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        if (t4 instanceof S && (t4 = t4.data), t4.length % this.sizeForDimension[1] != 0) throw new Error("行数据长度不匹配");
        if (void 0 === e && (e = this.sizeForDimension[0]), e < 0 || e > this.sizeForDimension[0]) throw new Error("行索引越界");
        if (!i && -1 !== t4.findIndex((t5) => "number" != typeof t5)) throw new Error("填充数组元素类型不匹配");
        return this.data.splice(e * this.sizeForDimension[1], 0, ...t4), this.sizeForDimension[0] += t4.length / this.sizeForDimension[1], this;
    }
    insertCols(t4, e, i = false) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        const [s, r] = this.sizeForDimension;
        if (!(t4 instanceof S)) {
            if (t4.length % s != 0) throw new Error("列数据长度不匹配");
            t4 = new S([s, t4.length / s], t4, i);
        }
        if (void 0 === e && (e = r), e < 0 || e > r) throw new Error("列索引越界");
        for (let i2 = t4.sizeForDimension[1] - 1, n2 = 0; i2 >= 0; i2--, n2++) for (let o2 = s - 1; o2 >= 0; o2--) this.data.splice(o2 * (r + n2) + e, 0, t4.get([o2, i2]));
        return this.sizeForDimension[1] += t4.sizeForDimension[1], this;
    }
    deleteRow(t4, e = 1) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        const [i, s] = this.sizeForDimension;
        if (void 0 === t4 && (t4 = i - 1), t4 < 0 || t4 + e > i) throw new Error("行索引越界");
        return this.data.splice(t4 * s, e * s), this.sizeForDimension[0] -= e, this;
    }
    deleteCol(t4, e = 1) {
        if (2 !== this.dimension) throw new Error("data必须是二维数组");
        const [i, s] = this.sizeForDimension;
        if (void 0 === t4 && (t4 = s - 1), t4 < 0 || t4 + e > s) throw new Error("列索引越界");
        for (let r = i - 1; r >= 0; r--) this.data.splice(r * s + t4, e);
        return this.sizeForDimension[1] -= e, this;
    }
    get m00() {
        return this.get([0, 0]);
    }
    set m00(t4) {
        this.set([0, 0], t4);
    }
    get m01() {
        return this.get([0, 1]);
    }
    set m01(t4) {
        this.set([0, 1], t4);
    }
    get m02() {
        return this.get([0, 2]);
    }
    set m02(t4) {
        this.set([0, 2], t4);
    }
    get m03() {
        return this.get([0, 3]);
    }
    set m03(t4) {
        this.set([0, 3], t4);
    }
    get m10() {
        return this.get([1, 0]);
    }
    set m10(t4) {
        this.set([1, 0], t4);
    }
    get m11() {
        return this.get([1, 1]);
    }
    set m11(t4) {
        this.set([1, 1], t4);
    }
    get m12() {
        return this.get([1, 2]);
    }
    set m12(t4) {
        this.set([1, 2], t4);
    }
    get m13() {
        return this.get([1, 3]);
    }
    set m13(t4) {
        this.set([1, 3], t4);
    }
    get m20() {
        return this.get([2, 0]);
    }
    set m20(t4) {
        this.set([2, 0], t4);
    }
    get m21() {
        return this.get([2, 1]);
    }
    set m21(t4) {
        this.set([2, 1], t4);
    }
    get m22() {
        return this.get([2, 2]);
    }
    set m22(t4) {
        this.set([2, 2], t4);
    }
    get m23() {
        return this.get([2, 3]);
    }
    set m23(t4) {
        this.set([2, 3], t4);
    }
    get m30() {
        return this.get([3, 0]);
    }
    set m30(t4) {
        this.set([3, 0], t4);
    }
    get m31() {
        return this.get([3, 1]);
    }
    set m31(t4) {
        this.set([3, 1], t4);
    }
    get m32() {
        return this.get([3, 2]);
    }
    set m32(t4) {
        this.set([3, 2], t4);
    }
    get m33() {
        return this.get([3, 3]);
    }
    set m33(t4) {
        this.set([3, 3], t4);
    }
}
let C$1 = class C {
    constructor(t4, e = 0, i = false) {
        __publicField(this, "data");
        if (t4 instanceof S || (t4 = new S(t4, e, i)), 2 !== t4.dimension) throw new Error("data必须是二维数组");
        this.data = t4;
    }
    static Build(t4, e) {
        return new C(new S(t4, e));
    }
    static BuildIdentity(t4) {
        return new C(S.BuildIdentity(t4));
    }
    static FromMatrix(t4) {
        return new C(t4.data);
    }
    get(t4) {
        return this.data.get(t4);
    }
    set(t4, e) {
        this.data.set(t4, e);
    }
    clone() {
        return new this.constructor(this.data.clone());
    }
    equals(t4) {
        return this.data.equals(t4.data);
    }
    get rawData() {
        return this.data.data;
    }
    get m00() {
        return this.data.m00;
    }
    set m00(t4) {
        this.data.m00 = t4;
    }
    get m01() {
        return this.data.m01;
    }
    set m01(t4) {
        this.data.m01 = t4;
    }
    get m02() {
        return this.data.m02;
    }
    set m02(t4) {
        this.data.m02 = t4;
    }
    get m03() {
        return this.data.m03;
    }
    set m03(t4) {
        this.data.m03 = t4;
    }
    get m10() {
        return this.data.m10;
    }
    set m10(t4) {
        this.data.m10 = t4;
    }
    get m11() {
        return this.data.m11;
    }
    set m11(t4) {
        this.data.m11 = t4;
    }
    get m12() {
        return this.data.m12;
    }
    set m12(t4) {
        this.data.m12 = t4;
    }
    get m13() {
        return this.data.m13;
    }
    set m13(t4) {
        this.data.m13 = t4;
    }
    get m20() {
        return this.data.m20;
    }
    set m20(t4) {
        this.data.m20 = t4;
    }
    get m21() {
        return this.data.m21;
    }
    set m21(t4) {
        this.data.m21 = t4;
    }
    get m22() {
        return this.data.m22;
    }
    set m22(t4) {
        this.data.m22 = t4;
    }
    get m23() {
        return this.data.m23;
    }
    set m23(t4) {
        this.data.m23 = t4;
    }
    get m30() {
        return this.data.m30;
    }
    set m30(t4) {
        this.data.m30 = t4;
    }
    get m31() {
        return this.data.m31;
    }
    set m31(t4) {
        this.data.m31 = t4;
    }
    get m32() {
        return this.data.m32;
    }
    set m32(t4) {
        this.data.m32 = t4;
    }
    get m33() {
        return this.data.m33;
    }
    set m33(t4) {
        this.data.m33 = t4;
    }
    get size() {
        return [...this.data.sizeForDimension];
    }
    get rowCount() {
        return this.size[0];
    }
    get colCount() {
        return this.size[1];
    }
    get isSquare() {
        return this.rowCount === this.colCount;
    }
    get isIdentity() {
        const [t4, e] = this.size;
        if (t4 !== e) return false;
        for (let i = 0; i < t4; i++) for (let t5 = 0; t5 < e; t5++) if (!w(this.get([i, t5]), i === t5 ? 1 : 0)) return false;
        return true;
    }
    get isDiagonal() {
        const [t4, e] = this.size;
        if (t4 !== e) return false;
        for (let i = 0; i < t4; i++) for (let t5 = 0; t5 < e; t5++) if (i !== t5 && !b(this.get([i, t5]))) return false;
        return true;
    }
    get isSymmetric() {
        const [t4, e] = this.size;
        if (t4 !== e) return false;
        for (let e2 = 0; e2 < t4; e2++) for (let i = e2 + 1; i < t4; i++) if (!w(this.get([e2, i]), this.get([i, e2]))) return false;
        return true;
    }
    get isUpperTriangular() {
        const [t4, e] = this.size;
        if (t4 !== e) return false;
        for (let e2 = 0; e2 < t4; e2++) for (let t5 = 0; t5 < e2; t5++) if (!b(this.get([e2, t5]))) return false;
        return true;
    }
    get isLowerTriangular() {
        const [t4, e] = this.size;
        if (t4 !== e) return false;
        for (let i = 0; i < t4; i++) for (let t5 = i + 1; t5 < e; t5++) if (!b(this.get([i, t5]))) return false;
        return true;
    }
    resize(t4, e = 0) {
        const [i, s] = this.size, [r, n2] = t4;
        return i > r ? this.data.deleteRow(r, i - r) : i < r && this.data.insertRows(new S([r - i, n2], e), i, true), s > n2 ? this.data.deleteCol(n2, s - n2) : s < n2 && this.data.insertCols(new S([r, n2 - s], e), s, true), this;
    }
    forEach(t4) {
        const [e, i] = this.size;
        for (let s = 0; s < e; s++) for (let e2 = 0; e2 < i; e2++) t4(this.get([s, e2]), [s, e2]);
    }
    flat() {
        return this.data.data.slice();
    }
    static FromCols(t4) {
        const e = t4.length, i = t4[0].size[0], s = new S([i, e]);
        for (let r = 0; r < e; r++) {
            const e2 = t4[r];
            if (e2.size[0] !== i) throw new Error("列向量的维度不匹配");
            for (let t5 = 0; t5 < i; t5++) s.set([t5, r], e2.get([t5, 0]));
        }
        return new C(s);
    }
    static FromRows(t4) {
        const e = t4.length, i = t4[0].size[1], s = new S([e, i]);
        for (let r = 0; r < e; r++) {
            const e2 = t4[r];
            if (e2.size[1] !== i) throw new Error("行向量的维度不匹配");
            for (let t5 = 0; t5 < i; t5++) s.set([r, t5], e2.get([0, t5]));
        }
        return new C(s);
    }
    col(t4) {
        const [e, i] = this.size;
        if (t4 < 0 || t4 >= i) throw new Error("列数越界");
        return new I(this.data.col(t4));
    }
    cols(t4, e) {
        const [i, s] = this.size;
        if (void 0 === e && (e = s - t4), t4 < 0 || t4 + e > s) throw new Error("列索引越界");
        if (e < 0) throw new Error("列数范围错误");
        const r = [];
        for (let i2 = t4; i2 < t4 + e; i2++) r.push(this.col(i2));
        return r;
    }
    allCol() {
        return this.cols(0);
    }
    mapCol(t4) {
        const [e, i] = this.size, s = [];
        for (let e2 = 0; e2 < i; e2++) s.push(t4(this.col(e2), e2, this));
        return s;
    }
    row(t4) {
        if (t4 < 0 || t4 >= this.size[0]) throw new Error("行数越界");
        return new A(this.data.row(t4));
    }
    rows(t4, e) {
        const [i, s] = this.size;
        if (void 0 === e && (e = i - t4), t4 < 0 || t4 + e > i) throw new Error("行索引越界");
        if (e < 0) throw new Error("行数范围错误");
        const r = [];
        for (let i2 = t4; i2 < t4 + e; i2++) r.push(this.row(i2));
        return r;
    }
    allRow() {
        return this.rows(0);
    }
    mapRow(t4) {
        const [e, i] = this.size, s = [];
        for (let i2 = 0; i2 < e; i2++) s.push(t4(this.row(i2), i2));
        return s;
    }
    subMatrix(t4, e = [0, 0]) {
        const i = e[0], s = e[1], [r, n2] = this.size, [o2, a2] = t4;
        if (o2 < 0 || a2 < 0) throw new Error("子矩阵大小不能为负");
        if (i < 0 || s < 0 || i + o2 > r || s + a2 > n2) throw new Error("子矩阵范围越界");
        const h2 = new S(t4);
        for (let t5 = 0; t5 < o2; t5++) for (let e2 = 0; e2 < a2; e2++) h2.set([t5, e2], this.get([t5 + i, e2 + s]));
        return new C(h2);
    }
    setSubMatrix(t4, e = [0, 0]) {
        const i = e[0], s = e[1], [r, n2] = this.size, [o2, a2] = t4.size;
        if (i < 0 || s < 0 || i + o2 > r || s + a2 > n2) throw new Error("子矩阵范围越界");
        for (let e2 = 0; e2 < o2; e2++) for (let r2 = 0; r2 < a2; r2++) this.set([e2 + i, r2 + s], t4.get([e2, r2]));
        return this;
    }
    get col0() {
        return this.col(0);
    }
    set col0(t4) {
        t4 instanceof I || (t4 = new I(t4)), this.setSubMatrix(t4);
    }
    get col1() {
        return this.col(1);
    }
    set col1(t4) {
        t4 instanceof I || (t4 = new I(t4)), this.setSubMatrix(t4, [0, 1]);
    }
    get col2() {
        return this.col(2);
    }
    set col2(t4) {
        t4 instanceof I || (t4 = new I(t4)), this.setSubMatrix(t4, [0, 2]);
    }
    get col3() {
        return this.col(3);
    }
    set col3(t4) {
        t4 instanceof I || (t4 = new I(t4)), this.setSubMatrix(t4, [0, 3]);
    }
    get row0() {
        return this.row(0);
    }
    set row0(t4) {
        t4 instanceof A || (t4 = new A(t4)), this.setSubMatrix(t4);
    }
    get row1() {
        return this.row(1);
    }
    set row1(t4) {
        t4 instanceof A || (t4 = new A(t4)), this.setSubMatrix(t4, [1, 0]);
    }
    get row2() {
        return this.row(2);
    }
    set row2(t4) {
        t4 instanceof A || (t4 = new A(t4)), this.setSubMatrix(t4, [2, 0]);
    }
    get row3() {
        return this.row(3);
    }
    set row3(t4) {
        t4 instanceof A || (t4 = new A(t4)), this.setSubMatrix(t4, [3, 0]);
    }
    insertCols(t4, e) {
        return t4 instanceof I ? t4 = t4.data : Array.isArray(t4) && t4[0] instanceof I && (t4 = t4.reduce((t5, e2) => (t5.push(...e2.data.data), t5), [])), this.data.insertCols(t4, e, true), this;
    }
    insertRows(t4, e) {
        return t4 instanceof A ? t4 = t4.data : Array.isArray(t4) && t4[0] instanceof A && (t4 = t4.reduce((t5, e2) => (t5.push(...e2.data.data), t5), [])), this.data.insertRows(t4, e, true), this;
    }
    deleteCol(t4, e = 1) {
        return this.data.deleteCol(t4, e), this;
    }
    deleteRow(t4, e = 1) {
        return this.data.deleteRow(t4, e), this;
    }
    transpose() {
        const [t4, e] = this.size;
        for (let i = 0; i < t4; i++) for (let t5 = i + 1; t5 < e; t5++) {
            const e2 = this.get([i, t5]);
            this.set([i, t5], this.get([t5, i])), this.set([t5, i], e2);
        }
        return new C(this.data);
    }
    transposeSubMatrix(t4, e = [0, 0]) {
        const i = e[0], s = e[1], [r, n2] = this.size, o2 = t4, a2 = t4;
        if (o2 < 0) throw new Error("子矩阵大小不能为负");
        if (i < 0 || s < 0 || i + o2 > r || s + a2 > n2) throw new Error("子矩阵范围越界");
        for (let t5 = 0; t5 < o2; t5++) for (let e2 = t5 + 1; e2 < a2; e2++) {
            const r2 = this.get([t5 + i, e2 + s]);
            this.set([t5 + i, e2 + s], this.get([e2 + i, t5 + s])), this.set([e2 + i, t5 + s], r2);
        }
        return this;
    }
    add(t4, e = [0, 0]) {
        const i = e[0], s = e[1], [r, n2] = this.size, [o2, a2] = t4.size;
        if (i < 0 || s < 0 || i + o2 > r || s + a2 > n2) throw new Error("子矩阵范围越界");
        for (let e2 = 0; e2 < o2; e2++) for (let r2 = 0; r2 < a2; r2++) this.set([e2 + i, r2 + s], this.get([e2 + i, r2 + s]) + t4.get([e2, r2]));
        return this;
    }
    subtract(t4, e = [0, 0]) {
        const i = e[0], s = e[1], [r, n2] = this.size, [o2, a2] = t4.size;
        if (i < 0 || s < 0 || i + o2 > r || s + a2 > n2) throw new Error("子矩阵范围越界");
        for (let e2 = 0; e2 < o2; e2++) for (let r2 = 0; r2 < a2; r2++) this.set([e2 + i, r2 + s], this.get([e2 + i, r2 + s]) - t4.get([e2, r2]));
        return this;
    }
    multiplyByNumber(t4) {
        const [e, i] = this.size;
        for (let s = 0; s < e; s++) for (let e2 = 0; e2 < i; e2++) this.set([s, e2], this.get([s, e2]) * t4);
        return this;
    }
    multiplyByNumberSubMatrix(t4, e, i = [0, 0]) {
        const s = i[0], r = i[1], [n2, o2] = this.size, [a2, h2] = e;
        if (a2 < 0 || h2 < 0) throw new Error("子矩阵大小不能为负");
        if (s < 0 || r < 0 || s + a2 > n2 || r + h2 > o2) throw new Error("子矩阵范围越界");
        for (let e2 = 0; e2 < a2; e2++) for (let i2 = 0; i2 < h2; i2++) this.set([e2 + s, i2 + r], this.get([e2 + s, i2 + r]) * t4);
        return this;
    }
    _getMultiply(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (i !== s) throw new Error("矩阵阶数不匹配，无法相乘");
        const n2 = new S([e, r]), o2 = this.isSquare, a2 = t4.isSquare, h2 = this.isDiagonal, c2 = t4.isDiagonal;
        if (o2 && a2 && h2 && c2) {
            for (let i2 = 0; i2 < e; i2++) n2.set([i2, i2], this.get([i2, i2]) * t4.get([i2, i2]));
            return n2;
        }
        if (h2) {
            for (let i2 = 0; i2 < e; i2++) for (let e2 = 0; e2 < r; e2++) n2.set([i2, e2], this.get([i2, i2]) * t4.get([i2, e2]));
            return n2;
        }
        if (c2) {
            for (let i2 = 0; i2 < e; i2++) for (let e2 = 0; e2 < r; e2++) n2.set([i2, e2], t4.get([e2, e2]) * this.get([i2, e2]));
            return n2;
        }
        for (let s2 = 0; s2 < e; s2++) for (let e2 = 0; e2 < r; e2++) {
            let r2 = 0;
            for (let n3 = 0; n3 < i; n3++) r2 += this.get([s2, n3]) * t4.get([n3, e2]);
            n2.set([s2, e2], r2);
        }
        return n2;
    }
    multiply(t4) {
        return this.data = this._getMultiply(t4), this;
    }
    getMultiply(t4) {
        return this.clone().multiply(t4);
    }
    multiplySubMatrix(t4, e, i = [0, 0]) {
        const s = i[0], r = i[1], [n2, o2] = this.size, [a2, h2] = t4.size;
        void 0 === e && (e = [a2, a2]);
        const [c2, l2] = e;
        if (c2 < 0 || l2 < 0) throw new Error("子矩阵大小不能为负");
        if (s < 0 || r < 0 || s + c2 > n2 || r + l2 > o2) throw new Error("子矩阵范围越界");
        if (a2 < l2 || h2 < l2) throw new Error("矩阵阶数不匹配，无法相乘");
        return this.setSubMatrix(this.subMatrix(e, i).multiply(t4.clone().resize([l2, l2])), i), this;
    }
    getMultiplySubMatrix(t4, e, i = [0, 0]) {
        return this.clone().multiplySubMatrix(t4, e, i);
    }
    multiplyRight(t4) {
        return this.multiply(t4);
    }
    multiplyRightSubMatrix(t4, e, i = [0, 0]) {
        return this.multiplySubMatrix(t4, e, i);
    }
    multiplyLeft(t4) {
        return this.data = C.FromMatrix(t4.clone()).multiply(this).data, this;
    }
    multiplyLeftSubMatrix(t4, e, i = [0, 0]) {
        const s = i[0], r = i[1], [n2, o2] = this.size, [a2, h2] = t4.size;
        void 0 === e && (e = [h2, h2]);
        const [c2, l2] = e;
        if (c2 < 0 || l2 < 0) throw new Error("子矩阵大小不能为负");
        if (s < 0 || r < 0 || s + c2 > n2 || r + l2 > o2) throw new Error("子矩阵范围越界");
        if (a2 < c2 || h2 < c2) throw new Error("矩阵阶数不匹配，无法相乘");
        return this.setSubMatrix(C.FromMatrix(t4.clone().resize([c2, c2])).multiply(this.subMatrix(e, i)), i), this;
    }
    getInverse() {
        if (!this.isSquare) throw new Error("矩阵不是方阵，无逆矩阵");
        const t4 = this.size[0];
        if (this.isDiagonal) {
            const e2 = new S([t4, t4]);
            for (let i2 = 0; i2 < t4; i2++) {
                const t5 = this.get([i2, i2]);
                if (b(t5)) return;
                e2.set([i2, i2], 1 / t5);
            }
            return new C(e2);
        }
        if (3 === t4) {
            const t5 = this.determinant();
            if (b(t5)) return;
            return new C(new S([3, 3], [(this.m11 * this.m22 - this.m12 * this.m21) / t5, (this.m02 * this.m21 - this.m01 * this.m22) / t5, (this.m01 * this.m12 - this.m02 * this.m11) / t5, (this.m12 * this.m20 - this.m10 * this.m22) / t5, (this.m00 * this.m22 - this.m02 * this.m20) / t5, (this.m02 * this.m10 - this.m00 * this.m12) / t5, (this.m10 * this.m21 - this.m11 * this.m20) / t5, (this.m01 * this.m20 - this.m00 * this.m21) / t5, (this.m00 * this.m11 - this.m01 * this.m10) / t5], true));
        }
        if (2 === t4) {
            const t5 = this.determinant();
            if (b(t5)) return;
            return new C(new S([2, 2], [this.m11 / t5, -this.m01 / t5, -this.m10 / t5, this.m00 / t5], true));
        }
        if (1 === t4) return new C(new S([1, 1], 1 / this.get([0, 0])));
        const e = S.BuildIdentity([t4, t4]), i = this.data.clone();
        for (let s = 0; s < t4; s++) {
            if (b(i.get([s, s]))) {
                let r2 = s + 1;
                for (; r2 < t4 && b(i.get([r2, s])); r2++) ;
                if (r2 === t4) return;
                for (let n2 = 0; n2 < t4; n2++) {
                    let t5 = i.get([s, n2]);
                    i.set([s, n2], i.get([r2, n2])), i.set([r2, n2], t5), t5 = e.get([s, n2]), e.set([s, n2], e.get([r2, n2])), e.set([r2, n2], t5);
                }
            }
            const r = i.get([s, s]);
            if (!M(r)) {
                i.set([s, s], 1);
                for (let e2 = s + 1; e2 < t4; e2++) i.set([s, e2], i.get([s, e2]) / r);
                for (let i2 = 0; i2 < t4; i2++) e.set([s, i2], e.get([s, i2]) / r);
            }
            for (let r2 = 0; r2 < t4; r2++) {
                if (r2 === s) continue;
                const n2 = i.get([r2, s]);
                if (!b(n2)) {
                    i.set([r2, s], 0);
                    for (let e2 = s + 1; e2 < t4; e2++) i.set([r2, e2], i.get([r2, e2]) - i.get([s, e2]) * n2);
                    for (let i2 = 0; i2 < t4; i2++) e.set([r2, i2], e.get([r2, i2]) - e.get([s, i2]) * n2);
                }
            }
        }
        return new C(e);
    }
    negate() {
        return this.multiplyByNumber(-1);
    }
    getNegate() {
        return this.clone().negate();
    }
    rank() {
        const [t4, e] = this.size, i = this.data.clone(), s = Math.min(t4, e);
        let r = 0;
        for (let n2 = 0; n2 < e; n2++) {
            let o2 = r;
            for (; o2 < t4 && b(i.get([o2, n2])); o2++) ;
            if (o2 === t4) continue;
            if (o2 !== r) for (let t5 = 0; t5 < e; t5++) {
                const e2 = i.get([r, t5]);
                i.set([r, t5], i.get([o2, t5])), i.set([o2, t5], e2);
            }
            const a2 = i.get([r, n2]);
            if (!M(a2)) {
                i.set([r, n2], 1);
                for (let t5 = n2 + 1; t5 < e; t5++) i.set([r, t5], i.get([r, t5]) / a2);
            }
            for (let s2 = 0; s2 < t4; s2++) {
                if (s2 === r) continue;
                const t5 = i.get([s2, n2]);
                if (!b(t5)) {
                    i.set([s2, n2], 0);
                    for (let o3 = n2 + 1; o3 < e; o3++) i.set([s2, o3], i.get([s2, o3]) - i.get([r, o3]) * t5);
                }
            }
            if (++r === s) break;
        }
        return r;
    }
    determinant() {
        if (!this.isSquare) throw new Error("矩阵不是方阵，无行列式");
        const [t4, e] = this.size;
        if (3 === t4) return this.m00 * this.m11 * this.m22 + this.m01 * this.m12 * this.m20 + this.m02 * this.m10 * this.m21 - this.m02 * this.m11 * this.m20 - this.m01 * this.m10 * this.m22 - this.m00 * this.m12 * this.m21;
        if (2 === t4) return this.m00 * this.m11 - this.m01 * this.m10;
        if (1 === t4) return this.m00;
        let i = 0;
        for (let t5 = 0; t5 < e; t5++) {
            const e2 = this.get([0, t5]);
            if (b(e2)) continue;
            i += (t5 % 2 == 0 ? 1 : -1) * e2 * this.clone().deleteRow(0).deleteCol(t5).determinant();
        }
        return i;
    }
    getAdjoint() {
        if (!this.isSquare) throw new Error("矩阵不是方阵，无伴随矩阵");
        const [t4, e] = this.size, i = new S([t4, e]);
        for (let s = 0; s < t4; s++) for (let t5 = 0; t5 < e; t5++) {
            const e2 = this.clone().deleteRow(s).deleteCol(t5).determinant();
            i.set([s, t5], (s + t5) % 2 == 0 ? e2 : -e2);
        }
        return new C(i);
    }
    normalize() {
        const [t4, e] = this.size;
        for (let i = 0; i < e; i++) {
            let e2 = 0;
            for (let s = 0; s < t4; s++) e2 += this.get([s, i]) ** 2;
            if (e2 = Math.sqrt(e2), !b(e2)) for (let s = 0; s < t4; s++) this.set([s, i], this.get([s, i]) / e2);
        }
        return this;
    }
    normalizeRow() {
        return this.transpose().normalize().transpose();
    }
    toString() {
        return this.data.toString();
    }
};
class T extends C$1 {
    constructor(t4) {
        if (super(t4), 1 !== this.rowCount && 1 !== this.colCount) throw new Error("向量的大小必须是n * 1或1 * n");
    }
    static FromMatrix(t4, e = true) {
        return new T(t4.data.resize(e ? [t4.data.data.length, 1] : [1, t4.data.data.length]));
    }
    dot(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (e !== s || i !== r) throw new Error("向量维度不匹配");
        let n2 = 0;
        for (let i2 = 0; i2 < e; i2++) n2 += this.get([i2, 0]) * t4.get([i2, 0]);
        return n2;
    }
    cross(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (e !== s || i !== r) throw new Error("向量维度不匹配");
        const n2 = 1 !== e ? e : i;
        if (2 !== n2 && 3 !== n2) throw new Error("叉积只能用于二维向量或三维向量");
        return 1 === i ? 2 === n2 ? this.m00 * t4.m10 - t4.m00 * this.m10 : new E([this.m10 * t4.m20 - t4.m10 * this.m20, this.m20 * t4.m00 - t4.m20 * this.m00, this.m00 * t4.m10 - t4.m00 * this.m10]) : 2 === n2 ? this.m00 * t4.m01 - t4.m00 * this.m01 : new E([this.m01 * t4.m02 - t4.m01 * this.m02, this.m02 * t4.m00 - t4.m02 * this.m00, this.m00 * t4.m01 - t4.m00 * this.m01]);
    }
    get norm() {
        return Math.sqrt(this.dot(this));
    }
    angleTo(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (e !== s || i !== r) throw new Error("向量维度不匹配");
        const n2 = this.dot(t4);
        return Math.acos(n2 / (this.norm * t4.norm));
    }
    get isZero() {
        return this.data.data.every(b);
    }
}
class I extends T {
    constructor(t4) {
        if (t4 instanceof S || (t4 = new S([t4.length, 1], t4, true)), super(t4), 1 !== t4.colCount) throw new Error("列向量必须是n * 1的矩阵");
    }
    static FromMatrix(t4) {
        return t4 instanceof I ? t4 : new I(t4.data.resize([t4.data.data.length, 1]));
    }
    get x() {
        return this.m00;
    }
    set x(t4) {
        this.m00 = t4;
    }
    get y() {
        return this.m10;
    }
    set y(t4) {
        this.m10 = t4;
    }
    get z() {
        return this.m20;
    }
    set z(t4) {
        this.m20 = t4;
    }
    get m0() {
        return this.m00;
    }
    set m0(t4) {
        this.m00 = t4;
    }
    get m1() {
        return this.m10;
    }
    set m1(t4) {
        this.m10 = t4;
    }
    get m2() {
        return this.m20;
    }
    set m2(t4) {
        this.m20 = t4;
    }
    get m3() {
        return this.m30;
    }
    set m3(t4) {
        this.m30 = t4;
    }
}
class E extends I {
    constructor(t4) {
        if (super(t4), 3 !== this.size[0]) throw new Error("三维列向量必须是3 * 1的矩阵");
    }
    static FromMatrix(t4) {
        return t4 instanceof E ? t4 : new E(t4.data.resize([3, 1]));
    }
    static FromXY(t4, e) {
        return new E([t4, e, 0]);
    }
    static FromXYZ(t4, e, i) {
        return new E([t4, e, i]);
    }
}
class A extends T {
    constructor(t4) {
        if (t4 instanceof S || (t4 = new S([1, t4.length], t4, true)), super(t4), 1 !== t4.rowCount) throw new Error("行向量必须是1 * n的矩阵");
    }
    static FromMatrix(t4) {
        return t4 instanceof A ? t4 : new A(t4.data.resize([1, t4.data.data.length]));
    }
    get x() {
        return this.m00;
    }
    set x(t4) {
        this.m00 = t4;
    }
    get y() {
        return this.m01;
    }
    set y(t4) {
        this.m01 = t4;
    }
    get z() {
        return this.m02;
    }
    set z(t4) {
        this.m02 = t4;
    }
    get m0() {
        return this.m00;
    }
    set m0(t4) {
        this.m00 = t4;
    }
    get m1() {
        return this.m01;
    }
    set m1(t4) {
        this.m01 = t4;
    }
    get m2() {
        return this.m02;
    }
    set m2(t4) {
        this.m02 = t4;
    }
    get m3() {
        return this.m03;
    }
    set m3(t4) {
        this.m03 = t4;
    }
}
var F;
!function(t4) {
    t4[t4.Local = 0] = "Local", t4[t4.Global = 1] = "Global";
}(F || (F = {}));
class R extends C$1 {
    getInverse() {
        return new C$1(new S([4, 4], [1, 0, 0, -this.m03, 0, 1, 0, -this.m13, 0, 0, 1, -this.m23, 0, 0, 0, 1], true));
    }
    multiply(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (i !== s) throw new Error("矩阵阶数不匹配，无法相乘");
        return C$1.FromMatrix(t4.clone().add(this.col3.deleteRow(3), [0, 3]));
    }
    static FromMatrix(t4) {
        return t4 instanceof R ? t4 : new R(t4.data);
    }
    buildMatrix() {
        return new C$1(new S([4, 4], [1, 0, 0, this.m03, 0, 1, 0, this.m13, 0, 0, 1, this.m23, 0, 0, 0, 1], true));
    }
}
class O extends C$1 {
    getInverse() {
        if (b(this.m20) && b(this.m21) && b(this.m02) && b(this.m12)) {
            const t4 = this.m00 * this.m11 - this.m01 * this.m10;
            if (b(t4)) return;
            return new C$1(new S([4, 4], [this.m11 / t4, -this.m01 / t4, 0, 0, -this.m10 / t4, this.m00 / t4, 0, 0, 0, 0, 1 / this.m22, 0, 0, 0, 0, 1], true));
        }
        return super.getInverse();
    }
    multiply(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (i !== s) throw new Error("矩阵阶数不匹配，无法相乘");
        const n2 = this.subMatrix([3, 3]);
        return t4.clone().multiplyLeftSubMatrix(n2).multiplyLeftSubMatrix(n2, [3, 1], [0, 3]), C$1.FromMatrix(t4);
    }
    static FromMatrix(t4) {
        return t4 instanceof O ? t4 : new O(t4.data);
    }
    buildMatrix() {
        return new C$1(new S([4, 4], [this.m00, this.m01, this.m02, 0, this.m10, this.m11, this.m12, 0, this.m20, this.m21, this.m22, 0, 0, 0, 0, 1], true));
    }
}
class L extends C$1 {
    getInverse() {
        return new C$1(new S([4, 4], [1 / this.m00, 0, 0, 0, 0, 1 / this.m11, 0, 0, 0, 0, 1 / this.m22, 0, 0, 0, 0, 1], true));
    }
    multiply(t4) {
        const [e, i] = this.size, [s, r] = t4.size;
        if (i !== s) throw new Error("矩阵阶数不匹配，无法相乘");
        const n2 = this.m00, o2 = this.m11, a2 = this.m11;
        return new C$1(new S([4, 4], [n2 * t4.m00, n2 * t4.m01, n2 * t4.m02, n2 * t4.m03, o2 * t4.m10, o2 * t4.m11, o2 * t4.m12, o2 * t4.m13, a2 * t4.m20, a2 * t4.m21, a2 * t4.m22, a2 * t4.m23, 0, 0, 0, 1], true));
    }
    static FromMatrix(t4) {
        return t4 instanceof L ? t4 : new L(t4.data);
    }
    buildMatrix() {
        return new C$1(new S([4, 4], [this.m00, 0, 0, 0, 0, this.m11, 0, 0, 0, 0, this.m22, 0, 0, 0, 0, 1], true));
    }
}
let P = class t2 {
    constructor(t4) {
        __publicField(this, "matrix");
        __publicField(this, "translateMatrix");
        __publicField(this, "rotateMatrix");
        __publicField(this, "skewMatrix");
        __publicField(this, "scaleMatrix");
        __publicField(this, "onChange", () => {
        });
        __publicField(this, "decomposeTranslateCache");
        __publicField(this, "decomposeEulerCache");
        __publicField(this, "decomposeSkewCache");
        __publicField(this, "decomposeScaleCache");
        __publicField(this, "inverseCache");
        __publicField(this, "_isMatrixLatest", true);
        __publicField(this, "_isSubMatrixLatest", true);
        var _a2, _b, _c2, _d2;
        if (this.matrix = (t4 == null ? void 0 : t4.matrix) || C$1.BuildIdentity([4, 4]), 4 !== this.matrix.rowCount || 4 !== this.matrix.colCount) throw new Error("矩阵数据错误：matrix不是4x4矩阵");
        if (this.translateMatrix = R.FromMatrix(((_a2 = t4 == null ? void 0 : t4.subMatrix) == null ? void 0 : _a2.translate) || C$1.BuildIdentity([4, 4])), 4 !== this.translateMatrix.rowCount || 4 !== this.translateMatrix.colCount) throw new Error("矩阵数据错误：translateMatrix必须为4x4矩阵");
        if (this.rotateMatrix = O.FromMatrix(((_b = t4 == null ? void 0 : t4.subMatrix) == null ? void 0 : _b.rotate) || C$1.BuildIdentity([4, 4])), 4 !== this.rotateMatrix.rowCount || 4 !== this.rotateMatrix.colCount) throw new Error("矩阵数据错误：rotateMatrix必须为4x4矩阵");
        if (this.skewMatrix = ((_c2 = t4 == null ? void 0 : t4.subMatrix) == null ? void 0 : _c2.skew) || C$1.BuildIdentity([4, 4]), 4 !== this.skewMatrix.rowCount || 4 !== this.skewMatrix.colCount) throw new Error("矩阵数据错误：skewMatrix必须为4x4矩阵");
        if (this.scaleMatrix = L.FromMatrix(((_d2 = t4 == null ? void 0 : t4.subMatrix) == null ? void 0 : _d2.scale) || C$1.BuildIdentity([4, 4])), 4 !== this.scaleMatrix.rowCount || 4 !== this.scaleMatrix.colCount) throw new Error("矩阵数据错误：scaleMatrix必须为4x4矩阵");
        ((t4 == null ? void 0 : t4.matrix) || (t4 == null ? void 0 : t4.subMatrix)) && (this.isMatrixLatest = !!(t4 == null ? void 0 : t4.matrix), this.isSubMatrixLatest = !!(t4 == null ? void 0 : t4.subMatrix));
    }
    clearDecomposeCache() {
        this.decomposeTranslateCache = void 0, this.decomposeEulerCache = void 0, this.decomposeSkewCache = void 0, this.decomposeScaleCache = void 0;
    }
    clearInverseCache() {
        this.inverseCache = void 0;
    }
    clearCache() {
        this.clearDecomposeCache(), this.clearInverseCache();
    }
    get isMatrixLatest() {
        return this._isMatrixLatest;
    }
    set isMatrixLatest(t4) {
        t4 || this.clearCache(), this._isMatrixLatest = t4;
    }
    get isSubMatrixLatest() {
        return this._isSubMatrixLatest;
    }
    set isSubMatrixLatest(t4) {
        t4 || this.clearCache(), this._isSubMatrixLatest = t4;
    }
    updateMatrix() {
        if (!this.isMatrixLatest || !this.isSubMatrixLatest) {
            if (this.isMatrixLatest) {
                this.translateMatrix = R.FromMatrix(C$1.BuildIdentity([4, 3]).insertCols(this.matrix.col3));
                const t4 = this.matrix.clone().resize([3, 3]);
                let e = t4.col0.cross(t4.col1);
                const i = e.dot(t4.col2) < 0;
                let s = t4.col0.angleTo(t4.col1);
                i && (s = Math.PI - s, e.negate());
                const r = s - 0.5 * Math.PI, { x: n2, y: o2, z: a2 } = e.cross(t4.col2), h2 = e.angleTo(t4.col2), c2 = Math.sin(h2), l2 = 1 - Math.cos(h2);
                this.skewMatrix = new C$1(new S([4, 4], [1, -Math.sin(r), -o2 * c2 + n2 * a2 * l2, 0, 0, Math.cos(r), n2 + o2 * a2 * l2, 0, 0, 0, 1 + l2 * (a2 ** 2 - 1), 0, 0, 0, 0, 1], true));
                const d2 = this.matrix.col0.norm, p2 = this.matrix.col1.norm * (i ? -1 : 1), u = this.matrix.col2.norm;
                this.scaleMatrix = L.FromMatrix(new C$1(new S([4, 4], [d2, 0, 0, 0, 0, p2, 0, 0, 0, 0, u, 0, 0, 0, 0, 1], true)));
                const f2 = this.translateMatrix.isIdentity ? this.matrix.clone() : this.translateMatrix.getInverse().multiply(this.matrix);
                this.scaleMatrix.isIdentity || f2.multiply(this.scaleMatrix.getInverse()), this.skewMatrix.isIdentity || f2.multiply(this.skewMatrix.getInverse()), this.rotateMatrix = O.FromMatrix(f2);
            } else this.matrix = this.translateMatrix.clone().multiply(this.rotateMatrix).multiply(this.skewMatrix).multiply(this.scaleMatrix);
            this.isMatrixLatest = true, this.isSubMatrixLatest = true;
        }
    }
    clone() {
        var _a2, _b, _c2, _d2;
        this.updateMatrix();
        const t4 = new this.constructor({ matrix: this.matrix.clone(), subMatrix: { translate: this.translateMatrix.clone(), rotate: this.rotateMatrix.clone(), skew: this.skewMatrix.clone(), scale: this.scaleMatrix.clone() } });
        return t4.decomposeTranslateCache = (_a2 = this.decomposeTranslateCache) == null ? void 0 : _a2.clone(), t4.decomposeEulerCache = (_b = this.decomposeEulerCache) == null ? void 0 : _b.clone(), t4.decomposeScaleCache = (_c2 = this.decomposeScaleCache) == null ? void 0 : _c2.clone(), t4.inverseCache = (_d2 = this.inverseCache) == null ? void 0 : _d2.clone(), this.decomposeSkewCache && (t4.decomposeSkewCache = { x: { axis: this.decomposeSkewCache.x.axis.clone(), angle: this.decomposeSkewCache.x.angle }, y: { axis: this.decomposeSkewCache.y.axis.clone(), angle: this.decomposeSkewCache.y.angle }, z: { axis: this.decomposeSkewCache.z.axis.clone(), angle: this.decomposeSkewCache.z.angle } }), t4;
    }
    equals(t4) {
        let e = this.isMatrixLatest && t4.isMatrixLatest, i = this.isSubMatrixLatest && t4.isSubMatrixLatest;
        return e || i || this.updateMatrix(), e = this.isMatrixLatest && t4.isMatrixLatest, i = this.isSubMatrixLatest && t4.isSubMatrixLatest, e ? this.matrix.equals(t4.matrix) : this.translateMatrix.equals(t4.translateMatrix) && this.rotateMatrix.equals(t4.rotateMatrix) && this.skewMatrix.equals(t4.skewMatrix) && this.scaleMatrix.equals(t4.scaleMatrix);
    }
    reset() {
        this.matrix = C$1.BuildIdentity([4, 4]), this.translateMatrix = R.FromMatrix(C$1.BuildIdentity([4, 4])), this.rotateMatrix = O.FromMatrix(C$1.BuildIdentity([4, 4])), this.skewMatrix = C$1.BuildIdentity([4, 4]), this.scaleMatrix = L.FromMatrix(C$1.BuildIdentity([4, 4])), this.isMatrixLatest = true, this.isSubMatrixLatest = true, this.onChange(this);
    }
    setMatrix(t4) {
        if (4 !== t4.rowCount || 4 !== t4.colCount) throw new Error("矩阵数据错误：matrix不是4x4矩阵");
        this.matrix = t4, this.isMatrixLatest = true, this.isSubMatrixLatest = false, this.onChange(this);
    }
    setSubMatrix(t4) {
        if (this.isSubMatrixLatest || this.updateMatrix(), t4.translate) {
            if (4 !== t4.translate.rowCount || 4 !== t4.translate.colCount) throw new Error("矩阵数据错误：translate必须为4x4矩阵");
            this.translateMatrix = R.FromMatrix(t4.translate);
        }
        if (t4.rotate) {
            if (4 !== t4.rotate.rowCount || 4 !== t4.rotate.colCount) throw new Error("矩阵数据错误：rotate必须为4x4矩阵");
            this.rotateMatrix = O.FromMatrix(t4.rotate);
        }
        if (t4.skew) {
            if (4 !== t4.skew.rowCount || 4 !== t4.skew.colCount) throw new Error("矩阵数据错误：skew必须为4x4矩阵");
            this.skewMatrix = t4.skew;
        }
        if (t4.scale) {
            if (4 !== t4.scale.rowCount || 4 !== t4.scale.colCount) throw new Error("矩阵数据错误：scale必须为4x4矩阵");
            this.scaleMatrix = L.FromMatrix(t4.scale);
        }
        this.isMatrixLatest = false, this.isSubMatrixLatest = true, this.onChange(this);
    }
    getInverse() {
        if (this.inverseCache) return this.inverseCache.clone();
        this.isMatrixLatest || this.updateMatrix();
        const e = this.matrix.getInverse();
        if (!e) throw new Error("矩阵不可逆");
        return this.inverseCache = new t2({ matrix: e }), this.inverseCache.clone();
    }
    static FromVectorToVector(e, i) {
        if (e.isZero || i.isZero) throw new Error("不能为零向量");
        const s = e.clone().normalize(), r = i.clone().normalize(), n2 = new t2();
        if (e.equals(i)) return n2;
        const o2 = s.cross(r), a2 = s.angleTo(r);
        return b(a2) || n2.rotateAt({ axis: new B(o2), angle: a2 }), n2;
    }
    static FromLineToLine(e, i) {
        return t2.FromVectorToVector(e.direction, i.direction).translate(i.point.clone().subtract(e.point));
    }
    static FromPlaneToPlane(e, i) {
        return t2.FromVectorToVector(e.normal, i.normal).translateAt({ axis: i.normal, distance: i.d - e.d });
    }
    _getMatrixEl(t4) {
        return this.isMatrixLatest || this.updateMatrix(), this.matrix[t4];
    }
    _setMatrixEl(t4, e) {
        this.isMatrixLatest || this.updateMatrix(), this.matrix[t4] = e, this.isSubMatrixLatest = false, this.onChange(this);
    }
    get m00() {
        return this._getMatrixEl("m00");
    }
    set m00(t4) {
        this._setMatrixEl("m00", t4);
    }
    get m01() {
        return this._getMatrixEl("m01");
    }
    set m01(t4) {
        this._setMatrixEl("m01", t4);
    }
    get m02() {
        return this._getMatrixEl("m02");
    }
    set m02(t4) {
        this._setMatrixEl("m02", t4);
    }
    get m03() {
        return this._getMatrixEl("m03");
    }
    set m03(t4) {
        this._setMatrixEl("m03", t4);
    }
    get m10() {
        return this._getMatrixEl("m10");
    }
    set m10(t4) {
        this._setMatrixEl("m10", t4);
    }
    get m11() {
        return this._getMatrixEl("m11");
    }
    set m11(t4) {
        this._setMatrixEl("m11", t4);
    }
    get m12() {
        return this._getMatrixEl("m12");
    }
    set m12(t4) {
        this._setMatrixEl("m12", t4);
    }
    get m13() {
        return this._getMatrixEl("m13");
    }
    set m13(t4) {
        this._setMatrixEl("m13", t4);
    }
    get m20() {
        return this._getMatrixEl("m20");
    }
    set m20(t4) {
        this._setMatrixEl("m20", t4);
    }
    get m21() {
        return this._getMatrixEl("m21");
    }
    set m21(t4) {
        this._setMatrixEl("m21", t4);
    }
    get m22() {
        return this._getMatrixEl("m22");
    }
    set m22(t4) {
        this._setMatrixEl("m22", t4);
    }
    get m23() {
        return this._getMatrixEl("m23");
    }
    set m23(t4) {
        this._setMatrixEl("m23", t4);
    }
    get m30() {
        return this._getMatrixEl("m30");
    }
    set m30(t4) {
        this._setMatrixEl("m30", t4);
    }
    get m31() {
        return this._getMatrixEl("m31");
    }
    set m31(t4) {
        this._setMatrixEl("m31", t4);
    }
    get m32() {
        return this._getMatrixEl("m32");
    }
    set m32(t4) {
        this._setMatrixEl("m32", t4);
    }
    get m33() {
        return this._getMatrixEl("m33");
    }
    set m33(t4) {
        this._setMatrixEl("m33", t4);
    }
    transform(t4) {
        Array.isArray(t4) && (t4 = C$1.FromCols(t4));
        const [e, i] = t4.size;
        if (3 !== e) throw new Error("点必须是3维列向量");
        return this.isMatrixLatest || this.updateMatrix(), this.matrix.clone().multiply(t4.clone().insertRows(new S([1, i], 1))).deleteRow();
    }
    transformLine(t4) {
        return t4.clone().transform(this);
    }
    transformPlane(t4) {
        return t4.clone().transform(this);
    }
    transformCol(t4) {
        return E.FromMatrix(this.transform(t4));
    }
    translate(t4) {
        const e = new C$1(new S([4, 4], [1, 0, 0, t4.x, 0, 1, 0, t4.y, 0, 0, 1, t4.z, 0, 0, 0, 1], true));
        return this.isMatrixLatest ? (this.matrix = e.multiply(this.matrix), this.isSubMatrixLatest = false) : (this.translateMatrix = R.FromMatrix(e.multiply(this.translateMatrix)), this.isMatrixLatest = false), this.onChange(this), this;
    }
    translateAt(t4) {
        return this.translate(t4.axis.clone().normalize().multiplyByNumber(t4.distance));
    }
    translateInLocal(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = this.matrix.clone().resize([3, 3]).normalize();
        return this.translate(e.multiply(t4).col0);
    }
    translateX(t4) {
        this.translate(E.FromXYZ(t4, 0, 0));
    }
    translateY(t4) {
        this.translate(E.FromXYZ(0, t4, 0));
    }
    translateZ(t4) {
        this.translate(E.FromXYZ(0, 0, t4));
    }
    preTranslate(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = new C$1(new S([4, 4], [1, 0, 0, t4.x, 0, 1, 0, t4.y, 0, 0, 1, t4.z, 0, 0, 0, 1], true));
        return this.matrix.multiply(e), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    preTranslateX(t4) {
        this.preTranslate(new E([t4, 0, 0]));
    }
    preTranslateY(t4) {
        this.preTranslate(new E([0, t4, 0]));
    }
    preTranslateZ(t4) {
        this.preTranslate(new E([0, 0, t4]));
    }
    setTranslate(t4) {
        return this.isSubMatrixLatest || this.updateMatrix(), this.translateMatrix = R.FromMatrix(new C$1(new S([4, 4], [1, 0, 0, t4.x, 0, 1, 0, t4.y, 0, 0, 1, t4.z, 0, 0, 0, 1], true))), this.isMatrixLatest = false, this.onChange(this), this;
    }
    setTranslateX(t4) {
        const e = this.decomposeTranslate();
        this.setTranslate(new E([t4, e.y, e.z]));
    }
    setTranslateY(t4) {
        const e = this.decomposeTranslate();
        this.setTranslate(new E([e.x, t4, e.z]));
    }
    setTranslateZ(t4) {
        const e = this.decomposeTranslate();
        this.setTranslate(new E([e.x, e.y, t4]));
    }
    hasTranslate() {
        return this.isSubMatrixLatest || this.updateMatrix(), b(this.translateMatrix.m03) && b(this.translateMatrix.m13) && b(this.translateMatrix.m23);
    }
    onlyTranslate() {
        return this.isMatrixLatest || this.updateMatrix(), this.matrix.clone().resize([3, 3]).isIdentity;
    }
    scale(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        const e = new C$1(new S([4, 4], [t4.vector.x, 0, 0, 0, 0, t4.vector.y, 0, 0, 0, 0, t4.vector.z, 0, 0, 0, 0, 1], true));
        if (t4.mode === F.Local) {
            if (t4.point) {
                const i = this.scaleMatrix.buildMatrix().resize([3, 3]);
                this.scaleMatrix = L.FromMatrix(e.multiply(this.scaleMatrix));
                const s = this.scaleMatrix.buildMatrix().resize([3, 3]).subtract(i).multiply(t4.point.clone().negate()).col0;
                this.translate(s);
            } else this.scaleMatrix = L.FromMatrix(e.multiply(this.scaleMatrix));
            this.isMatrixLatest = false;
        } else t4.point && this.translate(t4.point.getNegate()), this.matrix = e.multiply(this.matrix), this.isSubMatrixLatest = false, t4.point && this.translate(t4.point);
        return this.onChange(this), this;
    }
    scaleX(t4) {
        return this.scale({ point: t4.point, vector: new E([t4.value, 1, 1]), mode: t4.mode });
    }
    scaleY(t4) {
        return this.scale({ point: t4.point, vector: new E([1, t4.value, 1]), mode: t4.mode });
    }
    scaleZ(t4) {
        return this.scale({ point: t4.point, vector: new E([1, 1, t4.value]), mode: t4.mode });
    }
    preScale(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = new C$1(new S([4, 4], [t4.vector.x, 0, 0, 0, 0, t4.vector.y, 0, 0, 0, 0, t4.vector.z, 0, 0, 0, 0, 1], true));
        return t4.point && this.translate(t4.point.getNegate()), this.matrix.multiply(e), this.isSubMatrixLatest = false, t4.point && this.translate(t4.point), this.onChange(this), this;
    }
    preScaleX(t4) {
        return this.preScale({ vector: new E([t4.value, 1, 1]) });
    }
    preScaleY(t4) {
        return this.preScale({ vector: new E([1, t4.value, 1]) });
    }
    preScaleZ(t4) {
        return this.preScale({ vector: new E([1, 1, t4.value]) });
    }
    setScale(t4) {
        return this.isSubMatrixLatest || this.updateMatrix(), this.scaleMatrix = L.FromMatrix(new C$1(new S([4, 4], [t4.x, 0, 0, 0, 0, t4.y, 0, 0, 0, 0, t4.z, 0, 0, 0, 0, 1], true))), this.isMatrixLatest = false, this.onChange(this), this;
    }
    setScaleX(t4) {
        const e = this.decomposeScale();
        this.setScale(new E([t4, e.y, e.z]));
    }
    setScaleY(t4) {
        const e = this.decomposeScale();
        this.setScale(new E([e.x, t4, e.z]));
    }
    setScaleZ(t4) {
        const e = this.decomposeScale();
        this.setScale(new E([e.x, e.y, t4]));
    }
    hasScale() {
        return this.isSubMatrixLatest || this.updateMatrix(), !this.scaleMatrix.isIdentity;
    }
    onlyScale() {
        return !this.hasTranslate() && !this.hasSkew() && !this.hasRotation();
    }
    rotateX(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        const e = Math.sin(t4.angle), i = Math.cos(t4.angle), s = new C$1(new S([4, 4], [1, 0, 0, 0, 0, i, -e, 0, 0, e, i, 0, 0, 0, 0, 1], true));
        return t4.mode === F.Local ? (this.rotateMatrix = O.FromMatrix(s.multiply(this.rotateMatrix)), this.isMatrixLatest = false) : (this.matrix = s.multiply(this.matrix), this.isSubMatrixLatest = false), this.onChange(this), this;
    }
    preRotateX(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = Math.sin(t4), i = Math.cos(t4), s = new C$1(new S([4, 4], [1, 0, 0, 0, 0, i, -e, 0, 0, e, i, 0, 0, 0, 0, 1], true));
        return this.matrix.multiply(s), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    rotateY(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        const e = Math.sin(t4.angle), i = Math.cos(t4.angle), s = new C$1(new S([4, 4], [i, 0, e, 0, 0, 1, 0, 0, -e, 0, i, 0, 0, 0, 0, 1], true));
        return t4.mode === F.Local ? (this.rotateMatrix = O.FromMatrix(s.multiply(this.rotateMatrix)), this.isMatrixLatest = false) : (this.matrix = s.multiply(this.matrix), this.isSubMatrixLatest = false), this.onChange(this), this;
    }
    preRotateY(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = Math.sin(t4), i = Math.cos(t4), s = new C$1(new S([4, 4], [i, 0, e, 0, 0, 1, 0, 0, -e, 0, i, 0, 0, 0, 0, 1], true));
        return this.matrix.multiply(s), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    rotateZ(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        const e = Math.sin(t4.angle), i = Math.cos(t4.angle), s = new C$1(new S([4, 4], [i, -e, 0, 0, e, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], true));
        return t4.mode === F.Local ? (this.rotateMatrix = O.FromMatrix(s.multiply(this.rotateMatrix)), this.isMatrixLatest = false) : (this.matrix = s.multiply(this.matrix), this.isSubMatrixLatest = false), this.onChange(this), this;
    }
    preRotateZ(t4) {
        this.isMatrixLatest || this.updateMatrix();
        const e = Math.sin(t4), i = Math.cos(t4), s = new C$1(new S([4, 4], [i, -e, 0, 0, e, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], true));
        return this.matrix.multiply(s), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    rotate(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix(), void 0 === t4.axis && (t4.axis = N.FromPoints(E.FromXYZ(0, 0, 1)));
        let [e, i, s] = t4.axis.direction.rawData;
        const r = -t4.angle, n2 = Math.cos(r), o2 = Math.sin(r), a2 = 1 - n2, h2 = new C$1(new S([4, 4], [1 + a2 * (e ** 2 - 1), s * o2 + e * i * a2, -i * o2 + e * s * a2, 0, -s * o2 + e * i * a2, 1 + a2 * (i ** 2 - 1), e * o2 + i * s * a2, 0, i * o2 + e * s * a2, -e * o2 + i * s * a2, 1 + a2 * (s ** 2 - 1), 0, 0, 0, 0, 1], true));
        return t4.mode === F.Local ? (this.rotateMatrix = O.FromMatrix(h2.multiply(this.rotateMatrix)), this.isMatrixLatest = false) : (this.matrix = h2.multiply(this.matrix), this.isSubMatrixLatest = false), this.onChange(this), this;
    }
    preRotate(t4) {
        this.isMatrixLatest || this.updateMatrix(), void 0 === t4.axis && (t4.axis = N.FromPoints(E.FromXYZ(0, 0, 1)));
        let [e, i, s] = t4.axis.direction.rawData;
        s = -s;
        const r = Math.cos(t4.angle), n2 = Math.sin(t4.angle), o2 = 1 - r, a2 = new C$1(new S([4, 4], [1 + o2 * (e ** 2 - 1), s * n2 + e * i * o2, -i * n2 + e * s * o2, 0, -s * n2 + e * i * o2, 1 + o2 * (i ** 2 - 1), e * n2 + i * s * o2, 0, i * n2 + e * s * o2, -e * n2 + i * s * o2, 1 + o2 * (s ** 2 - 1), 0, 0, 0, 0, 1], true));
        return this.matrix.multiply(a2), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    rotateAt(t4) {
        var _a2;
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        const e = (_a2 = t4.axis) == null ? void 0 : _a2.point;
        if (t4.mode === F.Local) if (e) {
            let i = e.clone();
            this.scaleMatrix.isIdentity || (i = this.scaleMatrix.buildMatrix().resize([3, 3]).multiply(i)), this.skewMatrix.isIdentity || (i = this.skewMatrix.clone().resize([3, 3]).multiply(i));
            const s = this.rotateMatrix.buildMatrix().resize([3, 3]);
            this.rotate(t4);
            const r = this.rotateMatrix.buildMatrix().resize([3, 3]).subtract(s).multiply(i.negate()).col0;
            this.translate(r);
        } else this.rotate(t4);
        else e && this.translate(e.getNegate()), this.rotate(t4), e && this.translate(e);
        return this.onChange(this), this;
    }
    preRotateAt(t4) {
        return this.isMatrixLatest || this.updateMatrix(), t4.axis && this.preTranslate(t4.axis.point), this.preRotate(t4), t4.axis && this.preTranslate(t4.axis.point.clone().getNegate()), this.onChange(this), this;
    }
    setRotate(t4) {
        this.isSubMatrixLatest || this.updateMatrix();
        const [e, i, s] = t4.rawData, r = Math.cos(e), n2 = Math.sin(e), o2 = Math.cos(i), a2 = Math.sin(i), h2 = Math.cos(s), c2 = Math.sin(s);
        return this.rotateMatrix = O.FromMatrix(new C$1(new S([4, 4], [h2 * o2 - c2 * n2 * a2, -r * c2, h2 * a2 + o2 * c2 * n2, 0, o2 * c2 + h2 * n2 * a2, h2 * r, c2 * a2 - h2 * o2 * n2, 0, -r * a2, n2, r * o2, 0, 0, 0, 0, 1], true))), this.isMatrixLatest = false, this.onChange(this), this;
    }
    setRotateX(t4) {
        return this.setRotate(new E([t4, 0, 0]));
    }
    setRotateY(t4) {
        return this.setRotate(new E([0, t4, 0]));
    }
    setRotateZ(t4) {
        return this.setRotate(new E([0, 0, t4]));
    }
    hasRotation() {
        return this.isSubMatrixLatest || this.updateMatrix(), !this.rotateMatrix.isIdentity;
    }
    onlyRotation() {
        return !this.hasTranslate() && !this.hasSkew() && !this.hasScale();
    }
    _getSkewMatrix(t4) {
        function e(t5, e2) {
            const i2 = -t5.angle, s2 = Math.cos(i2), r2 = Math.sin(i2), n2 = 1 - s2, [o2, a2, h2] = t5.axis.rawData;
            return [() => E.FromXYZ(1 + n2 * (o2 ** 2 - 1), -h2 * r2 + o2 * a2 * n2, a2 * r2 + o2 * h2 * n2), () => E.FromXYZ(h2 * r2 + o2 * a2 * n2, 1 + n2 * (a2 ** 2 - 1), -o2 * r2 + a2 * h2 * n2), () => E.FromXYZ(-a2 * r2 + o2 * h2 * n2, o2 * r2 + a2 * h2 * n2, 1 + n2 * (h2 ** 2 - 1))][e2]();
        }
        const i = void 0 === t4.x || 0 === t4.x.angle ? E.FromXYZ(1, 0, 0) : e(t4.x, 0), s = void 0 === t4.y || 0 === t4.y.angle ? E.FromXYZ(0, 1, 0) : e(t4.y, 1), r = void 0 === t4.z || 0 === t4.z.angle ? E.FromXYZ(0, 0, 1) : e(t4.z, 2);
        return C$1.FromCols([i, s, r]).insertCols([0, 0, 0]).insertRows([0, 0, 0, 1]);
    }
    skew(t4) {
        void 0 === t4.mode && (t4.mode = F.Global), (t4.mode === F.Local && !this.isSubMatrixLatest || t4.mode === F.Global && !this.isMatrixLatest) && this.updateMatrix();
        let e = C$1.BuildIdentity([4, 4]);
        return void 0 !== t4.skew ? e = this._getSkewMatrix(t4.skew) : void 0 !== t4.skewAxis && (void 0 !== t4.skewAxis.x && e.setSubMatrix(t4.skewAxis.x, [0, 0]), void 0 !== t4.skewAxis.y && e.setSubMatrix(t4.skewAxis.y, [0, 1]), void 0 !== t4.skewAxis.z && e.setSubMatrix(t4.skewAxis.z, [0, 2])), t4.mode === F.Local ? (this.skewMatrix = e.multiply(this.skewMatrix), this.isMatrixLatest = false) : (this.matrix = e.multiply(this.matrix), this.isSubMatrixLatest = false), this.onChange(this), this;
    }
    preSkew(t4) {
        this.isMatrixLatest || this.updateMatrix();
        let e = C$1.BuildIdentity([4, 4]);
        return void 0 !== t4.skew ? e = this._getSkewMatrix(t4.skew) : void 0 !== t4.skewAxis && (void 0 !== t4.skewAxis.x && e.setSubMatrix(t4.skewAxis.x, [0, 0]), void 0 !== t4.skewAxis.y && e.setSubMatrix(t4.skewAxis.y, [0, 1]), void 0 !== t4.skewAxis.z && e.setSubMatrix(t4.skewAxis.z, [0, 2])), this.matrix.multiply(e), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    setSkew(t4) {
        this.isSubMatrixLatest || this.updateMatrix();
        let e = C$1.BuildIdentity([4, 4]);
        return void 0 !== t4.skew ? e = this._getSkewMatrix(t4.skew) : void 0 !== t4.skewAxis && (void 0 !== t4.skewAxis.x && e.setSubMatrix(t4.skewAxis.x.normalize(), [0, 0]), void 0 !== t4.skewAxis.y && e.setSubMatrix(t4.skewAxis.y.normalize(), [0, 1]), void 0 !== t4.skewAxis.z && e.setSubMatrix(t4.skewAxis.z.normalize(), [0, 2])), this.skewMatrix = e, this.isMatrixLatest = false, this.onChange(this), this;
    }
    hasSkew() {
        return this.isSubMatrixLatest || this.updateMatrix(), !this.skewMatrix.isIdentity;
    }
    onlySkew() {
        return !this.hasTranslate() && !this.hasRotation() && !this.hasScale();
    }
    addTransform(t4) {
        return t4.isMatrixLatest || t4.updateMatrix(), this.isMatrixLatest || this.updateMatrix(), this.matrix = t4.matrix.clone().multiply(this.matrix), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    addPreTransform(t4) {
        return t4.isMatrixLatest || t4.updateMatrix(), this.isMatrixLatest || this.updateMatrix(), this.matrix = this.matrix.clone().multiply(t4.matrix), this.isSubMatrixLatest = false, this.onChange(this), this;
    }
    mirrorX(t4) {
        return this.scaleX({ point: E.FromXYZ(t4 || 0, 0, 0), value: -1 });
    }
    mirrorY(t4) {
        return this.scaleY({ point: E.FromXYZ(0, t4 || 0, 0), value: -1 });
    }
    mirrorZ(t4) {
        return this.scaleZ({ point: E.FromXYZ(0, 0, t4 || 0), value: -1 });
    }
    flip(e) {
        const i = t2.FromPlaneToPlane(e, z.FromVerticalX());
        return this.addTransform(i).mirrorX().addTransform(i.getInverse());
    }
    preFlip(e) {
        const i = t2.FromPlaneToPlane(e, z.FromVerticalX());
        return this.addPreTransform(i.clone().mirrorX().addTransform(i.getInverse()));
    }
    flipH(t4) {
        return this.flip(new z(E.FromXYZ(1, 0, 0), t4 || 0));
    }
    preFlipH(t4) {
        return this.preFlip(new z(E.FromXYZ(1, 0, 0), t4 || 0));
    }
    flipV(t4) {
        return this.flip(new z(E.FromXYZ(0, 1, 0), t4 || 0));
    }
    preFlipV(t4) {
        return this.preFlip(new z(E.FromXYZ(0, 1, 0), t4 || 0));
    }
    decomposeTranslate() {
        if (void 0 !== this.decomposeTranslateCache) return this.decomposeTranslateCache.clone();
        const t4 = this.isMatrixLatest ? this.matrix : this.translateMatrix;
        return this.decomposeTranslateCache = t4.col3.deleteRow(), this.decomposeTranslateCache.clone();
    }
    decomposeEuler() {
        return void 0 !== this.decomposeEulerCache || (this.isSubMatrixLatest || this.updateMatrix(), this.decomposeEulerCache = t2.DecomposeEuler(this.rotateMatrix)), this.decomposeEulerCache.clone();
    }
    decomposeScale() {
        return void 0 !== this.decomposeScaleCache || (this.isSubMatrixLatest || this.updateMatrix(), this.decomposeScaleCache = new E([this.scaleMatrix.m00, this.scaleMatrix.m11, this.scaleMatrix.m22])), this.decomposeScaleCache.clone();
    }
    decomposeSkew() {
        if (void 0 === this.decomposeSkewCache) {
            this.isSubMatrixLatest || this.updateMatrix();
            const t4 = this.skewMatrix.col0.deleteRow(), e = this.skewMatrix.col1.deleteRow(), i = this.skewMatrix.col2.deleteRow(), s = E.FromXYZ(1, 0, 0), r = E.FromXYZ(0, 1, 0), n2 = E.FromXYZ(0, 0, 1), o2 = Math.asin(-this.skewMatrix.m01), a2 = { x: { axis: n2.clone(), angle: 0 }, y: { axis: n2.clone(), angle: o2 }, z: { axis: n2.cross(i), angle: n2.angleTo(i) } };
            t4.equals(s) || (a2.x = { axis: s.cross(t4), angle: s.angleTo(t4) }), e.equals(r) || (a2.y = { axis: r.cross(e), angle: r.angleTo(e) }), this.decomposeSkewCache = a2;
        }
        return { x: { axis: this.decomposeSkewCache.x.axis.clone(), angle: this.decomposeSkewCache.x.angle }, y: { axis: this.decomposeSkewCache.y.axis.clone(), angle: this.decomposeSkewCache.y.angle }, z: { axis: this.decomposeSkewCache.z.axis.clone(), angle: this.decomposeSkewCache.z.angle } };
    }
    static DecomposeEuler(t4) {
        const e = Math.asin(t4.m21);
        let i, s;
        return e === Math.PI / 2 || e === -Math.PI / 2 ? (i = Math.atan2(t4.m10, t4.m00), s = 0) : (i = Math.atan2(-t4.m20, t4.m22), s = Math.atan2(-t4.m01, t4.m11)), new E([e, i, s]);
    }
    decompose() {
        return { translate: this.decomposeTranslate(), rotate: this.decomposeEuler(), scale: this.decomposeScale(), skew: this.decomposeSkew() };
    }
    clearRotation() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.rotateMatrix = O.FromMatrix(C$1.BuildIdentity([4, 4])), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearSkew() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.skewMatrix = C$1.BuildIdentity([4, 4]), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearSkewAndResetScale() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.scaleMatrix.multiplyByNumberSubMatrix(this.skewMatrix.m00, [3, 1], [0, 0]).multiplyByNumberSubMatrix(this.skewMatrix.m11, [3, 1], [0, 1]).multiplyByNumberSubMatrix(this.skewMatrix.m22, [3, 1], [0, 2]), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearScale() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.scaleMatrix = L.FromMatrix(C$1.BuildIdentity([4, 4])), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearScaleAndKeepSkew() {
        this.isSubMatrixLatest || this.updateMatrix();
        const t4 = 1 / this.skewMatrix.m00, e = 1 / this.skewMatrix.m11, i = 1 / this.skewMatrix.m22;
        return this.scaleMatrix = L.FromMatrix(new C$1(new S([4, 4], [t4, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1], true))), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearScaleSize() {
        const t4 = this.decomposeScale();
        return this.setScale(E.FromXYZ(t4.x < 0 ? -1 : 1, t4.y < 0 ? -1 : 1, t4.z < 0 ? -1 : 1)), this;
    }
    clearScaleSizeAndKeepSkew() {
        this.isSubMatrixLatest || this.updateMatrix();
        const t4 = this.decomposeScale(), e = (t4.x < 0 ? -1 : 1) / this.skewMatrix.m00, i = (t4.y < 0 ? -1 : 1) / this.skewMatrix.m11, s = (t4.z < 0 ? -1 : 1) / this.skewMatrix.m22;
        return this.scaleMatrix = L.FromMatrix(new C$1(new S([4, 4], [e, 0, 0, 0, 0, i, 0, 0, 0, 0, s, 0, 0, 0, 0, 1], true))), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearRKS() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.rotateMatrix = O.FromMatrix(C$1.BuildIdentity([4, 4])), this.skewMatrix = C$1.BuildIdentity([4, 4]), this.scaleMatrix = L.FromMatrix(C$1.BuildIdentity([4, 4])), this.isMatrixLatest = false, this.onChange(this), this;
    }
    clearTranslate() {
        return this.isSubMatrixLatest || this.updateMatrix(), this.translateMatrix = R.FromMatrix(C$1.BuildIdentity([4, 4])), this.isMatrixLatest = false, this.onChange(this), this;
    }
    makeFromRotateMatrix() {
        return new t2({ matrix: C$1.FromMatrix(this.rotateMatrix.clone()) });
    }
    makeFromTranslateMatrix() {
        return new t2({ matrix: C$1.FromMatrix(this.translateMatrix.clone()) });
    }
    makeFromSkewMatrix() {
        return new t2({ matrix: C$1.FromMatrix(this.skewMatrix.clone()) });
    }
    makeFromScaleMatrix() {
        return new t2({ matrix: C$1.FromMatrix(this.scaleMatrix.clone()) });
    }
    getMatrix() {
        return this.isMatrixLatest || this.updateMatrix(), this.matrix.clone();
    }
    getCoordinateSystemMatrix() {
        return this.isMatrixLatest || this.updateMatrix(), this.matrix.clone().resize([3, 4]);
    }
    toString() {
        return this.isMatrixLatest || this.updateMatrix(), this.matrix.toString();
    }
}, B = class t3 {
    constructor(t4, e) {
        __publicField(this, "direction");
        __publicField(this, "point");
        this.direction = t4.clone().normalize(), this.point = e ? e.clone() : E.FromXYZ(0, 0, 0);
    }
    static FromPoints(e, i) {
        return void 0 === i && ([e, i] = [E.FromXYZ(0, 0, 0), e]), new t3(i.subtract(e), i);
    }
    static FromParallelX(e) {
        return e && (e.x = 0), new t3(E.FromXYZ(1, 0, 0), e);
    }
    static FromParallelY(e) {
        return e && (e.y = 0), new t3(E.FromXYZ(0, 1, 0), e);
    }
    static FromParallelZ(e) {
        return e && (e.z = 0), new t3(E.FromXYZ(0, 0, 1), e);
    }
    clone() {
        return new t3(this.direction.clone(), this.point.clone());
    }
    transform(t4) {
        return this.direction = t4.transform(this.direction).col0, this.point = t4.transform(this.point).col0, this;
    }
    distanceToPoint(t4) {
        return this.direction.cross(t4.subtract(this.point)).norm;
    }
    projectionPoint(t4) {
        const e = this.direction.dot(t4.subtract(this.point));
        return this.point.add(this.direction.clone().multiplyByNumber(e));
    }
    isPointOnLine(t4) {
        return b(this.direction.cross(t4.subtract(this.point)).norm);
    }
    isLineParallel(t4) {
        return b(this.direction.cross(t4.direction).norm);
    }
    isLineVertical(t4) {
        return b(this.direction.dot(t4.direction));
    }
    intersectionWithLine(t4) {
        const e = this.direction, i = t4.direction, s = this.point, r = t4.point, n2 = C$1.FromCols([e, i.clone().negate()]), o2 = r.clone().subtract(s), a2 = n2.getInverse();
        if (void 0 === a2) return;
        const { x: h2, y: c2 } = a2.multiply(o2).col0;
        return s.clone().add(e.clone().multiplyByNumber(h2));
    }
    isLineIntersect(t4) {
        return !!this.intersectionWithLine(t4);
    }
    equals(t4) {
        return this.isLineParallel(t4) && this.isPointOnLine(t4.point);
    }
    toString() {
        return `x = ${this.point.m0} + ${this.direction.m0}t, y = ${this.point.m1} + ${this.direction.m1}t, z = ${this.point.m2} + ${this.direction.m2}t`;
    }
};
class N extends B {
    constructor(t4) {
        super(t4, E.FromXYZ(0, 0, 0));
    }
    static FromPoints(t4) {
        return new B(t4);
    }
    static FromXAxis() {
        return new B(E.FromXYZ(1, 0, 0));
    }
    static FromYAxis() {
        return new B(E.FromXYZ(0, 1, 0));
    }
    static FromZAxis() {
        return new B(E.FromXYZ(0, 0, 1));
    }
}
class z {
    constructor(t4, e) {
        __publicField(this, "normal");
        __publicField(this, "d");
        this.normal = t4.clone().normalize(), this.d = e;
    }
    static FromPointAndNormal(t4, e) {
        return new z(e, -e.dot(t4));
    }
    static FromPoints(t4, e, i) {
        const s = e.subtract(t4), r = i.subtract(t4), n2 = s.cross(r);
        if (0 === n2.norm) throw new Error("三点共线");
        return new z(n2.normalize(), -n2.dot(t4));
    }
    static FromVerticalX(t4 = 0) {
        return new z(E.FromXYZ(1, 0, 0), t4);
    }
    static FromVerticalY(t4 = 0) {
        return new z(E.FromXYZ(0, 1, 0), t4);
    }
    static FromVerticalZ(t4 = 0) {
        return new z(E.FromXYZ(0, 0, 1), t4);
    }
    clone() {
        return new z(this.normal.clone(), this.d);
    }
    transform(t4) {
        return this.normal = t4.transform(this.normal).col0, this.d = t4.transform(this.normal.clone().multiplyByNumber(this.d)).col0.norm, this;
    }
    distanceToPointDirect(t4) {
        return this.normal.dot(t4) + this.d;
    }
    distanceToPoint(t4) {
        return Math.abs(this.distanceToPointDirect(t4));
    }
    projectionPoint(t4) {
        const e = this.distanceToPointDirect(t4);
        return t4.subtract(this.normal.clone().multiplyByNumber(e));
    }
    intersectionWithLine(t4) {
        if (this.isLineParallel(t4)) return;
        const e = (this.d + this.normal.dot(this.normal)) / this.normal.dot(t4.direction);
        return t4.point.add(t4.direction.clone().multiplyByNumber(e));
    }
    intersectionWithPlane(t4) {
        if (this.isPlaneParallel(t4)) return;
        const e = this.normal.cross(t4.normal);
        return new B(e, this.intersectionWithLine(new B(e, this.normal.multiplyByNumber(this.d))));
    }
    isPointOnPlane(t4) {
        return b(this.distanceToPoint(t4));
    }
    isLineOnPlane(t4) {
        return this.isPointOnPlane(t4.point) && b(this.normal.dot(t4.direction));
    }
    isLineParallel(t4) {
        return b(this.normal.dot(t4.direction));
    }
    isLineVertical(t4) {
        return t4.isLineParallel(new B(this.normal));
    }
    isPlaneParallel(t4) {
        return b(this.normal.cross(t4.normal).norm);
    }
    isPlaneVertical(t4) {
        return b(this.normal.dot(t4.normal));
    }
    equals(t4) {
        return this.isPlaneParallel(t4) && this.isPointOnPlane(t4.normal.multiplyByNumber(t4.d));
    }
    toString() {
        return `${this.normal.m0}x + ${this.normal.m1}y + ${this.normal.m2}z + ${this.d} = 0`;
    }
}
const D = "8BC00DB1-35BD-1B62-F81F-23E231443680";
function H(t4) {
    if (t4.__uuid === D) return t4;
}
function W(t4) {
    if (t4.__uuid === D) return t4;
}
function $(t4) {
    return t4.__uuid === D;
}
class X {
    constructor() {
        __publicField(this, "__uuid", D);
        __publicField(this, "typeId", "");
        __publicField(this, "__parent");
        __publicField(this, "__propKey");
    }
    get parent() {
        return this.__parent;
    }
    notify(...t4) {
        this.__parent && this.__parent.notify(this.__propKey, ...t4);
    }
    onRollback(t4) {
        this.__parent && this.__parent.onRollback(t4);
    }
    clone() {
        throw new Error("not implemented");
    }
    getCrdtPath() {
        if (!this.__parent) return [];
        if (Array.isArray(this.__parent)) {
            const t4 = this.__parent.getCrdtPath(), e = this.id;
            return e && t4.push(e), t4;
        }
        return this.__parent.getCrdtPath().concat(this.__propKey);
    }
    getOpTarget(t4) {
        let e = this;
        for (let i = 0; i < t4.length; i++) {
            const s = t4[i];
            if (e = e instanceof Map ? e.get(s) : e instanceof Array ? e.find((t5) => t5.id === s) : e[s], !e) return;
            if (e instanceof X) return e.getOpTarget(t4.slice(i + 1));
        }
        return e;
    }
}
class G extends Array {
    constructor() {
        super(...arguments);
        __publicField(this, "__uuid", D);
        __publicField(this, "typeId", "array");
        __publicField(this, "__parent");
        __publicField(this, "__propKey");
    }
    get parent() {
        return this.__parent;
    }
    notify(...t4) {
        this.__parent && this.__parent.notify(this.__propKey, ...t4);
    }
    onRollback(t4) {
        this.__parent && this.__parent.onRollback(t4);
    }
    getCrdtPath() {
        return this.__parent ? this.__parent.getCrdtPath().concat(this.__propKey) : [];
    }
}
class Y extends Map {
    constructor() {
        super(...arguments);
        __publicField(this, "__uuid", D);
        __publicField(this, "typeId", "map");
        __publicField(this, "__parent");
        __publicField(this, "__propKey");
    }
    get parent() {
        return this.__parent;
    }
    notify(...t4) {
        this.__parent && this.__parent.notify(this.__propKey, ...t4);
    }
    onRollback(t4) {
        this.__parent && this.__parent.onRollback(t4);
    }
    getCrdtPath() {
        return this.__parent ? this.__parent.getCrdtPath().concat(this.__propKey) : [];
    }
    toJSON() {
        const t4 = {};
        for (let [e, i] of this) t4[e] = i;
        return t4;
    }
}
class U extends X {
    constructor() {
        super(...arguments);
        __publicField(this, "__watcher", /* @__PURE__ */ new Set());
    }
    watch(t4) {
        return this.__watcher.add(t4), () => {
            this.__watcher.delete(t4);
        };
    }
    unwatch(t4) {
        return this.__watcher.delete(t4);
    }
    notify(...t4) {
        0 !== this.__watcher.size && Array.from(this.__watcher).forEach((e) => {
            e(...t4);
        });
    }
}
class Z extends U {
    constructor(t4, e) {
        super();
        __publicField(this, "__resource", /* @__PURE__ */ new Map());
        __publicField(this, "__loader");
        __publicField(this, "__updater");
        __publicField(this, "__guard");
        __publicField(this, "__loading", /* @__PURE__ */ new Map());
        __publicField(this, "__crdtpath");
        this.__guard = e, this.__crdtpath = t4;
    }
    getCrdtPath() {
        return this.__crdtpath;
    }
    get size() {
        return this.__resource.size;
    }
    get keys() {
        return Array.from(this.__resource.keys());
    }
    has(t4) {
        return this.__resource.has(t4);
    }
    delete(t4) {
        return this.__resource.delete(t4);
    }
    get resource() {
        return Array.from(this.__resource.values());
    }
    async get(t4) {
        let e = this.__resource.get(t4);
        if (e) return e;
        let i = this.__loading.get(t4);
        if (i) {
            if (i.timeout > Date.now()) return new Promise((t5, e2) => {
                i == null ? void 0 : i.resolves.push(t5), i == null ? void 0 : i.rejects.push(e2);
            });
            i.timeout = Date.now() + 6e4;
        } else i = { id: t4, timeout: Date.now() + 6e4, resolves: [], rejects: [] }, this.__loading.set(t4, i);
        return e = this.__loader && await this.__loader(t4), e && (e = this.add(t4, e)), i.resolves.forEach((t5) => t5(e)), this.__loading.delete(i.id), e;
    }
    setLoader(t4) {
        this.__loader = t4;
    }
    setUpdater(t4) {
        this.__updater = t4;
    }
    getSync(t4) {
        return this.__resource.get(t4);
    }
    add(t4, e) {
        return e = this.__guard && this.__guard(e) || e, this.__resource.set(t4, e), this.__updater && this.__updater(e), this.notify(t4), e;
    }
    forEach(t4) {
        this.__resource.forEach((e, i) => {
            t4(e, i);
        });
    }
}
class j {
    constructor() {
        __publicField(this, "transact");
        __publicField(this, "cache", /* @__PURE__ */ new Map());
        __publicField(this, "__notifys", /* @__PURE__ */ new Map());
        __publicField(this, "optiNotify", true);
        __publicField(this, "settrap", true);
    }
    addNotify(t4, e) {
        if (t4) if (this.optiNotify) {
            const i = c(t4);
            let s = this.__notifys.get(i);
            s ? s.keys.add(e) : this.__notifys.set(i, { target: t4, keys: /* @__PURE__ */ new Set([e]) });
        } else t4.notify(e);
    }
    fireNotify() {
        this.__notifys.forEach((t4) => {
            t4.target.notify(...t4.keys);
        }), this.__notifys.clear();
    }
    clearNotify() {
        this.__notifys.clear();
    }
}
function J(t4, e, i) {
    const s = t4.cache;
    let r = s.get(c(e));
    return r ? !!r.has(i) || (r.add(i), false) : (r = /* @__PURE__ */ new Set(), r.add(i), s.set(c(e), r), false);
}
class K {
    constructor(t4) {
        __publicField(this, "__context");
        this.__context = t4;
    }
    set(t4, e, i, s) {
        if (e.toString().startsWith("__")) return Reflect.set(t4, e, i, s);
        if (void 0 === this.__context.transact) throw new Error(`NOT inside transact: set '${e.toString()}'`);
        if (this.__context.settrap) throw new Error(`NOT inside Api: set '${e.toString()}'`);
        let r = false;
        if (t4 instanceof Array) {
            if ("length" === e) {
                if (t4.length > i) for (let e2 = i, s2 = t4.length; e2 < s2; e2++) {
                    if (t4[e2] && !J(this.__context, t4, e2)) {
                        const i2 = new tt(t4, e2, t4[e2]);
                        this.__context.transact.push(i2);
                    }
                }
                if (t4.length != i && (r = true, !J(this.__context, t4, e))) {
                    const i2 = new tt(t4, e, Reflect.get(t4, e));
                    this.__context.transact.push(i2);
                }
            } else if (r = true, !J(this.__context, t4, e)) {
                const r2 = t4.length, n3 = new tt(t4, e, Reflect.get(t4, e));
                this.__context.transact.push(n3), Q(i, t4, this, e), i = rt(i, this);
                const o2 = Reflect.set(t4, e, i, s);
                if (this.__context.addNotify(H(t4), e), r2 !== t4.length && !J(this.__context, t4, "length")) {
                    const e2 = new tt(t4, "length", r2);
                    this.__context.transact.push(e2);
                }
                return o2;
            }
        } else if (r = true, !J(this.__context, t4, e)) {
            const i2 = new tt(t4, e, Reflect.get(t4, e));
            this.__context.transact.push(i2);
        }
        Q(i, t4, this, e), i = rt(i, this);
        const n2 = Reflect.set(t4, e, i, s);
        return r && this.__context.addNotify(H(t4), e), n2;
    }
    deleteProperty(t4, e) {
        if (e.toString().startsWith("__")) return Reflect.deleteProperty(t4, e);
        if (void 0 === this.__context.transact) throw new Error(`NOT inside transact: delete '${e.toString()}'`);
        if (this.__context.settrap) throw new Error(`NOT inside Api: delete '${e.toString()}'`);
        if (!J(this.__context, t4, e)) {
            const i2 = new tt(t4, e, Reflect.get(t4, e));
            this.__context.transact.push(i2);
        }
        const i = Reflect.deleteProperty(t4, e);
        return this.__context.addNotify(H(t4), e), i;
    }
    get(t4, e, i) {
        if (!(t4 instanceof Map)) {
            const s = Reflect.get(t4, e, i);
            return void 0 === s && "__isProxy" === e || s;
        }
        if ("get" === e) return Reflect.get(t4, e, i).bind(t4);
        if ("set" === e || "delete" === e) {
            if (void 0 === this.__context.transact) throw new Error(`NOT inside transact: set '${e.toString()}'`);
            if (this.__context.settrap) throw new Error(`NOT inside Api: set '${e.toString()}'`);
            return Reflect.get(this.sub(this.__context, t4, this), e);
        }
        if ("size" === e) return t4.size;
        if ("clear" === e) return false;
        {
            const s = Reflect.get(t4, e, i);
            if (void 0 === s) {
                if ("__isProxy" === e) return true;
            } else if ("function" == typeof s) return s.bind(t4);
            return s;
        }
    }
    has(t4, e) {
        if (t4 instanceof Map) return t4.has(e);
        return Reflect.has(t4, e);
    }
    sub(t4, e, i) {
        return { get: (t5) => Map.prototype.get.bind(e)(t5), set(s, r) {
                var _a2;
                const n2 = Map.prototype.set.bind(e);
                Q(r, e, i, s), n2(s, r = rt(r, i));
                const o2 = new tt(e, "set", { isContentExist: true, content: r, key: s });
                (_a2 = t4.transact) == null ? void 0 : _a2.push(o2), t4.addNotify(H(e), s);
            }, delete(i2) {
                var _a2;
                const s = Map.prototype.get.bind(e)(i2);
                Map.prototype.delete.bind(e)(i2);
                const r = new tt(e, "delete", { isContentExist: false, content: s, key: i2 });
                (_a2 = t4.transact) == null ? void 0 : _a2.push(r), t4.addNotify(H(e), i2);
            } };
    }
}
const q = (t4) => t4 && t4.__isProxy;
function Q(t4, e, i, s) {
    "object" == typeof t4 && $(e) && (t4.__parent = q(e) ? e : new Proxy(e, i), t4.__propKey = s);
}
class tt {
    constructor(t4, e, i) {
        __publicField(this, "__target");
        __publicField(this, "__propertyKey");
        __publicField(this, "__value");
        this.__target = t4, this.__propertyKey = e, this.__value = i;
    }
    swap(t4, e) {
        if (this.__target instanceof Map) "set" !== this.__propertyKey && "delete" !== this.__propertyKey || (this.__value.isContentExist ? this.__target.delete(this.__value.key) : this.__target.set(this.__value.key, this.__value.content), this.__value.isContentExist = !this.__value.isContentExist);
        else {
            const t5 = Reflect.get(this.__target, this.__propertyKey);
            if (this.__target instanceof Array && void 0 === this.__value && this.__propertyKey) {
                const t6 = Number.parseInt(this.__propertyKey.toString());
                Number.isInteger(t6) && t6.toString() == this.__propertyKey ? Reflect.deleteProperty(this.__target, this.__propertyKey) : (Q(this.__value, this.__target, e, this.__propertyKey), Reflect.set(this.__target, this.__propertyKey, this.__value));
            } else Q(this.__value, this.__target, e, this.__propertyKey), Reflect.set(this.__target, this.__propertyKey, this.__value);
            this.__value = t5;
        }
        t4.addNotify(H(this.__target), this.__propertyKey);
    }
    get target() {
        return this.__target;
    }
    get propertyKey() {
        return this.__propertyKey;
    }
    get value() {
        return this.__value;
    }
}
class et extends tt {
    constructor(t4) {
        super(t4, "", "");
        __publicField(this, "__haslen", false);
        __publicField(this, "__len", 0);
        __publicField(this, "__recs", []);
    }
    push(t4) {
        if (c(t4.target) !== c(this.target)) throw new Error("");
        0 === this.__recs.length && (this.__len = Reflect.get(t4.target, "length")), "length" == t4.propertyKey ? this.__haslen = true : this.__recs.push(t4);
    }
    swap(t4, e) {
        const i = Reflect.get(this.target, "length");
        for (let i2 = 0, s = this.__recs.length; i2 < s; i2++) this.__recs[i2].swap(t4, e);
        this.__haslen && (Reflect.set(this.target, "length", this.__len), this.__len = i);
    }
}
class it extends Array {
    constructor(t4) {
        super();
        __publicField(this, "__name");
        __publicField(this, "__cache", /* @__PURE__ */ new Map());
        this.__name = t4;
    }
    get name() {
        return this.__name;
    }
    exec(t4, e) {
        for (let i = 0, s = this.length; i < s; i++) {
            this[i].swap(t4, e);
        }
    }
    unexec(t4, e) {
        for (let i = this.length - 1; i >= 0; i--) {
            this[i].swap(t4, e);
        }
    }
    rollback(t4, e, i) {
        for (let s = this.length - 1; s >= 0; s--) {
            const r = this[s];
            r.swap(t4, e);
            const n2 = W(r.target);
            n2 && n2.onRollback(i);
        }
    }
    push(...t4) {
        for (let e = 0, i = t4.length; e < i; e++) {
            const i2 = t4[e];
            if (i2 instanceof tt && i2.target instanceof Array) {
                let t5 = this.__cache.get(c(i2.target));
                void 0 === t5 && (t5 = new et(i2.target), this.__cache.set(c(i2.target), t5), super.push(t5)), t5.push(i2);
            } else super.push(i2);
        }
        return this.length;
    }
}
class st extends U {
    constructor(t4) {
        super();
        __publicField(this, "__context");
        __publicField(this, "__ph");
        __publicField(this, "__trans", []);
        __publicField(this, "__index", 0);
        __publicField(this, "__needundo");
        __publicField(this, "__saveStartStack");
        this.__context = new j(), this.__ph = new K(this.__context), this.__context.settrap = !t4 || (t4.settrap ?? true), this.__needundo = !!t4 && (t4.needundo ?? false);
    }
    get transactCtx() {
        return this.__context;
    }
    undo() {
        this.canUndo() && (this.__index--, this.__context.optiNotify = true, this.__trans[this.__index].unexec(this.__context, this.__ph), this.__context.fireNotify(), this.notify());
    }
    redo() {
        this.canRedo() && (this.__context.optiNotify = true, this.__trans[this.__index].exec(this.__context, this.__ph), this.__index++, this.__context.fireNotify(), this.notify());
    }
    canUndo() {
        return this.__index > 0;
    }
    canRedo() {
        return this.__index < this.__trans.length;
    }
    start(t4) {
        if (void 0 !== this.__context.transact) throw new Error(`has transact not committed：${this.__context.transact.name}`);
        this.__saveStartStack = new Error(), this.__context.optiNotify = true, this.__context.cache.clear(), this.__context.transact = new it(t4);
    }
    _commit() {
        if (void 0 === this.__context.transact) throw new Error("No transace neet commit");
        this.__context.cache.clear(), this.__trans.length = this.__index, this.__needundo && (this.__trans.push(this.__context.transact), this.__index++), this.__saveStartStack = void 0, this.__context.transact = void 0, this.__context.fireNotify(), this.notify();
    }
    commit() {
        this._commit();
    }
    rollback(t4 = "") {
        if (void 0 === this.__context.transact) throw new Error();
        this.__context.cache.clear(), this.__context.transact.rollback(this.__context, this.__ph, t4), this.__context.transact = void 0, this.__context.fireNotify();
    }
    isInTransact() {
        return void 0 !== this.__context.transact;
    }
    guard(t4) {
        return rt(t4, this.__ph);
    }
    isGuarded(t4) {
        return "object" == typeof t4 && q(t4);
    }
}
function rt(t4, e) {
    if ("object" != typeof t4 || q(t4)) return t4;
    const i = [t4];
    for (; i.length > 0; ) {
        const t5 = i.pop();
        let s;
        if ($(t5) && (s = q(t5) ? t5 : new Proxy(t5, e)), t5 instanceof Map) t5.forEach((t6, r, n2) => {
            r.toString().startsWith("__") || "object" == typeof t6 && (s && (t6.__parent = s, t6.__propKey = r), q(t6) || (n2.set(r, new Proxy(t6, e)), i.push(t6)));
        });
        else for (const r in t5) {
            const n2 = Reflect.get(t5, r);
            if (r.toString().startsWith("__")) ;
            else if ("object" == typeof n2 && (s && (n2.__parent = s, n2.__propKey = r), !q(n2))) {
                const s2 = new Proxy(n2, e);
                Reflect.set(t5, r, s2), i.push(n2);
            }
        }
    }
    return new Proxy(t4, e);
}
var nt, ot, at, ht, ct, lt, dt, pt, ut, ft, gt, mt, _t, yt, xt, wt, bt, Mt, vt, St, Ct, Tt, It, kt, Et, At, Ft, Rt, Ot, Lt, Pt, Bt, Nt, zt, Vt, Dt, Ht, Wt, $t, Xt, Gt, Yt, Ut, Zt, jt, Jt;
!function(t4) {
    t4.Normal = "normal", t4.Darken = "darken", t4.Multiply = "multiply", t4.ColorBurn = "color-burn", t4.Lighten = "lighten", t4.Screen = "screen", t4.ColorDodge = "color-dodge", t4.Overlay = "overlay", t4.SoftLight = "soft-light", t4.HardLight = "hard-light", t4.Difference = "difference", t4.Exclusion = "exclusion", t4.Hue = "hue", t4.Saturation = "saturation", t4.Color = "color", t4.Luminosity = "luminosity", t4.PlusDarker = "plus-darker", t4.PlusLighter = "plus-lighter";
}(nt || (nt = {})), function(t4) {
    t4.Gaussian = "gaussian", t4.Motion = "motion", t4.Zoom = "zoom", t4.Background = "background";
}(ot || (ot = {})), function(t4) {
    t4.None = "none", t4.Union = "union", t4.Subtract = "subtract", t4.Intersect = "intersect", t4.Diff = "diff";
}(at || (at = {})), function(t4) {
    t4.Inner = "inner", t4.Center = "center", t4.Outer = "outer";
}(ht || (ht = {})), function(t4) {
    t4.Inherit = "inherit", t4.Renew = "renew";
}(ct || (ct = {})), function(t4) {
    t4.None = "none", t4.Ordered1Ai = "ordered-1ai", t4.Disorded = "disorded";
}(lt || (lt = {})), function(t4) {
    t4.From = "from", t4.To = "to";
}(dt || (dt = {})), function(t4) {
    t4.Top = "top", t4.Right = "right", t4.Bottom = "bottom", t4.Left = "left";
}(pt || (pt = {})), function(t4) {
    t4.Miter = "miter", t4.Bevel = "bevel", t4.Round = "round";
}(ut || (ut = {})), function(t4) {
    t4.None = "none", t4.Straight = "straight", t4.Mirrored = "mirrored", t4.Asymmetric = "asymmetric", t4.Disconnected = "disconnected";
}(ft || (ft = {})), function(t4) {
    t4.Png = "png", t4.Jpg = "jpg", t4.Tiff = "tiff", t4.Eps = "eps", t4.Pdf = "pdf", t4.Webp = "webp", t4.Svg = "svg";
}(gt || (gt = {})), function(t4) {
    t4.Suffix = "suffix", t4.Prefix = "prefix";
}(mt || (mt = {})), function(t4) {
    t4.Scale = "scale", t4.Width = "width", t4.Height = "height";
}(_t || (_t = {})), function(t4) {
    t4.Nonzero = "nonzero", t4.Evenodd = "evenodd";
}(yt || (yt = {})), function(t4) {
    t4.SolidColor = "solid-color", t4.Gradient = "gradient", t4.Pattern = "pattern";
}(xt || (xt = {})), function(t4) {
    t4.Linear = "linear", t4.Radial = "radial", t4.Angular = "angular";
}(wt || (wt = {})), function(t4) {
    t4.X = "X", t4.Y = "Y";
}(bt || (bt = {})), function(t4) {
    t4.Fill = "fill", t4.Stretch = "stretch", t4.Fit = "fit", t4.Crop = "crop", t4.Tile = "tile";
}(Mt || (Mt = {})), function(t4) {
    t4.Butt = "butt", t4.Round = "round", t4.Projecting = "projecting";
}(vt || (vt = {})), function(t4) {
    t4.Miter = "miter", t4.Round = "round", t4.Bevel = "bevel";
}(St || (St = {})), function(t4) {
    t4.Line = "line", t4.FilledArrow = "filled-arrow", t4.OpenArrow = "open-arrow", t4.FilledCircle = "filled-circle", t4.FilledSquare = "filled-square", t4.Round = "round", t4.Square = "square";
}(Ct || (Ct = {})), function(t4) {
    t4.NONE = "NONE", t4.CLOSEONCLICKOUTSIDE = "CLOSE_ON_CLICK_OUTSIDE";
}(Tt || (Tt = {})), function(t4) {
    t4.NONE = "NONE", t4.SOLIDCOLOR = "SOLID_COLOR";
}(It || (It = {})), function(t4) {
    t4.TOPLEFT = "TOP_LEFT", t4.TOPCENTER = "TOP_CENTER", t4.TOPRIGHT = "TOP_RIGHT", t4.CENTERLEFT = "CENTER_LEFT", t4.CENTER = "CENTER", t4.CENTERRIGHT = "CENTER_RIGHT", t4.BOTTOMLEFT = "BOTTOM_LEFT", t4.BOTTOMCENTER = "BOTTOM_CENTER", t4.BOTTOMRIGHT = "BOTTOM_RIGHT";
}(kt || (kt = {})), function(t4) {
    t4.Name = "name", t4.Text = "text", t4.Image = "image", t4.Fills = "fills", t4.Borders = "borders", t4.Shadows = "shadows", t4.Visible = "visible", t4.Lock = "lock", t4.Variable = "variable", t4.SymbolID = "symbolID", t4.ContextSettings = "contextSettings", t4.TableCell = "tableCell", t4.StartMarkerType = "startMarkerType", t4.EndMarkerType = "endMarkerType", t4.ExportOptions = "exportOptions", t4.CornerRadius = "cornerRadius", t4.Blur = "blur", t4.ProtoInteractions = "protoInteractions";
}(Et || (Et = {})), function(t4) {
    t4.Exposure = "exposure", t4.Contrast = "contrast", t4.Saturation = "saturation", t4.Temperature = "temperature", t4.Tint = "tint", t4.Shadow = "shadow", t4.Hue = "hue";
}(At || (At = {})), function(t4) {
    t4.NONE = "NONE", t4.INTERNALNODE = "INTERNAL_NODE", t4.BACK = "BACK", t4.URL = "URL", t4.CLOSE = "CLOSE";
}(Ft || (Ft = {})), function(t4) {
    t4.LINEAR = "LINEAR", t4.INCUBIC = "IN_CUBIC", t4.OUTCUBIC = "OUT_CUBIC", t4.INOUTCUBIC = "INOUT_CUBIC", t4.INBACKCUBIC = "IN_BACK_CUBIC", t4.OUTBACKCUBIC = "OUT_BACK_CUBIC", t4.INOUTBACKCUBIC = "INOUT_BACK_CUBIC";
}(Rt || (Rt = {})), function(t4) {
    t4.ONCLICK = "ON_CLICK", t4.DBCLICK = "DB_CLICK", t4.RIGHTCLICK = "RIGHT_CLICK", t4.DRAG = "DRAG", t4.HOVER = "HOVER", t4.MOUSEENTER = "MOUSE_ENTER", t4.MOUSELEAVE = "MOUSE_LEAVE", t4.MOUSEDOWN = "MOUSE_DOWN", t4.MOUSEUP = "MOUSE_UP", t4.AFTERTIMEOUT = "AFTER_TIMEOUT";
}(Ot || (Ot = {})), function(t4) {
    t4.NAVIGATE = "NAVIGATE", t4.SWAPSTATE = "SWAP_STATE", t4.SCROLLTO = "SCROLL_TO", t4.OVERLAY = "OVERLAY", t4.SWAP = "SWAP";
}(Lt || (Lt = {})), function(t4) {
    t4.INSTANTTRANSITION = "INSTANT_TRANSITION", t4.DISSOLVE = "DISSOLVE", t4.MOVEFROMRIGHT = "MOVE_FROM_RIGHT", t4.MOVEFROMLEFT = "MOVE_FROM_LEFT", t4.MOVEFROMTOP = "MOVE_FROM_TOP", t4.MOVEFROMBOTTOM = "MOVE_FROM_BOTTOM", t4.MOVEOUTTORIGHT = "MOVE_OUT_TO_RIGHT", t4.MOVEOUTTOLEFT = "MOVE_OUT_TO_LEFT", t4.MOVEOUTTOTOP = "MOVE_OUT_TO_TOP", t4.MOVEOUTTOBOTTOM = "MOVE_OUT_TO_BOTTOM", t4.SLIDEFROMRIGHT = "SLIDE_FROM_RIGHT", t4.SLIDEFROMLEFT = "SLIDE_FROM_LEFT", t4.SLIDEFROMTOP = "SLIDE_FROM_TOP", t4.SLIDEFROMBOTTOM = "SLIDE_FROM_BOTTOM", t4.SLIDEOUTTORIGHT = "SLIDE_OUT_TO_RIGHT", t4.SLIDEOUTTOLEFT = "SLIDE_OUT_TO_LEFT", t4.SLIDEOUTTOTOP = "SLIDE_OUT_TO_TOP", t4.SLIDEOUTTOBOTTOM = "SLIDE_OUT_TO_BOTTOM", t4.PUSHFROMRIGHT = "PUSH_FROM_RIGHT", t4.PUSHFROMLEFT = "PUSH_FROM_LEFT", t4.PUSHFROMTOP = "PUSH_FROM_TOP", t4.PUSHFROMBOTTOM = "PUSH_FROM_BOTTOM", t4.SCROLLANIMATE = "SCROLL_ANIMATE";
}(Pt || (Pt = {})), function(t4) {
    t4.Stretch = "stretch", t4.PinToEdge = "pinToEdge", t4.Resize = "resize", t4.Float = "float";
}(Bt || (Bt = {})), function(t4) {
    t4.NONE = "NONE", t4.HORIZONTAL = "HORIZONTAL", t4.VERTICAL = "VERTICAL", t4.BOTH = "BOTH";
}(Nt || (Nt = {})), function(t4) {
    t4.Inner = "inner", t4.Outer = "outer";
}(zt || (zt = {})), function(t4) {
    t4.Path = "path", t4.Path2 = "path2", t4.Group = "group", t4.Artboard = "artboard", t4.Image = "image", t4.Page = "page", t4.Text = "text", t4.SymbolRef = "symbol-ref", t4.Symbol = "symbol", t4.SymbolUnion = "symbol-union", t4.Rectangle = "rectangle", t4.Triangle = "triangle", t4.Star = "star", t4.Polygon = "polygon", t4.Oval = "oval", t4.Line = "line", t4.Table = "table", t4.TableCell = "table-cell", t4.Contact = "contact", t4.Cutout = "cutout", t4.BoolShape = "bool-shape";
}(Vt || (Vt = {})), function(t4) {
    t4.Normal = "normal", t4.Top = "top", t4.Bottom = "bottom", t4.Left = "left", t4.Right = "right", t4.Custom = "custom";
}(Dt || (Dt = {})), function(t4) {
    t4.None = "none", t4.Single = "single", t4.Double = "double";
}(Ht || (Ht = {})), function(t4) {
    t4.None = "none", t4.Text = "text", t4.Image = "image";
}(Wt || (Wt = {})), function(t4) {
    t4.Flexible = "flexible", t4.Fixed = "fixed", t4.FixWidthAndHeight = "fixWidthAndHeight";
}($t || ($t = {})), function(t4) {
    t4.Left = "left", t4.Right = "right", t4.Centered = "centered", t4.Justified = "justified", t4.Natural = "natural";
}(Xt || (Xt = {})), function(t4) {
    t4.Horizontal = "horizontal", t4.Vertical = "vertical";
}(Gt || (Gt = {})), function(t4) {
    t4.None = "none", t4.Uppercase = "uppercase", t4.Lowercase = "lowercase", t4.UppercaseFirst = "uppercase-first";
}(Yt || (Yt = {})), function(t4) {
    t4.Top = "top", t4.Middle = "middle", t4.Bottom = "bottom";
}(Ut || (Ut = {})), function(t4) {
    t4.None = "none", t4.Single = "single", t4.Double = "double";
}(Zt || (Zt = {})), function(t4) {
    t4.Name = "name", t4.Color = "color", t4.Gradient = "gradient", t4.Text = "text", t4.Visible = "visible", t4.Lock = "lock", t4.SymbolRef = "symbolRef", t4.Status = "status", t4.ImageRef = "imageRef", t4.Fills = "fills", t4.Borders = "borders", t4.Shadows = "shadows", t4.Style = "style", t4.ContextSettings = "contextSettings", t4.TableCell = "tableCell", t4.MarkerType = "markerType", t4.ExportOptions = "exportOptions", t4.CornerRadius = "cornerRadius", t4.Blur = "blur", t4.ProtoInteractions = "protoInteractions";
}(jt || (jt = {})), function(t4) {
    t4.NonZero = "non-zero", t4.EvenOdd = "even-odd";
}(Jt || (Jt = {}));
class Kt extends X {
    constructor(t4 = 0, e = 0) {
        super();
        __publicField(this, "typeId", "border-style");
        __publicField(this, "length");
        __publicField(this, "gap");
        this.length = t4, this.gap = e;
    }
}
class qt extends X {
    constructor(t4) {
        super();
        __publicField(this, "typeId", "bullet-numbers");
        __publicField(this, "type");
        __publicField(this, "behavior");
        __publicField(this, "offset");
        this.type = t4;
    }
}
class Qt extends X {
    constructor(t4 = false, e = 0, i = 0, s = 0, r = 0) {
        super();
        __publicField(this, "typeId", "color-controls");
        __publicField(this, "isEnabled");
        __publicField(this, "brightness");
        __publicField(this, "contrast");
        __publicField(this, "hue");
        __publicField(this, "saturation");
        this.isEnabled = t4, this.brightness = e, this.contrast = i, this.hue = s, this.saturation = r;
    }
}
let te = class extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0) {
        super();
        __publicField(this, "typeId", "color");
        __publicField(this, "alpha");
        __publicField(this, "red");
        __publicField(this, "green");
        __publicField(this, "blue");
        this.alpha = t4, this.red = e, this.green = i, this.blue = s;
    }
};
class ee extends X {
    constructor(t4, e = 1) {
        super();
        __publicField(this, "typeId", "context-settings");
        __publicField(this, "blenMode");
        __publicField(this, "opacity");
        this.blenMode = t4, this.opacity = e;
    }
}
class ie extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0) {
        super();
        __publicField(this, "typeId", "corner-radius");
        __publicField(this, "lt");
        __publicField(this, "rt");
        __publicField(this, "lb");
        __publicField(this, "rb");
        this.lt = t4, this.rt = e, this.lb = i, this.rb = s;
    }
}
class se extends X {
    constructor(t4, e, i, s, r) {
        super();
        __publicField(this, "typeId", "curve-point");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "mode");
        __publicField(this, "radius");
        __publicField(this, "fromX");
        __publicField(this, "fromY");
        __publicField(this, "toX");
        __publicField(this, "toY");
        __publicField(this, "hasFrom");
        __publicField(this, "hasTo");
        this.crdtidx = t4, this.id = e, this.x = i, this.y = s, this.mode = r;
    }
}
class re extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0) {
        super();
        __publicField(this, "typeId", "ellipse");
        __publicField(this, "cx");
        __publicField(this, "cy");
        __publicField(this, "rx");
        __publicField(this, "ry");
        this.cx = t4, this.cy = e, this.rx = i, this.ry = s;
    }
}
class ne extends X {
    constructor(t4, e = 1) {
        super();
        __publicField(this, "typeId", "graphics-context-settings");
        __publicField(this, "blendMode");
        __publicField(this, "opacity");
        this.blendMode = t4, this.opacity = e;
    }
}
class oe extends X {
    constructor(t4, e, i, s = 0) {
        super();
        __publicField(this, "typeId", "guide");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "axis");
        __publicField(this, "offset");
        this.crdtidx = t4, this.id = e, this.axis = i, this.offset = s;
    }
}
class ae extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0) {
        super();
        __publicField(this, "typeId", "overlay-margin");
        __publicField(this, "top");
        __publicField(this, "bottom");
        __publicField(this, "left");
        __publicField(this, "right");
        this.top = t4, this.bottom = e, this.left = i, this.right = s;
    }
}
class he extends X {
    constructor(t4, e) {
        super();
        __publicField(this, "typeId", "overlay-position");
        __publicField(this, "position");
        __publicField(this, "margin");
        this.position = t4, this.margin = e;
    }
}
class ce extends X {
    constructor() {
        super(...arguments);
        __publicField(this, "typeId", "padding");
        __publicField(this, "left");
        __publicField(this, "top");
        __publicField(this, "right");
        __publicField(this, "bottom");
    }
}
class le extends X {
    constructor(t4, e, i) {
        super();
        __publicField(this, "typeId", "page-list-item");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "name");
        __publicField(this, "versionId");
        this.crdtidx = t4, this.id = e, this.name = i;
    }
}
class de extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0, r = 0, n2 = 0, o2 = 0) {
        super();
        __publicField(this, "typeId", "paint-filter");
        __publicField(this, "exposure");
        __publicField(this, "contrast");
        __publicField(this, "saturation");
        __publicField(this, "temperature");
        __publicField(this, "tint");
        __publicField(this, "shadow");
        __publicField(this, "hue");
        this.exposure = t4, this.contrast = e, this.saturation = i, this.temperature = s, this.tint = r, this.shadow = n2, this.hue = o2;
    }
}
class pe extends X {
    constructor(t4, e, i, s) {
        super();
        __publicField(this, "typeId", "path-segment");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "points");
        __publicField(this, "isClosed");
        this.crdtidx = t4, this.id = e, this.points = i, this.isClosed = s;
    }
}
class ue extends X {
    constructor(t4 = 1, e = 0, i = 0, s = 1, r = 0, n2 = 0) {
        super();
        __publicField(this, "typeId", "pattern-transform");
        __publicField(this, "m00");
        __publicField(this, "m01");
        __publicField(this, "m02");
        __publicField(this, "m10");
        __publicField(this, "m11");
        __publicField(this, "m12");
        this.m00 = t4, this.m01 = e, this.m02 = i, this.m10 = s, this.m11 = r, this.m12 = n2;
    }
}
class fe extends X {
    constructor(t4 = 0, e = 0) {
        super();
        __publicField(this, "typeId", "point-2d");
        __publicField(this, "x");
        __publicField(this, "y");
        this.x = t4, this.y = e;
    }
}
class ge extends X {
    constructor(t4, e) {
        super();
        __publicField(this, "typeId", "prototype-starting-point");
        __publicField(this, "name");
        __publicField(this, "desc");
        this.name = t4, this.desc = e;
    }
}
class me extends X {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super();
        __publicField(this, "typeId", "shadow");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "isEnabled");
        __publicField(this, "blurRadius");
        __publicField(this, "color");
        __publicField(this, "offsetX");
        __publicField(this, "offsetY");
        __publicField(this, "spread");
        __publicField(this, "position");
        __publicField(this, "contextSettings");
        this.crdtidx = t4, this.id = e, this.isEnabled = i, this.blurRadius = s, this.color = r, this.offsetX = n2, this.offsetY = o2, this.spread = a2, this.position = h2;
    }
}
class _e extends X {
    constructor(t4 = 0, e = 0, i = 0, s = 0) {
        super();
        __publicField(this, "typeId", "shape-frame");
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "width");
        __publicField(this, "height");
        this.x = t4, this.y = e, this.width = i, this.height = s;
    }
}
class ye extends X {
    constructor(t4 = 0, e = 0) {
        super();
        __publicField(this, "typeId", "shape-size");
        __publicField(this, "width");
        __publicField(this, "height");
        this.width = t4, this.height = e;
    }
}
class xe extends X {
    constructor(t4, e, i, s) {
        super();
        __publicField(this, "typeId", "stop");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "position");
        __publicField(this, "color");
        this.crdtidx = t4, this.id = e, this.position = i, this.color = s;
    }
}
let we = class extends X {
    constructor(t4 = 1, e = 0, i = 0, s = 0, r = 1, n2 = 0) {
        super();
        __publicField(this, "typeId", "transform");
        __publicField(this, "m00");
        __publicField(this, "m01");
        __publicField(this, "m02");
        __publicField(this, "m10");
        __publicField(this, "m11");
        __publicField(this, "m12");
        this.m00 = t4, this.m01 = e, this.m02 = i, this.m10 = s, this.m11 = r, this.m12 = n2;
    }
};
class be extends X {
    constructor(t4, e, i) {
        super();
        __publicField(this, "typeId", "border-options");
        __publicField(this, "isEnabled");
        __publicField(this, "lineCapStyle");
        __publicField(this, "lineJoinStyle");
        this.isEnabled = t4, this.lineCapStyle = e, this.lineJoinStyle = i;
    }
}
class Me extends X {
    constructor(t4, e = 1, i = 1, s = 1, r = 1) {
        super();
        __publicField(this, "typeId", "border-side-setting");
        __publicField(this, "sideType");
        __publicField(this, "thicknessTop");
        __publicField(this, "thicknessLeft");
        __publicField(this, "thicknessBottom");
        __publicField(this, "thicknessRight");
        this.sideType = t4, this.thicknessTop = e, this.thicknessLeft = i, this.thicknessBottom = s, this.thicknessRight = r;
    }
}
class ve extends X {
    constructor(t4, e) {
        super();
        __publicField(this, "typeId", "contact-form");
        __publicField(this, "contactType");
        __publicField(this, "shapeId");
        this.contactType = t4, this.shapeId = e;
    }
}
class Se extends X {
    constructor(t4, e, i, s) {
        super();
        __publicField(this, "typeId", "contact-role");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "roleType");
        __publicField(this, "shapeId");
        this.crdtidx = t4, this.id = e, this.roleType = i, this.shapeId = s;
    }
}
class Ce extends X {
    constructor(t4, e, i) {
        super();
        __publicField(this, "typeId", "crdt-number");
        __publicField(this, "id");
        __publicField(this, "crdtidx");
        __publicField(this, "value");
        this.id = t4, this.crdtidx = e, this.value = i;
    }
}
class Te extends X {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super();
        __publicField(this, "typeId", "export-format");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "absoluteSize");
        __publicField(this, "fileFormat");
        __publicField(this, "name");
        __publicField(this, "namingScheme");
        __publicField(this, "scale");
        __publicField(this, "visibleScaleType");
        this.crdtidx = t4, this.id = e, this.absoluteSize = i, this.fileFormat = s, this.name = r, this.namingScheme = n2, this.scale = o2, this.visibleScaleType = a2;
    }
}
class Ie extends X {
    constructor(t4, e = 0, i = false, s = false, r = false, n2 = false) {
        super();
        __publicField(this, "typeId", "export-options");
        __publicField(this, "exportFormats");
        __publicField(this, "childOptions");
        __publicField(this, "shouldTrim");
        __publicField(this, "trimTransparent");
        __publicField(this, "canvasBackground");
        __publicField(this, "unfold");
        this.exportFormats = t4, this.childOptions = e, this.shouldTrim = i, this.trimTransparent = s, this.canvasBackground = r, this.unfold = n2;
    }
}
class ke extends X {
    constructor(t4, e) {
        super();
        __publicField(this, "typeId", "overlay-background-appearance");
        __publicField(this, "backgroundType");
        __publicField(this, "backgroundColor");
        this.backgroundType = t4, this.backgroundColor = e;
    }
}
let Ee = class extends X {
    constructor(t4) {
        super();
        __publicField(this, "typeId", "prototype-actions");
        __publicField(this, "connectionType");
        __publicField(this, "targetNodeID");
        __publicField(this, "transitionType");
        __publicField(this, "transitionDuration");
        __publicField(this, "easingType");
        __publicField(this, "connectionURL");
        __publicField(this, "openUrlInNewTab");
        __publicField(this, "navigationType");
        __publicField(this, "easingFunction");
        __publicField(this, "extraScrollOffset");
        this.connectionType = t4;
    }
};
class Ae extends X {
    constructor(t4) {
        super();
        __publicField(this, "typeId", "prototype-event");
        __publicField(this, "interactionType");
        __publicField(this, "transitionTimeout");
        this.interactionType = t4;
    }
}
class Fe extends X {
    constructor(t4, e, i, s) {
        super();
        __publicField(this, "typeId", "prototype-inter-action");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "event");
        __publicField(this, "actions");
        __publicField(this, "isDeleted");
        this.crdtidx = t4, this.id = e, this.event = i, this.actions = s;
    }
}
let Re = class extends X {
    constructor(t4, e, i, s, r, n2, o2) {
        super();
        __publicField(this, "typeId", "comment");
        __publicField(this, "pageId");
        __publicField(this, "id");
        __publicField(this, "frame");
        __publicField(this, "user");
        __publicField(this, "createAt");
        __publicField(this, "content");
        __publicField(this, "parasiticBody");
        __publicField(this, "parentId");
        __publicField(this, "rootId");
        this.pageId = t4, this.id = e, this.frame = i, this.user = s, this.createAt = r, this.content = n2, this.parasiticBody = o2;
    }
};
class Oe extends X {
    constructor(t4, e, i, s, r, n2) {
        super();
        __publicField(this, "typeId", "document-meta");
        __publicField(this, "id");
        __publicField(this, "name");
        __publicField(this, "fmtVer");
        __publicField(this, "pagesList");
        __publicField(this, "lastCmdId");
        __publicField(this, "symbolregist");
        __publicField(this, "freesymbols");
        this.id = t4, this.name = e, this.fmtVer = i, this.pagesList = s, this.lastCmdId = r, this.symbolregist = n2;
    }
}
const Ne = { Mask: 255, Right: 1, Width: 2, Left: 4, Bottom: 8, Height: 16, Top: 32, HCenter: 64, VCenter: 128, Default: 54, isFixedToLeft(t4) {
        return !(!(t4 & this.Left) || t4 & this.Right || t4 & this.HCenter);
    }, isFixedToRight(t4) {
        return !(!(t4 & this.Right) || t4 & this.Left || t4 & this.HCenter);
    }, isFixedLeftAndRight(t4) {
        return !(!(t4 & this.Left) || !(t4 & this.Right) || t4 & this.HCenter);
    }, isHorizontalJustifyCenter(t4) {
        return !(!(t4 & this.HCenter) || t4 & this.Left || t4 & this.Right);
    }, isHorizontalScale(t4) {
        return !(t4 & this.Left || t4 & this.Right || t4 & this.HCenter);
    }, isFlexWidth(t4) {
        return !(t4 & this.Width);
    }, isFixedWidth(t4) {
        return !!(t4 & this.Width);
    }, setToFixedLeft(t4) {
        return t4 &= ~this.Right, (t4 &= ~this.HCenter) | this.Left;
    }, setToFixedRight(t4) {
        return t4 &= ~this.Left, (t4 &= ~this.HCenter) | this.Right;
    }, setToFixedLeftAndRight(t4) {
        return t4 &= ~this.Width, (t4 &= ~this.HCenter) | this.Left | this.Right;
    }, setToHorizontalJustifyCenter(t4) {
        return t4 &= ~this.Left, (t4 &= ~this.Right) | this.HCenter;
    }, setToScaleByWidth(t4) {
        return t4 & ~this.Left & ~this.HCenter & ~this.Right & ~this.Width;
    }, setToWidthFlex(t4) {
        return t4 & ~this.Width;
    }, setToWidthFixed(t4) {
        return t4 & this.Left && t4 & this.Right || this.isHorizontalScale(t4) ? t4 : t4 | this.Width;
    }, isFixedToTop(t4) {
        return !(!(t4 & this.Top) || t4 & this.Bottom || t4 & this.VCenter);
    }, isFixedToBottom(t4) {
        return !(!(t4 & this.Bottom) || t4 & this.Top || t4 & this.VCenter);
    }, isFixedTopAndBottom(t4) {
        return !(!(t4 & this.Top) || !(t4 & this.Bottom) || t4 & this.VCenter);
    }, isVerticalJustifyCenter(t4) {
        return !(!(t4 & this.VCenter) || t4 & this.Top || t4 & this.Bottom);
    }, isVerticalScale(t4) {
        return !(t4 & this.Top || t4 & this.Bottom || t4 & this.VCenter);
    }, isFlexHeight(t4) {
        return !(t4 & this.Height);
    }, isFixedHeight(t4) {
        return !!(t4 & this.Height);
    }, setToFixedTop(t4) {
        return t4 &= ~this.Bottom, (t4 &= ~this.VCenter) | this.Top;
    }, setToFixedBottom(t4) {
        return t4 &= ~this.Top, (t4 &= ~this.VCenter) | this.Bottom;
    }, setToFixedTopAndBottom(t4) {
        return t4 &= ~this.Height, (t4 &= ~this.VCenter) | this.Bottom | this.Top;
    }, setToVerticalJustifyCenter(t4) {
        return t4 &= ~this.Top, (t4 &= ~this.Bottom) | this.VCenter;
    }, setToScaleByHeight(t4) {
        return t4 & ~this.Top & ~this.VCenter & ~this.Bottom & ~this.Height;
    }, setToHeightFlex(t4) {
        return t4 & ~this.Height;
    }, setToHeightFixed(t4) {
        return t4 & this.Top && t4 & this.Bottom || this.isVerticalScale(t4) ? t4 : t4 | this.Height;
    } }, ze = [new se([0], "f9bbacab-970e-4bb6-9df2-32b02ea26ccc", 0, 0, ft.Straight), new se([1], "114f9903-1a14-4534-a7bf-ae10c77c39ff", 1, 0, ft.Straight), new se([2], "a22094f2-6e4d-4d64-ab35-13fe5452f3a5", 1, 1, ft.Straight), new se([3], "9407a2d0-e77b-4a44-a064-90f611342e39", 0, 1, ft.Straight)];
var Ve, De;
!function(t4) {
    t4[t4.Fixed = 0] = "Fixed", t4[t4.Editable = 1] = "Editable";
}(Ve || (Ve = {})), function(t4) {
    t4[t4.None = 0] = "None", t4[t4.Fixed = 1] = "Fixed", t4[t4.Rect = 2] = "Rect";
}(De || (De = {}));
const He = 0.135, We = 1e-7, $e = {};
function Xe(t4, e, i) {
    return t4.computeCoord(e, i);
}
function Ge(t4, e, i) {
    const s = t4.computeCoord(e, i);
    return s.x -= t4.m02, s.y -= t4.m12, s;
}
function Ye(t4, e) {
    const i = Xe(t4, e[1], e[2]);
    e[1] = i.x, e[2] = i.y;
}
function Ue(t4, e) {
    const i = Ge(t4, e[1], e[2]);
    e[1] = i.x, e[2] = i.y;
}
$e.M = Ye, $e.m = Ue, $e.L = Ye, $e.l = Ue, $e.A = function(t4, e) {
    let i = Ge(t4, e[1], e[2]);
    e[1] = i.x, e[2] = i.y, i = Xe(t4, e[6], e[7]), e[6] = i.x, e[7] = i.y;
}, $e.a = function(t4, e) {
    let i = Ge(t4, e[1], e[2]);
    e[1] = i.x, e[2] = i.y, i = Ge(t4, e[6], e[7]), e[6] = i.x, e[7] = i.y;
}, $e.H = function(t4, e) {
    const i = Xe(t4, e[1], 0);
    e[1] = i.x;
}, $e.h = function(t4, e) {
    const i = Ge(t4, e[1], 0);
    e[1] = i.x;
}, $e.V = function(t4, e) {
    const i = Xe(t4, 0, e[1]);
    e[1] = i.y;
}, $e.v = function(t4, e) {
    const i = Ge(t4, 0, e[1]);
    e[1] = i.y;
}, $e.C = function(t4, e) {
    let i;
    i = Xe(t4, e[1], e[2]), e[1] = i.x, e[2] = i.y, i = Xe(t4, e[3], e[4]), e[3] = i.x, e[4] = i.y, i = Xe(t4, e[5], e[6]), e[5] = i.x, e[6] = i.y;
}, $e.c = function(t4, e) {
    let i;
    i = Ge(t4, e[1], e[2]), e[1] = i.x, e[2] = i.y, i = Ge(t4, e[3], e[4]), e[3] = i.x, e[4] = i.y, i = Ge(t4, e[5], e[6]), e[5] = i.x, e[6] = i.y;
}, $e.Q = function(t4, e) {
    let i;
    i = Xe(t4, e[1], e[2]), e[1] = i.x, e[2] = i.y, i = Xe(t4, e[3], e[4]), e[3] = i.x, e[4] = i.y;
}, $e.q = function(t4, e) {
    let i;
    i = Ge(t4, e[1], e[2]), e[1] = i.x, e[2] = i.y, i = Ge(t4, e[3], e[4]), e[3] = i.x, e[4] = i.y;
}, $e.Z = function(t4, e) {
}, $e.z = function(t4, e) {
};
const Ze = {};
function je(t4, e) {
    t4.minX > e ? t4.minX = e : t4.maxX < e && (t4.maxX = e);
}
function Je(t4, e) {
    t4.minY > e ? t4.minY = e : t4.maxY < e && (t4.maxY = e);
}
function Ke(t4, e, i, s, r) {
    const n2 = 1 - t4;
    return n2 * n2 * n2 * e + 3 * n2 * n2 * t4 * i + 3 * n2 * t4 * t4 * s + t4 * t4 * t4 * r;
}
function qe(t4, e, i, s, r, n2, o2, a2) {
    const h2 = { minX: Math.min(t4, o2), minY: Math.min(e, a2), maxX: Math.max(t4, o2), maxY: Math.max(e, a2) }, c2 = i - t4, l2 = s - e, d2 = n2 - s, p2 = o2 - r, u = a2 - n2;
    if (i < h2.minX || i > h2.maxX || r < h2.minX || r > h2.maxX) {
        let e2 = r - i;
        c2 + p2 !== 2 * e2 && (e2 += 1e-4);
        const s2 = 2 * (c2 - e2);
        let n3 = 2 * (c2 - 2 * e2 + p2);
        0 === n3 && (n3 = 1e-4);
        const a3 = (2 * e2 - 2 * c2) * (2 * e2 - 2 * c2) - 2 * c2 * n3, l3 = Math.sqrt(a3), d3 = (s2 + l3) / n3, u2 = (s2 - l3) / n3;
        0 < d3 && d3 < 1 && je(h2, Ke(d3, t4, i, r, o2)), 0 < u2 && u2 < 1 && je(h2, Ke(u2, t4, i, r, o2));
    }
    if (s < h2.minY || s > h2.maxY || n2 < h2.minY || n2 > h2.maxY) {
        let t5 = d2;
        l2 + u !== 2 * t5 && (t5 += 1e-4);
        const i2 = 2 * (l2 - t5);
        let r2 = 2 * (l2 - 2 * t5 + u);
        0 === r2 && (r2 = 1e-4);
        const o3 = (2 * t5 - 2 * l2) * (2 * t5 - 2 * l2) - 2 * l2 * r2, c3 = Math.sqrt(o3), p3 = (i2 + c3) / r2, f2 = (i2 - c3) / r2;
        0 < p3 && p3 < 1 && Je(h2, Ke(p3, e, s, n2, a2)), 0 < f2 && f2 < 1 && Je(h2, Ke(f2, e, s, n2, a2));
    }
    return h2;
}
Ze.M = function(t4, e, i) {
    t4[1] += e, t4[2] += i;
}, Ze.m = function(t4, e, i) {
}, Ze.L = function(t4, e, i) {
    t4[1] += e, t4[2] += i;
}, Ze.l = function(t4, e, i) {
}, Ze.A = function(t4, e, i) {
    t4[6] += e, t4[7] += i;
}, Ze.a = function(t4, e, i) {
}, Ze.H = function(t4, e, i) {
    t4[1] += e;
}, Ze.h = function(t4, e, i) {
}, Ze.V = function(t4, e, i) {
    t4[1] += i;
}, Ze.v = function(t4, e, i) {
}, Ze.C = function(t4, e, i) {
    t4[1] += e, t4[2] += i, t4[3] += e, t4[4] += i, t4[5] += e, t4[6] += i;
}, Ze.c = function(t4, e, i) {
}, Ze.S = function(t4, e, i) {
    t4[1] += e, t4[2] += i, t4[3] += e, t4[4] += i;
}, Ze.s = function(t4, e, i) {
}, Ze.Q = function(t4, e, i) {
    t4[1] += e, t4[2] += i, t4[3] += e, t4[4] += i;
}, Ze.q = function(t4, e, i) {
}, Ze.T = function(t4, e, i) {
    t4[1] += e, t4[2] += i;
}, Ze.t = function(t4, e, i) {
}, Ze.Z = function(t4, e, i) {
}, Ze.z = function(t4, e, i) {
};
const Qe = 2 * Math.PI;
function ti(t4, e, i, s, r, n2, o2, a2) {
    return { x: r * (t4 *= i) - n2 * (e *= s) + o2, y: n2 * t4 + r * e + a2 };
}
function ei(t4, e) {
    const i = 4 / 3 * Math.tan(e / 4), s = Math.cos(t4), r = Math.sin(t4), n2 = Math.cos(t4 + e), o2 = Math.sin(t4 + e);
    return [{ x: s - r * i, y: r + s * i }, { x: n2 + o2 * i, y: o2 - n2 * i }, { x: n2, y: o2 }];
}
function ii(t4, e, i, s) {
    const r = t4 * s - e * i < 0 ? -1 : 1;
    let n2 = (t4 * i + e * s) / (Math.sqrt(t4 * t4 + e * e) * Math.sqrt(t4 * t4 + e * e));
    return n2 > 1 && (n2 = 1), n2 < -1 && (n2 = -1), r * Math.acos(n2);
}
function si(t4, e) {
    const i = t4.x, s = t4.y, r = e[5], n2 = e[6];
    let o2 = e[0], a2 = e[1];
    const h2 = e[2], c2 = e[3], l2 = e[4], d2 = [];
    if (0 === o2 || 0 === a2) return null;
    const p2 = Math.sin(h2 * Math.PI / 180), u = Math.cos(h2 * Math.PI / 180), f2 = u * (i - r) / 2 + p2 * (s - n2) / 2, g2 = -p2 * (i - r) / 2 + u * (s - n2) / 2;
    if (0 === f2 && 0 === g2) return null;
    const m2 = Math.pow(f2, 2) / Math.pow(o2, 2) + Math.pow(g2, 2) / Math.pow(a2, 2);
    m2 > 1 && (o2 *= Math.sqrt(m2), a2 *= Math.sqrt(m2));
    const _2 = function(t5, e2, i2, s2, r2, n3, o3, a3, h3, c3, l3, d3) {
        const p3 = Math.pow(r2, 2), u2 = Math.pow(n3, 2), f3 = Math.pow(l3, 2), g3 = Math.pow(d3, 2);
        let m3 = p3 * u2 - p3 * g3 - u2 * f3;
        m3 < 0 && (m3 = 0), m3 /= p3 * g3 + u2 * f3, m3 = Math.sqrt(m3) * (o3 === a3 ? -1 : 1);
        const _3 = m3 * r2 / n3 * d3, y3 = m3 * -n3 / r2 * l3, x3 = c3 * _3 - h3 * y3 + (t5 + i2) / 2, w3 = h3 * _3 + c3 * y3 + (e2 + s2) / 2, b3 = (l3 - _3) / r2, M3 = (d3 - y3) / n3, v2 = (-l3 - _3) / r2, S2 = (-d3 - y3) / n3, C3 = ii(1, 0, b3, M3);
        let T2 = ii(b3, M3, v2, S2);
        return 0 === a3 && T2 > 0 && (T2 -= Qe), 1 === a3 && T2 < 0 && (T2 += Qe), [x3, w3, C3, T2];
    }(i, s, r, n2, o2, a2, c2, l2, p2, u, f2, g2), y2 = _2[0], x2 = _2[1];
    let w2 = _2[2], b2 = _2[3];
    const M2 = Math.max(Math.ceil(Math.abs(b2) / (Qe / 4)), 1);
    b2 /= M2;
    for (let t5 = 0; t5 < M2; t5++) d2.push(ei(w2, b2)), w2 += b2;
    return d2.map(function(t5) {
        const e2 = ti(t5[0].x, t5[0].y, o2, a2, u, p2, y2, x2), i2 = ti(t5[1].x, t5[1].y, o2, a2, u, p2, y2, x2), s2 = ti(t5[2].x, t5[2].y, o2, a2, u, p2, y2, x2);
        return [e2.x, e2.y, i2.x, i2.y, s2.x, s2.y];
    });
}
const ri = {};
function ni(t4, e, i) {
    t4.boundsinited || (t4.boundsinited = true, t4.bounds.minX = t4.bounds.maxX = t4.prepoint.x, t4.bounds.minY = t4.bounds.maxY = t4.prepoint.y), je(t4.bounds, e), Je(t4.bounds, i);
}
ri.M = (t4, e) => {
    const i = e[1], s = e[2];
    t4.beginpoint.x = i, t4.beginpoint.y = s, t4.prepoint.x = i, t4.prepoint.y = s, ni(t4, t4.prepoint.x, t4.prepoint.y);
}, ri.m = (t4, e) => {
    const i = t4.prepoint.x + e[1], s = t4.prepoint.y + e[2];
    t4.beginpoint.x = i, t4.beginpoint.y = s, t4.prepoint.x = i, t4.prepoint.y = s, ni(t4, t4.prepoint.x, t4.prepoint.y);
}, ri.L = (t4, e) => {
    const i = e[1], s = e[2];
    ni(t4, i, s), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.l = (t4, e) => {
    const i = t4.prepoint.x + e[1], s = t4.prepoint.y + e[2];
    ni(t4, i, s), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.A = (t4, e) => {
    const i = e[6], s = e[7], r = si(t4.prepoint, e.slice(1));
    if (r) for (let i2 = 0, s2 = r.length; i2 < s2; i2++) {
        const s3 = (e = ["C", ...r[i2]])[5], n2 = e[6], o2 = e[1], a2 = e[2], h2 = e[3], c2 = e[4], l2 = qe(t4.prepoint.x, t4.prepoint.y, o2, a2, h2, c2, s3, n2);
        ni(t4, l2.minX, l2.minY), ni(t4, l2.maxX, l2.maxY);
    }
    t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.a = (t4, e) => {
    const i = t4.prepoint.x + e[6], s = t4.prepoint.y + e[7];
    (e = e.slice(0))[0] = "A", e[6] = i, e[7] = s;
    const r = si(t4.prepoint, e.slice(1));
    if (r) for (let i2 = 0, s2 = r.length; i2 < s2; i2++) {
        const s3 = (e = ["C", ...r[i2]])[5], n2 = e[6], o2 = e[1], a2 = e[2], h2 = e[3], c2 = e[4], l2 = qe(t4.prepoint.x, t4.prepoint.y, o2, a2, h2, c2, s3, n2);
        ni(t4, l2.minX, l2.minY), ni(t4, l2.maxX, l2.maxY);
    }
    t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.H = (t4, e) => {
    const i = e[1], s = t4.prepoint.y;
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.h = (t4, e) => {
    const i = t4.prepoint.x + e[1], s = t4.prepoint.y;
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.V = (t4, e) => {
    const i = t4.prepoint.x, s = e[1];
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.v = (t4, e) => {
    const i = t4.prepoint.x, s = t4.prepoint.y + e[1];
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.C = (t4, e) => {
    const i = e[5], s = e[6], r = e[1], n2 = e[2], o2 = e[3], a2 = e[4], h2 = qe(t4.prepoint.x, t4.prepoint.y, r, n2, o2, a2, i, s);
    ni(t4, h2.minX, h2.minY), ni(t4, h2.maxX, h2.maxY), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.c = (t4, e) => {
    const i = t4.prepoint.x + e[5], s = t4.prepoint.y + e[6], r = t4.prepoint.x + e[1], n2 = t4.prepoint.y + e[2], o2 = t4.prepoint.x + e[3], a2 = t4.prepoint.y + e[4], h2 = qe(t4.prepoint.x, t4.prepoint.y, r, n2, o2, a2, i, s);
    ni(t4, h2.minX, h2.minY), ni(t4, h2.maxX, h2.maxY), t4.prepoint.x = i, t4.prepoint.y = s;
}, ri.Z = (t4, e) => {
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = t4.beginpoint.x, t4.prepoint.y = t4.beginpoint.y;
}, ri.z = (t4, e) => {
    ni(t4, t4.prepoint.x, t4.prepoint.y), t4.prepoint.x = t4.beginpoint.x, t4.prepoint.y = t4.beginpoint.y;
}, ri.Q = (t4, e) => {
}, ri.q = (t4, e) => {
};
const oi = /([achlmrqstvz])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?\s*,?\s*)+)/gi, ai = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s*,?\s*/gi;
const hi = {};
function ci(e, i, s) {
    if (!e.points.length) {
        const i2 = new se([0], v4(), e.beginpoint.x, e.beginpoint.y, ft.Straight);
        e.points.push(i2);
    }
    const r = new se([e.points.length], v4(), i, s, ft.Straight);
    e.points.push(r), e.prepoint.x = i, e.prepoint.y = s;
}
function li(e, i, s, r, n2, o2, a2) {
    const h2 = e.points.length;
    if (h2) {
        const t4 = e.points[e.points.length - 1];
        t4.hasFrom = true, t4.fromX = i, t4.fromY = s;
    } else {
        const r2 = new se([0], v4(), e.beginpoint.x, e.beginpoint.y, ft.Asymmetric);
        r2.hasFrom = true, r2.fromX = i, r2.fromY = s, e.points.push(r2);
    }
    const c2 = new se([h2], v4(), o2, a2, ft.Asymmetric);
    c2.hasTo = true, c2.toX = r, c2.toY = n2, e.prepoint = { x: o2, y: a2 }, e.preHandle = { x: r, y: n2 }, e.points.push(c2);
}
function di(e, i, s, r, n2) {
    const o2 = e.points.length;
    if (o2) {
        const t4 = e.points[e.points.length - 1];
        t4.hasFrom = true, t4.fromX = i, t4.fromY = s;
    } else {
        const r2 = new se([0], v4(), e.beginpoint.x, e.beginpoint.y, ft.Asymmetric);
        r2.hasFrom = true, r2.fromX = i, r2.fromY = s, e.points.push(r2);
    }
    e.prepoint = { x: r, y: n2 }, e.preHandle = { x: i, y: s }, e.points.push(new se([o2], v4(), r, n2, ft.Asymmetric));
}
hi.M = (t4, e) => {
    const i = e[1], s = e[2], r = { beginpoint: { x: i, y: s }, prepoint: { x: i, y: s }, points: [], preHandle: { x: i, y: s }, lastCommand: "M" };
    t4.segs.push(r);
}, hi.m = (t4, e) => {
    if (1 === t4.segs.length) return hi.M(t4, e);
    const i = t4.segs[t4.segs.length - 1], s = (i.prepoint.x || 0) + e[1], r = (i.prepoint.y || 0) + e[2], n2 = { beginpoint: { x: s, y: r }, prepoint: { x: s, y: r }, points: [], preHandle: { x: s, y: r }, lastCommand: "M" };
    t4.segs.push(n2);
}, hi.L = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, e[1], e[2]), i.lastCommand = "L";
}, hi.l = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, i.prepoint.x + e[1], i.prepoint.y + e[2]), i.lastCommand = "L";
}, hi.A = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = e[6], r = e[7], n2 = si(i.prepoint, e.slice(1));
    if (n2) for (let t5 = 0, s2 = n2.length; t5 < s2; t5++) {
        const s3 = (e = ["C", ...n2[t5]])[5], r2 = e[6];
        li(i, e[1], e[2], e[3], e[4], s3, r2);
    }
    i.prepoint.x = s, i.prepoint.y = r, i.lastCommand = "C";
}, hi.a = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = i.prepoint.x + e[6], r = i.prepoint.y + e[7];
    (e = e.slice(0))[0] = "A", e[6] = s, e[7] = r;
    const n2 = si(i.prepoint, e.slice(1));
    if (n2) for (let t5 = 0, s2 = n2.length; t5 < s2; t5++) {
        const s3 = (e = ["C", ...n2[t5]])[5], r2 = e[6];
        li(i, e[1], e[2], e[3], e[4], s3, r2);
    }
    i.prepoint.x = s, i.prepoint.y = r, i.lastCommand = "C";
}, hi.H = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, e[1], i.prepoint.y), i.lastCommand = "H";
}, hi.h = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, i.prepoint.x + e[1], i.prepoint.y), i.lastCommand = "H";
}, hi.V = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, i.prepoint.x, e[1]), i.lastCommand = "V";
}, hi.v = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    ci(i, i.prepoint.x, i.prepoint.y + e[1]), i.lastCommand = "V";
}, hi.C = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = e[5], r = e[6];
    li(i, e[1], e[2], e[3], e[4], s, r), i.lastCommand = "C";
}, hi.c = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = i.prepoint.x + e[5], r = i.prepoint.y + e[6];
    li(i, i.prepoint.x + e[1], i.prepoint.y + e[2], i.prepoint.x + e[3], i.prepoint.y + e[4], s, r), i.lastCommand = "C";
}, hi.S = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    if ("C" === i.lastCommand) {
        li(i, 2 * i.prepoint.x - i.preHandle.x, 2 * i.prepoint.y - i.preHandle.y, e[1], e[2], e[3], e[4]);
    } else {
        const t5 = e[1], s = e[2];
        e[1], e[2];
        di(i, t5, s, e[3], e[4]);
    }
    e[0] = "C", i.lastCommand = "C";
}, hi.s = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    if ("C" === i.lastCommand) {
        li(i, 2 * i.prepoint.x - i.preHandle.x, 2 * i.prepoint.y - i.preHandle.y, i.prepoint.x + e[1], i.prepoint.y + e[2], i.prepoint.x + e[3], i.prepoint.y + e[4]);
    } else {
        di(i, i.prepoint.x + e[1], i.prepoint.y + e[2], i.prepoint.x + e[3], i.prepoint.y + e[4]);
    }
    e[0] = "C", i.lastCommand = "C";
}, hi.Q = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = e[3], r = e[4];
    di(i, e[1], e[2], s, r), e[0] = "C", i.lastCommand = "C";
}, hi.q = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1], s = i.prepoint.x + e[3], r = i.prepoint.y + e[4];
    di(i, i.prepoint.x + e[1], i.prepoint.y + e[2], s, r), e[0] = "C", i.lastCommand = "C";
}, hi.T = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    if ("C" === i.lastCommand) {
        di(i, 2 * i.prepoint.x - i.preHandle.x, 2 * i.prepoint.y - i.preHandle.y, e[1], e[2]), e[0] = "C", i.lastCommand = "C";
    } else {
        ci(i, e[1], e[2]), i.lastCommand = "L";
    }
}, hi.t = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    if ("C" === i.lastCommand) {
        di(i, 2 * i.prepoint.x - i.preHandle.x, 2 * i.prepoint.y - i.preHandle.y, e[1] + i.prepoint.x, e[2] + i.prepoint.y), e[0] = "C", i.lastCommand = "C";
    } else {
        ci(i, i.prepoint.x + e[1], i.prepoint.y + e[2]), i.lastCommand = "L";
    }
}, hi.Z = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    i.isClosed = true, i.prepoint.x = i.beginpoint.x, i.prepoint.y = i.beginpoint.y, i.lastCommand = "Z";
}, hi.z = (t4, e) => {
    const i = t4.segs[t4.segs.length - 1];
    i.isClosed = true, i.prepoint.x = i.beginpoint.x, i.prepoint.y = i.beginpoint.y, i.lastCommand = "Z";
};
class pi {
    constructor(t4) {
        __publicField(this, "m_segs");
        __publicField(this, "__bounds");
        this.m_segs = "string" == typeof t4 ? function(t5) {
            if (!t5) return [];
            const e = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 }, i = [];
            return t5.replace(oi, function(t6, s, r) {
                const n2 = [];
                let o2 = s.toLowerCase();
                if (r.replace(ai, function(t7, e2) {
                    return e2 && n2.push(+e2), "";
                }), "m" == o2 && n2.length > 2 && (i.push([s].concat(n2.splice(0, 2))), o2 = "l", s = "m" == s ? "l" : "L"), "r" == o2) i.push([s].concat(n2));
                else for (; n2.length >= e[o2] && (i.push([s].concat(n2.splice(0, e[o2]))), e[o2]); ) ;
                return "";
            }), i;
        }(t4) : t4 || [];
    }
    get length() {
        return this.m_segs.length;
    }
    push(...t4) {
        t4.forEach((t5) => {
            t5 && this.m_segs.push(...t5.m_segs);
        }), this.__bounds = void 0;
    }
    clone() {
        const t4 = [];
        this.m_segs.forEach((e2) => {
            t4.push(e2.slice());
        });
        const e = new pi(t4);
        return e.__bounds = this.__bounds, e;
    }
    translate(t4, e) {
        var _a2;
        "m" === ((_a2 = this.m_segs[0]) == null ? void 0 : _a2[0]) && (this.m_segs[0][0] = "M"), this.m_segs = this.m_segs.map(/* @__PURE__ */ function(t5, e2) {
            return (i) => (Ze[i[0]](i, t5, e2), i);
        }(t4, e)), this.__bounds && (this.__bounds.maxX += t4, this.__bounds.minX += t4, this.__bounds.maxY += e, this.__bounds.minY += e);
    }
    transform(t4) {
        var e;
        this.m_segs = this.m_segs.map((e = t4, (t5) => {
            const i = $e[t5[0]];
            if (!i) throw console.error(t5), new Error();
            return i(e, t5), t5;
        })), this.__bounds = void 0;
    }
    toString() {
        return this.m_segs.map((t4) => t4.join(" ")).join(" ");
    }
    calcBounds() {
        return this.__bounds || (this.__bounds = function(t4) {
            const e = { beginpoint: { x: 0, y: 0 }, prepoint: { x: 0, y: 0 }, bounds: { minX: 0, minY: 0, maxX: 0, maxY: 0 }, boundsinited: false };
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i], r = ri[s2[0]];
                if (!r) throw new Error("no bounds handler for " + s2[0]);
                r(e, s2);
            }
            return t4.length > 0 && "z" !== t4[t4.length - 1][0].toString().toLowerCase() && ri.z(e, t4[t4.length - 1]), e.bounds;
        }(this.m_segs)), this.__bounds;
    }
    toCurvePoints(t4, e) {
        return function(t5, e2, i) {
            const s = { width: e2, height: i, segs: [] };
            s.segs.push({ beginpoint: { x: 0, y: 0 }, prepoint: { x: 0, y: 0 }, points: [], preHandle: { x: 0, y: 0 }, lastCommand: "M" });
            for (let e3 = 0, i2 = t5.length; e3 < i2; e3++) {
                const i3 = t5[e3];
                hi[i3[0]](s, i3);
            }
            for (let t6 = 0, e3 = s.segs.length; t6 < e3; t6++) {
                const e4 = s.segs[t6], i2 = e4.points.length;
                if (i2 <= 1) continue;
                const r2 = e4.points[0], n2 = e4.points[i2 - 1];
                Math.abs(n2.x - r2.x) < We && Math.abs(n2.y - r2.y) < We && (e4.isClosed = true, n2.hasTo && (r2.hasTo = true, r2.toX = n2.toX, r2.toY = n2.toY), e4.points.splice(i2 - 1, 1));
            }
            const r = [];
            for (let t6 = 0, e3 = s.segs.length; t6 < e3; t6++) {
                const e4 = s.segs[t6];
                e4.points.length <= 1 || r.push({ points: e4.points, isClosed: !!e4.isClosed });
            }
            return r.forEach((t6) => {
                t6.points = t6.points.map((t7) => (t7.hasFrom && (t7.fromX = (t7.fromX || 0) / e2, t7.fromY = (t7.fromY || 0) / i), t7.hasTo && (t7.toX = (t7.toX || 0) / e2, t7.toY = (t7.toY || 0) / i), t7.x /= e2, t7.y /= i, t7));
            }), r;
        }(this.m_segs, t4, e);
    }
    freeze() {
        this.m_segs.forEach((t4) => Object.freeze(t4)), Object.freeze(this.m_segs);
    }
}
function ui(t4, e, i) {
    return { x: t4.x + (e.x - t4.x) * i, y: t4.y + (e.y - t4.y) * i };
}
function fi(t4, e, i, s, r) {
    const n2 = ui(t4, e, r), o2 = ui(e, i, r), a2 = ui(i, s, r), h2 = ui(n2, o2, r), c2 = ui(o2, a2, r), l2 = ui(h2, c2, r);
    return [[t4, n2, h2, l2], [l2, c2, a2, s]];
}
function gi(t4, e, i, s, r) {
    return { x: Math.pow(1 - t4, 3) * e.x + 3 * Math.pow(1 - t4, 2) * t4 * i.x + 3 * (1 - t4) * Math.pow(t4, 2) * s.x + Math.pow(t4, 3) * r.x, y: Math.pow(1 - t4, 3) * e.y + 3 * Math.pow(1 - t4, 2) * t4 * i.y + 3 * (1 - t4) * Math.pow(t4, 2) * s.y + Math.pow(t4, 3) * r.y };
}
function mi(t4, e, i, s, r) {
    const n2 = 3 * (e.x - t4.x), o2 = 3 * (e.y - t4.y), a2 = 3 * (i.x - e.x) - n2, h2 = 3 * (i.y - e.y) - o2, c2 = r * (n2 + r * (a2 + r * (s.x - t4.x - n2 - a2))), l2 = r * (o2 + r * (h2 + r * (s.y - t4.y - o2 - h2)));
    return Math.sqrt(c2 * c2 + l2 * l2);
}
function _i(t4, e, i, s, r, n2 = 1e-5) {
    let o2 = 0, a2 = 1, h2 = 0.5;
    for (; o2 <= a2; ) {
        const c2 = mi(t4, e, i, s, h2);
        if (Math.abs(c2 - r) < n2) return h2;
        c2 < r ? (o2 = h2, h2 += 0.5 * (a2 - h2)) : (a2 = h2, h2 -= 0.5 * (h2 - o2));
    }
    return null;
}
function yi(t4, e) {
    return Math.hypot(t4.x - e.x, t4.y - e.y);
}
function xi(t4, e) {
    return { x: t4.x - e.x, y: t4.y - e.y };
}
function wi(t4) {
    const e = Math.hypot(t4.x, t4.y);
    return { x: t4.x / e, y: t4.y / e };
}
function bi(t4, e) {
    return { x: t4.x * e, y: t4.y * e };
}
function Mi(t4, e) {
    return { x: t4.x + e.x, y: t4.y + e.y };
}
function vi(t4, e, i, s, r = 0) {
    let n2 = false;
    const o2 = t4.length;
    if (o2 < 2) return [];
    const a2 = {}, h2 = [], c2 = (t5, e2, i2, s2, r2, n3) => {
        h2.push(["C", t5, e2, i2, s2, r2, n3]);
    }, l2 = (t5, e2) => ({ x: t5 * i, y: e2 * s }), d2 = t4.map((t5) => l2(t5.x, t5.y));
    for (let t5 = 0; t5 < o2 - 1; t5++) f2(t5, t5 + 1);
    function p2(i2) {
        const s2 = t4[i2];
        return !!(e || 0 !== i2 && i2 !== o2 - 1) && (!s2.hasFrom && !s2.hasTo && ((s2.radius || 0) > 0 || r > 0));
    }
    function u(e2) {
        if (a2[e2]) return a2[e2];
        const i2 = 0 === e2 ? o2 - 1 : e2 - 1, s2 = e2 === o2 - 1 ? 0 : e2 + 1, n3 = t4[i2], h3 = t4[e2], c3 = t4[s2], p3 = d2[i2], u2 = d2[e2], f3 = d2[s2], g2 = yi(u2, p3), m2 = yi(u2, f3), _2 = function(t5, e3, i3) {
            const s3 = yi(t5, e3), r2 = yi(e3, i3), n4 = yi(i3, t5);
            return Math.acos((r2 * r2 + s3 * s3 - n4 * n4) / (2 * r2 * s3));
        }(p3, u2, f3);
        if (Number.isNaN(_2)) return;
        let y2 = h3.radius || r;
        const x2 = Math.tan(_2 / 2);
        let w2 = y2 / x2;
        const b2 = Math.min((n3.radius || r) > 0 ? g2 / 2 : g2, (c3.radius || r) > 0 ? m2 / 2 : m2);
        w2 > b2 && (w2 = b2, y2 = w2 * x2);
        const M2 = wi(xi(p3, u2)), v2 = wi(xi(f3, u2));
        let S2 = Mi(bi(M2, w2), u2), C3 = Mi(bi(v2, w2), u2);
        const T2 = 4 / 3 * Math.tan((Math.PI - _2) / 4);
        let I2 = Mi(bi(M2, -y2 * T2), S2), k = Mi(bi(v2, -y2 * T2), C3), E2 = [], A2 = [];
        if (n3.hasFrom) {
            const t5 = l2(n3.fromX || 0, n3.fromY || 0), e3 = _i(u2, u2, t5, p3, w2);
            if (null !== e3) {
                const i3 = gi(e3, u2, u2, t5, p3);
                S2 = i3 || S2, E2 = fi(u2, u2, t5, p3, e3), I2 = E2[0][2];
            }
        }
        if (c3.hasTo) {
            const t5 = l2(c3.toX || 0, c3.toY || 0), e3 = _i(u2, u2, t5, f3, w2);
            if (null !== e3) {
                const i3 = gi(e3, u2, u2, t5, f3);
                C3 = i3 || C3, A2 = fi(u2, u2, t5, f3, e3), k = A2[0][2];
            }
        }
        return a2[e2] = { curPoint: u2, preTangent: S2, nextTangent: C3, preHandle: I2, nextHandle: k, preSlices: E2, nextSlices: A2 }, a2[e2];
    }
    function f2(e2, i2) {
        let s2, r2, o3, a3, f3, g2 = true;
        if (p2(e2) && (f3 = u(e2))) {
            const { nextTangent: t5, nextSlices: e3 } = f3;
            s2 = t5, e3.length && (r2 = e3[1][1], a3 = e3[1][2]), g2 = false;
        } else {
            const i3 = t4[e2];
            s2 = d2[e2], r2 = i3.hasFrom ? l2(i3.fromX || 0, i3.fromY || 0) : void 0;
        }
        var m2, _2;
        n2 || (n2 = true, m2 = s2.x, _2 = s2.y, h2.push(["M", m2, _2]));
        const y2 = p2(i2);
        if (y2 && (f3 = u(i2))) {
            const { preTangent: t5, preSlices: e3 } = f3;
            o3 = t5, e3.length && (r2 = e3[1][2], a3 = e3[1][1]);
        } else {
            const e3 = t4[i2];
            o3 = d2[i2], g2 && (a3 = e3.hasTo ? l2(e3.toX || 0, e3.toY || 0) : void 0);
        }
        if (r2 || a3 ? c2((r2 == null ? void 0 : r2.x) ?? (s2 == null ? void 0 : s2.x), (r2 == null ? void 0 : r2.y) ?? s2.y, (a3 == null ? void 0 : a3.x) ?? o3.x, (a3 == null ? void 0 : a3.y) ?? o3.y, o3.x, o3.y) : ((t5, e3) => {
            h2.push(["L", t5, e3]);
        })(o3.x, o3.y), y2 && f3) {
            const { nextTangent: t5, preHandle: e3, nextHandle: i3 } = f3;
            c2(e3.x, e3.y, i3.x, i3.y, t5.x, t5.y);
        }
    }
    return e && (f2(o2 - 1, 0), h2.push(["Z"])), h2;
}
function Si(t4, e, i) {
    const s = t4.m00 * e.m00 + t4.m01 * e.m10, r = t4.m10 * e.m00 + t4.m11 * e.m10, n2 = t4.m00 * e.m01 + t4.m01 * e.m11, o2 = t4.m10 * e.m01 + t4.m11 * e.m11, a2 = t4.m00 * e.m02 + t4.m01 * e.m12 + t4.m02, h2 = t4.m10 * e.m02 + t4.m11 * e.m12 + t4.m12;
    i.m00 = s, i.m01 = n2, i.m02 = a2, i.m10 = r, i.m11 = o2, i.m12 = h2;
}
const Ci = new we();
function Ti(t4, e, i, s, r, n2) {
    return Ci.m00 = t4, Ci.m01 = i, Ci.m02 = r, Ci.m10 = e, Ci.m11 = s, Ci.m12 = n2, Ci;
}
const _Ii = class _Ii extends we {
    toMatrix() {
        const t4 = this;
        return new o(t4.m00, t4.m10, t4.m01, t4.m11, t4.m02, t4.m12);
    }
    get translateX() {
        return this.m02;
    }
    set translateX(t4) {
        this.m02 = t4;
    }
    get translateY() {
        return this.m12;
    }
    set translateY(t4) {
        this.m12 = t4;
    }
    equals(t4) {
        return Math.abs(this.m00 - t4.m00) <= We && Math.abs(this.m01 - t4.m01) <= We && Math.abs(this.m02 - t4.m02) <= We && Math.abs(this.m10 - t4.m10) <= We && Math.abs(this.m11 - t4.m11) <= We && Math.abs(this.m12 - t4.m12) <= We;
    }
    reset(t4) {
        t4 ? (this.m00 = t4.m00, this.m01 = t4.m01, this.m02 = t4.m02, this.m10 = t4.m10, this.m11 = t4.m11, this.m12 = t4.m12) : (this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m10 = 0, this.m11 = 1, this.m12 = 0);
    }
    clone() {
        const t4 = this;
        return new _Ii(t4.m00, t4.m01, t4.m02, t4.m10, t4.m11, t4.m12);
    }
    multiAtLeft(t4) {
        Si(t4, this, this);
    }
    multi(t4) {
        Si(this, t4, this);
    }
    trans(t4, e) {
        this.multiAtLeft(Ti(1, 0, 0, 1, t4, e));
    }
    preTrans(t4, e) {
        this.multi(Ti(1, 0, 0, 1, t4, e));
    }
    transTo(t4, e) {
        const i = this.computeCoord(0, 0), s = t4 - i.x, r = e - i.y;
        this.trans(s, r);
    }
    scale(t4, e) {
        this.multiAtLeft(Ti(t4, 0, 0, e ?? t4, 0, 0));
    }
    preScale(t4, e) {
        this.multi(Ti(t4, 0, 0, e ?? t4, 0, 0));
    }
    skewX(t4) {
        this.multiAtLeft(Ti(1, 0, Math.tan(t4), 1, 0, 0));
    }
    scaleX(t4) {
        this.multiAtLeft(Ti(t4, 0, 0, 1, 0, 0));
    }
    scaleY(t4) {
        this.multiAtLeft(Ti(1, 0, 0, t4, 0, 0));
    }
    rotate(t4, e, i) {
        (e || i) && this.trans(-(e || 0), -(i || 0));
        const s = Math.cos(t4), r = Math.sin(t4);
        this.multiAtLeft(Ti(s, r, -r, s, 0, 0)), (e || i) && this.trans(e || 0, i || 0);
    }
    computeCoord(t4, e) {
        const i = "object" == typeof t4, s = i ? t4.x : t4, r = i ? t4.y : e;
        return { x: this.m00 * s + this.m01 * r + this.m02, y: this.m10 * s + this.m11 * r + this.m12 };
    }
    computeCoord2(t4, e) {
        return { x: this.m00 * t4 + this.m01 * e + this.m02, y: this.m10 * t4 + this.m11 * e + this.m12 };
    }
    computeCoord3(t4) {
        const e = t4.x, i = t4.y;
        return { x: this.m00 * e + this.m01 * i + this.m02, y: this.m10 * e + this.m11 * i + this.m12 };
    }
    computeRef(t4, e) {
        return { x: this.m00 * t4 + this.m01 * e, y: this.m10 * t4 + this.m11 * e };
    }
    get inverse() {
        const t4 = [this.m00, this.m10, this.m01, this.m11, this.m02, this.m12], e = t4[0] * t4[3] - t4[1] * t4[2];
        return _Ii.from([t4[3] / e, -t4[1] / e, -t4[2] / e, t4[0] / e, (t4[2] * t4[5] - t4[4] * t4[3]) / e, (t4[1] * t4[4] - t4[5] * t4[0]) / e]);
    }
    inverseCoord(t4, e) {
        const i = "object" == typeof t4, s = i ? t4.x : t4, r = i ? t4.y : e, n2 = this.inverse;
        return { x: n2.m00 * s + n2.m01 * r + n2.m02, y: n2.m10 * s + n2.m11 * r + n2.m12 };
    }
    inverseRef(t4, e) {
        const i = this.inverse;
        return { x: i.m00 * t4 + i.m01 * e, y: i.m10 * t4 + i.m11 * e };
    }
    toString() {
        return "matrix(" + this.toArray().join(",") + ")";
    }
    toArray() {
        return [this.m00, this.m10, this.m01, this.m11, this.m02, this.m12];
    }
    flipVert(t4) {
        t4 && this.trans(0, -t4), this.multiAtLeft(Ti(1, 0, 0, -1, 0, 0)), t4 && this.trans(0, t4);
    }
    flipHoriz(t4) {
        t4 && this.trans(-t4, 0), this.multiAtLeft(Ti(-1, 0, 0, 1, 0, 0)), t4 && this.trans(t4, 0);
    }
    get identity() {
        return _Ii.from([1, 0, 0, 1, 0, 0]);
    }
    isIdentity() {
        const t4 = [1, 0, 0, 1, 0, 0], e = this.toArray();
        for (let i = 0, s = e.length; i < s; i++) if (Math.abs(e[i] - t4[i]) > We) return false;
        return true;
    }
    isValid() {
        const t4 = this.toArray();
        for (let e = 0, i = t4.length; e < i; e++) {
            const i2 = t4[e];
            if (Number.isNaN(i2) || !Number.isFinite(i2)) return false;
        }
        return true;
    }
    checkValid() {
        if (!this.isValid()) throw new Error("Wrong Matrix: " + this.toString());
    }
};
__publicField(_Ii, "from", function(t4) {
    return Array.isArray(t4) ? new _Ii(t4[0], t4[2], t4[4], t4[1], t4[3], t4[5]) : new _Ii(t4.m00, t4.m01, t4.m02, t4.m10, t4.m11, t4.m12);
});
let Ii = _Ii;
function ki(t4) {
    return new P({ matrix: new C$1([4, 4], [t4.m00, t4.m01, 0, t4.m02, t4.m10, t4.m11, 0, t4.m12, 0, 0, 1, 0, 0, 0, 0, 1], true) });
}
function Ei(t4) {
    return new Ii(t4.m00, t4.m01, t4.m03, t4.m10, t4.m11, t4.m13);
}
function Fi(t4, e) {
    t4.m00 = e.m00, t4.m10 = e.m10, t4.m01 = e.m01, t4.m11 = e.m11, t4.m02 = e.m03, t4.m12 = e.m13;
}
class Ri extends X {
    constructor(t4, e, i, s) {
        super();
        __publicField(this, "typeId", "variable");
        __publicField(this, "id");
        __publicField(this, "type");
        __publicField(this, "name");
        __publicField(this, "value");
        this.id = t4, this.type = e, this.name = i, this.value = s;
    }
}
class Oi extends X {
    constructor(t4, e, i, s, r, n2) {
        super();
        __publicField(this, "__watcher", /* @__PURE__ */ new Set());
        __publicField(this, "__bubblewatcher", /* @__PURE__ */ new Set());
        __publicField(this, "typeId", "shape");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "type");
        __publicField(this, "style");
        __publicField(this, "transform");
        __publicField(this, "boolOp");
        __publicField(this, "isFixedToViewport");
        __publicField(this, "isLocked");
        __publicField(this, "isVisible");
        __publicField(this, "exportOptions");
        __publicField(this, "name");
        __publicField(this, "nameIsFixed");
        __publicField(this, "resizingConstraint");
        __publicField(this, "resizingType");
        __publicField(this, "constrainerProportions");
        __publicField(this, "clippingMaskMode");
        __publicField(this, "hasClippingMask");
        __publicField(this, "shouldBreakMaskChain");
        __publicField(this, "varbinds");
        __publicField(this, "haveEdit");
        __publicField(this, "prototypeStartingPoint");
        __publicField(this, "prototypeInteractions");
        __publicField(this, "overlayPosition");
        __publicField(this, "overlayBackgroundInteraction");
        __publicField(this, "overlayBackgroundAppearance");
        __publicField(this, "scrollDirection");
        __publicField(this, "mask");
        this.crdtidx = t4, this.id = e, this.name = i, this.type = s, this.transform = r, this.style = n2;
    }
    watch(t4) {
        return this.__watcher.add(t4), () => {
            this.__watcher.delete(t4);
        };
    }
    unwatch(t4) {
        return this.__watcher.delete(t4);
    }
    notify(...t4) {
        var _a2;
        this.__watcher.size > 0 && Array.from(this.__watcher).forEach((e) => {
            e(...t4);
        }), (_a2 = this.parent) == null ? void 0 : _a2.bubblenotify(...t4);
    }
    bubblewatch(t4) {
        return this.__bubblewatcher.add(t4), () => {
            this.__bubblewatcher.delete(t4);
        };
    }
    bubbleunwatch(t4) {
        return this.__bubblewatcher.delete(t4);
    }
    bubblenotify(...t4) {
        var _a2;
        this.__bubblewatcher.size > 0 && Array.from(this.__bubblewatcher).forEach((e) => {
            e(...t4);
        }), (_a2 = this.parent) == null ? void 0 : _a2.bubblenotify(...t4);
    }
    getCrdtPath() {
        const t4 = this.getPage();
        return t4 && t4 !== this ? [t4.id, this.id] : [this.id];
    }
    getOpTarget(t4) {
        const e = t4[0];
        return "style" === e ? this.style.getOpTarget(t4.slice(1)) : ("varbinds" !== e || this.varbinds || (this.varbinds = new Y()), "exportOptions" !== e || this.exportOptions || (this.exportOptions = new Ie(new G(), 0, false, false, false, false)), "prototypeInteractions" !== e || this.prototypeInteractions || (this.prototypeInteractions = new G()), "overlayPosition" !== e || this.overlayPosition || (this.overlayPosition = new he(kt.CENTER, new ae())), "overlayBackgroundAppearance" !== e || this.overlayBackgroundAppearance || (this.overlayBackgroundAppearance = new ke(It.SOLIDCOLOR, new te(0.25, 0, 0, 0))), super.getOpTarget(t4));
    }
    get naviChilds() {
    }
    get isVirtualShape() {
        return false;
    }
    get isSymbolShape() {
        return false;
    }
    get rotation() {
        return 180 * ki(this.transform).decomposeEuler().z / Math.PI;
    }
    get x() {
        return this.transform.m02;
    }
    set x(t4) {
        this.transform.m02 = t4;
    }
    get y() {
        return this.transform.m12;
    }
    set y(t4) {
        this.transform.m12 = t4;
    }
    get size() {
        return new ye();
    }
    set size(t4) {
    }
    get frame() {
        const { width: t4, height: e } = this.size;
        return new _e(0, 0, t4, e);
    }
    hasSize() {
        return false;
    }
    getPathOfSize(t4, e) {
        return new pi();
    }
    getPath(t4) {
        return this.getPathOfSize(this.frame, t4);
    }
    getPathStr(t4) {
        return this.getPath(t4).toString();
    }
    getPage() {
        let t4 = this;
        for (; t4 && t4.type !== Vt.Page; ) t4 = t4.parent;
        return t4;
    }
    get parent() {
        let t4 = this.__parent;
        for (; t4 && !(t4 instanceof Oi); ) t4 = t4.parent;
        return t4;
    }
    realXY() {
        return this.frame2Root();
    }
    frame2Root() {
        const t4 = this.frame, e = this.matrix2Root(), i = e.computeCoord(t4.x, t4.y), s = e.computeCoord(t4.x + t4.width, t4.y + t4.height);
        return new _e(i.x, i.y, s.x - i.x, s.y - i.y);
    }
    frame2Parent() {
        const t4 = this.frame;
        if (this.isNoTransform()) return new _e(this.transform.m02 + t4.x, this.transform.m12 + t4.y, t4.width, t4.height);
        const e = this.transform, i = e.computeCoord(t4.x, t4.y), s = e.computeCoord(t4.x + t4.width, t4.y + t4.height);
        return new _e(i.x, i.y, s.x - i.x, s.y - i.y);
    }
    matrix2Root() {
        let t4 = this;
        const e = new o();
        for (; t4; ) t4.matrix2Parent(e), t4 = t4.parent;
        return e;
    }
    isNoTransform() {
        const t4 = this.transform;
        return 1 == t4.m00 && 0 === t4.m01 && 0 === t4.m10 && 1 === t4.m11;
    }
    matrix2Parent(t4) {
        const e = this.transform.toMatrix();
        return t4 ? (t4.multiAtLeft(e), t4) : e;
    }
    boundingBox() {
        if (this.isNoTransform()) {
            const t5 = this.transform, e2 = this.frame;
            return new _e(t5.translateX, t5.translateY, e2.width, e2.height);
        }
        const t4 = this.getPath();
        if (t4.length > 0) {
            const e2 = this.transform;
            t4.transform(e2);
            const i2 = t4.calcBounds();
            return new _e(i2.minX, i2.minY, i2.maxX - i2.minX, i2.maxY - i2.minY);
        }
        const e = this.frame, i = this.transform, s = [{ x: e.x, y: e.y }, { x: e.x + e.width, y: e.y }, { x: e.x + e.width, y: e.y + e.height }, { x: e.x, y: e.y + e.height }].map((t5) => i.computeCoord(t5)), r = s.reduce((t5, e2) => Math.min(t5, e2.x), s[0].x), n2 = s.reduce((t5, e2) => Math.max(t5, e2.x), s[0].x), o2 = s.reduce((t5, e2) => Math.min(t5, e2.y), s[0].y), a2 = s.reduce((t5, e2) => Math.max(t5, e2.y), s[0].y);
        return new _e(r, o2, n2 - r, a2 - o2);
    }
    boundingBox2() {
        const t4 = this.frame, e = this.transform, i = [{ x: t4.x, y: t4.y }, { x: t4.x + t4.width, y: t4.y }, { x: t4.x + t4.width, y: t4.y + t4.height }, { x: t4.x, y: t4.y + t4.height }].map((t5) => e.computeCoord(t5)), s = i.reduce((t5, e2) => Math.min(t5, e2.x), i[0].x), r = i.reduce((t5, e2) => Math.max(t5, e2.x), i[0].x), n2 = i.reduce((t5, e2) => Math.min(t5, e2.y), i[0].y), o2 = i.reduce((t5, e2) => Math.max(t5, e2.y), i[0].y);
        return new _e(s, n2, r - s, o2 - n2);
    }
    boundingBox3() {
        const t4 = this.getPath();
        if (t4.length > 0) {
            const e = t4.calcBounds();
            return new _e(e.minX, e.minY, e.maxX - e.minX, e.maxY - e.minY);
        }
    }
    findVar(t4, e) {
        var _a2;
        (_a2 = this.parent) == null ? void 0 : _a2.findVar(t4, e);
    }
    getVisible() {
        if (!this.varbinds) return !!this.isVisible;
        if (this.isVirtualShape) return !!this.isVisible;
        const t4 = this.varbinds.get(Et.Visible);
        if (!t4) return !!this.isVisible;
        const e = [];
        this.findVar(t4, e);
        const i = e[e.length - 1];
        return i && i.type === jt.Visible ? !!i.value : !!this.isVisible;
    }
    onAdded() {
    }
    onRemoved() {
    }
    getFills() {
        return this.style.fills;
    }
    getBorders() {
        return this.style.borders;
    }
    getShadows() {
        return this.style.shadows;
    }
    get isContainer() {
        return false;
    }
    get pathType() {
        return Ve.Editable;
    }
    get isPathIcon() {
        return true;
    }
    get radius() {
        return [0];
    }
    get radiusType() {
        return De.None;
    }
    get isClosed() {
        return true;
    }
    get isStraight() {
        return false;
    }
    get isImageFill() {
        return this.getFills().some((t4) => t4.fillType === xt.Pattern);
    }
}
class Li extends Oi {
    constructor(t4, e, i, s, r, n2, o2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "typeId", "group-shape");
        __publicField(this, "childs");
        __publicField(this, "fixedRadius");
        this.childs = o2;
    }
    get naviChilds() {
        return this.childs;
    }
    removeChild(t4) {
        const e = this.indexOfChild(t4);
        return e >= 0 && this.childs.splice(e, 1), e >= 0;
    }
    removeChildAt(t4) {
        if (t4 >= 0) {
            const e = this.childs.splice(t4, 1);
            if (e.length > 0) return e[0];
        }
    }
    addChild(t4) {
        this.childs.push(t4);
    }
    addChildAt(t4, e) {
        if (e && e > this.childs.length) throw new Error("add child at outside index: " + e + " , childs length: " + this.childs.length);
        const i = e ?? this.childs.length;
        return this.childs.splice(i, 0, t4), this.childs[i];
    }
    indexOfChild(t4) {
        return this.childs.findIndex((e) => e.id == t4.id);
    }
    findChildById(t4) {
        return this.childs.find((e) => {
            if (e.id == t4) return e;
        });
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        return new pi([["M", 0, 0], ["l", i, 0], ["l", 0, s], ["l", -i, 0], ["z"]]);
    }
    get pathType() {
        return Ve.Fixed;
    }
    get isPathIcon() {
        return false;
    }
    get radiusType() {
        return De.Fixed;
    }
    get isImageFill() {
        return false;
    }
    get size() {
        return this.frame;
    }
    set size(t4) {
    }
    get frame() {
        const t4 = this.childs.map((t5) => t5.frame2Parent()).reduce((t5, e2, i2) => (0 === i2 ? (t5.minx = e2.x, t5.maxx = e2.x + e2.width, t5.miny = e2.y, t5.maxy = e2.y + e2.height) : (t5.minx = Math.min(t5.minx, e2.x), t5.maxx = Math.max(t5.maxx, e2.x + e2.width), t5.miny = Math.min(t5.miny, e2.y), t5.maxy = Math.max(t5.maxy, e2.y + e2.height)), t5), { minx: 0, miny: 0, maxx: 0, maxy: 0 }), { minx: e, miny: i, maxx: s, maxy: r } = t4;
        return new _e(e, i, s - e, r - i);
    }
}
class Pi extends Li {
    constructor(t4, e, i, s, r, n2, o2) {
        super(t4, e, i, Vt.BoolShape, r, n2, o2);
        __publicField(this, "typeId", "bool-shape");
    }
    getBoolOp() {
        if (0 === this.childs.length) return { op: at.None };
        const t4 = this.childs, e = t4[0].boolOp ?? at.None;
        for (let i = 1, s = t4.length; i < s; i++) {
            if ((t4[i].boolOp ?? at.None) !== e) return { op: e, isMulti: true };
        }
        return { op: e };
    }
    get isPathIcon() {
        return true;
    }
    get isImageFill() {
        return this.style.getFills().some((t4) => t4.fillType === xt.Pattern);
    }
}
function Bi(t4, e, i) {
    const s = t4.width, r = t4.height;
    if (!(i || e && (e.lt > 0 || e.lb > 0 || e.rb > 0 || e.rt > 0))) {
        return new pi([["M", 0, 0], ["l", s, 0], ["l", 0, r], ["l", -s, 0], ["z"]]);
    }
    const n2 = Math.min(s / 2, r / 2);
    let o2, a2, h2, c2;
    i ? (i = Math.min(i, n2), o2 = a2 = h2 = c2 = i = Math.max(0, i)) : (o2 = e.lt, a2 = e.lb, h2 = e.rt, c2 = e.rb, o2 = Math.max(0, Math.min(o2, n2)), a2 = Math.max(0, Math.min(a2, n2)), h2 = Math.max(0, Math.min(h2, n2)), c2 = Math.max(0, Math.min(c2, n2)));
    const l2 = new se([], "", 0, 0, ft.Straight), d2 = new se([], "", 1, 0, ft.Straight), p2 = new se([], "", 1, 1, ft.Straight), u = new se([], "", 0, 1, ft.Straight);
    return o2 > 0 && (l2.radius = o2), h2 > 0 && (d2.radius = h2), c2 > 0 && (p2.radius = c2), a2 > 0 && (u.radius = a2), new pi(vi(new G(l2, d2, p2, u), true, s, r, i));
}
class Ni extends Li {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2) {
        super(t4, e, i, s, r, n2, o2);
        __publicField(this, "typeId", "symbol-shape");
        __publicField(this, "size");
        __publicField(this, "variables");
        __publicField(this, "symtags");
        __publicField(this, "cornerRadius");
        __publicField(this, "guides");
        this.size = a2, this.variables = h2, this.guides = c2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getOpTarget(t4) {
        const e = t4[0];
        return "symtags" !== e || this.symtags || (this.symtags = new Y()), "cornerRadius" !== e || this.cornerRadius || (this.cornerRadius = new ie(0, 0, 0, 0)), "guides" !== e || this.guides || (this.guides = new G()), super.getOpTarget(t4);
    }
    addVar(t4) {
        return this.variables || (this.variables = new Y()), this.variables.set(t4.id, t4), this.variables.get(t4.id);
    }
    removeVar(t4) {
        return !!this.variables && this.variables.delete(t4);
    }
    deleteVar(t4) {
        this.variables && this.variables.delete(t4);
    }
    getVar(t4) {
        return this.variables && this.variables.get(t4);
    }
    setTag(t4, e) {
        this.symtags || (this.symtags = new Y()), this.symtags.set(t4, e);
    }
    get isSymbolUnionShape() {
        return false;
    }
    get isSymbolShape() {
        return true;
    }
    get isContainer() {
        return true;
    }
    getPathOfSize(t4, e) {
        return Bi(t4, this.cornerRadius, e);
    }
    get radius() {
        var _a2, _b, _c2, _d2;
        return [((_a2 = this.cornerRadius) == null ? void 0 : _a2.lt) || 0, ((_b = this.cornerRadius) == null ? void 0 : _b.rt) || 0, ((_c2 = this.cornerRadius) == null ? void 0 : _c2.rb) || 0, ((_d2 = this.cornerRadius) == null ? void 0 : _d2.lb) || 0];
    }
    get radiusType() {
        return De.Rect;
    }
}
__publicField(Ni, "Default_State", "49751e86-9b2c-4d1b-81b0-36f19b5407d2");
class zi extends Ni {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2, a2, h2);
        __publicField(this, "typeId", "symbol-union-shape");
    }
    get isSymbolUnionShape() {
        return true;
    }
    get isContainer() {
        return true;
    }
}
class Vi extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "typeId", "path-shape");
        __publicField(this, "size");
        __publicField(this, "pathsegs");
        __publicField(this, "fixedRadius");
        this.size = o2, this.pathsegs = a2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        e = this.fixedRadius ?? e;
        const r = [];
        return this.pathsegs.forEach((t5) => {
            r.push(...vi(t5.points, t5.isClosed, i, s, e));
        }), new pi(r);
    }
    get radius() {
        return this.pathsegs.reduce((t4, e) => e.points.reduce((t5, e2) => (t5.push(e2.radius || 0), t5), t4), []);
    }
    get radiusType() {
        return De.Fixed;
    }
    get isStraight() {
        if (1 !== this.pathsegs.length) return false;
        const t4 = this.pathsegs[0].points;
        if (2 !== t4.length) return false;
        const e = t4[0], i = t4[1];
        return !e.hasFrom && !i.hasTo;
    }
}
class Di extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "typeId", "path-shape2");
        __publicField(this, "size");
        __publicField(this, "pathsegs");
        __publicField(this, "fixedRadius");
        this.size = o2, this.pathsegs = a2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        e = this.fixedRadius ?? e;
        const r = [];
        return this.pathsegs.forEach((t5) => {
            r.push(...vi(t5.points, t5.isClosed, i, s, e));
        }), new pi(r);
    }
    get radius() {
        return this.pathsegs.reduce((t4, e) => e.points.reduce((t5, e2) => (t5.push(e2.radius || 0), t5), t4), []);
    }
    get pathType() {
        return Ve.Editable;
    }
    get radiusType() {
        return 1 === this.pathsegs.length && 4 === this.pathsegs[0].points.length && this.pathsegs[0].isClosed ? De.Rect : De.Fixed;
    }
}
class Hi extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "rect-shape");
    }
    get radiusType() {
        return this.haveEdit ? De.Fixed : De.Rect;
    }
}
class Wi extends Hi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "image-shape");
        __publicField(this, "imageRef");
        __publicField(this, "__imageMgr");
        __publicField(this, "__cacheData");
        __publicField(this, "__startLoad", false);
        this.imageRef = h2;
    }
    setImageMgr(t4) {
        this.__imageMgr = t4;
    }
    peekImage(t4 = false) {
        var _a2;
        const e = (_a2 = this.__cacheData) == null ? void 0 : _a2.base64;
        return e || (this.imageRef ? (t4 && !this.__startLoad && (this.__startLoad = true, this.__imageMgr && this.__imageMgr.get(this.imageRef).then((t5) => {
            this.__cacheData || (this.__cacheData = t5, t5 && this.notify());
        })), e) : "");
    }
    async loadImage() {
        return this.__cacheData ? this.__cacheData.base64 : (this.__cacheData = this.__imageMgr && await this.__imageMgr.get(this.imageRef), this.__cacheData && this.notify(), this.__cacheData && this.__cacheData.base64 || "");
    }
    get isPathIcon() {
        return false;
    }
    get isImageFill() {
        return true;
    }
}
class $i extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "oval-shape");
        __publicField(this, "ellipse");
        this.ellipse = h2;
    }
}
class Xi extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "line-shape");
    }
    get isStraight() {
        return !this.haveEdit;
    }
}
class Gi extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "typeId", "text-shape");
        __publicField(this, "size");
        __publicField(this, "text");
        __publicField(this, "fixedRadius");
        this.size = o2, this.text = a2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getOpTarget(t4) {
        return 0 === t4.length ? this : "text" === t4[0] ? this.text.getOpTarget(t4.slice(1)) : super.getOpTarget(t4);
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        if (e = this.fixedRadius ?? e) {
            const t5 = vi(ze, true, i, s, e);
            return new pi(t5);
        }
        return new pi([["M", 0, 0], ["l", i, 0], ["l", 0, s], ["l", -i, 0], ["z"]]);
    }
    getLayout() {
        return this.text.getLayout2(this.size);
    }
    get pathType() {
        return Ve.Fixed;
    }
    get isPathIcon() {
        return false;
    }
    get isImageFill() {
        return false;
    }
}
class Yi extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "cutout-shape");
        __publicField(this, "exportOptions");
        this.exportOptions = h2;
    }
    get pathType() {
        return Ve.Fixed;
    }
    get isPathIcon() {
        return false;
    }
    get radiusType() {
        return De.None;
    }
    get isImageFill() {
        return false;
    }
}
class Ui extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "polygon-shape");
        __publicField(this, "counts");
        this.counts = h2;
    }
}
class Zi extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "star-shape");
        __publicField(this, "counts");
        __publicField(this, "innerAngle");
        this.counts = h2, this.innerAngle = c2;
    }
}
class ji extends Li {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2) {
        super(t4, e, i, Vt.Artboard, r, n2, o2);
        __publicField(this, "typeId", "artboard");
        __publicField(this, "size");
        __publicField(this, "cornerRadius");
        __publicField(this, "haveEdit");
        __publicField(this, "guides");
        this.size = a2, this.haveEdit = h2, this.guides = c2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getOpTarget(t4) {
        const e = t4[0];
        return "cornerRadius" !== e || this.cornerRadius || (this.cornerRadius = new ie(0, 0, 0, 0)), "guides" !== e || this.guides || (this.guides = new G()), super.getOpTarget(t4);
    }
    getPath(t4) {
        return this.getPathOfSize(this.size, t4);
    }
    getPathOfSize(t4, e) {
        return Bi(t4, this.cornerRadius, e);
    }
    get isContainer() {
        return true;
    }
    get radius() {
        var _a2, _b, _c2, _d2;
        return [((_a2 = this.cornerRadius) == null ? void 0 : _a2.lt) || 0, ((_b = this.cornerRadius) == null ? void 0 : _b.rt) || 0, ((_c2 = this.cornerRadius) == null ? void 0 : _c2.rb) || 0, ((_d2 = this.cornerRadius) == null ? void 0 : _d2.lb) || 0];
    }
    get radiusType() {
        return De.Rect;
    }
}
const _Ji = class _Ji extends te {
    toRGBA() {
        return "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
    }
    toRGB() {
        return "rgb(" + this.red + "," + this.green + "," + this.blue + ")";
    }
    toHex() {
        const t4 = (t5) => 1 === t5.toString(16).toUpperCase().length ? `0${t5.toString(16).toUpperCase()}` : t5.toString(16).toUpperCase();
        return "#" + t4(this.red) + t4(this.green) + t4(this.blue);
    }
    equals(t4) {
        return this.alpha === t4.alpha && this.blue === t4.blue && this.green === t4.green && this.red === t4.red;
    }
    clone() {
        return new _Ji(this.alpha, this.red, this.green, this.blue);
    }
};
__publicField(_Ji, "DefaultColor", new _Ji(0, 0, 0, 0));
let Ji = _Ji;
class Ki extends U {
    constructor() {
        super();
    }
}
class qi extends Li {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, Vt.Page, r, n2, o2);
        __publicField(this, "typeId", "page");
        __publicField(this, "backgroundColor");
        __publicField(this, "artboards", /* @__PURE__ */ new Map());
        __publicField(this, "shapes", /* @__PURE__ */ new Map());
        __publicField(this, "__allshapes", /* @__PURE__ */ new Map());
        __publicField(this, "__collect", new Ki());
        __publicField(this, "__symbolshapes", /* @__PURE__ */ new Map());
        __publicField(this, "isReserveLib");
        __publicField(this, "cutouts", /* @__PURE__ */ new Map());
        __publicField(this, "guides");
        o2.forEach((t5) => this.onAddShape(t5)), this.isReserveLib = !!a2, this.guides = h2;
    }
    getOpTarget(t4) {
        if (0 === t4.length) throw new Error("path is empty");
        const e = t4[0];
        if (1 === t4.length) {
            if (e === this.id) return this;
            throw new Error("The shape is not found");
        }
        const i = t4[1], s = this.getShape(i, true);
        return s ? s.getOpTarget(t4.slice(2)) : ("guides" !== i || this.guides || (this.guides = new G()), super.getOpTarget(t4.slice(1)));
    }
    onAddShape(t4, e = true) {
        if (this.shapes.has(t4.id)) throw new Error("The same shape id already exists");
        if (this.shapes.set(t4.id, t4), this.__allshapes.set(t4.id, new WeakRef(t4)), t4.type === Vt.Artboard && this.artboards.set(t4.id, t4), t4.type === Vt.Symbol && this.__symbolshapes.set(t4.id, t4), t4.type === Vt.Cutout && this.cutouts.set(t4.id, t4), t4.onAdded(), e && t4 instanceof Li) {
            t4.childs.forEach((t5) => this.onAddShape(t5));
        }
    }
    onRemoveShape(t4, e = true) {
        if (this.shapes.delete(t4.id), t4.type === Vt.Artboard && this.artboards.delete(t4.id), t4.type === Vt.Symbol && this.__symbolshapes.delete(t4.id), t4.type === Vt.Cutout && this.cutouts.delete(t4.id), t4.onRemoved(), e && t4 instanceof Li) {
            t4.childs.forEach((t5) => this.onRemoveShape(t5));
        }
    }
    getShape(t4, e) {
        let i;
        if (e) {
            if (i = this.shapes.get(t4), !i) {
                const e2 = this.__allshapes.get(t4);
                i = e2 == null ? void 0 : e2.deref();
            }
        } else i = this.shapes.get(t4);
        return i || t4 !== this.id || (i = this), i;
    }
    get artboardList() {
        return Array.from(this.artboards.values());
    }
    getUsedFontNames(t4) {
        const e = t4 ?? /* @__PURE__ */ new Set(), i = [this];
        for (; i.length > 0; ) {
            const t5 = i.pop();
            t5 instanceof Li ? i.push(...t5.childs) : (t5 instanceof Gi || t5 instanceof ka) && t5.text && t5.text.getUsedFontNames(e);
        }
        return e;
    }
    get cutoutList() {
        return Array.from(this.cutouts.values());
    }
    get isContainer() {
        return true;
    }
}
__publicField(qi, "defaultBGColor", new Ji(1, 239, 239, 239));
class Qi extends X {
    constructor(t4, e, i, s, r, n2) {
        super();
        __publicField(this, "typeId", "gradient");
        __publicField(this, "elipseLength");
        __publicField(this, "from");
        __publicField(this, "to");
        __publicField(this, "stops");
        __publicField(this, "gradientType");
        __publicField(this, "gradientOpacity");
        this.from = t4, this.to = e, this.gradientType = i, this.stops = s, this.elipseLength = r, this.gradientOpacity = n2;
    }
}
class ts extends X {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2) {
        super();
        __publicField(this, "typeId", "border");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "isEnabled");
        __publicField(this, "fillType");
        __publicField(this, "color");
        __publicField(this, "contextSettings");
        __publicField(this, "position");
        __publicField(this, "thickness");
        __publicField(this, "gradient");
        __publicField(this, "borderStyle");
        __publicField(this, "cornerType");
        __publicField(this, "sideSetting");
        __publicField(this, "imageRef");
        __publicField(this, "imageScaleMode");
        __publicField(this, "rotation");
        __publicField(this, "scale");
        __publicField(this, "originalImageWidth");
        __publicField(this, "originalImageHeight");
        __publicField(this, "paintFilter");
        __publicField(this, "transform");
        __publicField(this, "__imageMgr");
        __publicField(this, "__cacheData");
        this.crdtidx = t4, this.id = e, this.isEnabled = i, this.fillType = s, this.color = r, this.position = n2, this.thickness = o2, this.borderStyle = a2, this.cornerType = h2, this.sideSetting = c2;
    }
    setImageMgr(t4) {
        this.__imageMgr = t4;
    }
    getImageMgr() {
        return this.__imageMgr;
    }
    async loadImage() {
        if (this.__cacheData) return this.__cacheData.media.base64;
        if (!this.imageRef) return "";
        const t4 = this.__imageMgr, e = t4 && await t4.get(this.imageRef);
        return e && (this.__cacheData = { media: e, ref: this.imageRef }, this.notify()), this.__cacheData && this.__cacheData.media.base64 || "";
    }
}
class es extends X {
    constructor(t4, e, i, s, r) {
        super();
        __publicField(this, "typeId", "fill");
        __publicField(this, "crdtidx");
        __publicField(this, "id");
        __publicField(this, "isEnabled");
        __publicField(this, "fillType");
        __publicField(this, "color");
        __publicField(this, "contextSettings");
        __publicField(this, "gradient");
        __publicField(this, "imageRef");
        __publicField(this, "fillRule");
        __publicField(this, "imageScaleMode");
        __publicField(this, "rotation");
        __publicField(this, "scale");
        __publicField(this, "originalImageWidth");
        __publicField(this, "originalImageHeight");
        __publicField(this, "paintFilter");
        __publicField(this, "transform");
        __publicField(this, "__imageMgr");
        __publicField(this, "__cacheData");
        __publicField(this, "__startLoad", false);
        __publicField(this, "__is_editing_image", false);
        this.crdtidx = t4, this.id = e, this.isEnabled = i, this.fillType = s, this.color = r;
    }
    setImageMgr(t4) {
        this.__imageMgr = t4;
    }
    getImageMgr() {
        return this.__imageMgr;
    }
    peekImage(t4 = false) {
        var _a2, _b;
        if (((_a2 = this.__cacheData) == null ? void 0 : _a2.ref) === this.imageRef) return (_b = this.__cacheData) == null ? void 0 : _b.media.base64;
        if (!this.imageRef) return "";
        if (t4 && !this.__startLoad) {
            this.__startLoad = true;
            const t5 = this.__imageMgr;
            t5 && t5.get(this.imageRef).then((t6) => {
                t6 && (this.__cacheData = { media: t6, ref: this.imageRef });
            }).finally(() => {
                var _a3;
                return this.__startLoad = false, this.notify("image-reload"), (_a3 = this.__cacheData) == null ? void 0 : _a3.media.base64;
            });
        }
    }
    reloadImage() {
        this.__cacheData = void 0, this.peekImage();
    }
    async loadImage() {
        if (this.__cacheData) return this.__cacheData.media.base64;
        if (!this.imageRef) return "";
        const t4 = this.__imageMgr, e = t4 && await t4.get(this.imageRef);
        return e && (this.__cacheData = { media: e, ref: this.imageRef }, this.notify()), this.__cacheData && this.__cacheData.media.base64 || "";
    }
    startEditImage(t4) {
        this.__is_editing_image = t4, this.notify();
    }
    get isEditingImage() {
        return this.__is_editing_image;
    }
}
class is extends X {
    constructor(t4, e, i) {
        super();
        __publicField(this, "typeId", "style");
        __publicField(this, "miterLimit");
        __publicField(this, "windingRule");
        __publicField(this, "blur");
        __publicField(this, "borderOptions");
        __publicField(this, "borders");
        __publicField(this, "colorControls");
        __publicField(this, "contextSettings");
        __publicField(this, "fills");
        __publicField(this, "innerShadows");
        __publicField(this, "shadows");
        __publicField(this, "contacts");
        __publicField(this, "startMarkerType");
        __publicField(this, "endMarkerType");
        __publicField(this, "varbinds");
        this.borders = t4, this.fills = e, this.shadows = i;
    }
    getOpTarget(t4) {
        const e = t4[0];
        return "contacts" !== e || this.contacts || (this.contacts = new G()), "contextSettings" !== e || this.contextSettings || (this.contextSettings = new ee(nt.Normal, 1)), super.getOpTarget(t4);
    }
    findVar(t4, e) {
        var _a2;
        return !!((_a2 = this.__parent) == null ? void 0 : _a2.findVar(t4, e));
    }
    getFills() {
        if (!this.varbinds) return this.fills;
        const t4 = this.varbinds.get(Et.Fills);
        if (!t4) return this.fills;
        const e = [];
        this.findVar(t4, e);
        const i = e[e.length - 1];
        return i && i.type === jt.Fills ? i.value : this.fills;
    }
    getBorders() {
        if (!this.varbinds) return this.borders;
        const t4 = this.varbinds.get(Et.Borders);
        if (!t4) return this.borders;
        const e = [];
        this.findVar(t4, e);
        const i = e[e.length - 1];
        return i && i.type === jt.Borders ? i.value : this.borders;
    }
}
__publicField(is, "DefaultWindingRule", Jt.EvenOdd);
class ss extends X {
    constructor(t4, e, i, s, r, n2) {
        super();
        __publicField(this, "typeId", "blur");
        __publicField(this, "isEnabled");
        __publicField(this, "center");
        __publicField(this, "motionAngle");
        __publicField(this, "radius");
        __publicField(this, "saturation");
        __publicField(this, "type");
        this.isEnabled = t4, this.center = e, this.saturation = i, this.type = s, this.motionAngle = r, this.radius = n2;
    }
}
class rs extends Re {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2, o2);
        __publicField(this, "__watcher", /* @__PURE__ */ new Set());
        __publicField(this, "status");
        this.status = 0, this.parentId = a2, this.rootId = h2;
    }
    watch(t4) {
        return this.__watcher.add(t4), () => {
            this.__watcher.delete(t4);
        };
    }
    unwatch(t4) {
        return this.__watcher.delete(t4);
    }
    notify(...t4) {
        0 !== this.__watcher.size && Array.from(this.__watcher).forEach((e) => {
            e(...t4);
        });
    }
    setStatus(t4) {
        this.status = t4;
    }
}
function ns(t4, e) {
    const i = t4.size;
    let s = e || t4.matrix2Root();
    return s.preScale(i.width, i.height), s = new o(s.inverse), s;
}
function os(t4, e, i) {
    const s = t4.size;
    switch (e) {
        case pt.Top:
            return i.computeCoord2(s.width / 2, 0);
        case pt.Right:
            return i.computeCoord2(s.width, s.height / 2);
        case pt.Bottom:
            return i.computeCoord2(s.width / 2, s.height);
        case pt.Left:
            return i.computeCoord2(0, s.height / 2);
        default:
            return false;
    }
}
function as(t4) {
    const e = t4.parent;
    if (!e) return false;
    const i = e.matrix2Root(), s = t4.boundingBox();
    return { xy1: i.computeCoord2(s.x, s.y), xy2: i.computeCoord2(s.x + s.width, s.y + s.height) };
}
function hs(t4, e, i, s, r) {
    const n2 = { left: s.x, right: r.x, top: s.y, bottom: r.y }, o2 = us.OFFSET;
    n2.left -= o2, n2.right += o2, n2.top -= o2, n2.bottom += o2;
    let a2 = os(t4, e, i);
    if (a2) {
        const t5 = Math.abs(a2.y - n2.top), e2 = Math.abs(a2.x - n2.right), i2 = Math.abs(a2.y - n2.bottom), s2 = Math.abs(a2.x - n2.left);
        let r2 = t5;
        const o3 = { x: a2.x, y: a2.y };
        return a2 = { x: o3.x, y: n2.top }, e2 < r2 && (r2 = e2, a2 = { x: n2.right, y: o3.y }), i2 < r2 && (r2 = i2, a2 = { x: o3.x, y: n2.bottom }), s2 < r2 && (a2 = { x: n2.left, y: o3.y }), a2;
    }
}
function cs(t4) {
    const e = [], i = [];
    for (let s2 = 0; s2 < t4.length; s2++) {
        const r2 = t4[s2];
        e.push(r2.x), i.push(r2.y);
    }
    const s = Math.min(...i), r = Math.max(...i), n2 = Math.min(...e), o2 = Math.max(...e);
    return [{ x: n2, y: s }, { x: o2, y: s }, { x: o2, y: r }, { x: n2, y: r }];
}
function ls(t4, e) {
    return Math.abs(t4 - e) < 1e-5;
}
function ds(t4, e) {
    return (!ls(t4[0].x, t4[1].x) || !ls(e[0].x, e[1].x)) && ((!ls(t4[0].y, t4[1].y) || !ls(e[0].y, e[1].y)) && (ls(t4[0].y, t4[1].y) && ls(e[0].x, e[1].x) ? { x: e[0].x, y: t4[0].y } : ls(t4[0].x, t4[1].x) && ls(e[0].y, e[1].y) ? { x: t4[0].x, y: e[0].y } : void 0));
}
function ps(t4, e) {
    return ls(t4.x, e.x) && ls(t4.y, e.y);
}
const _us = class _us {
    constructor(t4, e, i, s, r) {
        __publicField(this, "startPoint");
        __publicField(this, "endPoint");
        __publicField(this, "pointList");
        __publicField(this, "openList");
        __publicField(this, "closeList");
        __publicField(this, "shapeFrame1");
        __publicField(this, "shapeFrame2");
        this.startPoint = i, this.endPoint = s, this.pointList = r, this.openList = [], this.closeList = [], this.shapeFrame1 = t4, this.shapeFrame2 = e;
    }
    run() {
        for (this.openList = [{ id: v4(), point: this.startPoint, cost: 0, parent: null }], this.closeList = []; this.openList.length; ) {
            const e = this.most_advantageous_point();
            if (ps(e.point, this.endPoint)) return this.best_path(e);
            {
                this.remove_from_openlist(e), this.closeList.push(e);
                const i = this.next_points(e.point, this.pointList);
                for (let s = 0; s < i.length; s++) {
                    const r = i[s];
                    if (!this.is_exist_list(r, this.closeList) && !this.is_exist_list(r, this.openList)) {
                        const i2 = { id: v4(), point: r, parent: e, cost: 0 };
                        this.cost_assessment(i2), this.openList.push(i2);
                    }
                }
            }
        }
        return [];
    }
    run_easy() {
        for (this.openList = [{ id: v4(), point: this.startPoint, cost: 0, parent: null }], this.closeList = []; this.openList.length; ) {
            const e = this.most_advantageous_point();
            if (ps(e.point, this.endPoint)) return this.best_path(e);
            {
                this.remove_from_openlist(e), this.closeList.push(e);
                const i = this.next_points2(e.point, this.pointList);
                for (let s = 0; s < i.length; s++) {
                    const r = i[s];
                    if (!this.is_exist_list(r, this.closeList) && !this.is_exist_list(r, this.openList)) {
                        const i2 = { id: v4(), point: r, parent: e, cost: 0 };
                        this.cost_assessment(i2), this.openList.push(i2);
                    }
                }
            }
        }
        return [];
    }
    most_advantageous_point() {
        let t4 = 1 / 0, e = this.openList[0];
        for (let i = 0, s = this.openList.length; i < s; i++) {
            const s2 = this.openList[i];
            s2.cost < t4 && (e = s2, t4 = s2.cost);
        }
        return e;
    }
    best_path(t4) {
        const e = [t4];
        let i = t4.parent;
        for (; i; ) e.unshift(i), i = i.parent;
        return e.map((t5) => t5.point);
    }
    remove_from_openlist(t4) {
        const e = this.openList.findIndex((e2) => e2.id === t4.id);
        this.openList.splice(e, 1);
    }
    is_exist_list(t4, e) {
        return e.find((e2) => ps(e2.point, t4));
    }
    next_points(t4, e) {
        const { x: i, y: s } = t4, r = [], n2 = [];
        for (let o2 = 0, a2 = e.length; o2 < a2; o2++) {
            const a3 = e[o2];
            ps(t4, a3) || (ls(a3.x, i) && r.push(a3), ls(a3.y, s) && n2.push(a3));
        }
        return [...this.next_point_d(i, s, n2, "x", this.shapeFrame1, this.shapeFrame2), ...this.next_point_d(i, s, r, "y", this.shapeFrame1, this.shapeFrame2)];
    }
    next_points2(t4, e) {
        const { x: i, y: s } = t4, r = [], n2 = [];
        for (let o2 = 0, a2 = e.length; o2 < a2; o2++) {
            const a3 = e[o2];
            ps(t4, a3) || (ls(a3.x, i) && r.push(a3), ls(a3.y, s) && n2.push(a3));
        }
        return [...this.next_point_d2(i, s, n2, "x", this.shapeFrame1, this.shapeFrame2), ...this.next_point_d2(i, s, r, "y", this.shapeFrame1, this.shapeFrame2)];
    }
    is_through(t4, e, i, s) {
        let r = [i, s], n2 = Math.min(t4.x, e.x), o2 = Math.max(t4.x, e.x), a2 = Math.min(t4.y, e.y), h2 = Math.max(t4.y, e.y);
        const c2 = _us.OFFSET - 2;
        if (ls(t4.y, e.y)) for (let t5 = 0; t5 < r.length; t5++) {
            let e2 = r[t5];
            if (a2 >= e2.y - c2 && h2 <= e2.y + e2.height + c2 && n2 <= e2.x + e2.width + c2 && o2 >= e2.x - c2) return true;
        }
        else if (ls(t4.x, e.x)) for (let t5 = 0; t5 < r.length; t5++) {
            let e2 = r[t5];
            if (n2 >= e2.x - c2 && o2 <= e2.x + e2.width + c2 && a2 <= e2.y + e2.height + c2 && h2 >= e2.y - c2) return true;
        }
        return false;
    }
    next_point_d(t4, e, i, s, r, n2) {
        const o2 = "x" === s ? t4 : e;
        let a2 = null, h2 = null;
        for (let c2 = 0; c2 < i.length; c2++) {
            let l2 = i[c2];
            this.is_through({ x: t4, y: e }, l2, r, n2) || (l2[s] < o2 && (a2 ? l2[s] > a2[s] && (a2 = l2) : a2 = l2), l2[s] > o2 && (h2 ? l2[s] < h2[s] && (h2 = l2) : h2 = l2));
        }
        return [a2, h2].filter((t5) => !!t5);
    }
    next_point_d2(t4, e, i, s, r, n2) {
        const o2 = "x" === s ? t4 : e;
        let a2 = null, h2 = null;
        for (let t5 = 0; t5 < i.length; t5++) {
            let e2 = i[t5];
            e2[s] < o2 && (a2 ? e2[s] > a2[s] && (a2 = e2) : a2 = e2), e2[s] > o2 && (h2 ? e2[s] < h2[s] && (h2 = e2) : h2 = e2);
        }
        return [a2, h2].filter((t5) => !!t5);
    }
    cost_assessment(t4) {
        t4.cost = this.g_cost(t4) + this.h_cost(t4);
    }
    g_cost(t4) {
        let e = 0, i = t4.parent;
        for (; i; ) e += i.cost, i = i.parent;
        return e;
    }
    h_cost(t4) {
        return Math.abs(this.endPoint.x - t4.point.x) + Math.abs(this.endPoint.y - t4.point.y);
    }
};
__publicField(_us, "OFFSET", 20);
let us = _us;
function fs(e, i, s, r, n2, o2, a2) {
    const h2 = function(t4, e2, i2, s2, r2, n3) {
        const o3 = 20, a3 = t4.parent, h3 = i2.parent;
        if (!a3 || !h3) return false;
        const c3 = a3.matrix2Root(), l3 = h3.matrix2Root(), d3 = t4.boundingBox(), p3 = i2.boundingBox(), u2 = c3.computeCoord2(d3.x, d3.y), f3 = l3.computeCoord2(p3.x, p3.y), g3 = c3.computeCoord(d3.x + d3.width, d3.y + d3.height), m3 = l3.computeCoord2(p3.x + p3.width, p3.y + p3.height), _3 = g3.x - u2.x, y2 = g3.y - u2.y, x2 = m3.x - f3.x, w2 = m3.y - f3.y, b2 = { x: u2.x, y: u2.y, width: _3, height: y2 }, M2 = { x: f3.x, y: f3.y, width: x2, height: w2 }, v2 = os(t4, e2, r2), S2 = os(i2, s2, n3);
        if (!v2 || !S2) return false;
        let C3 = [];
        const T2 = hs(t4, e2, r2, u2, g3), I2 = hs(i2, s2, n3, f3, m3);
        if (!T2 || !I2) return false;
        C3.push(T2, I2);
        const k = { x: u2.x - o3, y: u2.y - o3 }, E2 = { x: g3.x + o3, y: g3.y + o3 };
        C3.push(...cs([T2, I2, k, E2]));
        const A2 = { x: f3.x - o3, y: f3.y - o3 }, F2 = { x: m3.x + o3, y: m3.y + o3 };
        C3.push(...cs([T2, I2, A2, F2]));
        const R2 = ds([v2, T2], [S2, I2]);
        if (R2) C3.push(R2);
        else {
            const t5 = ds([v2, T2], [I2, { x: I2.x + o3, y: I2.y }]);
            t5 && C3.push(t5);
            const e3 = ds([v2, T2], [I2, { x: I2.x, y: I2.y + o3 }]);
            e3 && C3.push(e3);
            const i3 = ds([S2, I2], [T2, { x: T2.x + o3, y: T2.y }]);
            i3 && C3.push(i3);
            const s3 = ds([S2, I2], [I2, { x: T2.x, y: T2.y + o3 }]);
            s3 && C3.push(s3);
        }
        return C3 = function(t5) {
            const e3 = [], i3 = {};
            for (let s3 = 0, r3 = t5.length; s3 < r3; s3++) {
                const { x: r4, y: n4 } = t5[s3];
                i3[`${r4}_${n4}`] || (e3.push(t5[s3]), i3[`${r4}_${n4}`] = true);
            }
            return e3;
        }(C3), { start_point: v2, end_point: S2, b_start_point: T2, b_end_point: I2, preparation_point: C3, ff1: b2, ff2: M2 };
    }(e, i, s, r, n2, o2);
    if (!h2) return;
    let { start_point: c2, end_point: l2, b_start_point: d2, b_end_point: p2, preparation_point: u, ff1: f2, ff2: g2 } = h2;
    let m2 = new us(f2, g2, d2, p2, u).run();
    if (!m2.length) {
        u = [c2, ...u, l2];
        m2 = new us(f2, g2, c2, l2, u).run_easy();
    }
    if (!m2.length) return;
    m2 = [c2, ...m2, l2];
    const _2 = [];
    for (let e2 = 0, i2 = m2.length; e2 < i2; e2++) {
        const i3 = a2.computeCoord3(m2[e2]);
        _2.push(new se([e2], v4(), i3.x, i3.y, ft.Straight));
    }
    return _2;
}
function gs(t4) {
    let e = [t4[0]];
    for (let i2 = 1, s = t4.length - 1; i2 < s; i2++) {
        const s2 = t4[i2 - 1].y, r = t4[i2 + 1].y;
        Math.abs(r - s2) > 1e-4 && e.push(t4[i2]);
    }
    e.push(t4[t4.length - 1]);
    let i = [e[0]];
    for (let t5 = 1, s = e.length - 1; t5 < s; t5++) {
        let s2 = e[t5 - 1].x, r = e[t5 + 1].x;
        Math.abs(r - s2) > 1e-4 && i.push(e[t5]);
    }
    return i.push(e[e.length - 1]), i;
}
function ms(t4, e) {
    return Math.abs(t4.x - e.x) < 1e-4 ? "ver" : Math.abs(t4.y - e.y) < 1e-4 && "hor";
}
function _s(t4, e) {
    return Math.abs(e.x - t4.x) > Math.abs(e.y - t4.y) ? "horizontal" : "vertical";
}
const ys = {};
function xs(t4, e, i) {
    const s = t4[0], r = t4[t4.length - 1];
    if (!s || !r) return;
    const n2 = _s({ x: s.x * e, y: s.y * i }, { x: r.x * e, y: r.y * i });
    ys[n2](t4, s, r);
}
function ws(t4, e, i, s = void 0, r = false) {
    let n2 = void 0 === s ? i.length - 1 : s;
    for (; n2 >= 0; --n2) {
        const s2 = i[n2], r2 = s2 instanceof Ni && s2.getVar(t4);
        if (!r2) continue;
        e.push(r2);
        const o2 = bs(t4, Et.Variable, i.slice(0, n2));
        return o2 && e.push(...o2), e;
    }
    if (r) for (n2 = void 0 === s ? i.length - 1 : s; n2 >= 0; --n2) {
        const s2 = i[n2], r2 = s2 instanceof Ar && s2.getOverrid(t4, Et.Variable);
        if (!r2) continue;
        e.push(r2.v);
        const o2 = bs(t4, Et.Variable, i.slice(0, n2));
        return o2 && e.push(...o2), e;
    }
}
function bs(t4, e, i) {
    let s;
    for (let r = i.length - 1; r >= 0; --r) {
        const n2 = i[r];
        if (n2 instanceof Ar) {
            const i2 = n2.getOverrid(t4, e);
            i2 && (s = i2), t4 = t4.length > 0 ? n2.id + "/" + t4 : n2.id;
        }
    }
    return s ? [s.v] : void 0;
}
function Ms(t4, e, i) {
    let s = [];
    for (let r = i.length - 1; r >= 0; --r) {
        const n2 = i[r];
        if (n2 instanceof Ar) {
            const i2 = n2.getOverrid(t4, e);
            i2 && s.push(i2.v), t4 = t4.length > 0 ? n2.id + "/" + t4 : n2.id;
        }
    }
    return s.length > 0 ? s : void 0;
}
function vs(t4, e, i, s = false) {
    const r = bs(t4.id, e, i);
    if (r) return r;
    const n2 = t4.varbinds, o2 = n2 == null ? void 0 : n2.get(e);
    if (o2) {
        const t5 = [];
        if (ws(o2, t5, i, void 0, s), t5 && t5.length > 0) return t5;
    }
}
function Ss() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
}
ys.horizontal = function(e, i, s) {
    e.length = 0;
    const r = (s.x + i.x) / 2, n2 = new se([1], v4(), r, i.y, ft.Straight), o2 = new se([2], v4(), r, s.y, ft.Straight);
    e.push(i, n2, o2, s);
}, ys.vertical = function(e, i, s) {
    e.length = 0;
    const r = (s.y + i.y) / 2, n2 = new se([1], v4(), i.x, r, ft.Straight), o2 = new se([2], v4(), s.x, r, ft.Straight);
    e.push(i, n2, o2, s);
};
class Cs extends Vi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2, l2) {
        super(t4, e, i, s, r, n2, o2, a2);
        __publicField(this, "typeId", "contact-shape");
        __publicField(this, "isEdited");
        __publicField(this, "mark");
        __publicField(this, "text");
        __publicField(this, "from");
        __publicField(this, "to");
        __publicField(this, "__pathCache");
        __publicField(this, "__page");
        this.crdtidx = t4, this.isEdited = h2, this.text = c2, this.mark = l2;
    }
    get points() {
        return this.pathsegs.length ? this.pathsegs[0].points : new G();
    }
    get isClosed() {
        var _a2;
        return !!((_a2 = this.pathsegs[0]) == null ? void 0 : _a2.isClosed);
    }
    get_pagexy(t4, e, i) {
        const s = t4.size;
        switch (e) {
            case pt.Top:
                return i.computeCoord2(s.width / 2, 0);
            case pt.Right:
                return i.computeCoord2(s.width, s.height / 2);
            case pt.Bottom:
                return i.computeCoord2(s.width / 2, s.height);
            case pt.Left:
                return i.computeCoord2(0, s.height / 2);
            default:
                return false;
        }
    }
    get_nearest_border_point(t4, e) {
        const i = t4.size, s = t4.matrix2Root(), r = [{ x: 0, y: 0 }, { x: i.width, y: 0 }, { x: i.width, y: i.height }, { x: 0, y: i.height }], n2 = s.computeCoord2(0, 0), o2 = { left: n2.x, right: n2.x, top: n2.y, bottom: n2.y };
        for (let t5 = 1; t5 < 4; t5++) {
            const e2 = r[t5], i2 = s.computeCoord2(e2.x, e2.y);
            i2.x < o2.left ? o2.left = i2.x : i2.x > o2.right && (o2.right = i2.x), i2.y < o2.top ? o2.top = i2.y : i2.y > o2.bottom && (o2.bottom = i2.y);
        }
        o2.left -= 20, o2.right += 20, o2.top -= 20, o2.bottom += 20;
        let a2 = this.get_pagexy(t4, e, s);
        if (a2) {
            const t5 = Math.abs(a2.y - o2.top), e2 = Math.abs(a2.x - o2.right), i2 = Math.abs(a2.y - o2.bottom), s2 = Math.abs(a2.x - o2.left);
            let r2 = t5;
            const n3 = { x: a2.x, y: a2.y };
            return a2 = { x: n3.x, y: o2.top }, e2 < r2 && (r2 = e2, a2 = { x: o2.right, y: n3.y }), i2 < r2 && (r2 = i2, a2 = { x: n3.x, y: o2.bottom }), s2 < r2 && (a2 = { x: o2.left, y: n3.y }), a2;
        }
    }
    getPoints() {
        const e = [...this.points];
        let i, s, r, n2, o2, a2, h2, c2, l2, d2, p2, u;
        (this.to || this.from) && (n2 = ns(this), i = this.getPage());
        const f2 = function(e2, i2, s2, r2) {
            if (!i2.from) return;
            const n3 = e2.getShape(i2.from.shapeId);
            if (!n3) return;
            const o3 = i2.from.contactType, a3 = n3.matrix2Root();
            let h3 = i2.get_pagexy(n3, o3, a3);
            if (!h3) return;
            h3 = r2.computeCoord3(h3);
            const c3 = h3;
            s2[0] = new se([0], v4(), h3.x, h3.y, ft.Straight);
            let l3 = i2.get_nearest_border_point(n3, o3);
            if (!l3) return;
            return l3 = r2.computeCoord3(l3), s2.splice(1, 0, new se([1], v4(), l3.x, l3.y, ft.Straight)), { page: e2, fromShape: n3, type1: o3, self_matrix: r2, from_matrix: a3, start_point: c3, s1: l3 };
        }(i, this, e, n2);
        f2 && (h2 = f2.fromShape, l2 = f2.type1, o2 = f2.from_matrix, p2 = f2.start_point, s = f2.s1);
        const g2 = function(e2, i2, s2, r2) {
            if (!i2.to) return;
            const n3 = e2.getShape(i2.to.shapeId);
            if (!n3) return;
            const o3 = i2.to.contactType, a3 = n3.matrix2Root();
            let h3 = i2.get_pagexy(n3, o3, a3);
            if (!h3) return;
            h3 = r2.computeCoord3(h3);
            const c3 = h3;
            s2[s2.length - 1] = new se([s2.length - 1], v4(), h3.x, h3.y, ft.Straight);
            let l3 = i2.get_nearest_border_point(n3, o3);
            if (!l3) return;
            return l3 = r2.computeCoord3(l3), s2.push(new se([s2.length], v4(), l3.x, l3.y, ft.Straight)), { page: e2, toShape: n3, type2: o3, self_matrix: r2, to_matrix: a3, end_point: c3, s2: l3 };
        }(i, this, e, n2);
        if (g2 && (c2 = g2.toShape, d2 = g2.type2, a2 = g2.to_matrix, u = g2.end_point, r = g2.s2), e.length <= 1) return console.log(this.name, ": points.length <= 1"), e;
        if (this.isEdited) return n2 || (n2 = ns(this)), p2 || (p2 = e[0]), u || (u = e[e.length - 1]), function(t4, e2, i2, s2, r2) {
            const n3 = [...t4];
            s2 ? n3.splice(1, 1) : s2 = n3[1], r2 ? n3.splice(n3.length - 2, 1) : r2 = n3[n3.length - 2];
            {
                const t5 = e2;
                let i3;
                const r3 = ms(t5, s2);
                if ("hor" === r3) {
                    const e3 = n3[1];
                    e3 && (i3 = new se([], "--", e3.x, t5.y, ft.Straight));
                } else if ("ver" === r3) {
                    const e3 = n3[2];
                    e3 && (i3 = new se([], "--", t5.x, e3.y, ft.Straight));
                }
                i3 && n3.splice(1, 1, i3);
            }
            {
                const t5 = n3.length, e3 = i2, s3 = ms(e3, r2);
                if ("hor" === s3) {
                    const i3 = n3[t5 - 2];
                    if (i3) {
                        const s4 = new se([], "--", i3.x, e3.y, ft.Straight);
                        n3.splice(t5 - 2, 1, s4);
                    }
                } else if ("ver" === s3) {
                    const i3 = n3[t5 - 3];
                    if (i3) {
                        const s4 = new se([], "--", e3.x, i3.y, ft.Straight);
                        n3.splice(t5 - 2, 1, s4);
                    }
                }
                n3[n3.length - 1] = new se([], "--", e3.x, e3.y, ft.Straight);
            }
            return gs(n3);
        }(e, p2, u, s, r);
        if (h2 && c2) {
            const t4 = fs(h2, l2, c2, d2, o2, a2, n2);
            if (t4 == null ? void 0 : t4.length) return gs(t4);
        }
        return h2 || c2 || xs(e, this.size.width, this.size.height), h2 && !c2 && function(e2, i2, s2) {
            if (!s2) {
                const t4 = i2[0];
                s2 = { x: t4.x, y: t4.y };
            }
            const r2 = i2.pop();
            Math.abs(s2.y - r2.y) * e2.size.height < 5 ? i2.push(new se([i2.length], v4(), r2.x, s2.y, ft.Straight)) : i2.push(new se([i2.length], v4(), r2.x, s2.y, ft.Straight), r2);
        }(this, e, s), !h2 && c2 && function(e2, i2, s2, r2) {
            if (!i2) return xs(e2, s2, r2);
            const n3 = e2[0], o3 = new se([e2.length - 1], v4(), i2.x, i2.y, ft.Straight), a3 = _s({ x: n3.x * s2, y: n3.y * r2 }, { x: i2.x * s2, y: i2.y * r2 });
            ys[a3](e2, n3, o3);
        }(e, u, this.size.width, this.size.height), gs(e);
    }
    getPath() {
        return this.getPathOfSize(this.size, this.fixedRadius);
    }
    getPath2() {
        return this.getPath();
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height, r = vi(this.getPoints(), !!this.isClosed, i, s, e);
        return this.__pathCache = new pi(r), this.__pathCache;
    }
    page() {
        return this.__page || (this.__page = this.getPage()), this.__page;
    }
    get isPathIcon() {
        return false;
    }
    get radiusType() {
        return De.Fixed;
    }
    get isImageFill() {
        return false;
    }
}
function Ts(t4, e) {
    return t4;
}
function Is(t4, e) {
    const i = { typeId: "color" };
    return i.typeId = t4.typeId, i.alpha = t4.alpha, i.red = t4.red, i.green = t4.green, i.blue = t4.blue, i;
}
function ks(t4, e) {
    const i = { typeId: "context-settings" };
    return i.typeId = t4.typeId, i.blenMode = Ts(t4.blenMode), i.opacity = t4.opacity, i;
}
function Es(t4, e) {
    const i = { typeId: "corner-radius" };
    return i.typeId = t4.typeId, i.lt = t4.lt, i.rt = t4.rt, i.lb = t4.lb, i.rb = t4.rb, i;
}
function As(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(t5);
    }), i;
}
function Rs(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(function(t6, e2) {
            const i2 = {};
            return i2.crdtidx = As(t6.crdtidx), i2.id = t6.id, i2.absoluteSize = t6.absoluteSize, i2.fileFormat = /* @__PURE__ */ function(t7, e3) {
                return t7;
            }(t6.fileFormat), i2.name = t6.name, i2.namingScheme = /* @__PURE__ */ function(t7, e3) {
                return t7;
            }(t6.namingScheme), i2.scale = t6.scale, i2.visibleScaleType = /* @__PURE__ */ function(t7, e3) {
                return t7;
            }(t6.visibleScaleType), i2;
        }(t5));
    }), i;
}
function Os(t4, e) {
    return t4;
}
function Ls(t4, e) {
    const i = { typeId: "guide" };
    return i.crdtidx = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(t6);
        }), i2;
    }(t4.crdtidx), i.typeId = t4.typeId, i.id = t4.id, i.axis = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.axis), i.offset = t4.offset, i;
}
function Ps(t4, e) {
    return t4;
}
function Bs(t4, e) {
    return t4;
}
function Ns(t4, e) {
    const i = {};
    return i.exposure = t4.exposure, i.contrast = t4.contrast, i.saturation = t4.saturation, i.temperature = t4.temperature, i.tint = t4.tint, i.shadow = t4.shadow, i.hue = t4.hue, i;
}
function zs(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(function(t6, e2) {
            const i2 = tr(t6);
            return i2.length = t6.length, i2;
        }(t5));
    }), i;
}
function Vs(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(function(t6, e2) {
            const i2 = {};
            return i2.crdtidx = As(t6.crdtidx), i2.id = t6.id, i2.x = t6.x, i2.y = t6.y, i2.mode = /* @__PURE__ */ function(t7, e3) {
                return t7;
            }(t6.mode), t6.radius && (i2.radius = t6.radius), t6.fromX && (i2.fromX = t6.fromX), t6.fromY && (i2.fromY = t6.fromY), t6.toX && (i2.toX = t6.toX), t6.toY && (i2.toY = t6.toY), t6.hasFrom && (i2.hasFrom = t6.hasFrom), t6.hasTo && (i2.hasTo = t6.hasTo), i2;
        }(t5));
    }), i;
}
function Ds(t4, e) {
    const i = {};
    return i.crdtidx = As(t4.crdtidx), i.id = t4.id, i.points = Vs(t4.points), i.isClosed = t4.isClosed, i;
}
function Hs(t4, e) {
    const i = {};
    return i.m00 = t4.m00, i.m01 = t4.m01, i.m02 = t4.m02, i.m10 = t4.m10, i.m11 = t4.m11, i.m12 = t4.m12, i;
}
function Ws(t4, e) {
    const i = {};
    return i.x = t4.x, i.y = t4.y, i;
}
function $s(t4, e) {
    const i = { typeId: "shadow" };
    return i.crdtidx = As(t4.crdtidx), i.typeId = t4.typeId, i.id = t4.id, i.isEnabled = t4.isEnabled, i.blurRadius = t4.blurRadius, i.color = Is(t4.color), i.offsetX = t4.offsetX, i.offsetY = t4.offsetY, i.spread = t4.spread, i.position = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.position), t4.contextSettings && (i.contextSettings = function(t5, e2) {
        const i2 = {};
        return i2.blendMode = Ts(t5.blendMode), i2.opacity = t5.opacity, i2;
    }(t4.contextSettings)), i;
}
function Xs(t4, e) {
    const i = {};
    return i.width = t4.width, i.height = t4.height, i;
}
function Gs(t4, e) {
    const i = {};
    return i.crdtidx = As(t4.crdtidx), i.id = t4.id, i.position = t4.position, i.color = Is(t4.color), i;
}
function Ys(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(function(t6, e2) {
            const i2 = {};
            return i2.crdtidx = As(t6.crdtidx), i2.id = t6.id, i2.roleType = /* @__PURE__ */ function(t7, e3) {
                return t7;
            }(t6.roleType), i2.shapeId = t6.shapeId, i2;
        }(t5));
    }), i;
}
function Us(t4, e) {
    const i = [];
    return t4.forEach((t5) => {
        i.push(function(t6, e2) {
            const i2 = {};
            i2.text = t6.text, i2.spans = zs(t6.spans), t6.attr && (i2.attr = sr(t6.attr));
            return i2;
        }(t5));
    }), i;
}
function Zs(t4, e) {
    const i = { typeId: "blur" };
    return i.typeId = t4.typeId, i.isEnabled = t4.isEnabled, i.center = Ws(t4.center), i.saturation = t4.saturation, i.type = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.type), t4.motionAngle && (i.motionAngle = t4.motionAngle), t4.radius && (i.radius = t4.radius), i;
}
function js(t4, e) {
    const i = {};
    return i.contactType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.contactType), i.shapeId = t4.shapeId, i;
}
function Js(t4, e) {
    const i = {};
    return i.id = t4.id, i.crdtidx = As(t4.crdtidx), i.value = t4.value, i;
}
function Ks(t4, e) {
    const i = { typeId: "export-options" };
    return i.typeId = t4.typeId, i.exportFormats = Rs(t4.exportFormats), i.childOptions = t4.childOptions, i.shouldTrim = t4.shouldTrim, i.trimTransparent = t4.trimTransparent, i.canvasBackground = t4.canvasBackground, i.unfold = t4.unfold, i;
}
function qs(t4, e) {
    const i = { typeId: "gradient" };
    return i.typeId = t4.typeId, i.from = Ws(t4.from), i.to = Ws(t4.to), i.gradientType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.gradientType), i.stops = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Gs(t6));
        }), i2;
    }(t4.stops), t4.elipseLength && (i.elipseLength = t4.elipseLength), t4.gradientOpacity && (i.gradientOpacity = t4.gradientOpacity), i;
}
function Qs(t4, e) {
    const i = {};
    return i.crdtidx = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(t6);
        }), i2;
    }(t4.crdtidx), i.id = t4.id, i.event = function(t5, e2) {
        const i2 = {};
        return i2.interactionType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.interactionType), t5.transitionTimeout && (i2.transitionTimeout = t5.transitionTimeout), i2;
    }(t4.event), i.actions = function(t5, e2) {
        const i2 = { typeId: "prototype-actions" };
        return i2.typeId = t5.typeId, i2.connectionType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.connectionType), t5.targetNodeID && (i2.targetNodeID = t5.targetNodeID), t5.transitionType && (i2.transitionType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.transitionType)), t5.transitionDuration && (i2.transitionDuration = t5.transitionDuration), t5.easingType && (i2.easingType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.easingType)), t5.connectionURL && (i2.connectionURL = t5.connectionURL), t5.openUrlInNewTab && (i2.openUrlInNewTab = t5.openUrlInNewTab), t5.navigationType && (i2.navigationType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.navigationType)), t5.easingFunction && (i2.easingFunction = function(t6, e3) {
            const i3 = [];
            return t6.forEach((t7) => {
                i3.push(t7);
            }), i3;
        }(t5.easingFunction)), t5.extraScrollOffset && (i2.extraScrollOffset = Ws(t5.extraScrollOffset)), i2;
    }(t4.actions), t4.typeId && (i.typeId = t4.typeId), t4.isDeleted && (i.isDeleted = t4.isDeleted), i;
}
function tr(t4, e) {
    const i = {};
    return t4.fontName && (i.fontName = t4.fontName), t4.fontSize && (i.fontSize = t4.fontSize), t4.color && (i.color = Is(t4.color)), t4.strikethrough && (i.strikethrough = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.strikethrough)), t4.underline && (i.underline = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.underline)), t4.weight && (i.weight = t4.weight), t4.italic && (i.italic = t4.italic), t4.bulletNumbers && (i.bulletNumbers = function(t5, e2) {
        const i2 = {};
        return i2.type = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.type), t5.behavior && (i2.behavior = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.behavior)), t5.offset && (i2.offset = t5.offset), i2;
    }(t4.bulletNumbers)), t4.highlight && (i.highlight = Is(t4.highlight)), t4.kerning && (i.kerning = t4.kerning), t4.transform && (i.transform = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.transform)), t4.placeholder && (i.placeholder = t4.placeholder), t4.fillType && (i.fillType = Os(t4.fillType)), t4.gradient && (i.gradient = qs(t4.gradient)), i;
}
function er(t4, e) {
    const i = { typeId: "border" };
    return i.crdtidx = As(t4.crdtidx), i.typeId = t4.typeId, i.id = t4.id, i.isEnabled = t4.isEnabled, i.fillType = Os(t4.fillType), i.color = Is(t4.color), i.position = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.position), i.thickness = t4.thickness, i.borderStyle = function(t5, e2) {
        const i2 = {};
        return i2.length = t5.length, i2.gap = t5.gap, i2;
    }(t4.borderStyle), i.cornerType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.cornerType), i.sideSetting = function(t5, e2) {
        const i2 = {};
        return i2.sideType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.sideType), i2.thicknessTop = t5.thicknessTop, i2.thicknessLeft = t5.thicknessLeft, i2.thicknessBottom = t5.thicknessBottom, i2.thicknessRight = t5.thicknessRight, i2;
    }(t4.sideSetting), t4.contextSettings && (i.contextSettings = ks(t4.contextSettings)), t4.gradient && (i.gradient = qs(t4.gradient)), t4.imageRef && (i.imageRef = t4.imageRef), t4.imageScaleMode && (i.imageScaleMode = Ps(t4.imageScaleMode)), t4.rotation && (i.rotation = t4.rotation), t4.scale && (i.scale = t4.scale), t4.originalImageWidth && (i.originalImageWidth = t4.originalImageWidth), t4.originalImageHeight && (i.originalImageHeight = t4.originalImageHeight), t4.paintFilter && (i.paintFilter = Ns(t4.paintFilter)), t4.transform && (i.transform = Hs(t4.transform)), i;
}
function ir(t4, e) {
    const i = { typeId: "fill" };
    return i.crdtidx = As(t4.crdtidx), i.typeId = t4.typeId, i.id = t4.id, i.isEnabled = t4.isEnabled, i.fillType = Os(t4.fillType), i.color = Is(t4.color), t4.contextSettings && (i.contextSettings = ks(t4.contextSettings)), t4.gradient && (i.gradient = qs(t4.gradient)), t4.imageRef && (i.imageRef = t4.imageRef), t4.fillRule && (i.fillRule = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.fillRule)), t4.imageScaleMode && (i.imageScaleMode = Ps(t4.imageScaleMode)), t4.rotation && (i.rotation = t4.rotation), t4.scale && (i.scale = t4.scale), t4.originalImageWidth && (i.originalImageWidth = t4.originalImageWidth), t4.originalImageHeight && (i.originalImageHeight = t4.originalImageHeight), t4.paintFilter && (i.paintFilter = Ns(t4.paintFilter)), t4.transform && (i.transform = Hs(t4.transform)), (e == null ? void 0 : e.medias) && i.imageRef && e.medias.add(i.imageRef), i;
}
function sr(t4, e) {
    const i = tr(t4);
    return t4.alignment && (i.alignment = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.alignment)), t4.paraSpacing && (i.paraSpacing = t4.paraSpacing), t4.minimumLineHeight && (i.minimumLineHeight = t4.minimumLineHeight), t4.maximumLineHeight && (i.maximumLineHeight = t4.maximumLineHeight), t4.indent && (i.indent = t4.indent), i;
}
function rr(t4, e) {
    const i = { typeId: "style" };
    return i.typeId = t4.typeId, i.borders = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(er(t6));
        }), i2;
    }(t4.borders), i.fills = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(ir(t6, e2));
        }), i2;
    }(t4.fills, e), i.shadows = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push($s(t6));
        }), i2;
    }(t4.shadows), t4.miterLimit && (i.miterLimit = t4.miterLimit), t4.windingRule && (i.windingRule = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.windingRule)), t4.blur && (i.blur = Zs(t4.blur)), t4.borderOptions && (i.borderOptions = function(t5, e2) {
        const i2 = {};
        return i2.isEnabled = t5.isEnabled, i2.lineCapStyle = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.lineCapStyle), i2.lineJoinStyle = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.lineJoinStyle), i2;
    }(t4.borderOptions)), t4.colorControls && (i.colorControls = function(t5, e2) {
        const i2 = {};
        return i2.isEnabled = t5.isEnabled, i2.brightness = t5.brightness, i2.contrast = t5.contrast, i2.hue = t5.hue, i2.saturation = t5.saturation, i2;
    }(t4.colorControls)), t4.contextSettings && (i.contextSettings = ks(t4.contextSettings)), t4.innerShadows && (i.innerShadows = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push($s(t6));
        }), i2;
    }(t4.innerShadows)), t4.contacts && (i.contacts = Ys(t4.contacts)), t4.startMarkerType && (i.startMarkerType = Bs(t4.startMarkerType)), t4.endMarkerType && (i.endMarkerType = Bs(t4.endMarkerType)), t4.varbinds && (i.varbinds = (() => {
        const e2 = {};
        return t4.varbinds.forEach((t5, i2) => {
            e2[i2] = t5;
        }), e2;
    })()), i;
}
function nr(t4, e) {
    const i = sr(t4);
    return t4.verAlign && (i.verAlign = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.verAlign)), t4.orientation && (i.orientation = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.orientation)), t4.textBehaviour && (i.textBehaviour = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.textBehaviour)), t4.padding && (i.padding = function(t5, e2) {
        const i2 = {};
        return t5.left && (i2.left = t5.left), t5.top && (i2.top = t5.top), t5.right && (i2.right = t5.right), t5.bottom && (i2.bottom = t5.bottom), i2;
    }(t4.padding)), i;
}
function or(t4, e) {
    const i = { typeId: "text" };
    return i.typeId = t4.typeId, i.paras = Us(t4.paras), t4.attr && (i.attr = nr(t4.attr)), i;
}
function ar(t4, e) {
    const i = { typeId: "shape" };
    return i.crdtidx = As(t4.crdtidx), i.typeId = t4.typeId, i.id = t4.id, i.name = t4.name, i.type = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.type), i.transform = function(t5, e2) {
        const i2 = {};
        return i2.m00 = t5.m00, i2.m01 = t5.m01, i2.m02 = t5.m02, i2.m10 = t5.m10, i2.m11 = t5.m11, i2.m12 = t5.m12, i2;
    }(t4.transform), i.style = rr(t4.style, e), t4.boolOp && (i.boolOp = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.boolOp)), t4.isFixedToViewport && (i.isFixedToViewport = t4.isFixedToViewport), t4.isLocked && (i.isLocked = t4.isLocked), t4.isVisible && (i.isVisible = t4.isVisible), t4.exportOptions && (i.exportOptions = Ks(t4.exportOptions)), t4.nameIsFixed && (i.nameIsFixed = t4.nameIsFixed), t4.resizingConstraint && (i.resizingConstraint = t4.resizingConstraint), t4.resizingType && (i.resizingType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.resizingType)), t4.constrainerProportions && (i.constrainerProportions = t4.constrainerProportions), t4.clippingMaskMode && (i.clippingMaskMode = t4.clippingMaskMode), t4.hasClippingMask && (i.hasClippingMask = t4.hasClippingMask), t4.shouldBreakMaskChain && (i.shouldBreakMaskChain = t4.shouldBreakMaskChain), t4.varbinds && (i.varbinds = (() => {
        const e2 = {};
        return t4.varbinds.forEach((t5, i2) => {
            e2[i2] = t5;
        }), e2;
    })()), t4.haveEdit && (i.haveEdit = t4.haveEdit), t4.prototypeStartingPoint && (i.prototypeStartingPoint = function(t5, e2) {
        const i2 = { typeId: "prototype-starting-point" };
        return i2.typeId = t5.typeId, i2.name = t5.name, i2.desc = t5.desc, i2;
    }(t4.prototypeStartingPoint)), t4.prototypeInteractions && (i.prototypeInteractions = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Qs(t6));
        }), i2;
    }(t4.prototypeInteractions)), t4.overlayPosition && (i.overlayPosition = function(t5, e2) {
        const i2 = { typeId: "overlay-position" };
        return i2.typeId = t5.typeId, i2.position = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.position), i2.margin = function(t6, e3) {
            const i3 = {};
            return i3.top = t6.top, i3.bottom = t6.bottom, i3.left = t6.left, i3.right = t6.right, i3;
        }(t5.margin), i2;
    }(t4.overlayPosition)), t4.overlayBackgroundInteraction && (i.overlayBackgroundInteraction = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.overlayBackgroundInteraction)), t4.overlayBackgroundAppearance && (i.overlayBackgroundAppearance = function(t5, e2) {
        const i2 = { typeId: "overlay-background-appearance" };
        return i2.typeId = t5.typeId, i2.backgroundType = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.backgroundType), i2.backgroundColor = Is(t5.backgroundColor), i2;
    }(t4.overlayBackgroundAppearance)), t4.scrollDirection && (i.scrollDirection = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.scrollDirection)), t4.mask && (i.mask = t4.mask), i;
}
function hr(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "table-cell", i.cellType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.cellType), i.text = or(t4.text), t4.imageRef && (i.imageRef = t4.imageRef), t4.rowSpan && (i.rowSpan = t4.rowSpan), t4.colSpan && (i.colSpan = t4.colSpan), (e == null ? void 0 : e.medias) && i.imageRef && e.medias.add(i.imageRef), i;
}
function cr(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "table-shape", i.size = Xs(t4.size), i.cells = (() => {
        const i2 = {};
        return t4.cells.forEach((t5, s) => {
            i2[s] = hr(t5, e);
        }), i2;
    })(), i.rowHeights = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Js(t6));
        }), i2;
    }(t4.rowHeights), i.colWidths = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Js(t6));
        }), i2;
    }(t4.colWidths), t4.textAttr && (i.textAttr = nr(t4.textAttr)), i;
}
function lr(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "text-shape", i.size = Xs(t4.size), i.text = or(t4.text), t4.fixedRadius && (i.fixedRadius = t4.fixedRadius), i;
}
function dr(t4, e) {
    const i = {};
    return i.id = t4.id, i.type = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.type), i.name = t4.name, i.value = (() => {
        if ("object" != typeof t4.value) return t4.value;
        if (Array.isArray(t4.value)) return function(t5, e2) {
            const i2 = [];
            return t5.forEach((t6) => {
                i2.push((() => {
                    if ("object" != typeof t6) return t6;
                    if ("border" === t6.typeId) return er(t6);
                    if ("fill" === t6.typeId) return ir(t6, e2);
                    if ("shadow" === t6.typeId) return $s(t6);
                    if ("prototype-inter-action" === t6.typeId) return Qs(t6);
                    throw new Error("unknow typeId: " + t6.typeId);
                })());
            }), i2;
        }(t4.value, e);
        if ("color" === t4.value.typeId) return Is(t4.value);
        if ("text" === t4.value.typeId) return or(t4.value);
        if ("gradient" === t4.value.typeId) return qs(t4.value);
        if ("style" === t4.value.typeId) return rr(t4.value, e);
        if ("context-settings" === t4.value.typeId) return ks(t4.value);
        if ("table-cell" === t4.value.typeId) return hr(t4.value, e);
        if ("export-options" === t4.value.typeId) return Ks(t4.value);
        if ("corner-radius" === t4.value.typeId) return Es(t4.value);
        if ("blur" === t4.value.typeId) return Zs(t4.value);
        throw new Error("unknow typeId: " + t4.value.typeId);
    })(), i;
}
function pr(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "path-shape", i.size = Xs(t4.size), i.pathsegs = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Ds(t6));
        }), i2;
    }(t4.pathsegs), t4.fixedRadius && (i.fixedRadius = t4.fixedRadius), i;
}
function ur(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "path-shape2", i.size = Xs(t4.size), i.pathsegs = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Ds(t6));
        }), i2;
    }(t4.pathsegs), t4.fixedRadius && (i.fixedRadius = t4.fixedRadius), i;
}
function fr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "polygon-shape", i.counts = t4.counts, i;
}
function gr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "rect-shape", i;
}
function mr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "star-shape", i.counts = t4.counts, i.innerAngle = t4.innerAngle, i;
}
function _r(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "symbol-ref-shape", i.size = Xs(t4.size), i.refId = t4.refId, i.variables = (() => {
        const i2 = {};
        return t4.variables.forEach((t5, s) => {
            i2[s] = dr(t5, e);
        }), i2;
    })(), t4.overrides && (i.overrides = (() => {
        const e2 = {};
        return t4.overrides.forEach((t5, i2) => {
            e2[i2] = t5;
        }), e2;
    })()), t4.isCustomSize && (i.isCustomSize = t4.isCustomSize), t4.cornerRadius && (i.cornerRadius = Es(t4.cornerRadius)), (e == null ? void 0 : e.refsymbols) && e.refsymbols.add(i.refId), i;
}
function yr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "contact-shape", i.isEdited = t4.isEdited, i.text = or(t4.text), i.mark = t4.mark, t4.from && (i.from = js(t4.from)), t4.to && (i.to = js(t4.to)), i;
}
function xr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "cutout-shape", i;
}
function wr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "image-shape", i.imageRef = t4.imageRef, (e == null ? void 0 : e.medias) && e.medias.add(i.imageRef), i;
}
function br(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "line-shape", i;
}
function Mr(t4, e) {
    const i = pr(t4, e);
    return i.typeId = "oval-shape", i.ellipse = function(t5, e2) {
        const i2 = {};
        return i2.cx = t5.cx, i2.cy = t5.cy, i2.rx = t5.rx, i2.ry = t5.ry, i2;
    }(t4.ellipse), i;
}
function vr(t4, e) {
    const i = Cr(t4, e);
    return i.typeId = "artboard", i.size = Xs(t4.size), t4.cornerRadius && (i.cornerRadius = Es(t4.cornerRadius)), t4.guides && (i.guides = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Ls(t6));
        }), i2;
    }(t4.guides)), i;
}
function Sr(t4, e) {
    const i = Cr(t4, e);
    return i.typeId = "bool-shape", i;
}
function Cr(t4, e) {
    const i = ar(t4, e);
    return i.typeId = "group-shape", i.childs = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push((() => {
                if ("object" != typeof t6) return t6;
                if ("group-shape" === t6.typeId) return Cr(t6, e2);
                if ("image-shape" === t6.typeId) return wr(t6, e2);
                if ("path-shape" === t6.typeId) return pr(t6, e2);
                if ("path-shape2" === t6.typeId) return ur(t6, e2);
                if ("rect-shape" === t6.typeId) return gr(t6, e2);
                if ("symbol-ref-shape" === t6.typeId) return _r(t6, e2);
                if ("symbol-shape" === t6.typeId) return Ir(t6, e2);
                if ("symbol-union-shape" === t6.typeId) return kr(t6, e2);
                if ("text-shape" === t6.typeId) return lr(t6, e2);
                if ("artboard" === t6.typeId) return vr(t6, e2);
                if ("line-shape" === t6.typeId) return br(t6, e2);
                if ("oval-shape" === t6.typeId) return Mr(t6, e2);
                if ("table-shape" === t6.typeId) return cr(t6, e2);
                if ("contact-shape" === t6.typeId) return yr(t6, e2);
                if ("shape" === t6.typeId) return ar(t6, e2);
                if ("cutout-shape" === t6.typeId) return xr(t6, e2);
                if ("bool-shape" === t6.typeId) return Sr(t6, e2);
                if ("polygon-shape" === t6.typeId) return fr(t6, e2);
                if ("star-shape" === t6.typeId) return mr(t6, e2);
                throw new Error("unknow typeId: " + t6.typeId);
            })());
        }), i2;
    }(t4.childs, e), t4.fixedRadius && (i.fixedRadius = t4.fixedRadius), i;
}
function Tr(t4, e) {
    const i = Cr(t4, e);
    return i.typeId = "page", t4.backgroundColor && (i.backgroundColor = Is(t4.backgroundColor)), t4.guides && (i.guides = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Ls(t6));
        }), i2;
    }(t4.guides)), i;
}
function Ir(t4, e) {
    const i = Cr(t4, e);
    return i.typeId = "symbol-shape", i.size = Xs(t4.size), i.variables = (() => {
        const i2 = {};
        return t4.variables.forEach((t5, s) => {
            i2[s] = dr(t5, e);
        }), i2;
    })(), t4.symtags && (i.symtags = (() => {
        const e2 = {};
        return t4.symtags.forEach((t5, i2) => {
            e2[i2] = t5;
        }), e2;
    })()), t4.cornerRadius && (i.cornerRadius = Es(t4.cornerRadius)), t4.guides && (i.guides = function(t5, e2) {
        const i2 = [];
        return t5.forEach((t6) => {
            i2.push(Ls(t6));
        }), i2;
    }(t4.guides)), (e == null ? void 0 : e.symbols) && e.symbols.add(i.id), i;
}
function kr(t4, e) {
    const i = Ir(t4, e);
    return i.typeId = "symbol-union-shape", i;
}
function Er(t4, e) {
    return e === Et.Variable ? t4 : t4.length > 0 ? t4 + "/" + e : e;
}
class Ar extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "__symMgr");
        __publicField(this, "typeId", "symbol-ref-shape");
        __publicField(this, "__refId");
        __publicField(this, "size");
        __publicField(this, "overrides");
        __publicField(this, "variables");
        __publicField(this, "isCustomSize");
        __publicField(this, "cornerRadius");
        __publicField(this, "__isAdded", false);
        __publicField(this, "__imageMgr");
        this.size = o2, this.__refId = a2, this.variables = h2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    toJSON() {
        return _r(this);
    }
    getOpTarget(t4) {
        return "overrides" !== t4[0] || this.overrides || (this.overrides = new Y()), super.getOpTarget(t4);
    }
    removeVirbindsEx(t4) {
        return !!this.overrides && this.overrides.delete(t4);
    }
    get symData() {
    }
    onSymbolReady() {
        this.notify("symbol-ready");
    }
    get refId() {
        return this.__refId;
    }
    set refId(t4) {
        const e = this.__symMgr;
        t4 !== this.__refId && (e && e.removeRef(this.__refId, this), this.__refId = t4, e && e.addRef(t4, this));
    }
    onAdded() {
        this.__isAdded = true;
        const t4 = this.__symMgr;
        t4 && t4.addRef(this.refId, this);
    }
    onRemoved() {
        this.__isAdded = false;
        const t4 = this.__symMgr;
        t4 && t4.removeRef(this.refId, this);
    }
    setImageMgr(t4) {
        this.__imageMgr = t4;
    }
    getImageMgr() {
        return this.__imageMgr;
    }
    setSymbolMgr(t4) {
        this.__symMgr = t4, t4 && this.__isAdded && t4.addRef(this.refId, this);
    }
    getSymbolMgr() {
        return this.__symMgr;
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        return new pi([["M", 0, 0], ["l", i, 0], ["l", 0, s], ["l", -i, 0], ["z"]]);
    }
    getOverrid(t4, e) {
        t4 = Er(t4, e);
        const i = this.overrides && this.overrides.get(t4);
        if (i) {
            const e2 = this.variables && this.variables.get(i);
            if (e2) return { refId: t4, v: e2 };
        }
    }
    getOverrid2(t4, e) {
        return t4 = Er(t4, e), this.overrides && this.overrides.get(t4);
    }
    getVar(t4) {
        return this.variables && this.variables.get(t4);
    }
    get pathType() {
        return Ve.Fixed;
    }
    get isPathIcon() {
        return false;
    }
    get radius() {
        return [0];
    }
    get radiusType() {
        return De.Rect;
    }
    get isImageFill() {
        return false;
    }
}
class Fr extends Ee {
    getOpTarget(t4) {
        return "extraScrollOffset" !== t4[0] || this.extraScrollOffset || (this.extraScrollOffset = new fe(0, 0)), super.getOpTarget(t4);
    }
}
class Rr {
    constructor(t4, e) {
        __publicField(this, "grid", []);
        __publicField(this, "_rowCount");
        __publicField(this, "_colCount");
        for (let e2 = 0; e2 < t4; e2++) this.grid.push([]);
        this._rowCount = t4, this._colCount = e;
    }
    get rowCount() {
        return this._rowCount;
    }
    get colCount() {
        return this._colCount;
    }
    set(t4, e, i) {
        this.grid[t4][e] = i;
    }
    get(t4, e) {
        return this.grid[t4][e];
    }
}
function Or(t4) {
    const e = t4.charCodeAt(0);
    return e >= 97 && e <= 122 ? String.fromCharCode(e - 32) : t4;
}
function Lr(t4, e, i) {
    if (!i) return t4;
    switch (i) {
        case Yt.Lowercase:
            return function(t5) {
                const e2 = t5.charCodeAt(0);
                return e2 >= 65 && e2 <= 90 ? String.fromCharCode(e2 + 32) : t5;
            }(t4);
        case Yt.Uppercase:
            return Or(t4);
        case Yt.UppercaseFirst:
            if (e) return Or(t4);
    }
    return t4;
}
const Pr = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], Br = Pr.length;
const Nr = [["I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"], ["X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"], ["C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"], ["M", "MM", "MMM"]];
const zr = ["•", "◦", "▪"];
var Vr;
function Dr(t4, e) {
    switch (t4 % 3) {
        case 0:
            return e + 1 + ".";
        case 1:
            return function(t5) {
                if (t5 < 0) return "";
                const e2 = [];
                for (let i = 0; ; i++) {
                    const s = Math.floor(t5 / Br);
                    if (!(s >= 1)) {
                        i > 0 ? e2.push(Pr[t5 % Br - 1]) : e2.push(Pr[t5 % Br]);
                        break;
                    }
                    e2.push(Pr[t5 % Br]), t5 = s;
                }
                return e2.reverse().join("");
            }(e) + ".";
        case 2:
            return function(t5) {
                if (t5 <= 0) return "";
                t5 > 3999 && (t5 %= 3999);
                const e2 = "" + t5;
                let i = "";
                for (let t6 = 0; t6 < e2.length; t6++) {
                    const s = e2.charAt(t6);
                    "0" != s && (i += Nr[e2.length - t6 - 1][parseInt(s) - 1]);
                }
                return i;
            }(e + 1) + ".";
    }
    return "";
}
!function(t4) {
    t4[t4.Number = 0] = "Number", t4[t4.Letter = 1] = "Letter", t4[t4.Roman = 2] = "Roman";
}(Vr || (Vr = {}));
const Hr = /* @__PURE__ */ new Map();
function Wr(t4, e, i) {
    const s = i.weight || 400, r = (i.italic ? "italic " : "normal ") + s + " " + e + "px " + i.fontName, n2 = t4[0] + "#" + r;
    if (Hr.has(n2)) return Hr.get(n2);
    const o2 = (0, p.text.textMeasure)(t4[0], r);
    return Hr.set(n2, o2), o2;
}
function $r(t4, e, i, s) {
    var _a2;
    const r = ((_a2 = t4.attr) == null ? void 0 : _a2.indent) || 0;
    let n2, o2 = "", a2 = 0;
    const h2 = e.fontSize || 0;
    if (i.type === lt.Disorded) {
        o2 = function(t6) {
            return zr[t6 % zr.length];
        }(r);
        const t5 = 2, i2 = h2, s2 = e.fontSize ? 0.6 * e.fontSize : 10;
        n2 = { char: o2, metrics: Wr(o2, h2, e), cw: 2 * s2 - t5, ch: i2, index: 0, x: t5, cc: 1 };
    } else {
        if (i.type !== lt.Ordered1Ai) throw new Error("unknow bullet numbers type: " + i.type);
        {
            if (i.behavior === ct.Renew) a2 = i.offset || 0;
            else for (let t6 = s.length - 1; t6 >= 0; t6--) {
                const e2 = s[t6];
                if (e2.level < r) break;
                if (!(e2.level > r)) {
                    if (e2.type !== lt.Ordered1Ai) break;
                    a2 = e2.index + 1;
                    break;
                }
            }
            const t5 = function(t6) {
                switch (t6 % 3) {
                    case 0:
                        return Vr.Number;
                    case 1:
                        return Vr.Letter;
                    case 2:
                        return Vr.Roman;
                }
                throw new Error("getOrderedType error");
            }(r);
            o2 = Dr(r, a2);
            const c3 = e.transform, l2 = h2, d2 = e.fontSize ? 0.6 * e.fontSize : 10;
            let u = 0;
            if (c3 && c3 === Yt.Uppercase) {
                let t6 = "";
                for (let e2 = 0, i2 = o2.length; e2 < i2; e2++) {
                    t6 += Lr(o2.charAt(e2), false, c3);
                }
                o2 = t6;
            }
            if (u = d2 * o2.length, t5 === Vr.Roman) {
                const t6 = "normal " + (e.fontSize || 10) + "px " + e.fontName, i2 = Math.ceil(function(t7, e2) {
                    const i3 = p.text.textMeasure;
                    return t7.split("").reduce((t8, s2) => {
                        const r2 = i3(s2.charAt(0), e2);
                        return t8 + ((r2 == null ? void 0 : r2.width) ?? 0);
                    }, 0);
                }(o2, t6) / d2);
                u = Math.max(2, i2) * d2;
            }
            n2 = { char: o2, metrics: Wr(o2, h2, e), cw: u, ch: l2, index: 0, x: 0, cc: 1 }, t5 === Vr.Number && 0 === a2 && (n2.x = 0.2 * d2, n2.cw = n2.cw - n2.x);
        }
    }
    const c2 = new Ur(n2);
    return c2.index = a2, c2.level = r, c2.text = o2, c2.type = i.type, s.push(c2), c2;
}
const Xr = 28;
class Gr extends Array {
    constructor() {
        super(...arguments);
        __publicField(this, "attr");
        __publicField(this, "charCount", 0);
    }
    get graphCount() {
        return this.length;
    }
    push(...t4) {
        return 1 === t4.length ? this.charCount += t4[0].cc : this.charCount += t4.reduce((t5, e) => t5 + e.cc, 0), super.push(...t4);
    }
}
class Yr extends Array {
    constructor() {
        super(...arguments);
        __publicField(this, "maxFontSize", 0);
        __publicField(this, "x", 0);
        __publicField(this, "y", 0);
        __publicField(this, "lineHeight", 0);
        __publicField(this, "lineWidth", 0);
        __publicField(this, "graphWidth", 0);
        __publicField(this, "graphCount", 0);
        __publicField(this, "charCount", 0);
        __publicField(this, "alignment", Xt.Left);
        __publicField(this, "layoutWidth", 0);
    }
    get actualBoundingBoxDescent() {
        return Math.round(this.maxFontSize * He);
    }
    push(...t4) {
        var _a2;
        return 1 === t4.length ? (this.maxFontSize = Math.max(this.maxFontSize, ((_a2 = t4[0].attr) == null ? void 0 : _a2.fontSize) || 0), this.charCount += t4[0].charCount, ++this.graphCount) : (this.maxFontSize = t4.reduce((t5, e) => {
            var _a3;
            return Math.max(t5, ((_a3 = e.attr) == null ? void 0 : _a3.fontSize) || 0);
        }, this.maxFontSize), this.charCount += t4.reduce((t5, e) => t5 + e.charCount, 0), this.graphCount += t4.length), super.push(...t4);
    }
    toJSON() {
        const t4 = [];
        for (let e = 0; e < this.length; ++e) t4.push(this[e]);
        return { maxFontSize: this.maxFontSize, actualBoundingBoxDescent: this.actualBoundingBoxDescent, x: this.x, y: this.y, lineHeight: this.lineHeight, lineWidth: this.lineWidth, graphWidth: this.graphWidth, graphCount: this.graphCount, charCount: this.charCount, alignment: this.alignment, layoutWidth: this.layoutWidth, graphs: t4 };
    }
}
class Ur {
    constructor(t4) {
        __publicField(this, "index", 0);
        __publicField(this, "level", 0);
        __publicField(this, "text", "");
        __publicField(this, "type", lt.None);
        __publicField(this, "graph");
        this.graph = t4;
    }
}
class Zr extends Array {
    constructor() {
        super(...arguments);
        __publicField(this, "paraHeight", 0);
        __publicField(this, "paraWidth", 0);
        __publicField(this, "graphCount", 0);
        __publicField(this, "charCount", 0);
        __publicField(this, "yOffset", 0);
        __publicField(this, "xOffset", 0);
        __publicField(this, "bulletNumbers");
    }
    toJSON() {
        const t4 = [];
        for (let e = 0; e < this.length; ++e) t4.push(this[e]);
        return { paraHeight: this.paraHeight, graphCount: this.graphCount, charCount: this.charCount, yOffset: this.yOffset, xOffset: this.xOffset, paraWidth: this.paraWidth, bulletNumbers: this.bulletNumbers, lines: t4 };
    }
}
class jr {
    constructor() {
        __publicField(this, "layout");
        __publicField(this, "owners", []);
        __publicField(this, "__layoutWidth", 0);
        __publicField(this, "__textBehaviour");
        __publicField(this, "__verAlign");
        __publicField(this, "__frame", { width: 0, height: 0 });
    }
    update(t4, e) {
        var _a2, _b, _c2, _d2, _e2, _f2, _g2;
        const i = ((e2) => {
            switch (e2) {
                case $t.Flexible:
                    return Number.MAX_VALUE;
                case $t.Fixed:
                case $t.FixWidthAndHeight:
                    return t4.width;
            }
        })(((_a2 = e.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible);
        if (this.__layoutWidth !== i) this.__layoutWidth = i, this.layout = void 0;
        else if (this.layout) {
            const i2 = this.layout;
            if (this.__frame.height !== t4.height || this.__verAlign !== (((_b = e.attr) == null ? void 0 : _b.verAlign) ?? Ut.Top)) {
                const i3 = ((e2) => {
                    switch (e2) {
                        case Ut.Top:
                            return 0;
                        case Ut.Middle:
                            return (t4.height - this.layout.contentHeight) / 2;
                        case Ut.Bottom:
                            return t4.height - this.layout.contentHeight;
                    }
                })(((_c2 = e.attr) == null ? void 0 : _c2.verAlign) ?? Ut.Top);
                this.layout.yOffset = i3;
            }
            const s = ((_d2 = e.attr) == null ? void 0 : _d2.textBehaviour) ?? $t.Flexible;
            if (this.__frame.width !== t4.width && s === $t.Flexible) {
                let s2 = Number.MAX_SAFE_INTEGER;
                for (let r = 0, n2 = e.paras.length; r < n2; r++) {
                    const n3 = e.paras[r], o2 = i2.paras[r];
                    switch (((_e2 = n3.attr) == null ? void 0 : _e2.alignment) ?? Xt.Left) {
                        case Xt.Centered:
                            s2 = Math.min(s2, -(o2.paraWidth - t4.width) / 2);
                            break;
                        case Xt.Left:
                        case Xt.Natural:
                            s2 = Math.min(s2, 0);
                            break;
                        case Xt.Justified:
                        case Xt.Right:
                            s2 = Math.min(s2, -(o2.paraWidth - t4.width));
                    }
                }
                i2.alignX = s2 === Number.MAX_SAFE_INTEGER ? 0 : s2;
            }
        }
        this.__frame.width = t4.width, this.__frame.height = t4.height, this.__textBehaviour = (_f2 = e.attr) == null ? void 0 : _f2.textBehaviour, this.__verAlign = (_g2 = e.attr) == null ? void 0 : _g2.verAlign;
    }
}
function Jr(t4, e, i) {
    var _a2;
    if (t4.layoutWidth !== i || t4.alignment !== e) {
        if (t4.alignment === Xt.Justified || t4.alignment === Xt.Natural) for (; ; ) {
            const s = t4[t4.length - 1], r = s[s.length - 1];
            let n2, o2;
            if (t4.length > 0 && (o2 = t4[0], n2 = o2[0]), !o2 || !n2) throw new Error("layout result wrong");
            let a2 = t4.graphCount;
            qr(r.char.charCodeAt(0)) && a2--;
            let h2 = false;
            if (1 === o2.length && ((_a2 = o2.attr) == null ? void 0 : _a2.placeholder) && (a2--, h2 = true), a2 <= 1) break;
            const c2 = i - t4.graphWidth - n2.x;
            if (e === Xt.Natural) {
                if (c2 > t4.graphWidth / a2) break;
            }
            const l2 = 1 === a2 ? 0 : c2 / (a2 - 1);
            let d2 = 0;
            for (let e2 = h2 ? 1 : 0, i2 = t4.length; e2 < i2; e2++) {
                const i3 = t4[e2];
                for (let t5 = 0, e3 = i3.length; t5 < e3; t5++) {
                    i3[t5].x -= d2, --a2, a2 > 0 && (d2 += l2);
                }
            }
            break;
        }
        Kr(t4, e, i);
    }
}
function Kr(t4, e, i) {
    var _a2;
    switch (e) {
        case Xt.Left:
            t4.x = 0;
            break;
        case Xt.Centered:
            t4.x = (i - t4.graphWidth) / 2;
            break;
        case Xt.Right: {
            let e2;
            if (t4.length > 0) {
                const i2 = t4[t4.length - 1];
                e2 = i2[i2.length - 1];
            }
            if (!e2) throw new Error("layout result wrong");
            const s = i - e2.x - e2.cw;
            t4.x = s;
            break;
        }
        case Xt.Natural:
        case Xt.Justified: {
            const s = t4[t4.length - 1], r = s[s.length - 1];
            let n2, o2;
            if (t4.x = 0, t4.length > 0 && (o2 = t4[0], n2 = o2[0]), !o2 || !n2) throw new Error("layout result wrong");
            let a2 = t4.graphCount;
            qr(r.char.charCodeAt(0)) && a2--;
            let h2 = false;
            if (1 === o2.length && ((_a2 = o2.attr) == null ? void 0 : _a2.placeholder) && (a2--, h2 = true), a2 <= 1) break;
            const c2 = i - t4.graphWidth - n2.x;
            if (e === Xt.Natural) {
                if (c2 > t4.graphWidth / a2) break;
            }
            let l2 = 0;
            const d2 = 1 === a2 ? 0 : c2 / (a2 - 1);
            for (let e2 = h2 ? 1 : 0, i2 = t4.length; e2 < i2; e2++) {
                const i3 = t4[e2];
                for (let t5 = 0, e3 = i3.length; t5 < e3; t5++) {
                    i3[t5].x += l2, --a2, a2 > 0 && (l2 += d2);
                }
            }
            break;
        }
    }
    t4.alignment = e, t4.layoutWidth = i;
}
function qr(t4) {
    switch (t4) {
        case 10:
        case 13:
        case 8232:
        case 8233:
            return true;
    }
    return false;
}
function Qr(t4, e) {
    const i = t4.charCodeAt(e);
    if (!(55296 <= i && i <= 56319)) return t4.charAt(e);
    const s = t4.charCodeAt(e + 1);
    if (!(56320 <= s && s <= 57343)) return t4.charAt(e);
    const r = t4.charCodeAt(e + 2);
    return 8205 === r ? String.fromCharCode(i, s, r) + Qr(t4, e + 3) : String.fromCharCode(i, s);
}
function tn(t4, e, i, s) {
    let r = 0;
    const n2 = function(t5, e2, i2, s2) {
        var _a2, _b, _c2, _d2;
        const r2 = p.text.textMeasure;
        let n3 = e2.spans, o3 = n3.length;
        if (0 === o3) {
            if (0 === e2.length) return [];
            o3 = 1, n3 = new G(new Ca(e2.length));
        }
        const a3 = ((_a2 = e2.attr) == null ? void 0 : _a2.kerning) ?? 0, h3 = e2.text;
        let c3 = 0;
        const l3 = h3.length;
        let d3 = 0, u = 0, f2 = n3[d3], g2 = (f2.italic ? "italic " : "normal ") + (f2.weight || 400) + " " + f2.fontSize + "px " + f2.fontName;
        const m2 = (((_b = e2.attr) == null ? void 0 : _b.indent) || 0) * Xr, _2 = Math.min(m2, i2), y2 = i2;
        let x2, w2 = _2, b2 = new Yr();
        const M2 = [];
        let v2 = d3;
        const S2 = ((_c2 = e2.attr) == null ? void 0 : _c2.transform) ?? ((_d2 = t5.attr) == null ? void 0 : _d2.transform);
        for (; c3 < l3; ) {
            if (d3 >= o3 && (d3 = o3 - 1), v2 !== d3 && (v2 = d3, f2 = n3[d3], g2 = (f2.italic ? "italic " : "normal ") + (f2.weight || 400) + " " + f2.fontSize + "px " + f2.fontName), 0 === f2.length && d3 < o3 - 1) {
                d3++;
                continue;
            }
            const t6 = Qr(h3, c3), i3 = t6.charCodeAt(0);
            if (1 === t6.length && qr(i3)) {
                let e3;
                if (x2 || (x2 = new Gr(), x2.attr = f2), x2.length > 0) e3 = x2[x2.length - 1];
                else if (b2.length > 0) {
                    const t7 = b2[b2.length - 1];
                    e3 = t7[t7.length - 1];
                }
                e3 && (w2 = e3.x + e3.cw), x2.push({ char: "\n", metrics: void 0, cw: 0, ch: f2.fontSize ?? 0, index: c3, x: w2, cc: 1 }), c3 += t6.length, u++, u >= f2.length && (u = 0, d3++), b2.push(x2), x2 = void 0, M2.push(b2), b2 = new Yr(), w2 = _2;
                continue;
            }
            const l4 = f2.kerning ?? a3;
            if (1 === t6.length && 0 === d3 && 42 === i3 && f2.placeholder && 1 === f2.length && f2.bulletNumbers) {
                const i4 = $r(e2, f2, f2.bulletNumbers, s2);
                i4.graph.x += w2, x2 || (x2 = new Gr(), x2.attr = f2), x2.push(i4.graph), w2 = i4.graph.x + i4.graph.cw + l4, c3 += t6.length, u++, u >= f2.length && (u = 0, d3++, b2.push(x2), x2 = void 0), M2.bulletNumbers = i4;
                continue;
            }
            const p2 = f2.transform ?? S2, m3 = Lr(t6, 0 === c3 || 1 === c3 && !!M2.bulletNumbers, p2), C3 = r2(m3, g2), T2 = (C3 == null ? void 0 : C3.width) ?? 0, I2 = f2.fontSize ?? 0, k = "number" != typeof I2 ? Number.parseFloat(I2) : I2;
            T2 + w2 <= y2 ? (x2 || (x2 = new Gr(), x2.attr = f2), x2.push({ char: m3, metrics: C3, cw: T2, ch: k, index: c3, x: w2, cc: t6.length }), w2 += T2 + l4, c3 += t6.length, u++, u >= f2.length && (u = 0, d3++, b2.push(x2), x2 = void 0)) : 0 !== b2.length || x2 && 0 !== x2.length ? (x2 && b2.push(x2), x2 = new Gr(), x2.attr = f2, M2.push(b2), b2 = new Yr(), w2 = _2, x2.push({ char: m3, metrics: C3, cw: T2, ch: k, index: c3, x: w2, cc: t6.length }), w2 += T2 + l4, c3 += t6.length, u++, u >= f2.length && (u = 0, d3++, b2.push(x2), x2 = void 0)) : (x2 || (x2 = new Gr(), x2.attr = f2), x2.push({ char: m3, metrics: C3, cw: T2, ch: k, index: c3, x: Math.max(0, y2 - T2), cc: t6.length }), b2.push(x2), x2 = void 0, M2.push(b2), b2 = new Yr(), w2 = _2, c3 += t6.length, u++, u >= f2.length && (u = 0, d3++));
        }
        return x2 && x2.length > 0 && b2.push(x2), b2.length > 0 && M2.push(b2), M2;
    }(t4, e, i, s), o2 = e.attr;
    let a2 = 0, h2 = 0, c2 = 0;
    const l2 = n2.map((t5) => {
        let e2 = t5.maxFontSize;
        o2 && o2.maximumLineHeight && (e2 = Math.min(o2.maximumLineHeight, e2)), o2 && o2.minimumLineHeight && (e2 = Math.max(o2.minimumLineHeight, e2));
        const i2 = a2;
        a2 += e2, h2 += t5.graphCount, c2 += t5.charCount, t5.y = i2, t5.lineHeight = e2;
        const s2 = t5[0][0], n3 = t5[t5.length - 1], l3 = n3[n3.length - 1];
        return t5.graphWidth = l3.x + l3.cw - s2.x, t5.lineWidth = l3.x + l3.cw, r = Math.max(t5.lineWidth + t5.x, r), t5;
    }), d2 = new Zr(...l2);
    return d2.paraHeight = a2, d2.graphCount = h2, d2.charCount = c2, d2.paraWidth = r, d2.bulletNumbers = n2.bulletNumbers, d2;
}
function en(t4, e, i) {
    var _a2, _b, _c2, _d2, _e2, _f2;
    const s = ((t5) => {
        switch (t5) {
            case $t.Flexible:
                return Number.MAX_VALUE;
            case $t.Fixed:
            case $t.FixWidthAndHeight:
                return e.width;
        }
    })(((_a2 = t4.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible), r = (_b = t4.attr) == null ? void 0 : _b.padding, n2 = (r == null ? void 0 : r.left) ?? 0, o2 = (r == null ? void 0 : r.top) ?? 0, a2 = (r == null ? void 0 : r.right) ?? 0, h2 = (r == null ? void 0 : r.bottom) ?? 0, c2 = [];
    let l2 = 0, d2 = 0;
    const p2 = [], u = s - n2 - a2;
    for (let e2 = 0, i2 = t4.paras.length; e2 < i2; e2++) {
        const i3 = tn(t4, t4.paras[e2], u, p2);
        if (e2 > 0) {
            const i4 = t4.paras[e2 - 1], s2 = ((_c2 = i4.attr) == null ? void 0 : _c2.paraSpacing) || 0;
            l2 += s2;
        }
        i3.yOffset = l2, l2 += i3.paraHeight, d2 = Math.max(i3.paraWidth, d2), c2.push(i3);
    }
    const f2 = ((_d2 = t4.attr) == null ? void 0 : _d2.textBehaviour) ?? $t.Flexible, g2 = f2 === $t.Flexible ? d2 : u;
    let m2 = Number.MAX_SAFE_INTEGER;
    for (let i2 = 0, s2 = t4.paras.length; i2 < s2; i2++) {
        const s3 = t4.paras[i2], r2 = c2[i2], n3 = ((_e2 = s3.attr) == null ? void 0 : _e2.alignment) ?? Xt.Left;
        for (let t5 = 0, e2 = r2.length; t5 < e2; t5++) {
            Kr(r2[t5], n3, g2);
        }
        if (f2 === $t.Flexible) switch (n3) {
            case Xt.Centered:
                m2 = Math.min(m2, -(r2.paraWidth - e.width) / 2);
                break;
            case Xt.Left:
            case Xt.Natural:
                m2 = Math.min(m2, 0);
                break;
            case Xt.Justified:
            case Xt.Right:
                m2 = Math.min(m2, -(r2.paraWidth - e.width));
        }
    }
    const _2 = ((t5) => {
        switch (t5) {
            case Ut.Top:
                return o2;
            case Ut.Middle:
                return (e.height - l2 - o2 - h2) / 2;
            case Ut.Bottom:
                return e.height - l2 - h2;
        }
    })(((_f2 = t4.attr) == null ? void 0 : _f2.verAlign) ?? Ut.Top);
    return { alignX: m2 === Number.MAX_SAFE_INTEGER ? 0 : m2, xOffset: n2, yOffset: _2, paras: c2, contentHeight: l2, contentWidth: d2 };
}
const sn = 1, rn = sn;
function nn(t4, e) {
    if (e && e.fmtVer < sn) {
        const e2 = t4, i = e2.frame, s = e2.isFlippedHorizontal, r = e2.isFlippedVertical, n2 = e2.rotation ?? 0;
        if (s || r || n2) {
            const t5 = new o(), a2 = i.width / 2, h2 = i.height / 2;
            t5.trans(-a2, -h2), n2 && t5.rotate(n2 / 360 * 2 * Math.PI), s && t5.flipHoriz(), r && t5.flipVert(), t5.trans(a2, h2), t5.trans(i.x, i.y), e2.size = { width: i.width, height: i.height };
            const c2 = new Ii(t5.m00, t5.m01, t5.m02, t5.m10, t5.m11, t5.m12);
            e2.transform = c2;
        } else {
            e2.size = { width: i.width, height: i.height };
            const t5 = new Ii();
            t5.m02 = i.x, t5.m12 = i.y, e2.transform = t5;
        }
    }
}
function on(t4) {
    return t4 instanceof Map ? t4 : { forEach: (e) => Object.keys(t4).forEach((i) => e(t4[i], i)) };
}
function an(t4, e) {
    return t4;
}
function hn(t4, e) {
    return new Kt(t4.length, t4.gap);
}
function cn(t4, e) {
    return new Ji(t4.alpha, t4.red, t4.green, t4.blue);
}
function ln(t4, e) {
    return new ee(an(t4.blenMode), t4.opacity);
}
function dn(t4, e) {
    return new ie(t4.lt, t4.rt, t4.lb, t4.rb);
}
function pn(t4, e) {
    const i = new G();
    return t4.forEach((t5, e2) => {
        i.push(t5);
    }), i;
}
function un(t4, e) {
    const i = t4;
    i.cornerRadius && (i.radius = i.cornerRadius), i.hasCurveFrom && (i.hasFrom = true, i.fromX = i.curveFrom.x, i.fromY = i.curveFrom.y), i.hasCurveTo && (i.hasTo = true, i.toX = i.curveTo.x, i.toY = i.curveTo.y), i.point && (i.x = i.point.x, i.y = i.point.y), i.curveMode && (i.mode = i.curveMode);
    const s = new se(pn(t4.crdtidx), t4.id, t4.x, t4.y, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.mode));
    return function(t5, e2, i2) {
        e2.radius && (t5.radius = e2.radius), e2.fromX && (t5.fromX = e2.fromX), e2.fromY && (t5.fromY = e2.fromY), e2.toX && (t5.toX = e2.toX), e2.toY && (t5.toY = e2.toY), e2.hasFrom && (t5.hasFrom = e2.hasFrom), e2.hasTo && (t5.hasTo = e2.hasTo);
    }(s, t4), s;
}
function fn(t4, e) {
    return t4;
}
function gn(t4, e) {
    const i = new G();
    return t4.forEach((t5, s) => {
        i.push((() => {
            if ("object" != typeof t5) return t5;
            if ("group-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Bo(t5, e);
            if ("image-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Co(t5, e);
            if ("path-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), po(t5, e);
            if ("path-shape2" === t5.typeId) return uo(t5, e);
            if ("rect-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), _o(t5, e);
            if ("symbol-ref-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), wo(t5, e);
            if ("symbol-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Do(t5, e);
            if ("symbol-union-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Wo(t5, e);
            if ("text-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), ho(t5, e);
            if ("artboard" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Fo(t5, e);
            if ("line-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Io(t5, e);
            if ("oval-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), Eo(t5, e);
            if ("table-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), ao(t5, e);
            if ("contact-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), bo(t5, e);
            if ("shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), function(t6, e2) {
                const i2 = new Oi(pn(t6.crdtidx), t6.id, t6.name, An(t6.type), On(t6.transform), eo(t6.style, e2));
                return no(i2, t6), i2;
            }(t5, e);
            if ("cutout-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), vo(t5, e);
            if ("bool-shape" === t5.typeId) return Oo(t5, e);
            if ("polygon-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), go(t5, e);
            if ("star-shape" === t5.typeId) return t5.crdtidx || (t5.crdtidx = [s]), xo(t5, e);
            throw new Error("unknow typeId: " + t5.typeId);
        })());
    }), i;
}
function mn(t4, e) {
    const i = new oe(function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(t6);
        }), i2;
    }(t4.crdtidx), t4.id, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.axis), t4.offset);
    return i;
}
function _n(t4, e) {
    return t4;
}
function yn(t4, e) {
    return t4;
}
function xn(t4, e) {
    const i = new he(/* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.position), function(t5, e2) {
        return new ae(t5.top, t5.bottom, t5.left, t5.right);
    }(t4.margin));
    return i;
}
function wn(t4, e) {
    const i = new le(pn(t4.crdtidx), t4.id, t4.name);
    return function(t5, e2, i2) {
        e2.versionId && (t5.versionId = e2.versionId);
    }(i, t4), i;
}
function bn(t4, e) {
    return new de(t4.exposure, t4.contrast, t4.saturation, t4.temperature, t4.tint, t4.shadow, t4.hue);
}
function Mn(t4, e) {
    const i = new pe(pn(t4.crdtidx), t4.id, function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(un(t6));
        }), i2;
    }(t4.points), t4.isClosed);
    return i;
}
function vn(t4, e) {
    const i = new G();
    return t4.forEach((t5, e2) => {
        t5.crdtidx || (t5.crdtidx = [e2]), i.push(Mn(t5));
    }), i;
}
function Sn(t4, e) {
    return new ue(t4.m00, t4.m01, t4.m02, t4.m10, t4.m11, t4.m12);
}
function Cn(t4, e) {
    return new fe(t4.x, t4.y);
}
function Tn(t4, e) {
    return new ge(t4.name, t4.desc);
}
function In(t4, e, i) {
    e.contextSettings && (t4.contextSettings = function(t5, e2) {
        return new ne(an(t5.blendMode), t5.opacity);
    }(e.contextSettings));
}
function kn(t4, e) {
    const i = new me(pn(t4.crdtidx), t4.id, t4.isEnabled, t4.blurRadius, cn(t4.color), t4.offsetX, t4.offsetY, t4.spread, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.position));
    return In(i, t4), i;
}
function En(t4, e) {
    return new ye(t4.width, t4.height);
}
function An(t4, e) {
    return t4;
}
function Fn(t4, e) {
    return new xe(pn(t4.crdtidx), t4.id, t4.position, cn(t4.color));
}
function Rn(t4, e) {
    const i = new G();
    return t4.forEach((t5, e2) => {
        i.push(function(t6, e3) {
            const i2 = new Ta(t6.text, function(t7, e4) {
                const i3 = new G();
                return t7.forEach((t8, e5) => {
                    i3.push(jn(t8));
                }), i3;
            }(t6.spans));
            return function(t7, e4, i3) {
                e4.attr && (t7.attr = Qn(e4.attr));
            }(i2, t6), i2;
        }(t5));
    }), i;
}
function On(t4, e) {
    return new Ii(t4.m00, t4.m01, t4.m02, t4.m10, t4.m11, t4.m12);
}
function Ln(t4, e) {
    const i = new ss(t4.isEnabled, Cn(t4.center), t4.saturation, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.type));
    return function(t5, e2, i2) {
        e2.motionAngle && (t5.motionAngle = e2.motionAngle), e2.radius && (t5.radius = e2.radius);
    }(i, t4), i;
}
function Pn(t4, e) {
    return new Me(/* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.sideType), t4.thicknessTop, t4.thicknessLeft, t4.thicknessBottom, t4.thicknessRight);
}
function Bn(t4, e) {
    return new ve(/* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.contactType), t4.shapeId);
}
function Nn(t4, e) {
    return new Se(pn(t4.crdtidx), t4.id, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.roleType), t4.shapeId);
}
function zn(t4, e) {
    return new Ce(t4.id, pn(t4.crdtidx), t4.value);
}
function Vn(t4, e) {
    const i = new Te(pn(t4.crdtidx), t4.id, t4.absoluteSize, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.fileFormat), t4.name, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.namingScheme), t4.scale, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.visibleScaleType));
    return i;
}
function Dn(t4, e) {
    const i = new Ie(function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(Vn(t6));
        }), i2;
    }(t4.exportFormats), t4.childOptions, t4.shouldTrim, t4.trimTransparent, t4.canvasBackground, t4.unfold);
    return i;
}
function Hn(t4, e) {
    const i = new Qi(Cn(t4.from), Cn(t4.to), /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.gradientType), function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(Fn(t6));
        }), i2;
    }(t4.stops));
    return function(t5, e2, i2) {
        e2.elipseLength && (t5.elipseLength = e2.elipseLength), e2.gradientOpacity && (t5.gradientOpacity = e2.gradientOpacity);
    }(i, t4), i;
}
function Wn(t4, e) {
    return new ke(/* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.backgroundType), cn(t4.backgroundColor));
}
function $n(t4, e, i) {
    e.targetNodeID && (t4.targetNodeID = e.targetNodeID), e.transitionType && (t4.transitionType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.transitionType)), e.transitionDuration && (t4.transitionDuration = e.transitionDuration), e.easingType && (t4.easingType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.easingType)), e.connectionURL && (t4.connectionURL = e.connectionURL), e.openUrlInNewTab && (t4.openUrlInNewTab = e.openUrlInNewTab), e.navigationType && (t4.navigationType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.navigationType)), e.easingFunction && (t4.easingFunction = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(t6);
        }), i2;
    }(e.easingFunction)), e.extraScrollOffset && (t4.extraScrollOffset = Cn(e.extraScrollOffset));
}
function Xn(t4, e) {
    const i = new Fr(/* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.connectionType));
    return $n(i, t4), i;
}
function Gn(t4, e) {
    const i = new Fe(function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(t6);
        }), i2;
    }(t4.crdtidx), t4.id, function(t5, e2) {
        const i2 = new Ae(/* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.interactionType));
        return function(t6, e3, i3) {
            e3.transitionTimeout && (t6.transitionTimeout = e3.transitionTimeout);
        }(i2, t5), i2;
    }(t4.event), Xn(t4.actions));
    return function(t5, e2, i2) {
        e2.typeId && (t5.typeId = e2.typeId), e2.isDeleted && (t5.isDeleted = e2.isDeleted);
    }(i, t4), i;
}
function Yn(t4, e, i) {
    e.fontName && (t4.fontName = e.fontName), e.fontSize && (t4.fontSize = e.fontSize), e.color && (t4.color = cn(e.color)), e.strikethrough && (t4.strikethrough = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.strikethrough)), e.underline && (t4.underline = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.underline)), e.weight && (t4.weight = e.weight), e.italic && (t4.italic = e.italic), e.bulletNumbers && (t4.bulletNumbers = function(t5, e2) {
        const i2 = new qt(/* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.type));
        return function(t6, e3, i3) {
            e3.behavior && (t6.behavior = /* @__PURE__ */ function(t7, e4) {
                return t7;
            }(e3.behavior)), e3.offset && (t6.offset = e3.offset);
        }(i2, t5), i2;
    }(e.bulletNumbers)), e.highlight && (t4.highlight = cn(e.highlight)), e.kerning && (t4.kerning = e.kerning), e.transform && (t4.transform = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.transform)), e.placeholder && (t4.placeholder = e.placeholder), e.fillType && (t4.fillType = fn(e.fillType)), e.gradient && (t4.gradient = Hn(e.gradient));
}
function Un(t4, e) {
    const i = new ba();
    return Yn(i, t4), i;
}
const Zn = Yn;
function jn(t4, e) {
    const i = new Ca(t4.length);
    return Zn(i, t4), i;
}
function Jn(t4, e) {
    t4.sideSetting || (t4.sideSetting = { sideType: Dt.Normal, thicknessTop: t4.thickness, thicknessLeft: t4.thickness, thicknessBottom: t4.thickness, thicknessRight: t4.thickness });
    const i = new ts(pn(t4.crdtidx), t4.id, t4.isEnabled, fn(t4.fillType), cn(t4.color), /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.position), t4.thickness, hn(t4.borderStyle), /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.cornerType), Pn(t4.sideSetting));
    return function(t5, e2, i2) {
        e2.contextSettings && (t5.contextSettings = ln(e2.contextSettings)), e2.gradient && (t5.gradient = Hn(e2.gradient)), e2.imageRef && (t5.imageRef = e2.imageRef), e2.imageScaleMode && (t5.imageScaleMode = _n(e2.imageScaleMode)), e2.rotation && (t5.rotation = e2.rotation), e2.scale && (t5.scale = e2.scale), e2.originalImageWidth && (t5.originalImageWidth = e2.originalImageWidth), e2.originalImageHeight && (t5.originalImageHeight = e2.originalImageHeight), e2.paintFilter && (t5.paintFilter = bn(e2.paintFilter)), e2.transform && (t5.transform = Sn(e2.transform));
    }(i, t4), i;
}
function Kn(t4, e) {
    const i = new es(pn(t4.crdtidx), t4.id, t4.isEnabled, fn(t4.fillType), cn(t4.color));
    return function(t5, e2, i2) {
        e2.contextSettings && (t5.contextSettings = ln(e2.contextSettings)), e2.gradient && (t5.gradient = Hn(e2.gradient)), e2.imageRef && (t5.imageRef = e2.imageRef), e2.fillRule && (t5.fillRule = /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(e2.fillRule)), e2.imageScaleMode && (t5.imageScaleMode = _n(e2.imageScaleMode)), e2.rotation && (t5.rotation = e2.rotation), e2.scale && (t5.scale = e2.scale), e2.originalImageWidth && (t5.originalImageWidth = e2.originalImageWidth), e2.originalImageHeight && (t5.originalImageHeight = e2.originalImageHeight), e2.paintFilter && (t5.paintFilter = bn(e2.paintFilter)), e2.transform && (t5.transform = Sn(e2.transform));
    }(i, t4), (e == null ? void 0 : e.document) && i.setImageMgr(e.document.mediasMgr), i;
}
function qn(t4, e, i) {
    Yn(t4, e), e.alignment && (t4.alignment = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.alignment)), e.paraSpacing && (t4.paraSpacing = e.paraSpacing), e.minimumLineHeight && (t4.minimumLineHeight = e.minimumLineHeight), e.maximumLineHeight && (t4.maximumLineHeight = e.maximumLineHeight), e.indent && (t4.indent = e.indent);
}
function Qn(t4, e) {
    const i = new Ma();
    return qn(i, t4), i;
}
function to(t4, e, i) {
    e.miterLimit && (t4.miterLimit = e.miterLimit), e.windingRule && (t4.windingRule = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.windingRule)), e.blur && (t4.blur = Ln(e.blur)), e.borderOptions && (t4.borderOptions = function(t5, e2) {
        const i2 = new be(t5.isEnabled, /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.lineCapStyle), /* @__PURE__ */ function(t6, e3) {
            return t6;
        }(t5.lineJoinStyle));
        return i2;
    }(e.borderOptions)), e.colorControls && (t4.colorControls = function(t5, e2) {
        return new Qt(t5.isEnabled, t5.brightness, t5.contrast, t5.hue, t5.saturation);
    }(e.colorControls)), e.contextSettings && (t4.contextSettings = ln(e.contextSettings)), e.innerShadows && (t4.innerShadows = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(kn(t6));
        }), i2;
    }(e.innerShadows)), e.contacts && (t4.contacts = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(Nn(t6));
        }), i2;
    }(e.contacts)), e.startMarkerType && (t4.startMarkerType = yn(e.startMarkerType)), e.endMarkerType && (t4.endMarkerType = yn(e.endMarkerType)), e.varbinds && (t4.varbinds = (() => {
        const t5 = new Y();
        return on(e.varbinds).forEach((e2, i2) => {
            t5.set(i2, e2);
        }), t5;
    })());
}
function eo(t4, e) {
    const i = new is(function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(Jn(t6));
        }), i2;
    }(t4.borders), function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, s) => {
            t6.crdtidx || (t6.crdtidx = [s]), i2.push(Kn(t6, e2));
        }), i2;
    }(t4.fills, e), function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(kn(t6));
        }), i2;
    }(t4.shadows));
    return to(i, t4), i;
}
function io(t4, e, i) {
    qn(t4, e), e.verAlign && (t4.verAlign = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.verAlign)), e.orientation && (t4.orientation = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.orientation)), e.textBehaviour && (t4.textBehaviour = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.textBehaviour)), e.padding && (t4.padding = function(t5, e2) {
        const i2 = new ce();
        return function(t6, e3, i3) {
            e3.left && (t6.left = e3.left), e3.top && (t6.top = e3.top), e3.right && (t6.right = e3.right), e3.bottom && (t6.bottom = e3.bottom);
        }(i2, t5), i2;
    }(e.padding));
}
function so(t4, e) {
    const i = t4;
    "boolean" == typeof i.bold && (i.bold = i.bold ? 700 : 400), i.bold && (i.weight = i.bold);
    const s = new va();
    return io(s, t4), s;
}
function ro(t4, e) {
    const i = new Ia(Rn(t4.paras));
    return function(t5, e2, i2) {
        e2.attr && (t5.attr = so(e2.attr));
    }(i, t4), i;
}
function no(t4, e, i) {
    e.boolOp && (t4.boolOp = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.boolOp)), e.isFixedToViewport && (t4.isFixedToViewport = e.isFixedToViewport), e.isLocked && (t4.isLocked = e.isLocked), e.isVisible && (t4.isVisible = e.isVisible), e.exportOptions && (t4.exportOptions = Dn(e.exportOptions)), e.nameIsFixed && (t4.nameIsFixed = e.nameIsFixed), e.resizingConstraint && (t4.resizingConstraint = e.resizingConstraint), e.resizingType && (t4.resizingType = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.resizingType)), e.constrainerProportions && (t4.constrainerProportions = e.constrainerProportions), e.clippingMaskMode && (t4.clippingMaskMode = e.clippingMaskMode), e.hasClippingMask && (t4.hasClippingMask = e.hasClippingMask), e.shouldBreakMaskChain && (t4.shouldBreakMaskChain = e.shouldBreakMaskChain), e.varbinds && (t4.varbinds = (() => {
        const t5 = new Y();
        return on(e.varbinds).forEach((e2, i2) => {
            t5.set(i2, e2);
        }), t5;
    })()), e.haveEdit && (t4.haveEdit = e.haveEdit), e.prototypeStartingPoint && (t4.prototypeStartingPoint = Tn(e.prototypeStartingPoint)), e.prototypeInteractions && (t4.prototypeInteractions = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(Gn(t6));
        }), i2;
    }(e.prototypeInteractions)), e.overlayPosition && (t4.overlayPosition = xn(e.overlayPosition)), e.overlayBackgroundInteraction && (t4.overlayBackgroundInteraction = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.overlayBackgroundInteraction)), e.overlayBackgroundAppearance && (t4.overlayBackgroundAppearance = Wn(e.overlayBackgroundAppearance)), e.scrollDirection && (t4.scrollDirection = /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(e.scrollDirection)), e.mask && (t4.mask = e.mask);
}
function oo(t4, e) {
    t4.crdtidx || (t4.crdtidx = []), t4.text || (t4.text = { typeId: "text", paras: [{ text: "\n", spans: [{ fontName: "PingFang SC", fontSize: 14, length: 1, color: { typeId: "color", alpha: 0.85, red: 0, green: 0, blue: 0 } }], attr: { minimumLineHeight: 24 } }], attr: { textBehaviour: $t.Fixed, padding: { left: 5, top: 0, right: 3, bottom: 0 } } }), nn(t4, e);
    const i = new ka(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.cellType), ro(t4.text));
    return function(t5, e2, i2) {
        no(t5, e2), e2.imageRef && (t5.imageRef = e2.imageRef), e2.rowSpan && (t5.rowSpan = e2.rowSpan), e2.colSpan && (t5.colSpan = e2.colSpan);
    }(i, t4), i;
}
function ao(e, i) {
    if (e.datas || e.childs) {
        e.colWidths = e.colWidths.map((e2, i3) => ({ id: v4(), crdtidx: [i3], value: e2 })), e.rowHeights = e.rowHeights.map((e2, i3) => ({ id: v4(), crdtidx: [i3], value: e2 }));
        const i2 = e.colWidths.length, s2 = e.rowHeights.length, r = e.datas || e.childs, n2 = {};
        for (let t4 = 0; t4 < r.length; ++t4) {
            const o2 = r[t4];
            if (!o2) continue;
            const a2 = Math.floor(t4 / i2), h2 = t4 % i2;
            if (a2 >= s2) break;
            const c2 = e.rowHeights[a2].id + "," + e.colWidths[h2].id;
            n2[c2] = o2, o2.id = c2;
        }
        e.cells = n2;
    }
    nn(e, i);
    const s = new Ea(pn(e.crdtidx), e.id, e.name, An(e.type), On(e.transform), eo(e.style, i), En(e.size), (() => {
        const t4 = new Y();
        return on(e.cells).forEach((e2, s2) => {
            t4.set(s2, oo(e2, i));
        }), t4;
    })(), function(t4, e2) {
        const i2 = new G();
        return t4.forEach((t5, e3) => {
            i2.push(zn(t5));
        }), i2;
    }(e.rowHeights), function(t4, e2) {
        const i2 = new G();
        return t4.forEach((t5, e3) => {
            i2.push(zn(t5));
        }), i2;
    }(e.colWidths));
    return function(t4, e2, i2) {
        no(t4, e2), e2.textAttr && (t4.textAttr = so(e2.textAttr));
    }(s, e), (i == null ? void 0 : i.document) && s.setImageMgr(i.document.mediasMgr), s;
}
function ho(t4, e) {
    nn(t4, e);
    const i = new Gi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), ro(t4.text));
    return function(t5, e2, i2) {
        no(t5, e2), e2.fixedRadius && (t5.fixedRadius = e2.fixedRadius);
    }(i, t4), i;
}
function co(t4, e) {
    const i = new Ri(t4.id, /* @__PURE__ */ function(t5, e2) {
        return t5;
    }(t4.type), t4.name, (() => {
        if ("object" != typeof t4.value) return t4.value;
        if (Array.isArray(t4.value)) return function(t5, e2) {
            const i2 = new G();
            return t5.forEach((t6, s) => {
                i2.push((() => {
                    if ("object" != typeof t6) return t6;
                    if ("border" === t6.typeId) return t6.crdtidx || (t6.crdtidx = [s]), Jn(t6);
                    if ("fill" === t6.typeId) return t6.crdtidx || (t6.crdtidx = [s]), Kn(t6, e2);
                    if ("shadow" === t6.typeId) return t6.crdtidx || (t6.crdtidx = [s]), kn(t6);
                    if ("prototype-inter-action" === t6.typeId) return Gn(t6);
                    throw new Error("unknow typeId: " + t6.typeId);
                })());
            }), i2;
        }(t4.value, e);
        if ("color" === t4.value.typeId) return cn(t4.value);
        if ("text" === t4.value.typeId) return ro(t4.value);
        if ("gradient" === t4.value.typeId) return Hn(t4.value);
        if ("style" === t4.value.typeId) return eo(t4.value, e);
        if ("context-settings" === t4.value.typeId) return ln(t4.value);
        if ("table-cell" === t4.value.typeId) return oo(t4.value, e);
        if ("export-options" === t4.value.typeId) return Dn(t4.value);
        if ("corner-radius" === t4.value.typeId) return dn(t4.value);
        if ("blur" === t4.value.typeId) return Ln(t4.value);
        throw new Error("unknow typeId: " + t4.value.typeId);
    })());
    return i;
}
function lo(t4, e, i) {
    no(t4, e), e.fixedRadius && (t4.fixedRadius = e.fixedRadius);
}
function po(t4, e) {
    var _a2, _b;
    if (!((_a2 = t4.pathsegs) == null ? void 0 : _a2.length)) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: true };
        ((_b = t4 == null ? void 0 : t4.points) == null ? void 0 : _b.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new Vi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs));
    return lo(i, t4), i;
}
function uo(t4, e) {
    nn(t4, e);
    const i = new Di(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(Mn(t6));
        }), i2;
    }(t4.pathsegs));
    return function(t5, e2, i2) {
        no(t5, e2), e2.fixedRadius && (t5.fixedRadius = e2.fixedRadius);
    }(i, t4), i;
}
const fo = lo;
function go(t4, e) {
    nn(t4, e);
    const i = new Ui(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs), t4.counts);
    return fo(i, t4), i;
}
const mo = lo;
function _o(t4, e) {
    var _a2, _b;
    if (!((_a2 = t4.pathsegs) == null ? void 0 : _a2.length)) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: true };
        ((_b = t4 == null ? void 0 : t4.points) == null ? void 0 : _b.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new Hi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs));
    return mo(i, t4), i;
}
const yo = lo;
function xo(t4, e) {
    nn(t4, e);
    const i = new Zi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs), t4.counts, t4.innerAngle);
    return yo(i, t4), i;
}
function wo(t4, e) {
    t4.variables || (t4.variables = {}), t4.virbindsEx && (t4.overrides = t4.virbindsEx), nn(t4, e);
    const i = new Ar(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), t4.refId, (() => {
        const i2 = new Y();
        return on(t4.variables).forEach((t5, s) => {
            i2.set(s, co(t5, e));
        }), i2;
    })());
    return function(t5, e2, i2) {
        no(t5, e2), e2.overrides && (t5.overrides = (() => {
            const t6 = new Y();
            return on(e2.overrides).forEach((e3, i3) => {
                t6.set(i3, e3);
            }), t6;
        })()), e2.isCustomSize && (t5.isCustomSize = e2.isCustomSize), e2.cornerRadius && (t5.cornerRadius = dn(e2.cornerRadius));
    }(i, t4), (e == null ? void 0 : e.document) && (i.setSymbolMgr(e.document.symbolsMgr), i.setImageMgr(e.document.mediasMgr)), i;
}
function bo(t4, e) {
    var _a2, _b, _c2;
    if ((_a2 = t4.pathsegs) == null ? void 0 : _a2.length) ((_b = t4 == null ? void 0 : t4.pathsegs[0]) == null ? void 0 : _b.isClosed) && (t4.pathsegs[0].isClosed = false);
    else {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: false };
        ((_c2 = t4 == null ? void 0 : t4.points) == null ? void 0 : _c2.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new Cs(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs), t4.isEdited, ro(t4.text), t4.mark);
    return function(t5, e2, i2) {
        lo(t5, e2), e2.from && (t5.from = Bn(e2.from)), e2.to && (t5.to = Bn(e2.to));
    }(i, t4), i;
}
const Mo = lo;
function vo(t4, e) {
    var _a2, _b;
    if (!((_a2 = t4.pathsegs) == null ? void 0 : _a2.length)) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: true };
        ((_b = t4 == null ? void 0 : t4.points) == null ? void 0 : _b.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new Yi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs));
    return Mo(i, t4), i;
}
const So = lo;
function Co(t4, e) {
    const i = t4.size ?? t4.frame, s = { typeId: "fill", color: { typeId: "color", alpha: 1, blue: 216, green: 216, red: 216 }, crdtidx: [0], fillType: xt.Pattern, id: "bdcd3743-fb61-4aeb-8864-b95d47b84a90", imageRef: t4.imageRef, isEnabled: true, imageScaleMode: Mt.Fill, originalImageHeight: i.height, originalImageWidth: i.width };
    if (t4.style.fills = [s], !t4.pathsegs) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: true };
        if (t4 == null ? void 0 : t4.points.length) e2.points.push(...t4 == null ? void 0 : t4.points);
        else {
            const t5 = "62ea3ee3-3378-4602-a918-7e05f426bb8e", i2 = "1519da3c-c692-4e1d-beb4-01a85cc56738", s2 = "e857f541-4e7f-491b-96e6-2ca38f1d4c09", r2 = { crdtidx: [0], id: "b259921b-4eba-461d-afc3-c4c58c1fa337", mode: ft.Straight, x: 0, y: 0 }, n2 = { crdtidx: [1], id: t5, mode: ft.Straight, x: 1, y: 0 }, o2 = { crdtidx: [2], id: i2, mode: ft.Straight, x: 1, y: 1 }, a2 = { crdtidx: [3], id: s2, mode: ft.Straight, x: 0, y: 1 };
            e2.points.push(r2, n2, o2, a2);
        }
        t4.pathsegs = [e2];
    }
    nn(t4, e);
    const r = new Wi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs), t4.imageRef);
    return So(r, t4), r;
}
const To = lo;
function Io(t4, e) {
    var _a2, _b;
    if (!((_a2 = t4.pathsegs) == null ? void 0 : _a2.length)) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: false };
        ((_b = t4 == null ? void 0 : t4.points) == null ? void 0 : _b.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new Xi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs));
    return To(i, t4), i;
}
const ko = lo;
function Eo(t4, e) {
    var _a2, _b;
    if (!((_a2 = t4.pathsegs) == null ? void 0 : _a2.length)) {
        const e2 = { crdtidx: [0], id: "39e508e8-a1bb-4b55-ad68-aa2a9b3b447a", points: [], isClosed: true };
        ((_b = t4 == null ? void 0 : t4.points) == null ? void 0 : _b.length) && e2.points.push(...t4 == null ? void 0 : t4.points), t4.pathsegs = [e2];
    }
    nn(t4, e);
    const i = new $i(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), En(t4.size), vn(t4.pathsegs), function(t5, e2) {
        return new re(t5.cx, t5.cy, t5.rx, t5.ry);
    }(t4.ellipse));
    return ko(i, t4), i;
}
function Ao(t4, e, i) {
    Po(t4, e), e.cornerRadius && (t4.cornerRadius = dn(e.cornerRadius)), e.guides && (t4.guides = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(mn(t6));
        }), i2;
    }(e.guides));
}
function Fo(t4, e) {
    nn(t4, e);
    const i = new ji(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e), En(t4.size));
    return Ao(i, t4), i;
}
const Ro = Po;
function Oo(t4, e) {
    nn(t4, e);
    const i = new Pi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e));
    return Ro(i, t4), i;
}
function Lo(t4, e) {
    t4.symbolregist || (t4.symbolregist = {});
    const i = new Oe(t4.id, t4.name, t4.fmtVer, function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            t6.crdtidx || (t6.crdtidx = [e3]), i2.push(wn(t6));
        }), i2;
    }(t4.pagesList), t4.lastCmdId, (() => {
        const e2 = new Y();
        return on(t4.symbolregist).forEach((t5, i2) => {
            e2.set(i2, t5);
        }), e2;
    })());
    return function(t5, e2, i2) {
        e2.freesymbols && (t5.freesymbols = (() => {
            const t6 = new Y();
            return on(e2.freesymbols).forEach((e3, s) => {
                t6.set(s, (() => {
                    if ("object" != typeof e3) return e3;
                    if ("symbol-shape" === e3.typeId) return Do(e3, i2);
                    if ("symbol-union-shape" === e3.typeId) return Wo(e3, i2);
                    throw new Error("unknow typeId: " + e3.typeId);
                })());
            }), t6;
        })());
    }(i, t4, e), i;
}
function Po(t4, e, i) {
    no(t4, e), e.fixedRadius && (t4.fixedRadius = e.fixedRadius);
}
function Bo(t4, e) {
    if (t4.isBoolOpShape) return t4.typeId = "bool-shape", t4.type = Vt.BoolShape, Oo(t4, e);
    nn(t4, e);
    const i = new Li(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e));
    return Po(i, t4), i;
}
function No(t4, e, i) {
    Po(t4, e), e.backgroundColor && (t4.backgroundColor = cn(e.backgroundColor)), e.guides && (t4.guides = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(mn(t6));
        }), i2;
    }(e.guides));
}
function zo(t4, e) {
    t4.crdtidx || (t4.crdtidx = []), nn(t4, e);
    const i = new qi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e));
    return No(i, t4), i;
}
function Vo(t4, e, i) {
    Po(t4, e), e.symtags && (t4.symtags = (() => {
        const t5 = new Y();
        return on(e.symtags).forEach((e2, i2) => {
            t5.set(i2, e2);
        }), t5;
    })()), e.cornerRadius && (t4.cornerRadius = dn(e.cornerRadius)), e.guides && (t4.guides = function(t5, e2) {
        const i2 = new G();
        return t5.forEach((t6, e3) => {
            i2.push(mn(t6));
        }), i2;
    }(e.guides));
}
function Do(t4, e) {
    nn(t4, e);
    const i = new Ni(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e), En(t4.size), (() => {
        const i2 = new Y();
        return on(t4.variables).forEach((t5, s) => {
            i2.set(s, co(t5, e));
        }), i2;
    })());
    return Vo(i, t4), (e == null ? void 0 : e.document) && (e.document.symbolregist.get(i.id), e.document.symbolsMgr.add(i.id, i)), i;
}
const Ho = Vo;
function Wo(t4, e) {
    nn(t4, e);
    const i = new zi(pn(t4.crdtidx), t4.id, t4.name, An(t4.type), On(t4.transform), eo(t4.style, e), gn(t4.childs, e), En(t4.size), (() => {
        const i2 = new Y();
        return on(t4.variables).forEach((t5, s) => {
            i2.set(s, co(t5, e));
        }), i2;
    })());
    return Ho(i, t4), i;
}
function $o(t4, e, i, s, r) {
    for (; s > 0 && e < t4.length; ) {
        const n2 = t4[e], o2 = Math.min(n2.length, i + s);
        r(n2, i, o2 - i), s -= o2 - i, i = 0, e++;
    }
}
function Xo(t4, e, i, s) {
    for (let r = 0, n2 = t4.length; r < n2; r++) {
        const n3 = t4[r];
        if (e < n3.length) {
            $o(t4, r, e, i, s);
            break;
        }
        e -= n3.length;
    }
}
function Go(t4, e, i, s, r, n2) {
    for (; s > 0 && e < t4.length; ) {
        const o2 = t4[e], a2 = Math.min(o2.length, i + s);
        r(t4, e, o2, i, a2 - i), n2 && Xo(o2.spans, i, s, n2), s -= a2 - i, i = 0, e++;
    }
}
function Yo(t4, e, i, s, r) {
    for (let n2 = 0, o2 = t4.length; n2 < o2; n2++) {
        const o3 = t4[n2];
        if (e < o3.length) {
            Go(t4, n2, e, i, s, r);
            break;
        }
        e -= o3.length;
    }
}
const Uo = (t4, e) => {
    if (t4.gradientType !== e.gradientType || t4.elipseLength !== e.elipseLength || t4.gradientOpacity !== e.gradientOpacity) return false;
    if (t4.from.x !== e.from.x || t4.from.y !== e.from.y || t4.to.x !== e.to.x || t4.to.y !== e.to.y) return false;
    if (t4.stops.length !== e.stops.length) return false;
    for (let i = 0; i < t4.stops.length; i++) {
        const s = t4.stops[i], r = e.stops[i];
        if (s.position !== r.position || !s.color.equals(r.color)) return false;
    }
    return true;
};
function Zo(t4, e) {
    if (e.color) {
        if (!t4.color) return true;
        if (!e.color.equals(t4.color)) return true;
    } else if (t4.color) return true;
    if (e.highlight) {
        if (!t4.highlight) return true;
        if (!e.highlight.equals(t4.highlight)) return true;
    } else if (t4.highlight) return true;
    if (e.fontName !== t4.fontName) return true;
    if (e.fontSize !== t4.fontSize) return true;
    if (e.weight !== t4.weight) return true;
    if (!!e.italic != !!t4.italic) return true;
    if (e.underline !== t4.underline) return true;
    if (e.strikethrough !== t4.strikethrough) return true;
    if (e.kerning !== t4.kerning) return true;
    if (e.transform !== t4.transform) return true;
    if (e.bulletNumbers && !t4.bulletNumbers || !e.bulletNumbers && t4.bulletNumbers) return true;
    if (e.bulletNumbers && t4.bulletNumbers) {
        if (e.bulletNumbers.type !== t4.bulletNumbers.type) return true;
        if (e.bulletNumbers.offset !== t4.bulletNumbers.offset) return true;
        if (e.bulletNumbers.behavior !== t4.bulletNumbers.behavior) return true;
    }
    if (!!e.placeholder != !!t4.placeholder) return true;
    if (e.fillType !== t4.fillType) return true;
    if (e.gradient) {
        if (!t4.gradient) return true;
        if (!Uo(t4.gradient, e.gradient)) return true;
    } else if (t4.gradient) return true;
    return false;
}
function jo(t4, e, i) {
    Jo(t4, e, i);
}
function Jo(t4, e, i) {
    let s = false;
    if (e.color && (t4.color && e.color.equals(t4.color) || (t4.color = new Ji(e.color.alpha, e.color.red, e.color.green, e.color.blue), s = true)), e.highlight && (t4.highlight && e.highlight.equals(t4.highlight) || (t4.highlight = new Ji(e.highlight.alpha, e.highlight.red, e.highlight.green, e.highlight.blue), s = true)), e.fontName && (t4.fontName && e.fontName === t4.fontName || (t4.fontName = e.fontName, s = true)), e.fontSize && (t4.fontSize && e.fontSize === t4.fontSize || (t4.fontSize = e.fontSize, s = true)), void 0 !== e.weight && (t4.weight && t4.weight === e.weight || (t4.weight = e.weight, s = true)), void 0 !== e.italic && !!t4.italic !== e.italic && (t4.italic = !!e.italic || void 0, s = true), e.underline) {
        const i2 = e.underline === Zt.None ? void 0 : e.underline;
        i2 !== t4.underline && (t4.underline = i2, s = true);
    }
    if (e.strikethrough) {
        (e.strikethrough === Ht.None ? void 0 : e.strikethrough) !== t4.strikethrough && (t4.strikethrough = e.strikethrough === Ht.None ? void 0 : e.strikethrough, s = true);
    }
    return null != e.kerning && (null != t4.kerning && t4.kerning === e.kerning || (t4.kerning = e.kerning, s = true)), null != e.transform && (null != t4.transform && t4.transform === e.transform || (t4.transform = e.transform, s = true)), e.placeholder && i && (t4.placeholder || (t4.placeholder = true, s = true), e.bulletNumbers && (t4.bulletNumbers || (t4.bulletNumbers = new qt(e.bulletNumbers.type), s = true), e.bulletNumbers.type !== t4.bulletNumbers.type && (t4.bulletNumbers.type = e.bulletNumbers.type, s = true), e.bulletNumbers.offset !== t4.bulletNumbers.offset && (t4.bulletNumbers.offset = e.bulletNumbers.offset, s = true), e.bulletNumbers.behavior !== t4.bulletNumbers.behavior && (t4.bulletNumbers.behavior = e.bulletNumbers.behavior, s = true))), e.fillType && (t4.fillType && e.fillType === t4.fillType || (t4.fillType = e.fillType, s = true)), e.gradient && (t4.gradient && Uo(t4.gradient, e.gradient) || (t4.gradient = new Qi(e.gradient.from, e.gradient.to, e.gradient.gradientType, e.gradient.stops, e.gradient.elipseLength, e.gradient.gradientOpacity), s = true)), s;
}
function Ko(t4, e) {
    const i = e instanceof Ma ? e : e.attr;
    if (t4 instanceof Ta) {
        if (!t4.attr) return i && (t4.attr = Qn(i)), !!i;
        if (i) return qo(t4.attr, i);
    } else if (i) return qo(t4, i);
    return false;
}
function qo(t4, e) {
    let i = false;
    return i = Jo(t4, e), null != e.minimumLineHeight && (null != t4.minimumLineHeight && t4.minimumLineHeight === e.minimumLineHeight || (t4.minimumLineHeight = e.minimumLineHeight, i = true)), null != e.maximumLineHeight && (null != t4.maximumLineHeight && t4.maximumLineHeight === e.maximumLineHeight || (t4.maximumLineHeight = e.maximumLineHeight, i = true)), null != e.paraSpacing && (null != t4.paraSpacing && t4.paraSpacing === e.paraSpacing || (t4.paraSpacing = e.paraSpacing, i = true)), null != e.alignment && (null != t4.alignment && t4.alignment === e.alignment || (t4.alignment = e.alignment, i = true)), null != e.indent && (null != t4.indent && t4.indent === e.indent || (t4.indent = e.indent, i = true)), i;
}
function Qo(t4, e) {
    t4.attr ? (qo(t4.attr, e), e.verAlign && (t4.attr.verAlign = e.verAlign), e.orientation && (t4.attr.orientation = e.orientation), e.textBehaviour && (t4.attr.textBehaviour = e.textBehaviour)) : t4.attr = so(e);
}
function ta(t4) {
    const e = new Ia(new G()), i = new Ta("\n", new G());
    i.attr = new Ma(), i.attr.minimumLineHeight = 24, e.paras.push(i);
    const s = new Ca(i.length);
    return s.fontName = Ss() ? "PingFang SC" : "微软雅黑", s.fontSize = 14, s.color = new Ji(1, 51, 51, 51), i.spans.push(s), t4 && (Qo(e, t4), Ko(i, t4), jo(s, t4)), e;
}
function ea(t4, e, i) {
    const s = new Ia(new G()), r = new Ta("\n", new G());
    r.attr = new Ma(), r.attr.minimumLineHeight = 24, s.paras.push(r);
    const n2 = new Ca(r.length);
    return n2.fontName = Ss() ? "PingFang SC" : "微软雅黑", n2.fontSize = 14, n2.color = new Ji(0.85, 0, 0, 0), r.spans.push(n2), t4 && (Qo(s, t4), Ko(r, t4), jo(n2, t4)), e && Ko(r, e), i && jo(n2, i), s;
}
function ia(t4) {
    const e = ta(t4);
    return e.setTextBehaviour($t.Fixed), e.setPadding(5, 0, 3, 0), e;
}
function sa(t4, e, i, s, r) {
    const n2 = t4.spans;
    t4.text = t4.text.slice(0, i) + e + t4.text.slice(i);
    for (let o2 = 0, a2 = 0, h2 = n2.length, c2 = i; a2 < h2; a2++) {
        let i2 = n2[a2];
        if (o2 += i2.length, 0 === c2) {
            if (r || i2.placeholder) {
                const t5 = new Ca(e.length);
                if ("simple" === s && jo(t5, i2), r && jo(t5, r, true), i2.placeholder || t5.placeholder || Zo(i2, t5)) {
                    n2.splice(a2, 0, t5);
                    break;
                }
            }
            i2.length += e.length;
            break;
        }
        if (c2 < i2.length) {
            if (r) {
                const t5 = new Ca(e.length);
                if ("simple" === s && jo(t5, i2), jo(t5, r, true), i2.placeholder || t5.placeholder || Zo(i2, t5)) {
                    const e2 = new Ca(i2.length - c2);
                    jo(e2, i2), i2.length = c2, n2.splice(a2 + 1, 0, t5, e2);
                    break;
                }
            }
            i2.length += e.length;
            break;
        }
        if (c2 === i2.length) {
            if (r || i2.placeholder) {
                const t5 = new Ca(e.length);
                if ("simple" === s && jo(t5, i2), r && jo(t5, r, true), i2.placeholder || t5.placeholder || Zo(i2, t5)) {
                    n2.splice(a2 + 1, 0, t5);
                    break;
                }
            }
            i2.length += e.length;
            break;
        }
        if (a2 === h2 - 1) {
            if (i2.placeholder) {
                const s2 = new Ca(t4.length - e.length - o2);
                jo(s2, i2), n2.splice(a2 + 1, 0, s2), a2++, i2 = n2[a2];
            } else i2.length += t4.length - e.length - o2;
            if (r || i2.placeholder) {
                const t5 = new Ca(e.length);
                if ("simple" === s && jo(t5, i2), r && jo(t5, r, true), i2.placeholder || t5.placeholder || Zo(i2, t5)) {
                    n2.splice(a2 + 1, 0, t5);
                    break;
                }
            }
            i2.length += e.length;
            break;
        }
        c2 -= i2.length;
    }
}
function ra(t4, e, i, s, r, n2, o2) {
    const a2 = o2 && o2.attr, h2 = o2 && o2.paraAttr;
    let c2 = s.indexOf("\n");
    if (c2 < 0) {
        if (sa(i, s, r, n2, a2), h2) if ("simple" === n2) Ko(i, h2);
        else {
            const t5 = new Ma();
            Ko(t5, h2), i.attr = t5;
        }
    } else for (; c2 >= 0; ) {
        if (c2 > 0) {
            if (sa(i, s.slice(0, c2), r, n2, a2), h2) if ("simple" === n2) Ko(i, h2);
            else {
                const t5 = new Ma();
                Ko(t5, h2), i.attr = t5;
            }
            r += c2;
        }
        if (s = s.slice(c2 + 1), 0 === r) {
            const s2 = "\n", r2 = new Ca(1);
            if (i.spans.length > 0) {
                jo(r2, i.spans[0]);
            }
            a2 && jo(r2, a2, true);
            const o3 = new G(r2), c3 = new Ta(s2, o3);
            h2 && "simple" !== n2 || Ko(c3, i), h2 && Ko(c3, h2), t4.splice(e, 0, c3), e++;
        } else if (r < i.length - 1) {
            const s2 = i.text.slice(r);
            i.text = i.text.slice(0, r) + "\n";
            const o3 = i.spans, a3 = new G();
            for (let t5 = 0, e2 = o3.length, i2 = r; t5 < e2; t5++) {
                const r2 = o3[t5];
                if (0 === i2) {
                    a3.push(...o3.splice(t5, o3.length - t5));
                    break;
                }
                if (i2 < r2.length) {
                    const e3 = new Ca(r2.length - i2);
                    jo(e3, r2), r2.length = i2, a3.push(e3), a3.push(...o3.splice(t5 + 1, o3.length - t5 - 1));
                    break;
                }
                if (t5 === e2 - 1) {
                    const t6 = new Ca(s2.length);
                    jo(t6, r2), a3.push(t6);
                    break;
                }
                i2 -= r2.length;
            }
            const c3 = o3[o3.length - 1];
            if (c3.placeholder) {
                const t5 = new Ca(1);
                jo(t5, c3), o3.push(t5);
            } else c3.length++;
            const l2 = new Ta(s2, a3);
            h2 && "simple" !== n2 || Ko(l2, i), h2 && Ko(l2, h2), t4.splice(e + 1, 0, l2), e++, i = l2, r = 0;
        } else {
            const s2 = i.spans;
            let o3, c3 = Math.max(i.length - 2, 0);
            for (let t5 = 0; t5 < s2.length; t5++) {
                const e2 = s2[t5];
                if (c3 < e2.length) {
                    o3 = e2;
                    break;
                }
                c3 -= e2.length;
            }
            !o3 && i.spans.length > 0 && (o3 = i.spans[i.spans.length - 1]);
            const l2 = "\n", d2 = new Ca(1);
            o3 && jo(d2, o3);
            const p2 = new G(d2), u = new Ta(l2, p2);
            h2 && "simple" !== n2 || Ko(u, i), a2 && jo(d2, a2, true), h2 && Ko(u, h2), t4.splice(e + 1, 0, u), e++, i = u, r = 0;
        }
        if (c2 = s.indexOf("\n"), c2 < 0) {
            sa(i, s, r, n2, a2);
            break;
        }
    }
}
function na(t4, e, i, s, r) {
    const n2 = t4.paras;
    for (let t5 = 0, o2 = n2.length; t5 < o2; t5++) {
        const a2 = n2[t5];
        if (i < a2.length) {
            ra(n2, t5, a2, e, i, s, r);
            break;
        }
        if (t5 === o2 - 1) throw new Error("index outside text's range");
        i -= a2.length;
    }
}
function oa(t4, e, i) {
    1 === t4.paras.length && 1 === t4.paras[0].length && e.attr && Qo(t4, e.attr), function(t5, e2, i2, s) {
        if (0 !== e2.length) for (let r = 0, n2 = e2.length; r < n2; r++) {
            const n3 = e2[r], o2 = n3.spans;
            let a2 = 0;
            for (let e3 = 0, r2 = o2.length; e3 < r2; e3++) {
                const r3 = o2[e3], h2 = n3.text.slice(a2, a2 + r3.length);
                na(t5, h2, i2 + a2, s, { attr: r3, paraAttr: n3.attr }), a2 += h2.length;
            }
            a2 < n3.length && na(t5, n3.text.slice(a2), i2 + a2, s, { paraAttr: n3.attr }), i2 += n3.length;
        }
    }(t4, e.paras, i, "complex");
}
function aa(t4, e, i, s, r, n2, o2) {
    const a2 = [];
    for (; s > 0 && e < t4.length; ) {
        const h2 = t4[e];
        if (i > 0) {
            const s2 = new Ca(h2.length - i);
            jo(s2, h2), h2.length = i, t4.splice(e + 1, 0, s2), o2 += h2.length, i = 0, e++;
        } else if (s < h2.length) {
            const i2 = new Ca(h2.length - s);
            jo(i2, h2), h2.length = s, t4.splice(e + 1, 0, i2);
        } else if (a2.push({ index: i + o2, len: h2.length, value: h2[r] }), h2[r] = n2, o2 += h2.length, s -= h2.length, e > 0 && !Zo(h2, t4[e - 1])) {
            t4[e - 1].length += h2.length, t4.splice(e, 1);
        } else e++;
    }
    return a2;
}
function ha(t4, e, i, s, r) {
    const n2 = [];
    let o2 = e;
    return Yo(t4.paras, e, i, (t5, e2, i2, a2, h2) => {
        o2 -= a2, n2.push(...function(t6, e3, i3, s2, r2, n3) {
            for (let o3 = 0, a3 = t6.length; o3 < a3; o3++) {
                const a4 = t6[o3];
                if (e3 < a4.length) return aa(t6, o3, e3, i3, s2, r2, n3);
                n3 += a4.length, e3 -= a4.length;
            }
            return [];
        }(i2.spans, a2, h2, s, r, o2)), o2 += i2.length;
    }), n2;
}
function ca(t4, e, i) {
    const s = new G();
    for (let r = 0; r < t4.length && i > 0; ) {
        const n2 = t4[r];
        if (e < n2.length) {
            if (0 === e && i >= n2.length) {
                s.push(jn(n2)), t4.splice(r, 1), i -= n2.length;
                continue;
            }
            const o2 = Math.min(n2.length - e, i);
            n2.length -= o2, i -= o2, e = 0, r++;
            const a2 = jn(n2);
            a2.length = o2, s.push(a2);
        } else e -= n2.length, r++;
    }
    return s;
}
function la(t4, e) {
    t4.text += e.text;
    const i = t4.spans, s = i.length - 1;
    if (i.push(...e.spans.map((t5) => jn(t5))), s >= 0 && i.length - 1 > s) {
        const t5 = i[s], e2 = i[s + 1];
        Zo(t5, e2) || (t5.length += e2.length, i.splice(s + 1, 1));
    }
}
function da(t4, e, i, s, r) {
    if (r > 0 && e === t4.length - 1 && s + r >= i.length && (r = i.length - s - 1), s + r <= i.length) {
        let n3 = s + r === i.length;
        const o3 = i.text.slice(s, s + r);
        i.text = i.text.slice(0, s) + i.text.slice(s + r);
        const a3 = ca(i.spans, s, r), h3 = new Ta(o3, a3);
        Ko(h3, i);
        const c2 = new Ia(new G());
        if (c2.paras.push(h3), n3) {
            const s2 = t4[e + 1];
            t4.splice(e + 1, 1), la(i, s2);
        }
        return c2;
    }
    const n2 = t4[e].attr, o2 = new Ia(new G());
    let a2 = -1;
    if (s > 0) {
        a2 = e;
        const t5 = i.length, n3 = i.text.slice(s);
        i.text = i.text.slice(0, s);
        const h3 = ca(i.spans, s, r);
        r -= t5 - i.length, s = 0, e++;
        const c2 = new Ta(n3, h3);
        Ko(c2, i), o2.paras.push(c2);
    }
    let h2 = t4.length;
    for (; r > 0 && e < h2 && h2 > 1; ) {
        const i2 = t4[e];
        if (!(r >= i2.length)) break;
        {
            const s2 = i2.text, n3 = i2.spans.slice(0);
            t4.splice(e, 1), r -= i2.length, h2--;
            const a3 = new Ta(s2, n3.map((t5) => jn(t5)));
            Ko(a3, i2), o2.paras.push(a3);
        }
    }
    if (i = t4[e], r > 0 && e === t4.length - 1 && s + r >= i.length && (r = i.length - s - 1), r > 0 && e < h2) {
        const s2 = (i = t4[e]).text.slice(0, r);
        i.text = i.text.slice(r);
        const n3 = ca(i.spans, 0, r);
        r -= i.text.length;
        const a3 = new Ta(s2, n3);
        Ko(a3, i), o2.paras.push(a3);
    }
    if (a2 >= 0) {
        const e2 = t4[a2], i2 = e2.spans;
        if (a2 === t4.length - 1) e2.text += "\n", i2.length > 0 && i2[i2.length - 1].length++;
        else {
            const i3 = t4[a2 + 1];
            t4.splice(a2 + 1, 1), la(e2, i3);
        }
    } else if (n2 !== (i = t4[e]).attr) if (n2) {
        const t5 = new Ma();
        Ko(t5, n2), i.attr = t5;
    } else i.attr = void 0;
    return o2;
}
function pa(t4, e, i, s, r) {
    var _a2, _b, _c2, _d2, _e2, _f2, _g2, _h2;
    if (s <= 0) return r;
    const n2 = ((t5) => {
        switch (t5) {
            case $t.Flexible:
                return Number.MAX_VALUE;
            case $t.Fixed:
            case $t.FixWidthAndHeight:
                return e.width;
        }
    })(((_a2 = t4.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible), o2 = (_b = t4.attr) == null ? void 0 : _b.padding, a2 = (o2 == null ? void 0 : o2.left) ?? 0, h2 = (o2 == null ? void 0 : o2.top) ?? 0, c2 = (o2 == null ? void 0 : o2.right) ?? 0, l2 = (o2 == null ? void 0 : o2.bottom) ?? 0, d2 = n2 - a2 - c2, p2 = t4.paras, u = p2.length, f2 = r.paras;
    let g2 = 0, m2 = 0, _2 = 0;
    const y2 = [];
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (i < e2.charCount) break;
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 1");
        if (i -= e2.charCount, _2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_c2 = t7.attr) == null ? void 0 : _c2.paraSpacing) || 0;
            g2 += e3;
        }
        g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.bulletNumbers && y2.push(e2.bulletNumbers), e2.xOffset = 0;
    }
    const x2 = p2.length - f2.length + 1;
    for (let e2 = 0; _2 < u && e2 < x2; e2++, _2++) {
        const i2 = tn(t4, p2[_2], d2, y2);
        if (_2 > 0) {
            const t5 = p2[_2 - 1], e3 = ((_d2 = t5.attr) == null ? void 0 : _d2.paraSpacing) || 0;
            g2 += e3;
        }
        i2.yOffset = g2, g2 += i2.paraHeight, m2 = Math.max(i2.paraWidth, m2), 0 === e2 ? f2.splice(_2, 1, i2) : f2.splice(_2, 0, i2);
    }
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 2");
        if (_2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_e2 = t7.attr) == null ? void 0 : _e2.paraSpacing) || 0;
            g2 += e3;
        }
        e2.yOffset = g2, g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.xOffset = 0;
    }
    if (u !== f2.length) throw new Error("layout and data Not match 3");
    const w2 = ((_f2 = t4.attr) == null ? void 0 : _f2.textBehaviour) ?? $t.Flexible, b2 = w2 === $t.Flexible ? m2 : d2;
    let M2 = Number.MAX_SAFE_INTEGER;
    for (let i2 = 0, s2 = t4.paras.length; i2 < s2; i2++) {
        const s3 = t4.paras[i2], r2 = f2[i2], n3 = ((_g2 = s3.attr) == null ? void 0 : _g2.alignment) ?? Xt.Left;
        for (let t5 = 0, e2 = r2.length; t5 < e2; t5++) {
            Jr(r2[t5], n3, b2);
        }
        if (w2 === $t.Flexible) switch (n3) {
            case Xt.Centered:
                M2 = Math.min(M2, -(r2.paraWidth - e.width) / 2);
                break;
            case Xt.Left:
            case Xt.Natural:
                M2 = Math.min(M2, 0);
                break;
            case Xt.Justified:
            case Xt.Right:
                M2 = Math.min(M2, -(r2.paraWidth - e.width));
        }
    }
    const v2 = ((t5) => {
        switch (t5) {
            case Ut.Top:
                return h2;
            case Ut.Middle:
                return (e.height - g2 - h2 - l2) / 2;
            case Ut.Bottom:
                return e.height - g2 - l2;
        }
    })(((_h2 = t4.attr) == null ? void 0 : _h2.verAlign) ?? Ut.Top);
    return r.alignX = M2 === Number.MAX_SAFE_INTEGER ? 0 : M2, r.xOffset = a2, r.yOffset = v2, r.contentHeight = g2, r.contentWidth = m2, r;
}
function ua(t4, e, i, s, r) {
    var _a2, _b, _c2, _d2, _e2, _f2, _g2, _h2;
    if (s <= 0) return r;
    const n2 = ((t5) => {
        switch (t5) {
            case $t.Flexible:
                return Number.MAX_VALUE;
            case $t.Fixed:
            case $t.FixWidthAndHeight:
                return e.width;
        }
    })(((_a2 = t4.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible), o2 = (_b = t4.attr) == null ? void 0 : _b.padding, a2 = (o2 == null ? void 0 : o2.left) ?? 0, h2 = (o2 == null ? void 0 : o2.top) ?? 0, c2 = (o2 == null ? void 0 : o2.right) ?? 0, l2 = (o2 == null ? void 0 : o2.bottom) ?? 0, d2 = n2 - a2 - c2, p2 = t4.paras, u = p2.length, f2 = r.paras;
    let g2 = 0, m2 = 0, _2 = 0;
    const y2 = [];
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (i < e2.charCount) break;
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 4");
        if (i -= e2.charCount, _2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_c2 = t7.attr) == null ? void 0 : _c2.paraSpacing) || 0;
            g2 += e3;
        }
        g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.bulletNumbers && y2.push(e2.bulletNumbers), e2.xOffset = 0;
    }
    const x2 = f2.length - p2.length + 1;
    if (_2 < u && x2 > 0) {
        const e2 = tn(t4, p2[_2], d2, y2);
        if (_2 > 0) {
            const t5 = p2[_2 - 1], e3 = ((_d2 = t5.attr) == null ? void 0 : _d2.paraSpacing) || 0;
            g2 += e3;
        }
        e2.yOffset = g2, g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), f2.splice(_2, 1, e2), _2++;
        for (let t5 = 1; t5 < x2; t5++) f2.splice(_2, 1);
    }
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 5");
        if (_2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_e2 = t7.attr) == null ? void 0 : _e2.paraSpacing) || 0;
            g2 += e3;
        }
        e2.yOffset = g2, g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.xOffset = 0;
    }
    if (u !== f2.length) throw new Error("layout and data Not match 6");
    const w2 = ((_f2 = t4.attr) == null ? void 0 : _f2.textBehaviour) ?? $t.Flexible, b2 = w2 === $t.Flexible ? m2 : d2;
    let M2 = Number.MAX_SAFE_INTEGER;
    for (let i2 = 0, s2 = t4.paras.length; i2 < s2; i2++) {
        const s3 = t4.paras[i2], r2 = f2[i2], n3 = ((_g2 = s3.attr) == null ? void 0 : _g2.alignment) ?? Xt.Left;
        for (let t5 = 0, e2 = r2.length; t5 < e2; t5++) {
            Jr(r2[t5], n3, b2);
        }
        if (w2 === $t.Flexible) switch (n3) {
            case Xt.Centered:
                M2 = Math.min(M2, -(r2.paraWidth - e.width) / 2);
                break;
            case Xt.Left:
            case Xt.Natural:
                M2 = Math.min(M2, 0);
                break;
            case Xt.Justified:
            case Xt.Right:
                M2 = Math.min(M2, -(r2.paraWidth - e.width));
        }
    }
    const v2 = ((t5) => {
        switch (t5) {
            case Ut.Top:
                return h2;
            case Ut.Middle:
                return (e.height - g2 - h2 - l2) / 2;
            case Ut.Bottom:
                return e.height - g2 - l2;
        }
    })(((_h2 = t4.attr) == null ? void 0 : _h2.verAlign) ?? Ut.Top);
    return r.alignX = M2 === Number.MAX_SAFE_INTEGER ? 0 : M2, r.xOffset = a2, r.yOffset = v2, r.contentHeight = g2, r.contentWidth = m2, r;
}
function fa(t4, e, i, s, r) {
    var _a2, _b, _c2, _d2, _e2, _f2, _g2, _h2;
    if (s <= 0) return r;
    const n2 = ((t5) => {
        switch (t5) {
            case $t.Flexible:
                return Number.MAX_VALUE;
            case $t.Fixed:
            case $t.FixWidthAndHeight:
                return e.width;
        }
    })(((_a2 = t4.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible), o2 = (_b = t4.attr) == null ? void 0 : _b.padding, a2 = (o2 == null ? void 0 : o2.left) ?? 0, h2 = (o2 == null ? void 0 : o2.top) ?? 0, c2 = (o2 == null ? void 0 : o2.right) ?? 0, l2 = (o2 == null ? void 0 : o2.bottom) ?? 0, d2 = n2 - a2 - c2, p2 = t4.paras, u = p2.length, f2 = r.paras;
    let g2 = 0, m2 = 0, _2 = 0;
    const y2 = [];
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (i < e2.charCount) break;
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 7");
        if (i -= e2.charCount, _2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_c2 = t7.attr) == null ? void 0 : _c2.paraSpacing) || 0;
            g2 += e3;
        }
        g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.bulletNumbers && y2.push(e2.bulletNumbers), e2.xOffset = 0;
    }
    s += i;
    for (let e2 = f2.length; s >= 0 && _2 < u && _2 < e2; _2++) {
        const e3 = p2[_2], i2 = tn(t4, e3, d2, y2);
        if (_2 > 0) {
            const t5 = p2[_2 - 1], e4 = ((_d2 = t5.attr) == null ? void 0 : _d2.paraSpacing) || 0;
            g2 += e4;
        }
        i2.yOffset = g2, g2 += i2.paraHeight, m2 = Math.max(i2.paraWidth, m2), f2.splice(_2, 1, i2), s -= e3.length;
    }
    for (let t5 = f2.length; _2 < u && _2 < t5; _2++) {
        const t6 = p2[_2], e2 = f2[_2];
        if (t6.length !== e2.charCount) throw new Error("layout and data Not match 8");
        if (_2 > 0) {
            const t7 = p2[_2 - 1], e3 = ((_e2 = t7.attr) == null ? void 0 : _e2.paraSpacing) || 0;
            g2 += e3;
        }
        e2.yOffset = g2, g2 += e2.paraHeight, m2 = Math.max(e2.paraWidth, m2), e2.xOffset = 0;
    }
    if (u !== f2.length) throw new Error("layout and data Not match 9");
    const x2 = ((_f2 = t4.attr) == null ? void 0 : _f2.textBehaviour) ?? $t.Flexible, w2 = x2 === $t.Flexible ? m2 : d2;
    let b2 = Number.MAX_SAFE_INTEGER;
    for (let i2 = 0, s2 = t4.paras.length; i2 < s2; i2++) {
        const s3 = t4.paras[i2], r2 = f2[i2], n3 = ((_g2 = s3.attr) == null ? void 0 : _g2.alignment) ?? Xt.Left;
        for (let t5 = 0, e2 = r2.length; t5 < e2; t5++) {
            Jr(r2[t5], n3, w2);
        }
        if (x2 === $t.Flexible) switch (n3) {
            case Xt.Centered:
                b2 = Math.min(b2, -(r2.paraWidth - e.width) / 2);
                break;
            case Xt.Left:
            case Xt.Natural:
                b2 = Math.min(b2, 0);
                break;
            case Xt.Justified:
            case Xt.Right:
                b2 = Math.min(b2, -(r2.paraWidth - e.width));
        }
    }
    const M2 = ((t5) => {
        switch (t5) {
            case Ut.Top:
                return h2;
            case Ut.Middle:
                return (e.height - g2 - h2 - l2) / 2;
            case Ut.Bottom:
                return e.height - g2 - l2;
        }
    })(((_h2 = t4.attr) == null ? void 0 : _h2.verAlign) ?? Ut.Top);
    return r.alignX = b2 === Number.MAX_SAFE_INTEGER ? 0 : b2, r.xOffset = a2, r.yOffset = M2, r.contentHeight = g2, r.contentWidth = m2, r;
}
function ga(t4, e, i) {
    let s = "";
    return Yo(t4.paras, e, i, (t5, e2, i2, r, n2) => {
        s += i2.text.slice(r, r + n2);
    }), s;
}
const ma = new Ji(1, 0, 0, 0);
function _a(t4, e, i, s) {
    const r = t4.color ?? (i == null ? void 0 : i.color) ?? (s == null ? void 0 : s.color) ?? ma;
    void 0 === e.color ? e.color = r : r === e.color || (r === ma || e.color === ma ? e.colorIsMulti = true : r.equals(e.color) || (e.colorIsMulti = true));
    const n2 = t4.gradient ?? (i == null ? void 0 : i.gradient) ?? (s == null ? void 0 : s.gradient);
    void 0 === e.gradient ? e.gradient = n2 : void 0 === n2 ? e.gradientIsMulti = true : Uo(e.gradient, n2) || (e.gradientIsMulti = true);
    const o2 = t4.fontName ?? (i == null ? void 0 : i.fontName) ?? (s == null ? void 0 : s.fontName) ?? "";
    void 0 === e.fontName ? e.fontName = o2 : void 0 !== o2 && e.fontName === o2 || (e.fontNameIsMulti = true);
    const a2 = t4.fontSize ?? (i == null ? void 0 : i.fontSize) ?? (s == null ? void 0 : s.fontSize) ?? 0;
    void 0 === e.fontSize ? e.fontSize = a2 : void 0 !== a2 && e.fontSize === a2 || (e.fontSizeIsMulti = true);
    const h2 = t4.highlight ?? (i == null ? void 0 : i.highlight) ?? (s == null ? void 0 : s.highlight) ?? ma;
    void 0 === e.highlight ? e.highlight = h2 : h2 === e.highlight || (h2 === ma || e.highlight === ma ? e.highlightIsMulti = true : h2.equals(e.highlight) || (e.highlightIsMulti = true));
    const c2 = t4.weight ?? (i == null ? void 0 : i.weight) ?? (s == null ? void 0 : s.weight) ?? 400;
    void 0 === e.weight ? e.weight = c2 : void 0 !== c2 && e.weight === c2 || (e.weightIsMulti = true);
    const l2 = t4.italic ?? (i == null ? void 0 : i.italic) ?? (s == null ? void 0 : s.italic) ?? false;
    void 0 === e.italic ? e.italic = l2 : void 0 !== l2 && e.italic === l2 || (e.italicIsMulti = true);
    const d2 = t4.underline ?? (i == null ? void 0 : i.underline) ?? (s == null ? void 0 : s.underline) ?? Zt.None;
    void 0 === e.underline ? e.underline = d2 : void 0 !== d2 && e.underline === d2 || (e.underlineIsMulti = true);
    const p2 = t4.strikethrough ?? (i == null ? void 0 : i.strikethrough) ?? (s == null ? void 0 : s.strikethrough) ?? Ht.None;
    void 0 === e.strikethrough ? e.strikethrough = p2 : void 0 !== p2 && e.strikethrough === p2 || (e.strikethroughIsMulti = true);
    const u = t4.kerning ?? (i == null ? void 0 : i.kerning) ?? (s == null ? void 0 : s.kerning) ?? 0;
    void 0 === e.kerning ? e.kerning = u : void 0 !== u && e.kerning === u || (e.kerningIsMulti = true);
    const f2 = t4.transform ?? (i == null ? void 0 : i.transform) ?? (s == null ? void 0 : s.transform) ?? Yt.None;
    void 0 === e.transform ? e.transform = f2 : void 0 !== f2 && e.transform === f2 || (e.transformIsMulti = true);
    const g2 = t4.bulletNumbers;
    void 0 === e.bulletNumbers ? g2 && (e.bulletNumbers = g2) : g2 && e.bulletNumbers.type !== g2.type && (e.bulletNumbersIsMulti = true);
    const m2 = t4.fillType ?? (i == null ? void 0 : i.fillType) ?? (s == null ? void 0 : s.fillType) ?? xt.SolidColor;
    void 0 === e.fillType ? m2 && (e.fillType = m2) : m2 && e.fillType !== m2 && (e.fillTypeIsMulti = true);
}
function ya(t4, e) {
    t4.fontNameIsMulti ? e.fontNameIsMulti = true : t4.fontName && (e.fontName = t4.fontName), t4.colorIsMulti ? e.colorIsMulti = true : t4.color && (e.color = t4.color), t4.fontSizeIsMulti ? e.fontSizeIsMulti = true : void 0 !== t4.fontSize && (e.fontSize = t4.fontSize), t4.highlightIsMulti ? e.highlightIsMulti = true : t4.highlight && (e.highlight = t4.highlight), t4.weightIsMulti ? e.weightIsMulti = true : void 0 !== t4.weight && (e.weight = t4.weight), t4.italicIsMulti ? e.italicIsMulti = true : void 0 !== t4.italic && (e.italic = t4.italic), t4.underlineIsMulti ? e.underlineIsMulti = true : void 0 !== t4.underline && (e.underline = t4.underline), t4.strikethroughIsMulti ? e.strikethroughIsMulti = true : void 0 !== t4.strikethrough && (e.strikethrough = t4.strikethrough), t4.kerningIsMulti ? e.kerningIsMulti = true : void 0 !== t4.kerning && (e.kerning = t4.kerning), t4.transformIsMulti ? e.transformIsMulti = true : void 0 !== t4.transform && (e.transform = t4.transform), t4.bulletNumbersIsMulti ? e.bulletNumbersIsMulti = true : void 0 !== t4.bulletNumbers && (e.bulletNumbers = t4.bulletNumbers), t4.fillTypeIsMulti ? e.fillTypeIsMulti = true : t4.fillType && (e.fillType = t4.fillType), t4.gradientIsMulti ? e.gradientIsMulti = true : t4.gradient && (e.gradient = t4.gradient);
}
function xa(t4, e, i) {
    _a(t4, e, void 0, i);
    const s = t4.alignment ?? (i == null ? void 0 : i.alignment) ?? Xt.Left;
    void 0 === e.alignment ? e.alignment = s : void 0 !== s && e.alignment === s || (e.alignmentIsMulti = true);
    const r = t4.kerning ?? (i == null ? void 0 : i.kerning) ?? 0;
    void 0 === e.kerning ? e.kerning = r : void 0 !== r && e.kerning === r || (e.kerningIsMulti = true);
    const n2 = t4.maximumLineHeight ?? (i == null ? void 0 : i.maximumLineHeight) ?? 0;
    void 0 === e.maximumLineHeight ? e.maximumLineHeight = n2 : void 0 !== n2 && e.maximumLineHeight === n2 || (e.maximumLineHeightIsMulti = true);
    const o2 = t4.minimumLineHeight ?? (i == null ? void 0 : i.minimumLineHeight) ?? 0;
    void 0 === e.minimumLineHeight ? e.minimumLineHeight = o2 : void 0 !== o2 && e.minimumLineHeight === o2 || (e.minimumLineHeightIsMulti = true);
    const a2 = t4.paraSpacing ?? (i == null ? void 0 : i.paraSpacing) ?? 0;
    void 0 === e.paraSpacing ? e.paraSpacing = a2 : void 0 !== a2 && e.paraSpacing === a2 || (e.paraSpacingIsMulti = true);
}
function wa(t4, e, i, s) {
    const r = new Sa(), n2 = new Sa(), o2 = new Sa();
    if (t4.attr && (xa(t4.attr, o2, t4.attr), o2.verAlign = t4.attr.verAlign, o2.orientation = t4.attr.orientation, o2.textBehaviour = t4.attr.textBehaviour), 0 === i) {
        t4.alignParaRange(e, i).index !== e && --e, i = 1;
    } else s = void 0;
    let a2, h2 = 0;
    var c2, l2, d2, p2;
    return Yo(t4.paras, e, i, (e2, i2, s2, r2, o3) => {
        a2 = s2, h2 = r2;
        const c3 = s2.attr;
        c3 && xa(c3, n2, t4.attr);
    }, (e2, i2, s2) => {
        h2 += i2;
        (!(1 === e2.length && h2 === a2.length - 1) || a2.spans.length <= 1) && _a(e2, r, a2.attr, t4.attr), h2 += s2;
    }), ya(r, n2), ya(c2 = n2, l2 = o2), c2.alignmentIsMulti ? l2.alignmentIsMulti = true : c2.alignment && (l2.alignment = c2.alignment), c2.kerningIsMulti ? l2.kerningIsMulti = true : void 0 !== c2.kerning && (l2.kerning = c2.kerning), c2.maximumLineHeightIsMulti ? l2.maximumLineHeightIsMulti = true : void 0 !== c2.maximumLineHeight && (l2.maximumLineHeight = c2.maximumLineHeight), c2.minimumLineHeightIsMulti ? l2.minimumLineHeightIsMulti = true : void 0 !== c2.minimumLineHeight && (l2.minimumLineHeight = c2.minimumLineHeight), c2.paraSpacingIsMulti ? l2.paraSpacingIsMulti = true : void 0 !== c2.paraSpacing && (l2.paraSpacing = c2.paraSpacing), o2.color === ma && (o2.color = void 0), o2.highlight === ma && (o2.highlight = void 0), s && (d2 = o2, (p2 = s).fontName && (d2.fontName = p2.fontName, d2.fontNameIsMulti = false), void 0 !== p2.fontSize && (d2.fontSize = p2.fontSize, d2.fontSizeIsMulti = false), p2.color && (d2.color = p2.color, d2.colorIsMulti = false), p2.highlight && (d2.highlight = p2.highlight, d2.highlightIsMulti = false), void 0 !== p2.weight && (d2.weight = p2.weight, d2.weightIsMulti = false), void 0 !== p2.italic && (d2.italic = p2.italic, d2.italicIsMulti = false), p2.underline && (d2.underline = p2.underline, d2.underlineIsMulti = false), p2.strikethrough && (d2.strikethrough = p2.strikethrough, d2.strikethroughIsMulti = false), void 0 !== p2.kerning && (d2.kerning = p2.kerning, d2.kerningIsMulti = false), p2.transform && (d2.transform = p2.transform, d2.transformIsMulti = false), p2.fillType && (d2.fillType = p2.fillType, d2.fillTypeIsMulti = false), p2.gradient && (d2.gradient = p2.gradient, d2.gradientIsMulti = false)), o2;
}
class ba extends X {
    constructor() {
        super();
        __publicField(this, "typeId", "span-attr");
        __publicField(this, "fontName");
        __publicField(this, "fontSize");
        __publicField(this, "color");
        __publicField(this, "strikethrough");
        __publicField(this, "underline");
        __publicField(this, "weight");
        __publicField(this, "italic");
        __publicField(this, "bulletNumbers");
        __publicField(this, "highlight");
        __publicField(this, "kerning");
        __publicField(this, "transform");
        __publicField(this, "placeholder");
        __publicField(this, "fillType");
        __publicField(this, "gradient");
    }
}
class Ma extends ba {
    constructor() {
        super();
        __publicField(this, "typeId", "para-attr");
        __publicField(this, "alignment");
        __publicField(this, "paraSpacing");
        __publicField(this, "minimumLineHeight");
        __publicField(this, "maximumLineHeight");
        __publicField(this, "indent");
    }
}
class va extends Ma {
    constructor() {
        super();
        __publicField(this, "typeId", "text-attr");
        __publicField(this, "verAlign");
        __publicField(this, "orientation");
        __publicField(this, "textBehaviour");
        __publicField(this, "padding");
    }
}
class Sa extends va {
    constructor() {
        super(...arguments);
        __publicField(this, "fontNameIsMulti", false);
        __publicField(this, "fontSizeIsMulti", false);
        __publicField(this, "colorIsMulti", false);
        __publicField(this, "highlightIsMulti", false);
        __publicField(this, "weightIsMulti", false);
        __publicField(this, "italicIsMulti", false);
        __publicField(this, "underlineIsMulti", false);
        __publicField(this, "strikethroughIsMulti", false);
        __publicField(this, "alignmentIsMulti", false);
        __publicField(this, "paraSpacingIsMulti", false);
        __publicField(this, "kerningIsMulti", false);
        __publicField(this, "minimumLineHeightIsMulti", false);
        __publicField(this, "maximumLineHeightIsMulti", false);
        __publicField(this, "transformIsMulti", false);
        __publicField(this, "bulletNumbersIsMulti", false);
        __publicField(this, "fillTypeIsMulti", false);
        __publicField(this, "gradientIsMulti", false);
    }
}
class Ca extends ba {
    constructor(t4) {
        super();
        __publicField(this, "typeId", "span");
        __publicField(this, "length");
        this.length = t4;
    }
}
class Ta extends X {
    constructor(t4, e) {
        super();
        __publicField(this, "typeId", "para");
        __publicField(this, "text");
        __publicField(this, "spans");
        __publicField(this, "attr");
        this.text = t4, this.spans = e;
    }
    get length() {
        return this.text.length;
    }
    charAt(t4) {
        return this.text.charAt(t4);
    }
}
const _Ia = class _Ia extends X {
    constructor(t4) {
        super();
        __publicField(this, "typeId", "text");
        __publicField(this, "paras");
        __publicField(this, "attr");
        __publicField(this, "__layouts", /* @__PURE__ */ new Map());
        this.paras = t4;
    }
    dropLayout(t4, e) {
        let i = this.__layouts.get(t4);
        if (i) {
            const s = i.owners.indexOf(e);
            s >= 0 && (i.owners.splice(s, 1), 0 === i.owners.length && this.__layouts.delete(t4));
        }
    }
    getLayout3(t4, e, i) {
        const s = [t4.width, t4.height].join(",");
        if (s !== i) {
            let r2 = i && this.__layouts.get(i);
            if (r2) {
                if (1 === r2.owners.length && r2.owners[0] === e) return r2.update(t4, this), r2.layout || (r2.layout = en(this, t4)), this.__layouts.delete(i), this.__layouts.set(s, r2), { token: s, layout: r2.layout };
                const n2 = r2.owners.indexOf(e);
                n2 >= 0 && (r2.owners.splice(n2, 1), 0 === r2.owners.length && this.__layouts.delete(i));
            }
        }
        let r = this.__layouts.get(s);
        return r ? r.owners.indexOf(e) < 0 && r.owners.push(e) : (r = new jr(), r.owners.push(e), this.__layouts.set(s, r)), r.update(t4, this), r.layout || (r.layout = en(this, t4)), { token: s, layout: r.layout };
    }
    getLayout2(t4) {
        const e = [t4.width, t4.height].join(",");
        let i = this.__layouts.get(e);
        return i ? i.layout : en(this, t4);
    }
    getOpTarget(t4) {
        return 0 === t4.length ? this : "attr" === t4[0] ? (this.attr || (this.attr = new va()), this.attr.getOpTarget(t4.splice(1))) : void 0;
    }
    charAt(t4) {
        for (let e = 0, i = this.paras.length; e < i; e++) {
            const i2 = this.paras[e];
            if (t4 < i2.length) return i2.charAt(t4);
            t4 -= i2.length;
        }
        return "";
    }
    revertCharAt(t4) {
        for (let e = this.paras.length - 1; e >= 0; e--) {
            const i = this.paras[e];
            if (t4 < i.length) return i.charAt(i.length - t4 - 1);
            t4 -= i.length;
        }
        return "";
    }
    paraAt(t4) {
        for (let e = 0, i = this.paras.length; e < i; e++) {
            const i2 = this.paras[e];
            if (t4 < i2.length) return { para: i2, index: t4, paraIndex: e };
            t4 -= i2.length;
        }
    }
    spanAt(t4) {
        const e = this.paraAt(t4);
        if (!e) return;
        const i = e.para;
        t4 = e.index;
        const s = i.spans;
        for (let e2 = 0, i2 = s.length; e2 < i2; e2++) {
            const i3 = s[e2];
            if (t4 < i3.length) return i3;
            t4 -= i3.length;
        }
    }
    alignParaRange(t4, e) {
        if (t4 < 0) throw new Error("index < 0");
        const i = { index: t4, len: e };
        for (let s = 0, r = this.paras.length; s < r; s++) {
            const n2 = this.paras[s];
            if (t4 < n2.length) {
                i.index -= t4, i.len += t4, e += t4;
                for (let t5 = s; t5 < r; t5++) {
                    const s2 = this.paras[t5];
                    if (e <= s2.length) {
                        i.len += s2.length - e;
                        break;
                    }
                    e -= s2.length;
                }
                break;
            }
            t4 -= n2.length;
        }
        return i;
    }
    get length() {
        return this.paras.reduce((t4, e) => t4 + e.length, 0);
    }
    getText(t4, e) {
        if (t4 < 0) throw new Error("index < 0");
        return ga(this, t4, e);
    }
    toString() {
        const t4 = ga(this, 0, Number.MAX_VALUE);
        return t4.substring(0, t4.length - 1);
    }
    getTextWithFormat(t4, e) {
        if (t4 < 0) throw new Error("index < 0");
        return function(t5, e2, i) {
            const s = new _Ia(new G());
            return Yo(t5.paras, e2, i, (t6, e3, i2, r, n2) => {
                const o2 = r + n2, a2 = i2.text.slice(r, o2), h2 = new Ta(a2, new G());
                Ko(h2, i2), s.paras.push(h2);
            }, (t6, e3, i2) => {
                var _a2;
                const r = new Ca(e3 + i2 - e3);
                jo(r, t6), (_a2 = s.paras.at(-1)) == null ? void 0 : _a2.spans.push(r);
            }), s;
        }(this, t4, e);
    }
    getDefaultTextFormat() {
        return this.attr;
    }
    getTextFormat(t4, e, i) {
        if (t4 < 0) throw new Error("index < 0");
        return wa(this, t4, e, i);
    }
    getUsedFontNames(t4) {
        return function(t5, e) {
            const i = e ?? /* @__PURE__ */ new Set();
            return t5.attr && t5.attr.fontName && i.add(t5.attr.fontName), Yo(t5.paras, 0, Number.MAX_VALUE, (t6, e2, s, r, n2) => {
                const o2 = s.attr;
                o2 && o2.fontName && i.add(o2.fontName);
            }, (t6, e2, s) => {
                t6.fontName && i.add(t6.fontName);
            }), i;
        }(this, t4);
    }
    insertText(t4, e, i) {
        if (e < 0) throw new Error("index < 0");
        !function(t5, e2, i2, s) {
            na(t5, e2, i2, "simple", s);
        }(this, t4, e, i), this.__layouts.forEach((i2) => i2.layout = i2.layout && pa(this, i2.__frame, e, t4.length, i2.layout));
    }
    composingInputUpdate(t4) {
        if (t4 < 0) throw new Error("index < 0");
        this.__layouts.forEach((e) => e.layout = e.layout && ua(this, e.__frame, t4, 1, e.layout));
    }
    insertFormatText(t4, e) {
        if (e < 0) throw new Error("index < 0");
        oa(this, t4, e), this.__layouts.forEach((i) => i.layout = i.layout && pa(this, i.__frame, e, t4.length, i.layout));
    }
    formatText(t4, e, i, s) {
        if (t4 < 0) throw new Error("index < 0");
        const r = ha(this, t4, e, i, s);
        return this.__layouts.forEach((i2) => i2.layout = i2.layout && fa(this, i2.__frame, t4, e, i2.layout)), r;
    }
    formatPara(t4, e, i, s) {
        if (t4 < 0) throw new Error("index < 0");
        const r = function(t5, e2, i2, s2, r2) {
            const n2 = [];
            let o2 = e2;
            return Yo(t5.paras, e2, i2, (t6, e3, i3, a2, h2) => {
                o2 -= a2;
                const c2 = Math.min(i3.length, a2 + h2);
                n2.push({ index: a2 + o2, len: c2 - a2, value: i3.attr ? i3.attr[s2] : void 0 }), i3.attr || (i3.attr = new Ma()), i3.attr[s2] = r2, o2 += i3.length;
            }), n2;
        }(this, t4, e, i, s);
        return this.__layouts.forEach((i2) => i2.layout = i2.layout && fa(this, i2.__frame, t4, e, i2.layout)), r;
    }
    deleteText(t4, e) {
        if (t4 < 0) throw new Error("index < 0");
        const i = function(t5, e2, i2) {
            if (e2 < 0 && (i2 += e2, e2 = 0), i2 <= 0) return;
            const s = t5.paras;
            for (let r = 0, n2 = s.length; r < n2; r++) {
                let n3 = s[r];
                if (e2 < n3.length) {
                    const o2 = da(s, r, n3, e2, i2);
                    return t5.attr && Qo(o2, t5.attr), o2;
                }
                e2 -= n3.length;
            }
        }(this, t4, e);
        if (i && this.__layouts.size > 0) {
            const s = i.paras;
            let r = false;
            for (let t5 = 0, e2 = s.length; t5 < e2; t5++) {
                const e3 = s[t5];
                if ("*" === e3.text.at(0)) {
                    const t6 = e3.spans[0];
                    if (t6 && t6.placeholder && t6.bulletNumbers && 1 === t6.length) {
                        r = true;
                        break;
                    }
                }
            }
            r ? this.reLayout() : this.__layouts.forEach((i2) => i2.layout = i2.layout && ua(this, i2.__frame, t4, e, i2.layout));
        }
        return i;
    }
    onRollback(t4) {
        "composingInput" !== t4 && this.reLayout();
    }
    reLayout() {
        this.__layouts.forEach((t4) => t4.layout = void 0);
    }
    setTextBehaviour(t4) {
        this.attr || (this.attr = new va()), this.attr.textBehaviour = t4;
    }
    setTextVerAlign(t4) {
        this.attr || (this.attr = new va()), this.attr.verAlign = t4;
    }
    setBulletNumbersType(t4, e, i) {
        const s = function(t5, e2, i2, s2) {
            const r = [];
            return Yo(t5.paras, i2, s2, (t6, s3, n2, o2, a2) => {
                if (i2 -= o2, 0 === o2 && "*" === n2.text[0] && n2.spans[0].bulletNumbers && 1 === n2.spans[0].length) {
                    const t7 = n2.spans[0].bulletNumbers;
                    if (t7.type !== e2) {
                        const s4 = t7.type;
                        t7.type = e2, r.push({ index: i2, len: 1, value: s4 });
                    }
                }
                i2 += n2.length;
            }), r;
        }(this, t4, e, i);
        return this.reLayout(), s;
    }
    setBulletNumbersStart(t4, e, i) {
        const s = function(t5, e2, i2, s2) {
            const r = [];
            return Yo(t5.paras, i2, s2, (t6, s3, n2, o2, a2) => {
                if (i2 -= o2, 0 === o2 && "*" === n2.text[0] && n2.spans[0].bulletNumbers && 1 === n2.spans[0].length) {
                    const t7 = n2.spans[0].bulletNumbers;
                    if (t7.offset !== e2) {
                        const s4 = t7.offset || 0;
                        t7.offset = e2, r.push({ index: i2, len: 1, value: s4 });
                    }
                }
                i2 += n2.length;
            }), r;
        }(this, t4, e, i);
        return this.reLayout(), s;
    }
    setBulletNumbersBehavior(t4, e, i) {
        const s = function(t5, e2, i2, s2) {
            const r = [];
            return Yo(t5.paras, i2, s2, (t6, s3, n2, o2, a2) => {
                if (i2 -= o2, 0 === o2 && "*" === n2.text[0] && n2.spans[0].bulletNumbers && 1 === n2.spans[0].length) {
                    const t7 = n2.spans[0].bulletNumbers;
                    if (t7.behavior !== e2) {
                        const s4 = t7.behavior;
                        t7.behavior = e2, r.push({ index: i2, len: 1, value: s4 });
                    }
                }
                i2 += n2.length;
            }), r;
        }(this, t4, e, i);
        return this.reLayout(), s;
    }
    setParaIndent(t4, e, i) {
        const s = function(t5, e2, i2, s2) {
            const r = [];
            return Yo(t5.paras, i2, s2, (t6, s3, n2, o2, a2) => {
                var _a2;
                i2 -= o2;
                const h2 = ((_a2 = n2.attr) == null ? void 0 : _a2.indent) || 0;
                (e2 ?? 0) !== h2 && (n2.attr || (n2.attr = new Ma()), n2.attr.indent = e2, r.push({ index: i2, len: n2.length, value: h2 })), i2 += n2.length;
            }), r;
        }(this, t4, e, i);
        return this.reLayout(), s;
    }
    setPadding(t4, e, i, s) {
        this.attr || (this.attr = new va()), this.attr.padding || (this.attr.padding = new ce()), t4 && (this.attr.padding.left = t4), e && (this.attr.padding.top = e), i && (this.attr.padding.right = i), s && (this.attr.padding.bottom = s), this.reLayout();
    }
};
__publicField(_Ia, "DefaultFontSize", 12);
let Ia = _Ia;
class ka extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "typeId", "table-cell");
        __publicField(this, "cellType");
        __publicField(this, "text");
        __publicField(this, "imageRef");
        __publicField(this, "rowSpan");
        __publicField(this, "colSpan");
        __publicField(this, "__cacheData");
        __publicField(this, "__startLoad", false);
        this.cellType = o2, this.text = a2;
    }
    get size() {
        return this.frame;
    }
    set size(t4) {
    }
    get frame() {
        return new _e();
    }
    getOpTarget(t4) {
        var _a2;
        return 0 === t4.length ? this : "text" === t4[0] ? (this.text || (this.text = ia()), (_a2 = this.text) == null ? void 0 : _a2.getOpTarget(t4.slice(1))) : super.getOpTarget(t4);
    }
    getCrdtPath() {
        const t4 = this.__parent;
        if (!t4) throw new Error("cell not inside table?");
        return t4.getCrdtPath().concat(this.__propKey);
    }
    static getPathOfSize(t4) {
        const e = t4.width, i = t4.height;
        return new pi([["M", 0, 0], ["l", e, 0], ["l", 0, i], ["l", -e, 0], ["z"]]);
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        return new pi([["M", 0, 0], ["l", i, 0], ["l", 0, s], ["l", -i, 0], ["z"]]);
    }
    isImageCell() {
        return this.cellType === Wt.Image;
    }
    isTextCell() {
        return this.cellType === Wt.Text;
    }
    peekImage(t4 = false) {
        var _a2, _b;
        if (((_a2 = this.__cacheData) == null ? void 0 : _a2.ref) === this.imageRef) return (_b = this.__cacheData) == null ? void 0 : _b.media.base64;
        if (!this.imageRef) return "";
        if (t4 && !this.__startLoad) {
            this.__startLoad = true;
            const t5 = this.parent.__imageMgr;
            t5 && t5.get(this.imageRef).then((t6) => {
                t6 && (this.__cacheData = { media: t6, ref: this.imageRef });
            }).finally(() => {
                var _a3;
                return this.__startLoad = false, this.notify("image-reload"), (_a3 = this.__cacheData) == null ? void 0 : _a3.media.base64;
            });
        }
    }
    async loadImage() {
        if (this.__cacheData) return this.__cacheData.media.base64;
        if (!this.imageRef) return "";
        const t4 = this.parent.__imageMgr, e = t4 && await t4.get(this.imageRef);
        return e && (this.__cacheData = { media: e, ref: this.imageRef }, this.notify()), this.__cacheData && this.__cacheData.media.base64 || "";
    }
    getText() {
        if (!this.text) throw new Error("");
        return this.text;
    }
}
class Ea extends Oi {
    constructor(t4, e, i, s, r, n2, o2, a2, h2, c2) {
        super(t4, e, i, Vt.Table, r, n2);
        __publicField(this, "typeId", "table-shape");
        __publicField(this, "size");
        __publicField(this, "cells");
        __publicField(this, "rowHeights");
        __publicField(this, "colWidths");
        __publicField(this, "textAttr");
        __publicField(this, "__imageMgr");
        this.size = o2, this.rowHeights = h2, this.colWidths = c2, this.cells = a2;
    }
    get frame() {
        return new _e(0, 0, this.size.width, this.size.height);
    }
    hasSize() {
        return true;
    }
    getOpTarget(t4) {
        const e = t4[0];
        if ("cells" === e && t4.length > 1) {
            const e2 = t4[1], i = this.cells.get(e2);
            return i == null ? void 0 : i.getOpTarget(t4.slice(2));
        }
        return "textAttr" !== e || this.textAttr || (this.textAttr = new va()), super.getOpTarget(t4);
    }
    setImageMgr(t4) {
        this.__imageMgr = t4;
    }
    get naviChilds() {
    }
    get datas() {
        return this.cells;
    }
    get rowCount() {
        return this.rowHeights.length;
    }
    get colCount() {
        return this.colWidths.length;
    }
    getPathOfSize(t4, e) {
        const i = t4.width, s = t4.height;
        return new pi([["M", 0, 0], ["l", i, 0], ["l", 0, s], ["l", -i, 0], ["z"]]);
    }
    get pathType() {
        return Ve.Fixed;
    }
    get isPathIcon() {
        return false;
    }
    get isImageFill() {
        return false;
    }
}
__publicField(Ea, "MinCellSize", 10);
__publicField(Ea, "MaxRowCount", 50);
__publicField(Ea, "MaxColCount", 50);
class Aa extends U {
    constructor(t4, e, i) {
        super();
        __publicField(this, "__resource", /* @__PURE__ */ new Map());
        __publicField(this, "__guard");
        __publicField(this, "__crdtpath");
        __publicField(this, "__regist");
        this.__regist = e, this.__guard = i, this.__crdtpath = t4;
    }
    getCrdtPath() {
        return this.__crdtpath;
    }
    get size() {
        return this.__resource.size;
    }
    get keys() {
        return Array.from(this.__resource.keys());
    }
    get(t4) {
        return this._get(t4);
    }
    add(t4, e) {
        e = this.__guard && this.__guard(e) || e;
        let i = this.__resource.get(t4);
        return i || (i = { symbols: [], refs: /* @__PURE__ */ new Map() }, this.__resource.set(t4, i)), i.symbols.push(e), this._notify(t4), e;
    }
    clearDuplicate(t4) {
        var _a2;
        const e = (_a2 = this.__resource.get(t4)) == null ? void 0 : _a2.symbols;
        if (!e || e.length <= 1) return;
        const i = /* @__PURE__ */ new Set();
        for (let t5 = e.length - 1; t5 >= 0; --t5) {
            const s = e[t5].getPage(), r = s ? s.id : "freesymbols";
            i.has(r) ? e.splice(t5, 1) : i.add(r);
        }
    }
    _get(t4) {
        var _a2;
        const e = (_a2 = this.__resource.get(t4)) == null ? void 0 : _a2.symbols;
        if (!e) return;
        const i = this.__regist.get(t4);
        if (!i) return e[e.length - 1];
        let s;
        for (let t5 = e.length - 1; t5 >= 0; --t5) {
            const r = e[t5], n2 = r.getPage();
            if (!n2 && "freesymbols" === i) {
                s = r;
                break;
            }
            if (n2 && n2.id === i) {
                s = r;
                break;
            }
        }
        return s;
    }
    _notify(t4) {
        setTimeout(() => {
            if (!this._get(t4)) return;
            this.__resource.get(t4).refs.forEach((t5) => t5.onSymbolReady());
        });
    }
    getRefs(t4) {
        var _a2;
        return (_a2 = this.__resource.get(t4)) == null ? void 0 : _a2.refs;
    }
    removeRef(t4, e) {
        const i = this.__resource.get(t4);
        i && i.refs.delete(c(e));
    }
    addRef(t4, e) {
        e = this.__guard && this.__guard(e) || e;
        let i = this.__resource.get(t4);
        i || (i = { symbols: [], refs: /* @__PURE__ */ new Map() }, this.__resource.set(t4, i)), i.refs.set(c(e), e);
    }
}
class Fa extends U {
    constructor() {
        super();
    }
}
function Ra(t4) {
    if (!t4) return "";
    let e = "";
    for (const i of t4.childs) i instanceof Ar || (i instanceof Li ? e += Ra(i) : i instanceof Ea ? i.cells.forEach((t5) => {
        t5.text && (e += t5.text.toString());
    }) : i instanceof Gi && (e += i.text.toString()));
    return e;
}
class Oa extends Oe {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, rn, r ?? new G(), s, n2);
        __publicField(this, "__watcher", /* @__PURE__ */ new Set());
        __publicField(this, "__pages");
        __publicField(this, "__symbols");
        __publicField(this, "__styles");
        __publicField(this, "__medias");
        __publicField(this, "__versionId");
        __publicField(this, "__name");
        __publicField(this, "__correspondent");
        return this.__versionId = i, this.__name = e, this.__pages = new Z([t4, "pages"], (t5) => o2.guard(t5)), this.__symbols = new Aa([t4, "symbols"], n2, (t5) => o2.guard(t5)), this.__medias = new Z([t4, "medias"]), this.__styles = new Z([t4, "styles"]), this.__correspondent = new Fa(), this.freesymbols = a2, o2.guard(this);
    }
    watch(t4) {
        return this.__watcher.add(t4), () => {
            this.__watcher.delete(t4);
        };
    }
    unwatch(t4) {
        return this.__watcher.delete(t4);
    }
    notify(...t4) {
        0 !== this.__watcher.size && Array.from(this.__watcher).forEach((e) => {
            e(...t4);
        });
    }
    getCrdtPath() {
        return [this.id];
    }
    getOpTarget(t4) {
        if (0 === t4.length) throw new Error("path is empty");
        const e = t4[0];
        if (1 === t4.length) {
            if (e === this.id) return this;
            throw new Error("The shape is not found");
        }
        let i = this;
        const s = t4[1];
        let r = 2;
        for ("pages" === s ? i = this.__pages : "freesymbols" === s ? (this.freesymbols || (this.freesymbols = new Y()), i = this.freesymbols) : r = 1; r < t4.length; r++) {
            const e2 = t4[r];
            if (i = i instanceof Map ? i.get(e2) : i instanceof Array ? i.find((t5) => t5.id === e2) : i[e2], !i) return;
        }
        return i;
    }
    get versionId() {
        return this.__versionId;
    }
    get pagesMgr() {
        return this.__pages;
    }
    get symbolsMgr() {
        return this.__symbols;
    }
    getSymbolSync(t4) {
        return this.symbolsMgr.get(t4);
    }
    get mediasMgr() {
        return this.__medias;
    }
    get stylesMgr() {
        return this.__styles;
    }
    getPageItemAt(t4) {
        if (!(t4 < 0 || t4 >= this.pagesList.length)) return this.pagesList[t4];
    }
    indexOfPage(t4) {
        const e = "string" == typeof t4 ? t4 : t4.id;
        return this.pagesList.findIndex((t5) => t5.id === e);
    }
    getPageMetaById(t4) {
        return this.pagesList.find((e) => e.id === t4);
    }
    getPageIndexById(t4) {
        return this.pagesList.findIndex((e) => e.id === t4);
    }
    async getText() {
        let t4 = "";
        for (const e of this.pagesList) t4 += Ra(await this.__pages.get(e.id));
        return t4;
    }
}
function La(t4, e, i) {
    if ((Array.isArray(e) || "string" == typeof e) && (i = e = void 0), "string" != typeof t4) throw new Error("not support:" + t4);
    if (0 === t4.length) throw new Error("tag is empty");
    let s = "<" + t4;
    if (e) for (let t5 in e) {
        const i2 = e[t5];
        if ("style" === t5) {
            let e2 = "";
            for (let t6 in i2) void 0 !== i2[t6] && (e2 += t6 + ":" + i2[t6] + ";");
            s += " " + t5 + '="' + e2 + '"';
        } else void 0 !== i2 && (s += " " + t5 + '="' + i2 + '"');
    }
    if (s += ">", i) if (Array.isArray(i)) for (let t5 = 0, e2 = i.length; t5 < e2; t5++) s += i[t5];
    else {
        if ("string" != typeof i) throw new Error("unknow childs:" + i);
        s += i;
    }
    return s += "</" + t4 + ">", s;
}
function Pa(t4, e) {
    if (e.length > 0) {
        let i = "";
        for (let t5 = 0, s = e.length; t5 < s; ++t5) {
            const s2 = e[t5];
            s2 instanceof Ar && (i.length > 0 && (i += "/"), i += s2.id);
        }
        if (i.length > 0) return i + "/" + t4;
    }
    return t4;
}
function Ba(t4, e) {
    return e ? Pa(t4, e) : t4;
}
function Na(t4) {
    if (t4) {
        if (Array.isArray(t4)) return t4;
        if ("string" == typeof t4) return t4;
        if (t4 instanceof za) return [t4];
        throw new Error("childs must be string or EL or EL array");
    }
    return [];
}
class za {
    constructor(t4, e, i) {
        __publicField(this, "eltag");
        __publicField(this, "elattr");
        __publicField(this, "elchilds");
        this.eltag = t4, this.elattr = e || {}, this.elchilds = Na(i);
    }
    static make(t4, e, i) {
        return new za(t4, e, i);
    }
    reset(t4, e, i) {
        this.eltag = t4, this.elattr = e || {}, this.elchilds = Na(i);
    }
    get isViewNode() {
        return false;
    }
    recycle(t4) {
    }
    get outerHTML() {
        const t4 = (e) => {
            const i = Array.isArray(e.elchilds) ? e.elchilds.map((e2) => t4(e2)) : e.elchilds;
            return La(e.eltag, e.elattr, i);
        };
        return t4(this);
    }
    get innerHTML() {
        const t4 = (e) => {
            const i = Array.isArray(e.elchilds) ? e.elchilds.map((e2) => t4(e2)) : e.elchilds;
            return La(e.eltag, e.elattr, i);
        };
        return Array.isArray(this.elchilds) ? this.elchilds.reduce((e, i) => e + t4(i), "") : this.elchilds;
    }
}
function Da(t4, e, i) {
    return Array.isArray(e) ? za.make(t4, void 0, e) : za.make(t4, e, i);
}
const Ha = Ji.DefaultColor;
function Wa(t4, e) {
    const i = e.position, s = e.color || Ha;
    return t4("stop", { offset: 100 * i + "%", "stop-color": "rgba(" + s.red + "," + s.green + "," + s.blue + "," + s.alpha + ")", "stop-opacity": s.alpha });
}
function $a(t4, e, i) {
    const s = "gradient" + c(e);
    let r, n2;
    if (e.gradientType == wt.Linear) {
        const r2 = e.stops.length, o2 = [];
        for (let i2 = 0; i2 < r2; i2++) {
            const s2 = e.stops[i2];
            o2.push(Wa(t4, s2));
        }
        n2 = t4("linearGradient", { id: s, x1: e.from.x * i.width, y1: e.from.y * i.height, x2: e.to.x * i.width, y2: e.to.y * i.height, gradientUnits: "userSpaceOnUse" }, o2);
    } else if (e.gradientType == wt.Radial) {
        const r2 = e.stops.length, o2 = [];
        for (let i2 = 0; i2 < r2; i2++) {
            const s2 = e.stops[i2];
            o2.push(Wa(t4, s2));
        }
        const a2 = Math.sqrt((e.to.y * i.height - e.from.y * i.height) ** 2 + (e.to.x * i.width - e.from.x * i.width) ** 2), h2 = a2, c2 = e.elipseLength ? e.elipseLength * a2 * i.width / i.height : 0, l2 = Math.atan2(e.to.y * i.height - e.from.y * i.height, e.to.x * i.width - e.from.x * i.width) / Math.PI * 180;
        n2 = t4("radialGradient", { id: s, cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(" + e.from.x * i.width + "," + e.from.y * i.height + ") rotate(" + l2 + ") scale(" + h2 + " " + c2 + ")" }, o2);
    } else if (e.gradientType == wt.Angular) {
        let t5 = "";
        const s2 = e.stops.length, n3 = () => {
            const t6 = e.stops[0], i2 = e.stops[s2 - 1], r2 = 1 - i2.position, n4 = t6.position, o2 = t6.color || Ha, a2 = i2.color || Ha, h2 = 1 / (n4 + r2), c2 = r2 * h2, l2 = n4 * h2;
            let d2 = o2.red * c2 + a2.red * l2, p2 = o2.green * c2 + a2.green * l2, u = o2.blue * c2 + a2.blue * l2, f2 = o2.alpha * c2 + a2.alpha * l2;
            return d2 = Math.min(Math.max(Math.round(d2), 0), 255), p2 = Math.min(Math.max(Math.round(p2), 0), 255), u = Math.min(Math.max(Math.round(u), 0), 255), f2 = Math.min(Math.max(f2, 0), 1), { r: d2, g: p2, b: u, a: f2 };
        };
        if (s2 > 0 && e.stops[0].position > 0) {
            const { r: e2, g: i2, b: s3, a: r2 } = n3();
            t5 = "rgba(" + e2 + "," + i2 + "," + s3 + "," + r2 + ") 0deg";
        }
        for (let i2 = 0; i2 < s2; i2++) {
            const s3 = e.stops[i2], r2 = s3.color || Ha, n4 = "rgba(" + r2.red + "," + r2.green + "," + r2.blue + "," + r2.alpha + ")", o2 = Math.round(360 * s3.position);
            t5.length > 0 && (t5 += ","), t5 = t5 + n4 + " " + o2 + "deg";
        }
        if (s2 > 0 && e.stops[s2 - 1].position < 1) {
            const { r: e2, g: i2, b: s3, a: r2 } = n3();
            t5 = t5 + ",rgba(" + e2 + "," + i2 + "," + s3 + "," + r2 + ") 360deg";
        }
        r = "background: conic-gradient(" + ("from " + (Math.atan2(e.to.y * i.height - e.from.y * i.height, e.to.x * i.width - e.from.x * i.width) / Math.PI * 180 + 90) + "deg at " + 100 * e.from.x + "% " + 100 * e.from.y + "%") + "," + t5 + ");height:-webkit-fill-available;width:-webkit-fill-available;";
    }
    return { id: s, style: r, node: n2 };
}
function Xa(t4, e, i, s = yt.Evenodd) {
    return t4("clipPath", { id: e }, [t4("path", { d: i, "clip-rule": s })]);
}
const Ga = Ji.DefaultColor;
function Ya() {
    return Math.floor(1e4 * Math.random() + 1);
}
const Ua = "data:image/svg+xml;base64,PHN2ZyBkYXRhLXYtM2YyZGNlYTM9IiIgZGF0YS12LTJkNjBmMTNlPSIiIHdpZHRoPSI4MDAiIGhlaWdodD0iODAwIiB2aWV3Qm94PSIwIDAgNDAwIDQwMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczp4aHRtbD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pbllNaW4gbWVldCIgb3ZlcmZsb3c9InZpc2libGUiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsiPjxnPjxnPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDIxNiwyMTYsMjE2KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjE2LDIxNiwyMTYpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwyMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDIxNiwyMTYsMjE2KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwzMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMzAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwyMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMjAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMCwwLDApIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDIwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwxMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDEwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjE2LDIxNiwyMTYpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAwLDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigwLDAsMCkiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMDAsMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMzAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMjAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMCwwLDApIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDIwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDEwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMCwwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PC9nPjwvc3ZnPg==", Za = {};
function ja(t4, e, i, s, r) {
    const n2 = r.imageScaleMode || Mt.Fill;
    return Za[n2](t4, e, i, s, r);
}
Za[Mt.Fill] = function(t4, e, i, s, r) {
    const n2 = r.peekImage(true) || Ua;
    let o2 = r.originalImageWidth || 64, a2 = r.originalImageHeight || 64;
    const h2 = { "xlink:href": n2, x: 0, y: 0, "object-fit": "contain", preserveAspectRatio: "none meet" }, c2 = { width: e.width + 1, height: e.height + 1, x: 0, y: 0, patternUnits: "userSpaceOnUse", id: i }, l2 = e.width / o2, d2 = e.height / a2;
    if (e.width > e.height) {
        h2.width = e.width;
        let t5 = (a2 * l2 - e.height) / 2;
        if (t5 < 0) {
            delete h2.width, h2.height = e.height;
            t5 = (o2 * d2 - e.width) / 2, h2.x = -t5;
        } else h2.y = -t5;
    } else {
        h2.height = e.height;
        let t5 = (o2 * d2 - e.width) / 2;
        if (t5 < 0) {
            delete h2.height, h2.width = e.width;
            t5 = (a2 * l2 - e.height) / 2, h2.y = -t5;
        } else h2.x = -t5;
    }
    if (r.rotation && r.rotation > 0) if (90 === r.rotation || 270 === r.rotation) {
        const t5 = {};
        if (h2.width > 0) h2.height = h2.width, delete h2.width, 270 === r.rotation ? (t5.transform = `translate(0px ,${e.height / 2 + o2 * (e.width / a2) / 2}px) rotate(${r.rotation}deg)`, h2.y = 0) : (t5.transform = `translate(${e.width}px, ${e.height / 2 - o2 * (e.width / a2) / 2}px) rotate(${r.rotation}deg)`, h2.y = 0);
        else if (h2.width = h2.height, delete h2.height, 270 === r.rotation) {
            if (e.height / o2 * a2 > e.width) {
                const i2 = (e.height / o2 * a2 - e.width) / 2;
                t5.transform = `translate(${-i2}px ,${e.height}px) rotate(${r.rotation}deg)`;
            } else h2.height = e.width, delete h2.width, t5.transform = `translate(0px ,${e.height / 2 + o2 * (e.width / a2) / 2}px) rotate(${r.rotation}deg)`;
            h2.x = 0;
        } else {
            if (e.height / o2 * a2 > e.width) {
                const i2 = (e.height / o2 * a2 - e.width) / 2;
                t5.transform = `translate(${e.width + i2}px, 0px) rotate(${r.rotation}deg)`;
            } else h2.height = e.width, delete h2.width, t5.transform = `translate(${e.width}px ,${e.height / 2 - o2 * (e.width / a2) / 2}px) rotate(${r.rotation}deg)`;
            h2.x = 0;
        }
        h2.style = t5;
    } else h2.style = Ja(r.rotation, e);
    const p2 = Ka(t4, r), u = t4("image", h2), f2 = t4("pattern", c2, [u]);
    if (p2 && (h2.style ? h2.style.filter = p2.filter : h2.style = { filter: p2.filter }, p2.node.length)) {
        const e2 = t4("defs", p2.node);
        return t4("g", [e2, f2]);
    }
    return f2;
}, Za[Mt.Fit] = function(t4, e, i, s, r) {
    const n2 = r.peekImage(true) || Ua;
    let o2 = r.originalImageWidth || 64, a2 = r.originalImageHeight || 64;
    const h2 = { "xlink:href": n2, x: 0, y: 0, "object-fit": "contain", preserveAspectRatio: "none meet" }, c2 = { width: e.width + 1, height: e.height + 1, x: 0, y: 0, patternUnits: "userSpaceOnUse", id: i };
    if (r.rotation && r.rotation > 0) if (90 === r.rotation || 270 === r.rotation) {
        const t5 = o2;
        o2 = a2, a2 = t5;
    } else h2.style = Ja(r.rotation, e);
    const l2 = e.width / o2, d2 = e.height / a2;
    if (e.width > e.height) {
        h2.width = e.width;
        const t5 = a2 * l2;
        let i2 = (e.height - t5) / 2;
        if (i2 < 0) {
            delete h2.width, h2.height = e.height;
            const t6 = o2 * d2;
            i2 = (e.width - t6) / 2, h2.x = i2;
        } else h2.y = i2;
    } else {
        h2.height = e.height;
        const t5 = o2 * d2;
        let i2 = (e.width - t5) / 2;
        if (i2 < 0) {
            delete h2.height, h2.width = e.width;
            const t6 = a2 * l2;
            i2 = (e.height - t6) / 2, h2.y = i2;
        } else h2.x = i2;
    }
    if (r.rotation && r.rotation > 0 && (90 === r.rotation || 270 === r.rotation)) {
        const t5 = {};
        h2.width > 0 ? (h2.height = h2.width, delete h2.width, 270 === r.rotation ? t5.transform = `translate(0px ,${e.height - h2.y}px) rotate(${r.rotation}deg)` : (t5.transform = `translate(${e.width}px, 0) rotate(${r.rotation}deg)`, h2.x = h2.y), h2.y = 0) : (h2.width = h2.height, delete h2.height, 270 === r.rotation ? t5.transform = `translate(${e.width / 2 - o2 * d2 / 2}px ,${e.height}px) rotate(${r.rotation}deg)` : t5.transform = `translate(${e.width - h2.x}px, 0) rotate(${r.rotation}deg)`, h2.x = 0), h2.style = t5;
    }
    const p2 = Ka(t4, r), u = t4("image", h2), f2 = t4("pattern", c2, [u]);
    if (p2 && (h2.style ? h2.style.filter = p2.filter : h2.style = { filter: p2.filter }, p2.node.length)) {
        const e2 = t4("defs", p2.node);
        return t4("g", [e2, f2]);
    }
    return f2;
}, Za[Mt.Stretch] = function(t4, e, i, s, r) {
    const n2 = { "xlink:href": r.peekImage(true) || Ua, width: e.width, height: e.height, x: 0, y: 0, preserveAspectRatio: "none meet" };
    r.rotation && r.rotation > 0 && (90 === r.rotation || 270 === r.rotation ? (n2.width = e.height, n2.height = e.width, n2.style = { transform: `translate(${90 === r.rotation ? e.width : 0}px, ${270 === r.rotation ? e.height : 0}px) rotate(${r.rotation}deg)` }) : n2.style = Ja(r.rotation, e));
    const o2 = Ka(t4, r), a2 = t4("image", n2), h2 = t4("pattern", { width: e.width + 1, height: e.height + 1, x: 0, y: 0, patternUnits: "userSpaceOnUse", id: i }, [a2]);
    if (o2 && (n2.style ? n2.style.filter = o2.filter : n2.style = { filter: o2.filter }, o2.node.length)) {
        const e2 = t4("defs", o2.node);
        return t4("g", [e2, h2]);
    }
    return h2;
}, Za[Mt.Crop] = function(t4, e, i, s, r) {
}, Za[Mt.Tile] = function(t4, e, i, s, r) {
    let n2 = r.originalImageWidth || 64, o2 = r.originalImageHeight || 64, a2 = "number" == typeof r.scale ? r.scale : 0.5;
    const h2 = r.peekImage(true) || Ua, l2 = "mask-" + c(r) + Ya(), d2 = { "xlink:href": h2, width: n2 * a2, height: o2 * a2, x: 0, y: 0, "object-fit": "contain", preserveAspectRatio: "none meet" }, p2 = { width: n2 * a2, height: o2 * a2, x: 0, y: 0, patternUnits: "userSpaceOnUse", id: i };
    r.rotation && r.rotation > 0 && (90 === r.rotation || 270 === r.rotation ? p2.style = { transform: `translate(${p2.height / 2}px, ${p2.width / 2}px) rotate(${r.rotation}deg) translate(${-p2.width / 2}px, ${-p2.height / 2}px)` } : p2.style = Ja(r.rotation, { width: p2.width, height: p2.height }));
    const u = Ka(t4, r), f2 = t4("image", d2), g2 = t4("pattern", p2, [f2]), m2 = t4("mask", { id: l2, width: n2 * a2, height: o2 * a2 }, [t4("rect", { width: n2 * a2, height: o2 * a2, fill: "white", "fill-opacity": "0.5" }), t4("path", { d: s, fill: "white" })]);
    if (r.isEditingImage && n2 * a2 > e.width) {
        let e2 = {};
        r.rotation && r.rotation > 0 && (e2 = 90 === r.rotation || 270 === r.rotation ? { transform: `translate(${o2 * a2 / 2}px, ${n2 * a2 / 2}px) rotate(${r.rotation}deg) translate(${-n2 * a2 / 2}px, ${-o2 * a2 / 2}px)` } : Ja(r.rotation, { width: n2 * a2, height: o2 * a2 }));
        const i2 = [g2, m2, t4("image", { ...d2, style: e2, opacity: r.color.alpha, mask: "url(#" + l2 + ")" })];
        if (u) {
            if (u.node.length) {
                const e3 = t4("defs", u.node);
                i2.unshift(e3);
            }
            d2.style = { filter: u.filter };
        }
        return t4("g", i2);
    }
    if (u && (d2.style = { filter: u.filter }, u.node.length)) {
        const e2 = t4("defs", u.node);
        return t4("g", [e2, g2]);
    }
    return g2;
};
const Ja = (t4, e) => {
    if (!t4) return;
    const { width: i, height: s } = e, r = {};
    let n2 = `translate(${i / 2}px, ${s / 2}px) rotate(${t4}deg) translate(${-i / 2}px, ${-s / 2}px)`;
    return r.transform = n2, r;
}, Ka = (t4, e) => {
    let i = [], s = "";
    const r = e.paintFilter;
    if (r) {
        if (r.exposure) {
            const n2 = r.exposure / 200, o2 = "exposureFilter-" + c(e) + Ya(), a2 = { type: "linear", slope: "1", intercept: n2 }, h2 = t4("feComponentTransfer", [t4("feFuncR", a2), t4("feFuncG", a2), t4("feFuncB", a2)]), l2 = t4("filter", { id: o2 }, [h2]);
            i.push(l2), s += `url(#${o2}) `;
        }
        if (r.contrast) {
            s += `contrast(${1 + r.contrast / 200}) `;
        }
        if (r.saturation) {
            const n2 = t4("feColorMatrix", { type: "saturate", values: 1 + r.saturation / 100 }), o2 = "shadowFilter-" + c(e) + Ya(), a2 = t4("filter", { id: o2 }, [n2]);
            i.push(a2), s += `url(#${o2}) `;
        }
        if (r.temperature) {
            let n2 = 1, o2 = 1;
            r.temperature < 0 ? (n2 = 1 + r.temperature / 200, o2 = 1 - r.temperature / 25) : (n2 = 1 + r.temperature / 200, o2 = 1 - r.temperature / 100);
            const a2 = t4("feColorMatrix", { type: "matrix", values: `${n2} 0 0 0 0
                     0 1 0 0 0
                     0 0 ${o2} 0 0
                     0 0 0 1 0` }), h2 = "shadowFilter-" + c(e) + Ya(), l2 = t4("filter", { id: h2 }, [a2]);
            i.push(l2), s += `url(#${h2}) `;
        }
        if (r.tint) {
            let n2 = 1, o2 = 1;
            r.tint, n2 = 1 + r.tint / 200, o2 = 1 - r.tint / 200;
            const a2 = "shadowFilter-" + c(e) + Ya(), h2 = t4("feColorMatrix", { type: "matrix", values: `${n2} 0 0 0 0
                     0 ${o2} 0 0 0
                     0 0 1 0 0
                     0 0 0 1 0` }), l2 = t4("filter", { id: a2 }, [h2]);
            i.push(l2), s += `url(#${a2}) `;
        }
        if (r.shadow) {
            const n2 = r.shadow / 1e3, o2 = "shadowFilter-" + c(e) + Ya(), a2 = { type: "linear", slope: "1", intercept: n2 }, h2 = t4("feComponentTransfer", [t4("feFuncR", a2), t4("feFuncG", a2), t4("feFuncB", a2)]), l2 = t4("filter", { id: o2 }, [h2]);
            i.push(l2), s += `url(#${o2}) `;
        }
        if (r.hue) {
            const n2 = "hueFilter-" + c(e) + Ya(), o2 = t4("feColorMatrix", { type: "hueRotate", values: r.hue }), a2 = t4("filter", { id: n2 }, [o2]);
            i.push(a2), s += `url(#${n2}) `;
        }
        if (s.length) return { node: i, filter: s };
    }
};
function qa() {
    return Math.floor(1e4 * Math.random() + 1);
}
const Qa = {};
function th(t4, e, i, s) {
    const r = e.length, n2 = new Array();
    for (let o2 = 0; o2 < r; o2++) {
        const r2 = e[o2];
        if (!r2.isEnabled) continue;
        const a2 = r2.fillType;
        n2.push(Qa[a2](t4, i, r2, s));
    }
    return n2;
}
Qa[xt.SolidColor] = function(t4, e, i, s) {
    const r = i.color;
    return t4("path", { d: s, fill: "rgb(" + r.red + "," + r.green + "," + r.blue + ")", "fill-opacity": r ? r.alpha : 1, stroke: "none", "stroke-width": 0, "fill-rule": i.fillRule || "evenodd" });
}, Qa[xt.Gradient] = function(t4, e, i, s) {
    var _a2;
    const r = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, n2 = [], o2 = $a(t4, i.gradient, e);
    o2.node && n2.push(o2.node);
    const a2 = o2.id, h2 = o2.style;
    if (h2) {
        const o3 = "clippath-fill-" + c(i) + qa(), a3 = Xa(t4, o3, s);
        n2.push(a3), n2.push(t4("foreignObject", { width: e.width, height: e.height, x: 0, y: 0, "clip-path": "url(#" + o3 + ")", opacity: void 0 === r ? 1 : r }, t4("div", { width: "100%", height: "100%", style: h2 })));
    } else n2.push(t4("path", { d: s, fill: "url(#" + a2 + ")", "fill-opacity": void 0 === r ? 1 : r, stroke: "none", "stroke-width": 0, "fill-rule": i.fillRule || "evenodd" }));
    return t4("g", n2);
}, Qa[xt.Pattern] = function(t4, e, i, s) {
    const r = "pattern-fill-" + c(i) + qa(), n2 = i.color, o2 = ja(t4, e, r, s, i), a2 = t4("path", { d: s, fill: "url(#" + r + ")", "fill-opacity": n2 ? n2.alpha : 1 });
    return t4("g", [o2, a2]);
};
const eh = {};
eh[xt.SolidColor] = function(t4, e, i, s) {
    return Qa[xt.SolidColor](t4, e, i, s);
}, eh[xt.Gradient] = function(t4, e, i, s) {
    var _a2, _b;
    if (((_a2 = i.gradient) == null ? void 0 : _a2.gradientType) === wt.Angular) return Qa[xt.SolidColor](t4, e, i, s);
    const r = (_b = i.gradient) == null ? void 0 : _b.gradientOpacity, n2 = [], o2 = $a(t4, i.gradient, e);
    o2.node && n2.push(o2.node);
    const a2 = o2.id, h2 = o2.style;
    if (h2) {
        const o3 = "clippath-fill-" + c(i) + qa(), a3 = Xa(t4, o3, s);
        n2.push(a3), n2.push(t4("foreignObject", { width: e.width, height: e.height, x: 0, y: 0, "clip-path": "url(#" + o3 + ")", opacity: void 0 === r ? 1 : r }, t4("div", { width: "100%", height: "100%", style: h2 })));
    } else n2.push(t4("path", { d: s, fill: "url(#" + a2 + ")", "fill-opacity": void 0 === r ? 1 : r, stroke: "none", "stroke-width": 0, "fill-rule": i.fillRule || "evenodd" }));
    return t4("g", n2);
}, eh[xt.Pattern] = function(t4, e, i, s) {
    return Qa[xt.Pattern](t4, e, i, s);
};
const ih = {}, sh = {};
sh[ht.Inner] = function(t4, e, i, s, r) {
    var _a2;
    const n2 = Ya(), o2 = "clippath-border" + c(i) + n2, a2 = "mask1-border" + c(i) + n2, h2 = "mask2-border" + c(i) + n2, l2 = oh(i.sideSetting), d2 = e.width, p2 = e.height, u = $a(t4, i.gradient, e), f2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, g2 = { d: s, stroke: "white", "stroke-width": 2 * l2, "clip-path": "url(#" + o2 + ")", "stroke-linejoin": i.cornerType, opacity: void 0 === f2 ? 1 : f2 }, { length: m2, gap: _2 } = i.borderStyle;
    (m2 || _2) && (g2["stroke-dasharray"] = `${m2}, ${_2}`, g2["stroke-dashoffset"] = m2 / 2);
    const y2 = ch(r, i, false);
    g2.mask = "url(#" + h2 + ")";
    const x2 = t4("mask", { id: h2, x: 0, y: 0, width: d2, height: p2 }, [t4("path", { d: s, fill: "white" }), t4("path", { d: y2, fill: "black" })]), w2 = [];
    if (0 === Math.max(...r.radius)) {
        const r2 = { fill: "none", stroke: "white" };
        (m2 || _2) && (r2["stroke-dasharray"] = `${m2}, ${_2}`, r2["stroke-dashoffset"] = m2 / 2);
        const n3 = t4("rect", { x: 0, y: 0, width: d2, height: p2, fill: "black" }), a3 = dh(t4, e, i, r2, false), h3 = t4("clipPath", { id: o2 }, t4("path", { d: s, "clip-rule": "evenodd" })), c2 = t4("g", { "clip-path": "url(#" + o2 + ")" }, a3);
        w2.push(n3, h3, c2);
    } else {
        const e2 = t4("rect", { x: 0, y: 0, width: d2, height: p2, fill: "black" }), i2 = t4("clipPath", { id: o2 }, t4("path", { d: s, "clip-rule": "evenodd" }));
        w2.push(e2, i2, t4("path", g2), x2);
    }
    return t4("g", [t4("mask", { id: a2, width: d2, height: p2 }, w2), t4("foreignObject", { x: 0, y: 0, width: d2, height: p2, mask: "url(#" + a2 + ")" }, [t4("div", { width: "100%", height: "100%", style: u.style })])]);
}, sh[ht.Center] = function(t4, e, i, s, r) {
    var _a2;
    const n2 = Ya(), o2 = "mask1-border" + c(i) + n2, a2 = "mask2-border" + c(i) + n2, h2 = oh(i.sideSetting), l2 = $a(t4, i.gradient, e), d2 = -h2 / 2, p2 = -h2 / 2, u = e.width + h2, f2 = e.height + h2, g2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, m2 = { d: s, stroke: "white", "stroke-width": h2, "stroke-linejoin": i.cornerType, opacity: void 0 === g2 ? 1 : g2 };
    (Math.max(...r.radius) > 0 || i.sideSetting.sideType !== Dt.Custom) && (m2["stroke-linejoin"] = "miter");
    const { length: _2, gap: y2 } = i.borderStyle;
    (_2 || y2) && (m2["stroke-dasharray"] = `${_2}, ${y2}`, m2["stroke-dashoffset"] = _2 / 2);
    const x2 = nh(r, i, true), w2 = ch(r, i, true);
    m2.mask = "url(#" + a2 + ")";
    const b2 = [t4("mask", { id: a2, x: -h2 / 2, y: -h2 / 2, width: u, height: f2 }, [t4("path", { d: x2, fill: "white" }), t4("path", { d: w2, fill: "black" })]), t4("rect", { x: d2, y: p2, width: u, height: f2, fill: "black" })];
    if (0 === Math.max(...r.radius) && (_2 || y2)) {
        const s2 = { fill: "none", stroke: "white", "stroke-dasharray": _2, gap: y2, "stroke-dashoffset": _2 / 2 }, r2 = uh(t4, e, i.sideSetting, "white"), n3 = t4("g", { mask: "url(#" + a2 + ")" }, [...dh(t4, e, i, s2, true), r2]);
        b2.push(n3);
    } else b2.push(t4("path", m2));
    return t4("g", [t4("mask", { id: o2, maskContentUnits: "userSpaceOnUse", x: d2, y: p2, width: u, height: f2 }, b2), t4("foreignObject", { width: u, height: f2, x: d2, y: p2, mask: "url(#" + o2 + ")" }, t4("div", { width: "100%", height: "100%", style: l2.style }))]);
}, sh[ht.Outer] = function(t4, e, i, s, r) {
    var _a2;
    const n2 = oh(i.sideSetting), o2 = $a(t4, i.gradient, e), a2 = e.width + 2 * n2, h2 = e.height + 2 * n2, l2 = -n2, d2 = -n2, p2 = Ya(), u = "mask1-border" + c(i) + p2, f2 = "mask2-border" + c(i) + p2, g2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, m2 = { d: s, stroke: "white", "stroke-width": 2 * n2, mask: "url(#" + u + ")", "stroke-linejoin": i.cornerType, opacity: void 0 === g2 ? 1 : g2 };
    (Math.max(...r.radius) > 0 || i.sideSetting.sideType !== Dt.Custom) && (m2["stroke-linejoin"] = "miter");
    const { length: _2, gap: y2 } = i.borderStyle;
    (_2 || y2) && (m2["stroke-dasharray"] = `${_2}, ${y2}`, m2["stroke-dashoffset"] = _2 / 2);
    const x2 = nh(r, i, false), w2 = hh(e, r.radius, i.sideSetting);
    return t4("g", [t4("mask", { id: f2, x: l2, y: d2, width: a2, height: h2 }, [t4("mask", { id: u, x: -n2, y: -n2, width: a2, height: h2 }, [t4("path", { d: x2, fill: "white" }), t4("path", { d: s, fill: "black" }), t4("path", { d: w2, fill: "black" })]), t4("rect", { x: l2, y: d2, width: a2, height: h2, fill: "black" }), t4("path", m2)]), t4("foreignObject", { width: a2, height: h2, x: l2, y: d2, mask: "url(#" + f2 + ")" }, t4("div", { width: "100%", height: "100%", style: o2.style }))]);
}, ih[ht.Inner] = function(t4, e, i, s, r) {
    var _a2;
    const { length: n2, gap: o2 } = i.borderStyle;
    if (0 === Math.max(...r.radius)) return lh(t4, e, i, s);
    const a2 = Ya(), h2 = "clippath-border" + c(i) + a2, l2 = "mask-border" + c(i) + a2, { width: d2, height: p2 } = e;
    let u;
    const f2 = { d: s, fill: "none", stroke: "", "stroke-width": 2 * oh(i.sideSetting), "clip-path": "url(#" + h2 + ")" };
    (n2 || o2) && (f2["stroke-dasharray"] = `${n2}, ${o2}`, f2["stroke-dashoffset"] = n2 / 2);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        f2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        u = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        f2.opacity = void 0 === s2 ? 1 : s2, f2.stroke = "url(#" + u.id + ")";
    }
    const g2 = [];
    u && u.node && g2.push(u.node);
    const m2 = ch(r, i, false);
    f2.mask = "url(#" + l2 + ")";
    const _2 = t4("mask", { id: l2, x: 0, y: 0, width: d2, height: p2 }, [t4("path", { d: s, fill: "white" }), t4("path", { d: m2, fill: "black" })]);
    return g2.push(t4("clipPath", { id: h2 }, t4("path", { d: s, "clip-rule": "evenodd" })), _2, t4("path", f2)), t4("g", g2);
}, ih[ht.Center] = function(t4, e, i, s, r) {
    var _a2;
    const { length: n2, gap: o2 } = i.borderStyle;
    if (0 === Math.max(...r.radius) && (n2 || o2)) return ph(t4, e, i, s, r);
    const a2 = oh(i.sideSetting), h2 = Ya(), l2 = "mask-border" + c(i) + h2, d2 = r.radius;
    let p2;
    const u = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": a2 };
    (Math.max(...d2) > 0 || i.sideSetting.sideType !== Dt.Custom) && (u["stroke-linejoin"] = "miter"), (n2 || o2) && (u["stroke-dasharray"] = `${n2}, ${o2}`, u["stroke-dashoffset"] = n2 / 2);
    const f2 = e.width + a2, g2 = e.height + a2;
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        u.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        p2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        u.opacity = void 0 === s2 ? 1 : s2, u.stroke = "url(#" + p2.id + ")";
    }
    const m2 = nh(r, i, true), _2 = ch(r, i, true);
    u.mask = "url(#" + l2 + ")";
    const y2 = t4("mask", { id: l2, x: -a2 / 2, y: -a2 / 2, width: f2, height: g2 }, [t4("path", { d: m2, fill: "white" }), t4("path", { d: _2, fill: "black" })]), x2 = t4("path", u);
    return p2 && p2.node ? t4("g", [p2.node, y2, x2]) : t4("g", [y2, x2]);
}, ih[ht.Outer] = function(t4, e, i, s, r) {
    var _a2;
    const n2 = oh(i.sideSetting);
    let o2;
    const a2 = r.radius, h2 = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": 2 * n2 };
    (Math.max(...a2) > 0 || i.sideSetting.sideType !== Dt.Custom) && (h2["stroke-linejoin"] = "miter");
    const { length: l2, gap: d2 } = i.borderStyle;
    (l2 || d2) && (h2["stroke-dasharray"] = `${l2}, ${d2}`, h2["stroke-dashoffset"] = l2 / 2);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        h2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        o2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        h2.opacity = void 0 === s2 ? 1 : s2, h2.stroke = "url(#" + o2.id + ")";
    }
    const p2 = Ya(), u = "mask-border" + c(i) + p2;
    h2.mask = "url(#" + u + ")";
    const f2 = e.width + 2 * n2, g2 = e.height + 2 * n2, m2 = [];
    o2 && o2.node && m2.push(o2.node);
    const _2 = nh(r, i, false), y2 = hh(e, r.radius, i.sideSetting), x2 = t4("mask", { id: u, x: -n2, y: -n2, width: f2, height: g2 }, [t4("path", { d: _2, fill: "white" }), t4("path", { d: s, fill: "black" }), t4("path", { d: y2, fill: "black" })]), w2 = t4("path", h2);
    return m2.push(x2, w2), t4("g", m2);
};
const rh = (t4, e, i, s, r) => {
    const n2 = i.fillType, o2 = i.gradient && i.gradient.gradientType;
    return n2 == xt.Gradient && o2 == wt.Angular ? sh[i.position](t4, e, i, s, r) : ih[i.position](t4, e, i, s, r);
}, nh = (t4, e, i) => {
    const s = e.cornerType, { width: r, height: n2 } = t4.size, a2 = t4.radius, { sideType: h2, thicknessBottom: c2, thicknessTop: l2, thicknessLeft: d2, thicknessRight: p2 } = e.sideSetting, u = i ? l2 / 2 : l2, f2 = i ? c2 / 2 : c2, g2 = i ? d2 / 2 : d2, m2 = i ? p2 / 2 : p2;
    if (Math.max(...a2) > 0 || h2 !== Dt.Custom || s !== ut.Bevel) return ah(a2, t4.size, e.sideSetting, s, i);
    {
        const t5 = r + m2 + g2, e2 = n2 + u + f2, i2 = new se([], "", 0, -u, ft.Straight), s2 = new se([], "", r, -u, ft.Straight), a3 = new se([], "", r + m2, 0, ft.Straight), h3 = new se([], "", r + m2, n2, ft.Straight), c3 = new se([], "", r, n2 + f2, ft.Straight), l3 = new se([], "", 0, n2 + f2, ft.Straight), d3 = new se([], "", -g2, n2, ft.Straight), p3 = new se([], "", -g2, 0, ft.Straight), _2 = new pi(vi(new G(i2, s2, a3, h3, c3, l3, d3, p3), true, t5, e2, void 0)), y2 = new o();
        return y2.preScale(t5, e2), _2.transform(new o(y2.inverse)), _2.toString();
    }
}, oh = (t4) => {
    const { sideType: e, thicknessBottom: i, thicknessTop: s, thicknessLeft: r, thicknessRight: n2 } = t4;
    return Math.max(i, s, r, n2);
}, ah = (t4, e, i, s, r) => {
    const { width: n2, height: o2 } = e, { sideType: a2, thicknessBottom: h2, thicknessTop: c2, thicknessLeft: l2, thicknessRight: d2 } = i, p2 = new se([], "", 0, 0, ft.Straight), u = new se([], "", 1, 0, ft.Straight), f2 = new se([], "", 1, 1, ft.Straight), g2 = new se([], "", 0, 1, ft.Straight), m2 = r ? c2 / 2 : c2, _2 = r ? h2 / 2 : h2, y2 = r ? l2 / 2 : l2, x2 = r ? d2 / 2 : d2;
    if (Math.max(...t4) > 0) {
        const i2 = 0 === y2 ? m2 : 0 === m2 ? y2 : Math.min(y2, m2), s2 = 0 === y2 ? _2 : 0 === _2 ? y2 : Math.min(y2, _2), r2 = 0 === x2 ? m2 : 0 === m2 ? x2 : Math.min(x2, m2), n3 = 0 === x2 ? _2 : 0 === _2 ? x2 : Math.min(x2, _2), o3 = fh(t4, e);
        p2.radius = o3[0] > 0 ? o3[0] + i2 : 0, u.radius = o3[1] > 0 ? o3[1] + r2 : 0, f2.radius = o3[2] > 0 ? o3[2] + n3 : 0, g2.radius = o3[3] > 0 ? o3[3] + s2 : 0;
    } else if (s === ut.Round && a2 === Dt.Custom) {
        const t5 = y2 > 0 && m2 > 0 ? Math.min(y2, m2) : 0, e2 = x2 > 0 && m2 > 0 ? Math.min(x2, m2) : 0, i2 = x2 > 0 && _2 > 0 ? Math.min(x2, _2) : 0, s2 = y2 > 0 && _2 > 0 ? Math.min(y2, _2) : 0;
        p2.radius = t5, u.radius = e2, f2.radius = i2, g2.radius = s2;
    }
    let w2 = n2 + x2 + y2, b2 = o2 + m2 + _2;
    const M2 = new pi(vi(new G(p2, u, f2, g2), true, w2, b2, void 0));
    return M2.translate(-y2, -m2), M2.toString();
}, hh = (t4, e, i) => {
    const { sideType: s, thicknessBottom: r, thicknessTop: n2, thicknessLeft: a2, thicknessRight: h2 } = i;
    let c2 = t4.width, l2 = t4.height, d2 = { x: 0, y: 0 }, p2 = { x: c2, y: 0 }, u = { x: c2, y: l2 }, f2 = { x: 0, y: l2 };
    const g2 = fh(e, t4);
    0 === n2 ? (a2 > 0 ? (g2[0] > 0 ? d2.x = g2[0] : d2.x = 0, d2.y = -2) : (d2.x = -2, d2.y = -2), h2 > 0 ? (g2[1] > 0 ? p2.x -= g2[1] : p2.x = c2, p2.y = -2) : (p2.x += 2, p2.y = -2)) : (a2 > 0 ? d2.y = g2[0] : (g2[0] > 0 ? d2.y = g2[0] : d2.y = 0, d2.x = -2), h2 > 0 ? p2.y = g2[1] : (g2[1] > 0 ? p2.y = g2[1] : p2.y = 0, p2.x += 2)), 0 === r ? (a2 > 0 ? (g2[3] > 0 ? f2.x = g2[3] : f2.x = 0, f2.y = l2 + 2) : (f2.x = -2, f2.y += 2), h2 > 0 ? g2[2] > 0 ? u.x -= g2[2] : u.x = c2 : (u.x += 2, u.y += 2)) : (a2 > 0 ? (f2.x = 0, f2.y -= g2[3]) : (g2[3] > 0 ? f2.y -= g2[3] : f2.y = l2, f2.x = -2), h2 > 0 ? (u.x = c2, u.y -= g2[2]) : (g2[2] > 0 ? u.y -= g2[2] : u.y = l2, u.x += 2));
    const m2 = new se([], "", d2.x, d2.y, ft.Straight), _2 = new se([], "", p2.x, p2.y, ft.Straight), y2 = new se([], "", u.x, u.y, ft.Straight), x2 = new se([], "", f2.x, f2.y, ft.Straight), w2 = Math.max(p2.x, u.x), b2 = Math.max(u.y, f2.y), M2 = new pi(vi(new G(m2, _2, y2, x2), true, w2, b2, void 0)), v2 = new o();
    return v2.preScale(w2, b2), M2.transform(new o(v2.inverse)), M2.toString();
}, ch = (t4, e, i) => {
    const { width: s, height: r } = t4.size, n2 = t4.radius, { sideType: o2, thicknessBottom: a2, thicknessTop: h2, thicknessLeft: c2, thicknessRight: l2 } = e.sideSetting, d2 = i ? h2 / 2 : h2, p2 = i ? a2 / 2 : a2, u = i ? c2 / 2 : c2, f2 = i ? l2 / 2 : l2, g2 = new se([], "", 0, 0, ft.Straight), m2 = new se([], "", 1, 0, ft.Straight), _2 = new se([], "", 1, 1, ft.Straight), y2 = new se([], "", 0, 1, ft.Straight), x2 = fh(n2, t4.size);
    if (x2[0] > 0) {
        const t5 = Math.max(u, d2);
        t5 > x2[0] ? g2.radius = 0 : g2.radius = x2[0] - t5;
    }
    if (x2[1] > 0) {
        const t5 = Math.max(f2, d2);
        t5 > x2[1] ? m2.radius = 0 : m2.radius = x2[1] - t5;
    }
    if (x2[2] > 0) {
        const t5 = Math.max(f2, p2);
        t5 > x2[2] ? _2.radius = 0 : _2.radius = x2[2] - t5;
    }
    if (x2[3] > 0) {
        const t5 = Math.max(u, p2);
        t5 > x2[3] ? y2.radius = 0 : y2.radius = x2[3] - t5;
    }
    let w2 = f2 + u > s ? 0 : s - (f2 + u), b2 = d2 + p2 > r ? 0 : r - (d2 + p2);
    const M2 = new pi(vi(new G(g2, m2, _2, y2), true, w2, b2, void 0));
    return M2.translate(u, d2), M2.toString();
}, lh = (t4, e, i, s) => {
    var _a2;
    const r = Ya(), n2 = "clippath-border" + c(i) + r;
    let o2;
    const a2 = { fill: "none", stroke: "" }, { length: h2, gap: l2 } = i.borderStyle;
    (h2 || l2) && (a2["stroke-dasharray"] = `${h2}, ${l2}`, a2["stroke-dashoffset"] = h2 / 2);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        a2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        o2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        a2.opacity = void 0 === s2 ? 1 : s2, a2.stroke = "url(#" + o2.id + ")";
    }
    const d2 = [];
    o2 && o2.node && d2.push(o2.node);
    const p2 = dh(t4, e, i, a2, false);
    return d2.push(t4("clipPath", { id: n2 }, t4("path", { d: s, "clip-rule": "evenodd" })), t4("g", { "clip-path": "url(#" + n2 + ")" }, p2)), t4("g", d2);
}, dh = (t4, e, i, s, r) => {
    const { sideType: n2, thicknessTop: o2, thicknessLeft: a2, thicknessBottom: h2, thicknessRight: c2 } = i.sideSetting, { width: l2, height: d2 } = e, p2 = [], u = t4("path", { d: `M 0 0 L ${l2} 0`, ...s, "stroke-width": r ? o2 : 2 * o2 }), f2 = t4("path", { d: `M ${l2} 0 L ${l2} ${d2}`, ...s, "stroke-width": r ? c2 : 2 * c2 }), g2 = t4("path", { d: `M 0 0 L 0 ${d2}`, ...s, "stroke-width": r ? a2 : 2 * a2 }), m2 = t4("path", { d: `M 0 ${d2} L ${l2} ${d2}`, ...s, "stroke-width": r ? h2 : 2 * h2 });
    switch (n2) {
        case Dt.Top:
            p2.push(u);
            break;
        case Dt.Left:
            p2.push(g2);
            break;
        case Dt.Right:
            p2.push(f2);
            break;
        case Dt.Bottom:
            p2.push(m2);
            break;
        case Dt.Custom:
            p2.push(u, f2, g2, m2);
            break;
        default:
            return [];
    }
    return p2;
}, ph = (t4, e, i, s, r) => {
    var _a2;
    const n2 = oh(i.sideSetting), o2 = Ya(), a2 = "mask-border" + c(i) + o2;
    let h2;
    const l2 = { fill: "none", stroke: "" }, { length: d2, gap: p2 } = i.borderStyle;
    (d2 || p2) && (l2["stroke-dasharray"] = `${d2}, ${p2}`, l2["stroke-dashoffset"] = d2 / 2);
    const u = e.width + n2, f2 = e.height + n2;
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        l2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        h2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        l2.opacity = void 0 === s2 ? 1 : s2, l2.stroke = "url(#" + h2.id + ")";
    }
    const g2 = nh(r, i, true), m2 = t4("mask", { id: a2, x: -n2 / 2, y: -n2 / 2, width: u, height: f2 }, [t4("path", { d: s, fill: "black" }), t4("path", { d: g2, fill: "white" })]), _2 = uh(t4, e, i.sideSetting, l2.stroke), y2 = t4("g", { mask: "url(#" + a2 + ")" }, [...dh(t4, e, i, l2, true), _2]);
    return h2 && h2.node ? t4("g", [h2.node, m2, y2]) : t4("g", [m2, y2]);
}, uh = (t4, e, i, s) => {
    const { width: r, height: n2 } = e, { thicknessBottom: o2, thicknessLeft: a2, thicknessRight: h2, thicknessTop: c2 } = i;
    return t4("path", { d: `M ${-a2} ${-c2} L 0 ${-c2} L 0 0 L ${-a2} 0 Z M ${r} ${-c2} L ${r + h2} ${-c2} L ${r + h2} 0 L ${r} 0 Z M ${r} ${n2} L ${r + h2} ${n2} L ${r + h2} ${n2 + o2} L ${r} ${n2 + o2} Z M ${-a2} ${n2} L 0 ${n2} L 0 ${n2 + o2} L ${-a2} ${n2 + o2} Z`, fill: s, stroke: "none" });
}, fh = (t4, e) => {
    const { width: i, height: s } = e;
    let r = [...t4];
    const n2 = Math.min(i, s);
    return t4[0] > n2 / 2 && (t4[1] > 0 || t4[3] > 0 ? t4[1] > 0 && t4[3] > 0 ? r[0] = n2 / 2 : t4[1] > 0 ? r[0] = Math.min(t4[0], i / 2, s) : r[0] = Math.min(t4[0], i, s / 2) : t4[0] > n2 ? r[0] = n2 : r[0] = t4[0]), t4[1] > n2 / 2 && (t4[0] > 0 || t4[2] > 0 ? t4[0] > 0 && t4[2] > 0 ? r[1] = n2 / 2 : t4[0] > 0 ? r[1] = Math.min(t4[1], i / 2, s) : r[1] = Math.min(t4[1], i, s / 2) : t4[1] > n2 ? r[1] = n2 : r[1] = t4[1]), t4[2] > n2 / 2 && (t4[3] > 0 || t4[1] > 0 ? t4[3] > 0 && t4[1] > 0 ? r[2] = n2 / 2 : t4[3] > 0 ? r[2] = Math.min(t4[2], i / 2, s) : r[2] = Math.min(t4[2], i, s / 2) : t4[2] > n2 ? r[2] = n2 : r[2] = t4[2]), t4[3] > n2 / 2 && (t4[2] > 0 || t4[0] > 0 ? t4[2] > 0 && t4[0] > 0 ? r[3] = n2 / 2 : t4[2] > 0 ? r[3] = Math.min(t4[3], i / 2, s) : r[3] = Math.min(t4[3], i, s / 2) : t4[3] > n2 ? r[3] = n2 : r[3] = t4[3]), r;
}, gh = {}, mh = {};
function _h(t4, e, i, s, r, n2 = true) {
    const o2 = e.length, a2 = [];
    for (let h2 = 0; h2 < o2; h2++) {
        const o3 = e[h2];
        if (!o3.isEnabled) continue;
        const c2 = n2 ? o3.position : ht.Center, l2 = o3.fillType, d2 = o3.gradient && o3.gradient.gradientType;
        l2 == xt.Gradient && d2 == wt.Angular && void a2.push(mh[c2](t4, i, o3, s, r)) || (l2 == xt.SolidColor || l2 == xt.Gradient) && void a2.push(gh[c2](t4, i, o3, s, r)) || xt.Pattern;
    }
    return a2;
}
function yh(t4, e) {
    return t4 !== Dt.Normal && !e.haveEdit && [Vt.Rectangle, Vt.Artboard, Vt.Image, Vt.Symbol, Vt.SymbolRef, Vt.SymbolUnion].includes(e.type);
}
mh[ht.Inner] = function(t4, e, i, s, r) {
    var _a2;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const n2 = Ya(), o2 = "clippath-border" + c(i) + n2, a2 = "mask-border" + c(i) + n2, h2 = i.sideSetting.thicknessTop, l2 = e.width, d2 = e.height, p2 = $a(t4, i.gradient, e), u = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, f2 = { d: s, stroke: "white", "stroke-width": 2 * h2, "clip-path": "url(#" + o2 + ")", "stroke-linejoin": i.cornerType, opacity: void 0 === u ? 1 : u }, { length: g2, gap: m2 } = i.borderStyle;
    return (g2 || m2) && (f2["stroke-dasharray"] = `${g2}, ${m2}`), t4("g", [t4("mask", { id: a2, width: l2, height: d2 }, [t4("rect", { x: 0, y: 0, width: l2, height: d2, fill: "black" }), t4("clipPath", { id: o2 }, t4("path", { d: s, "clip-rule": "evenodd" })), t4("path", f2)]), t4("foreignObject", { x: 0, y: 0, width: l2, height: d2, mask: "url(#" + a2 + ")" }, t4("div", { width: "100%", height: "100%", style: p2.style }))]);
}, mh[ht.Center] = function(t4, e, i, s, r) {
    var _a2;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const n2 = Ya(), o2 = "mask-border" + c(i) + n2, a2 = i.sideSetting.thicknessTop, h2 = $a(t4, i.gradient, e), l2 = -a2 / 2, d2 = -a2 / 2, p2 = e.width + a2, u = e.height + a2, f2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, g2 = { d: s, stroke: "white", "stroke-width": a2, "stroke-linejoin": i.cornerType, opacity: void 0 === f2 ? 1 : f2 }, { length: m2, gap: _2 } = i.borderStyle;
    return (m2 || _2) && (g2["stroke-dasharray"] = `${m2}, ${_2}`), t4("g", [t4("mask", { id: o2, maskContentUnits: "userSpaceOnUse", x: l2, y: d2, width: p2, height: u }, [t4("rect", { x: l2, y: d2, width: p2, height: u, fill: "black" }), t4("path", g2)]), t4("foreignObject", { width: p2, height: u, x: l2, y: d2, mask: "url(#" + o2 + ")" }, t4("div", { width: "100%", height: "100%", style: h2.style }))]);
}, mh[ht.Outer] = function(t4, e, i, s, r) {
    var _a2;
    const n2 = i.sideSetting.thicknessTop;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const o2 = $a(t4, i.gradient, e), a2 = e.width + 2 * n2, h2 = e.height + 2 * n2, l2 = -n2, d2 = -n2, p2 = Ya(), u = "mask1-border" + c(i) + p2, f2 = "mask2-border" + c(i) + p2, g2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity, m2 = { d: s, stroke: "white", "stroke-width": 2 * n2, mask: "url(#" + u + ")", "stroke-linejoin": i.cornerType, opacity: void 0 === g2 ? 1 : g2 }, { length: _2, gap: y2 } = i.borderStyle;
    return (_2 || y2) && (m2["stroke-dasharray"] = `${_2}, ${y2}`), t4("g", [t4("mask", { id: f2, x: l2, y: d2, width: a2, height: h2 }, [t4("mask", { id: u, x: -n2, y: -n2, width: a2, height: h2 }, [t4("rect", { x: -n2, y: -n2, width: a2, height: h2, fill: "white" }), t4("path", { d: s, fill: "black" })]), t4("rect", { x: l2, y: d2, width: a2, height: h2, fill: "black" }), t4("path", m2)]), t4("foreignObject", { width: a2, height: h2, x: l2, y: d2, mask: "url(#" + f2 + ")" }, t4("div", { width: "100%", height: "100%", style: o2.style }))]);
}, gh[ht.Inner] = function(t4, e, i, s, r) {
    var _a2;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const n2 = Ya(), o2 = "clippath-border" + c(i) + n2;
    let a2;
    const h2 = { d: s, fill: "none", stroke: "", "stroke-width": 2 * i.sideSetting.thicknessTop, "stroke-linejoin": i.cornerType, "clip-path": "url(#" + o2 + ")" };
    r && Math.max(...r.radius) > 0 && (h2["stroke-linejoin"] = "miter");
    const { length: l2, gap: d2 } = i.borderStyle;
    (l2 || d2) && (h2["stroke-dasharray"] = `${l2}, ${d2}`);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        h2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        a2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        h2.opacity = void 0 === s2 ? 1 : s2, h2.stroke = "url(#" + a2.id + ")";
    }
    const p2 = [];
    return a2 && a2.node && p2.push(a2.node), p2.push(t4("clipPath", { id: o2 }, t4("path", { d: s, "clip-rule": "evenodd" })), t4("path", h2)), t4("g", p2);
}, gh[ht.Center] = function(t4, e, i, s, r) {
    var _a2;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const n2 = i.sideSetting.thicknessTop;
    let o2;
    const a2 = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": n2 };
    r && Math.max(...r.radius) > 0 && (a2["stroke-linejoin"] = "miter");
    const { length: h2, gap: c2 } = i.borderStyle;
    (h2 || c2) && (a2["stroke-dasharray"] = `${h2}, ${c2}`);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        a2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        o2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        a2.opacity = void 0 === s2 ? 1 : s2, a2.stroke = "url(#" + o2.id + ")";
    }
    const l2 = t4("path", a2);
    return o2 && o2.node ? t4("g", [o2.node, l2]) : l2;
}, gh[ht.Outer] = function(t4, e, i, s, r) {
    var _a2;
    if (r && yh(i.sideSetting.sideType, r)) return rh(t4, e, i, s, r);
    const n2 = i.sideSetting.thicknessTop;
    let o2;
    const a2 = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": 2 * n2 };
    r && Math.max(...r.radius) > 0 && (a2["stroke-linejoin"] = "miter");
    const { length: h2, gap: l2 } = i.borderStyle;
    (h2 || l2) && (a2["stroke-dasharray"] = `${h2}, ${l2}`);
    if (i.fillType == xt.SolidColor) {
        const t5 = i.color;
        a2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else {
        o2 = $a(t4, i.gradient, e);
        const s2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        a2.opacity = void 0 === s2 ? 1 : s2, a2.stroke = "url(#" + o2.id + ")";
    }
    const d2 = Ya(), p2 = "mask-border" + c(i) + d2;
    a2.mask = "url(#" + p2 + ")";
    const u = e.width + 2 * n2, f2 = e.height + 2 * n2, g2 = [];
    o2 && o2.node && g2.push(o2.node);
    const m2 = t4("mask", { id: p2, x: -n2, y: -n2, width: u, height: f2 }, [t4("rect", { x: -n2, y: -n2, width: u, height: f2, fill: "white" }), t4("path", { d: s, fill: "black" })]), _2 = t4("path", a2);
    return g2.push(m2, _2), t4("g", g2);
};
const xh = {};
function wh(t4, e, i, s, r, n2, o2, a2, h2) {
    const c2 = [], l2 = [];
    let d2 = [], p2 = [];
    for (let c3 = 0; c3 < i.length; c3++) {
        const u = i[c3], f2 = u.position;
        if (u.isEnabled) {
            if (f2 === zt.Outer) {
                if (a2 === Vt.Rectangle || a2 === Vt.Artboard || a2 === Vt.Oval) {
                    const { filter: i2, p: l3 } = xh[f2](t4, u, r, e, c3, s, n2, o2, a2, h2);
                    d2.push(i2), p2.push(l3);
                }
            } else if (f2 === zt.Inner) {
                const i2 = xh[f2](t4, u, r, e, c3, s, n2, o2, a2);
                l2.push(i2);
            }
        }
    }
    if (a2 !== Vt.Rectangle && a2 !== Vt.Artboard && a2 !== Vt.Oval) {
        const s2 = function(t5, e2, i2, s3, r2, n3) {
            e2 = e2.filter((t6) => t6.position === zt.Outer);
            const { width: o3, height: a3 } = i2, h3 = { props_w: [1.8 * o3], props_h: [1.8 * a3], props_x: [-0.4 * o3], props_y: [-0.4 * a3] };
            if (0 === e2.length) return;
            const c3 = [];
            for (let s4 = 0; s4 < e2.length; s4++) {
                const r3 = e2[s4], n4 = r3.position;
                if (r3.isEnabled && n4 === zt.Outer) {
                    Mh(r3, i2, h3);
                    const { color: e3, offsetX: n5, offsetY: o4, blurRadius: a4, spread: l4 } = r3, d4 = { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0\n                           0 0 0 0 0\n                           0 0 0 0 0\n                           0 0 0 127 0" }, p4 = { dx: n5, dy: o4 }, u2 = { stdDeviation: "" + a4 / 2 }, f2 = { type: "matrix", values: ` 0 0 0 ${e3.red / 255} 0
                               0 0 0 ${e3.green / 255} 0
                               0 0 0 ${e3.blue / 255} 0
                               0 0 0 ${e3.alpha} 0` }, g2 = { mode: "normal", in2: s4 > 0 ? `effect${s4}_dropShadow` : "BackgroundImageFix", result: `effect${s4 + 1}_dropShadow` }, m2 = [t5("feColorMatrix", d4), t5("feOffset", p4), t5("feGaussianBlur", u2), t5("feColorMatrix", f2), t5("feBlend", g2)];
                    c3.push(...m2);
                }
            }
            const l3 = { id: "pd_outer-" + s3, x: "-20%", y: "-20%", height: "140%", width: "140%" }, d3 = n3 === Vt.Line ? 9 * vh(r2) : vh(r2);
            0 !== o3 && 0 !== a3 && (l3.width = (Math.max(...h3.props_w) + Math.max(...h3.props_w) + 2 * d3) / o3 * 100 + "%", l3.height = (Math.max(...h3.props_h) + Math.max(...h3.props_h) + 2 * d3) / a3 * 100 + "%", l3.x = (Math.min(...h3.props_x) + Math.min(...h3.props_x) - d3) / o3 * 100 + "%", l3.y = (Math.min(...h3.props_y) + Math.min(...h3.props_y) - d3) / a3 * 100 + "%");
            const p3 = { "flood-opacity": "0", result: "BackgroundImageFix" }, u = { mode: "normal", in: "SourceGraphic", in2: `effect${e2.length}_dropShadow`, result: "shape" };
            return t5("filter", l3, [t5("feFlood", p3), ...c3, t5("feBlend", u)]);
        }(t4, i, r, e, o2, a2);
        s2 && c2.push(s2);
    }
    return d2.length && c2.push(t4("g", [...d2, ...p2])), c2.push(...l2), c2;
}
function bh(t4, e) {
    let i = [];
    if (e && e.length) for (let s = 0; s < e.length; s++) {
        if (e[s].position === zt.Inner) {
            let e2 = `url(#inner-shadow-${t4 + s})`;
            i.push(e2);
        }
    }
    return i;
}
xh[zt.Outer] = function(t4, e, i, s, r, n2, o2, a2, h2, c2) {
    const { width: l2, height: d2 } = i, p2 = { props_w: [1.4 * l2], props_h: [1.4 * d2], props_x: [-0.2 * l2], props_y: [-0.2 * d2] };
    Mh(e, i, p2);
    const { color: u, offsetX: f2, offsetY: g2, blurRadius: m2, spread: _2 } = e, { red: y2, green: x2, blue: w2, alpha: b2 } = u, M2 = { id: "spread" + s + r, x: "-20%", y: "-20%", height: "140%", width: "140%", "color-interpolation-filters": "sRGB" }, v2 = vh(a2);
    M2.width = (Math.max(...p2.props_w) + 2 * ((c2 == null ? void 0 : c2.saturation) || 0) + 2 * v2) / l2 * 100 + "%", M2.height = (Math.max(...p2.props_h) + 2 * ((c2 == null ? void 0 : c2.saturation) || 0) + 2 * v2) / d2 * 100 + "%", M2.x = (Math.min(...p2.props_x) - ((c2 == null ? void 0 : c2.saturation) || 0) - v2) / l2 * 100 + "%", M2.y = (Math.min(...p2.props_y) - ((c2 == null ? void 0 : c2.saturation) || 0) - v2) / d2 * 100 + "%";
    const S2 = _2 / 1e4, C3 = +((2 * _2 + l2 - _2 / 100) / l2 - S2).toFixed(3), T2 = +((2 * _2 + d2 - _2 / 100) / d2 - S2).toFixed(3), I2 = { type: "matrix", values: `0 0 0 ${y2 / 255} 0 0 0 0 ${x2 / 255} 0 0 0 0 ${w2 / 255} 0 0 0 0 ${b2} 0`, result: `color${r}` }, k = { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" }, E2 = { dx: f2 / C3, dy: g2 / T2 }, A2 = { stdDeviation: "" + m2 / 2 }, F2 = { mode: "normal", in2: "BackgroundImageFix", result: `effect${r + 1}_dropShadow` }, R2 = [t4("feFlood", { "flood-opacity": "0", result: "BackgroundImageFix" }), t4("feColorMatrix", k), t4("feOffset", E2), t4("feGaussianBlur", A2), t4("feColorMatrix", I2), t4("feBlend", F2)];
    c2 && c2.isEnabled && c2.type === ot.Gaussian && R2.push(t4("feGaussianBlur", { stdDeviation: "" + c2.saturation / 2 }));
    const O2 = t4("filter", M2, R2);
    let L2 = "none";
    if (o2.length) for (let t5 = 0; t5 < o2.length; t5++) {
        const e2 = o2[t5];
        if (0 !== e2.color.alpha && e2.isEnabled) {
            L2 = "black";
            break;
        }
    }
    const P2 = _h(t4, a2, i, n2, void 0);
    return { filter: O2, p: t4("g", { filter: `url(#spread${s + r})`, style: `transform-origin: left top; transform: translate(${l2 / 2}px, ${d2 / 2}px) scale(${C3 >= 0 ? C3 : 0}, ${T2 >= 0 ? T2 : 0}) translate(${-l2 / 2}px, ${-d2 / 2}px) ` }, [t4("path", { d: n2, fill: L2 }), ...P2]) };
}, xh[zt.Inner] = function(t4, e, i, s, r, n2, o2, a2, h2) {
    const c2 = `inner-shadow-${s + r}`, { width: l2, height: d2 } = i, { color: p2, offsetX: u, offsetY: f2, blurRadius: g2, spread: m2 } = e, _2 = { dx: u, dy: f2, result: "offsetBlur" }, y2 = { stdDeviation: "" + g2 / 2, in: "spread", in2: "offsetBlur", result: "blur" }, x2 = { operator: "out", in: "SourceGraphic", in2: "blur", result: "inverse" }, { red: w2, green: b2, blue: M2, alpha: v2 } = p2, S2 = { "flood-color": `rgba(${w2}, ${b2}, ${M2}, ${v2})`, result: "color" }, C3 = { operator: "in", in: "color", in2: "inverse", result: "shadow" }, T2 = { operator: "over", in: "shadow", in2: "SourceGraphic" }, I2 = { operator: "erode", radius: `${m2}`, result: "spread" }, k = { id: c2, x: 0.2 * -l2, y: 0.2 * -d2, height: 1.4 * d2, width: 1.4 * l2, "color-interpolation-filters": "sRGB", filterUnits: "userSpaceOnUse" };
    if (h2 === Vt.Line) {
        const t5 = 9 * vh(a2);
        k.x = -0.2 * l2 - t5, k.y = -0.2 * d2 - t5, k.width = 1.4 * l2 + 2 * t5, k.height = 1.4 * d2 + 2 * t5;
    }
    const E2 = [t4("feOffset", _2), t4("feMorphology", I2), t4("feGaussianBlur", y2), t4("feComposite", x2), t4("feFlood", S2), t4("feComposite", C3), t4("feComposite", T2)];
    return t4("filter", k, E2);
};
const Mh = (t4, e, i) => {
    const { offsetX: s, offsetY: r, blurRadius: n2, spread: o2 } = t4, { width: a2, height: h2 } = e, c2 = a2 + Math.abs(s) + 2 * n2 + Math.abs(2 * o2) + 0.4 * a2, l2 = h2 + Math.abs(r) + 2 * n2 + Math.abs(2 * o2) + 0.4 * h2, d2 = Math.min(0, s) - n2 - Math.min(0, o2) - 0.2 * a2, p2 = Math.min(0, r) - n2 - Math.min(0, o2) - 0.2 * h2;
    i.props_h.push(l2), i.props_w.push(c2), i.props_x.push(d2), i.props_y.push(p2);
}, vh = (t4) => {
    if (!t4.length) return 0;
    let e = 0;
    for (let i = 0; i < t4.length; i++) {
        const s = t4[i];
        if (!s.isEnabled || s.position === ht.Inner) continue;
        const { thicknessBottom: r, thicknessTop: n2, thicknessLeft: o2, thicknessRight: a2 } = s.sideSetting, h2 = Math.max(r, n2, o2, a2);
        h2 > e && (e = s.position === ht.Center ? h2 / 2 : h2);
    }
    return e;
}, Sh = {};
Sh[ot.Gaussian] = (t4, e, i, s) => {
    const r = { id: i, x: "-20%", y: "-20%", height: "140%", width: "140%", "color-interpolation-filters": "sRGB" }, n2 = { "flood-opacity": "0", result: "BackgroundImageFix" }, o2 = e.saturation / s.width * 100, a2 = e.saturation / s.height * 100;
    r.x = -(o2 + 20) + "%", r.y = -(a2 + 20) + "%", r.width = 2 * o2 + 140 + "%", r.height = 2 * a2 + 140 + "%";
    const h2 = { stdDeviation: e.saturation / 2 };
    return t4("defs", {}, [t4("filter", r, [t4("feFlood", n2), t4("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), t4("feGaussianBlur", h2)])]);
}, Sh[ot.Background] = (t4, e, i, s, r, n2, o2) => {
    const a2 = Ch(r), h2 = Ch(n2);
    if (!a2 && !h2) return;
    const l2 = "mask-blur" + c(e) + Ya();
    let d2 = { width: "100%", height: "100%" }, p2 = [];
    const u = { x: 0, y: 0, width: s.width, height: s.height }, f2 = [t4("path", { d: o2, fill: "white" })];
    if (h2) for (let e2 = 0; e2 < n2.length; e2++) {
        const i2 = n2[e2];
        let s2 = i2.sideSetting.thicknessTop;
        if (i2.position === ht.Inner) continue;
        i2.position === ht.Outer && (s2 *= 2);
        const r2 = { d: o2, fill: "white", stroke: "white", "stroke-width": s2 };
        i2.borderStyle.gap && (r2["stroke-dasharray"] = 10), f2.push(t4("path", r2));
    }
    const g2 = t4("mask", { id: l2 }, f2);
    p2.push(g2), d2["backdrop-filter"] = `blur(${e.saturation / 2}px)`, d2.mask = "url(#" + l2 + ")";
    const m2 = t4("div", { style: d2 }), _2 = t4("foreignObject", u, m2);
    return p2.push(_2), t4("g", p2);
};
const Ch = (t4) => {
    for (let e = 0; e < t4.length; e++) {
        const i = t4[e];
        if (i.color.alpha > 0 && i.isEnabled) return true;
    }
    return false;
};
class Th extends za {
    constructor() {
        super(...arguments);
        __publicField(this, "_events", {});
        __publicField(this, "_onceEvents", {});
        __publicField(this, "_emitLevel", 0);
        __publicField(this, "_removes", []);
        __publicField(this, "__watcher", /* @__PURE__ */ new Set());
    }
    on(t4, e) {
        (this._events[t4] || (this._events[t4] = [])).push(e);
        const i = () => this._events[t4] && this._events[t4].splice(this._events[t4].indexOf(e) >>> 0, 1);
        return { remove: () => {
                0 === this._emitLevel ? i() : this._removes.push(i);
            } };
    }
    once(t4, e) {
        (this._onceEvents[t4] || (this._onceEvents[t4] = [])).push(e);
        const i = () => this._onceEvents[t4] && this._onceEvents[t4].splice(this._onceEvents[t4].indexOf(e) >>> 0, 1);
        return { remove: () => {
                0 === this._emitLevel ? i() : this._removes.push(i);
            } };
    }
    emit(t4, ...e) {
        this._emitLevel++;
        try {
            (this._events[t4] || []).forEach((t5) => t5(...e)), (this._onceEvents[t4] || []).forEach((t5) => t5(...e)), delete this._onceEvents[t4];
        } finally {
            this._emitLevel--;
        }
        0 === this._emitLevel && (this._removes.forEach((t5) => t5()), this._removes.length = 0);
    }
    watch(t4) {
        return this.__watcher.add(t4), () => {
            this.__watcher.delete(t4);
        };
    }
    unwatch(t4) {
        return this.__watcher.delete(t4);
    }
    notify(...t4) {
        0 !== this.__watcher.size && Array.from(this.__watcher).forEach((e) => {
            e(...t4);
        });
    }
}
let Ih = class extends Th {
    constructor(t4, e) {
        super("");
        __publicField(this, "m_ctx");
        __publicField(this, "m_data");
        __publicField(this, "m_children", []);
        __publicField(this, "m_parent");
        __publicField(this, "m_scale");
        __publicField(this, "m_varsContainer");
        __publicField(this, "m_isVirtual");
        __publicField(this, "m_isdistroyed", false);
        __publicField(this, "m_nodeCount", 1);
        this.m_ctx = t4, this.m_data = e.data, this.m_scale = e.scale, this.m_isVirtual = e.isVirtual, this._datawatcher = this._datawatcher.bind(this), this.m_data.watch(this._datawatcher), this.varsContainer = e.varsContainer, this.m_ctx.setDirty(this);
    }
    setData(t4) {
        if (c(t4) === c(this.m_data)) return;
        this.m_data.unwatch(this._datawatcher), t4.watch(this._datawatcher), this.m_data = t4;
    }
    get varsContainer() {
        return this.m_varsContainer;
    }
    set varsContainer(t4) {
        this.m_varsContainer && this.m_varsContainer.forEach((t5) => t5.unwatch(this._datawatcher)), this.m_varsContainer = t4, this.m_varsContainer && this.m_varsContainer.forEach((t5) => t5.watch(this._datawatcher));
    }
    get isViewNode() {
        return true;
    }
    get nodeCount() {
        return this.m_nodeCount;
    }
    get data() {
        return this.m_data;
    }
    get id() {
        return Ba(this.m_data.id, this.m_varsContainer);
    }
    get parent() {
        return this.m_parent;
    }
    get childs() {
        return this.m_children;
    }
    get naviChilds() {
        return this.m_children;
    }
    get type() {
        return this.m_data.type;
    }
    get name() {
        return this.m_data.name;
    }
    get isVirtualShape() {
        return this.m_isVirtual;
    }
    _datawatcher(...t4) {
        this.m_ctx.setReLayout(this), this.m_ctx.setDirty(this), this.onDataChange(...t4), this.notify(...t4);
    }
    onDestory() {
    }
    get isDistroyed() {
        return this.m_isdistroyed;
    }
    onDataChange(...t4) {
    }
    layout(t4) {
        throw new Error("not implemented");
    }
    updateFrames() {
        return false;
    }
    render() {
        return 0;
    }
    asyncRender() {
        return 0;
    }
    getRootView() {
        let t4 = this;
        for (; t4; ) {
            if (t4.isRootView) return t4;
            t4 = t4.m_parent;
        }
    }
    onMounted() {
    }
    onUnmounted() {
    }
    addChild(t4, e) {
        if (t4.m_parent) throw new Error("child already added");
        void 0 !== e ? this.m_children.splice(e, 0, t4) : this.m_children.push(t4), t4.m_parent = this, this.m_nodeCount += t4.m_nodeCount;
        let i = this.m_parent, s = this;
        for (; i; ) s = i, i.m_nodeCount += t4.m_nodeCount, i = i.m_parent;
        s.isRootView && s.onAddView(t4), t4.onMounted();
    }
    addChilds(t4, e) {
        t4.forEach((t5) => {
            if (t5.m_parent) throw new Error("child already added");
        }), void 0 !== e ? this.m_children.splice(e, 0, ...t4) : this.m_children.push(...t4);
        let i = 0;
        t4.forEach((t5) => {
            t5.m_parent = this, i += t5.m_nodeCount;
        }), this.m_nodeCount += i;
        let s = this.m_parent, r = this;
        for (; s; ) r = s, s.m_nodeCount += i, s = s.m_parent;
        r.isRootView && r.onAddView(t4), t4.forEach((t5) => {
            t5.onMounted();
        });
    }
    removeChild(t4) {
        "number" != typeof t4 && (t4 = this.m_children.findIndex((e2) => e2.id === t4.id));
        const e = this.m_children.splice(t4, 1)[0];
        if (e) {
            this.m_nodeCount -= e.m_nodeCount;
            let t5 = this.m_parent, i = this;
            for (; t5; ) i = t5, t5.m_nodeCount -= e.m_nodeCount, t5 = t5.m_parent;
            i.isRootView && i.onRemoveView(this, e), e.m_parent = void 0, e.onUnmounted();
        }
        return e;
    }
    moveChild(t4, e) {
        if (t4.m_parent !== this) throw new Error("child not in this parent");
        if (e < 0 || e >= this.m_children.length) throw new Error("invalid index");
        const i = this.m_children.indexOf(t4);
        if (i === e) return false;
        if (i < 0) throw new Error("child not in this parent");
        return this.m_children.splice(i, 1), this.m_children.splice(e, 0, t4), true;
    }
    removeChilds(t4, e) {
        const i = this.m_children.splice(t4, e);
        if (i && i.length) {
            let t5 = 0;
            i.forEach((e3) => {
                t5 += e3.m_nodeCount;
            }), this.m_nodeCount -= t5;
            let e2 = this.m_parent, s = this;
            for (; e2; ) s = e2, e2.m_nodeCount -= t5, e2 = e2.m_parent;
            s.isRootView && s.onRemoveView(this, i), i.forEach((t6) => {
                t6.m_parent = void 0, t6.onUnmounted();
            });
        }
        return i;
    }
    toSVGString() {
        const t4 = this.m_data.size, e = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "xmlns:xhtml": "http://www.w3.org/1999/xhtml", preserveAspectRatio: "xMinYMin meet" };
        return e.width = t4.width, e.height = t4.height, e.overflow = "visible", La("svg", e, this.outerHTML);
    }
    destory() {
        if (this.m_parent) throw new Error("parent is not null");
        if (this.m_isdistroyed) throw new Error("already distroyed");
        this.id, this.m_ctx.removeReLayout(this), this.m_ctx.removeDirty(this), this.m_data.unwatch(this._datawatcher), this.m_varsContainer && this.m_varsContainer.forEach((t4) => t4.unwatch(this._datawatcher)), this.removeChilds(0, Number.MAX_VALUE).forEach((t4) => t4.destory()), this.onDestory(), this.m_isdistroyed = true, this.notify("destroy");
    }
};
function Eh(t4, e) {
    return t4 !== e && (void 0 === t4 || void 0 === e || (t4.x !== e.x || t4.y !== e.y));
}
function Ah(t4, e) {
    if (t4 === e) return false;
    if (void 0 === t4 || void 0 === e) return true;
    if (t4.length !== e.length) return true;
    for (let i = 0; i < t4.length; i++) if (t4[i].id !== e[i].id || c(t4[i]) !== c(e[i])) return true;
    return false;
}
function Rh(t4, e, i, s, r) {
    var _a2, _b, _c2;
    if (((_a2 = t4.parent) == null ? void 0 : _a2.type) === Vt.Page) return;
    const n2 = (_b = t4.parent) == null ? void 0 : _b.size;
    if (!n2) return;
    if (((_c2 = t4.parent) == null ? void 0 : _c2.type) === Vt.Group) i.x *= s, i.y *= r, i.width *= s, i.height *= r;
    else {
        const o2 = function(t5, e2, i2, s2, r2, n3, o3, a2, h2) {
            if (Ne.isHorizontalScale(t5)) e2 *= n3, s2 *= n3;
            else if (Ne.isFlexWidth(t5)) {
                let i3 = n3 * s2;
                if (Ne.isFixedToLeft(t5)) s2 = i3;
                else if (Ne.isFixedToRight(t5)) {
                    const t6 = h2.width - s2 - e2;
                    e2 = a2.width - i3 - t6, s2 = i3;
                } else if (Ne.isHorizontalJustifyCenter(t5)) {
                    const t6 = h2.width / 2 - e2 - s2 / 2;
                    e2 = a2.width / 2 - t6 - i3 / 2, s2 = i3;
                } else if (Ne.isFixedLeftAndRight(t5)) {
                    const t6 = h2.width - s2 - e2;
                    s2 = a2.width - e2 - t6;
                }
            } else Ne.isFixedToRight(t5) ? e2 = a2.width - h2.width + e2 : Ne.isHorizontalJustifyCenter(t5) && (e2 = a2.width / 2 - h2.width / 2 + e2);
            if (Ne.isVerticalScale(t5)) i2 *= o3, r2 *= o3;
            else if (Ne.isFlexHeight(t5)) {
                let e3 = o3 * r2;
                if (Ne.isFixedToTop(t5)) r2 = e3;
                else if (Ne.isFixedToBottom(t5)) {
                    const t6 = h2.height - r2 - i2;
                    i2 = a2.height - e3 - t6, r2 = e3;
                } else if (Ne.isVerticalJustifyCenter(t5)) {
                    const t6 = h2.height / 2 - i2 - r2 / 2;
                    i2 = a2.height / 2 - t6 - e3 / 2, r2 = e3;
                } else if (Ne.isFixedTopAndBottom(t5)) {
                    const t6 = h2.height - r2 - i2;
                    r2 = a2.height - i2 - t6;
                }
            } else Ne.isFixedToBottom(t5) ? i2 = a2.height - h2.height + i2 : Ne.isVerticalJustifyCenter(t5) && (i2 = a2.height / 2 - h2.height / 2 + i2);
            return { x: e2, y: i2, width: s2, height: r2 };
        }(t4.resizingConstraint ?? 0, i.x, i.y, i.width, i.height, s, r, e, n2);
        i.x = o2.x, i.y = o2.y, i.width = o2.width, i.height = o2.height;
    }
}
function Oh(t4, e) {
    const i = t4.toMatrix();
    return e ? (e.multiAtLeft(i), e) : i;
}
function Nh(t4, e) {
    if (1 == t4.m00 && 0 === t4.m01 && 0 === t4.m10 && 1 === t4.m11) return new _e(t4.m02, t4.m12, e.width, e.height);
    const i = t4.computeCoord(e.x, e.y), s = t4.computeCoord(e.x + e.width, e.y + e.height);
    return new _e(i.x, i.y, s.x - i.x, s.y - i.y);
}
function zh(t4, e, i, s, r) {
    return (t4.x !== e || t4.y !== i || t4.width !== s || t4.height !== r) && (t4.x = e, t4.y = i, t4.width = s, t4.height = r, true);
}
class Vh extends Ih {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "m_transform");
        __publicField(this, "_save_frame", new _e());
        __publicField(this, "m_frame", new _e());
        __publicField(this, "m_visibleFrame", new _e());
        __publicField(this, "m_outerFrame", new _e());
        __publicField(this, "_p_frame", new _e());
        __publicField(this, "_p_visibleFrame", new _e());
        __publicField(this, "_p_outerFrame", new _e());
        __publicField(this, "m_fixedRadius");
        __publicField(this, "m_path");
        __publicField(this, "m_pathstr");
        __publicField(this, "m_transform2");
        __publicField(this, "m_transform_form_mask");
        __publicField(this, "m_mask_group");
        __publicField(this, "m_render_version", 0);
        const i = e.data, s = i.transform;
        this.m_transform = new Ii(s.m00, s.m01, s.m02, s.m10, s.m11, s.m12), this.m_fixedRadius = i.fixedRadius;
    }
    hasSize() {
        return this.m_data.hasSize();
    }
    onMounted() {
        const t4 = this.parent, e = (t4 == null ? void 0 : t4.hasSize()) ? t4.frame : void 0;
        this._layout(this.m_data, e, this.varsContainer, this.m_scale), this.updateFrames();
    }
    get parent() {
        return this.m_parent;
    }
    get childs() {
        return this.m_children;
    }
    get style() {
        return this.data.style;
    }
    get exportOptions() {
        const t4 = this._findOV(Et.ExportOptions, jt.ExportOptions);
        return t4 ? t4.value : this.data.exportOptions;
    }
    get contextSettings() {
        const t4 = this._findOV(Et.ContextSettings, jt.ContextSettings);
        return t4 ? t4.value : this.data.style.contextSettings;
    }
    get naviChilds() {
        return this.m_children;
    }
    get transform() {
        return this.m_transform;
    }
    get transform2() {
        return this.m_transform2 || (this.m_transform2 = ki(this.m_transform)), this.m_transform2;
    }
    get transform2FromRoot() {
        const t4 = this.transform2.clone();
        return this.parent ? t4.addTransform(this.parent.transform2FromRoot) : t4;
    }
    get size() {
        return this.frame;
    }
    get frame() {
        return this.m_frame;
    }
    get visibleFrame() {
        return this.m_visibleFrame;
    }
    get outerFrame() {
        return this.m_outerFrame;
    }
    get rotation() {
        return 180 * ki(this.transform).decomposeEuler().z / Math.PI;
    }
    get fixedRadius() {
        return this.m_fixedRadius;
    }
    get resizingConstraint() {
        return this.data.resizingConstraint;
    }
    get constrainerProportions() {
        return this.data.constrainerProportions;
    }
    get isClosed() {
        return this.m_data.isClosed;
    }
    boundingBox() {
        if (this.isNoTransform()) {
            const t5 = this.transform.translateX, e2 = this.transform.translateY;
            return new _e(t5 + this.frame.x, e2 + this.frame.y, this.frame.width, this.frame.height);
        }
        const t4 = this.getPath().clone();
        if (t4.length > 0) {
            const e2 = this.matrix2Parent();
            t4.transform(e2);
            const i2 = t4.calcBounds();
            return new _e(i2.minX, i2.minY, i2.maxX - i2.minX, i2.maxY - i2.minY);
        }
        const e = this.frame, i = this.transform, s = [{ x: e.x, y: e.y }, { x: e.x + e.width, y: e.y }, { x: e.x + e.width, y: e.y + e.height }, { x: e.x, y: e.y + e.height }].map((t5) => i.computeCoord(t5)), r = s.reduce((t5, e2) => Math.min(t5, e2.x), s[0].x), n2 = s.reduce((t5, e2) => Math.max(t5, e2.x), s[0].x), o2 = s.reduce((t5, e2) => Math.min(t5, e2.y), s[0].y), a2 = s.reduce((t5, e2) => Math.max(t5, e2.y), s[0].y);
        return new _e(r, o2, n2 - r, a2 - o2);
    }
    boundingBox2() {
        const t4 = this.getPath().clone();
        if (t4.length > 0) {
            const e2 = this.matrix2Parent();
            t4.transform(e2);
            const i2 = t4.calcBounds();
            return new _e(i2.minX, i2.minY, i2.maxX - i2.minX, i2.maxY - i2.minY);
        }
        const e = this.frame, i = this.transform, s = [{ x: e.x, y: e.y }, { x: e.x + e.width, y: e.y }, { x: e.x + e.width, y: e.y + e.height }, { x: e.x, y: e.y + e.height }].map((t5) => i.computeCoord(t5)), r = s.reduce((t5, e2) => Math.min(t5, e2.x), s[0].x), n2 = s.reduce((t5, e2) => Math.max(t5, e2.x), s[0].x), o2 = s.reduce((t5, e2) => Math.min(t5, e2.y), s[0].y), a2 = s.reduce((t5, e2) => Math.max(t5, e2.y), s[0].y);
        return new _e(r, o2, n2 - r, a2 - o2);
    }
    onDataChange(...t4) {
        t4.includes("mask") && this.parent.updateMaskMap(), (t4.includes("points") || t4.includes("pathsegs") || t4.includes("isClosed") || (this.m_fixedRadius || 0) !== (this.m_data.fixedRadius || 0) || t4.includes("cornerRadius") || t4.includes("imageRef")) && (this.m_path = void 0, this.m_pathstr = void 0);
        const e = this.masked;
        e && e.notify("rerender-mask");
    }
    _findOV(t4, e) {
        if (!this.varsContainer) return;
        const i = vs(this.m_data, t4, this.varsContainer, true);
        if (!i) return;
        const s = i[i.length - 1];
        return s && s.type === e ? s : void 0;
    }
    _findOVAll(t4, e) {
        if (!this.varsContainer) return;
        return Ms(this.m_data.id, t4, this.varsContainer);
    }
    matrix2Root() {
        const t4 = this.transform.toMatrix(), e = this.parent;
        if (e) {
            const i = e.innerTransform;
            i && t4.multiAtLeft(i.toMatrix()), t4.multiAtLeft(e.matrix2Root());
        }
        return t4;
    }
    frame2Root() {
        const t4 = this.frame, e = this.matrix2Root(), i = e.computeCoord(t4.x, t4.y), s = e.computeCoord(t4.x + t4.width, t4.y + t4.height);
        return new _e(i.x, i.y, s.x - i.x, s.y - i.y);
    }
    frame2Parent() {
        if (this.isNoTransform()) {
            const t5 = this.transform.translateX, e2 = this.transform.translateY;
            return new _e(t5 + this.frame.x, e2 + this.frame.y, this.frame.width, this.frame.height);
        }
        const t4 = this.frame, e = this.matrix2Parent(), i = e.computeCoord(t4.x, t4.y), s = e.computeCoord(t4.x + t4.width, t4.y + t4.height);
        return new _e(i.x, i.y, s.x - i.x, s.y - i.y);
    }
    get name() {
        const t4 = this._findOV(Et.Name, jt.Name);
        return t4 ? t4.value : this.m_data.name;
    }
    getPage() {
        let t4 = this;
        for (; t4.type !== Vt.Page && t4.m_parent; ) t4 = t4.m_parent;
        return t4.type === Vt.Page ? t4 : void 0;
    }
    get varbinds() {
        return this.m_data.varbinds;
    }
    isNoTransform() {
        const { m00: t4, m01: e, m10: i, m11: s } = this.transform;
        return Math.abs(t4 - 1) < We && Math.abs(e) < We && Math.abs(i) < We && Math.abs(s - 1) < We;
    }
    matrix2Parent(t4) {
        return Oh(this.transform, t4);
    }
    getFills() {
        const t4 = this._findOV(Et.Fills, jt.Fills);
        return t4 ? t4.value : this.m_data.style.fills;
    }
    getBorders() {
        const t4 = this._findOV(Et.Borders, jt.Borders);
        return t4 ? t4.value : this.m_data.style.borders;
    }
    get cornerRadius() {
    }
    get startMarkerType() {
        const t4 = this._findOV(Et.StartMarkerType, jt.MarkerType);
        return t4 ? t4.value : this.m_data.style.startMarkerType;
    }
    get endMarkerType() {
        const t4 = this._findOV(Et.EndMarkerType, jt.MarkerType);
        return t4 ? t4.value : this.m_data.style.endMarkerType;
    }
    getShadows() {
        const t4 = this._findOV(Et.Shadows, jt.Shadows);
        return t4 ? t4.value : this.m_data.style.shadows;
    }
    get blur() {
        const t4 = this._findOV(Et.Blur, jt.Blur);
        return t4 ? t4.value : this.data.style.blur;
    }
    getPathStr() {
        return this.m_pathstr || (this.m_pathstr = this.getPath().toString()), this.m_pathstr;
    }
    getPath() {
        if (this.m_path) return this.m_path;
        const t4 = this.frame;
        return this.m_path = this.m_data.getPathOfSize(t4, this.m_fixedRadius), 0 === t4.x && 0 === t4.y || this.m_path.translate(t4.x, t4.y), this.m_path.freeze(), this.m_path;
    }
    get isVisible() {
        const t4 = this._findOV(Et.Visible, jt.Visible);
        return t4 ? t4.value : !!this.m_data.isVisible;
    }
    get isLocked() {
        const t4 = this._findOV(Et.Lock, jt.Lock);
        return t4 ? t4.value : !!this.m_data.isLocked;
    }
    get mask() {
        return !!this.m_data.mask;
    }
    get masked() {
        var _a2;
        return (_a2 = this.parent) == null ? void 0 : _a2.maskMap.get(this.m_data.id);
    }
    updateLayoutArgs(t4, e, i) {
        e.width === this.m_frame.width && e.height === this.m_frame.height && e.x === this.m_frame.x && e.y === this.m_frame.y || (this.m_pathstr = void 0, this.m_path = void 0, this.m_frame.x = e.x, this.m_frame.y = e.y, this.m_frame.width = e.width, this.m_frame.height = e.height), (this.m_fixedRadius || 0) !== (i || 0) && (this.m_fixedRadius = i, this.m_pathstr = void 0, this.m_path = void 0), this.m_transform.equals(t4) || (this.m_transform.reset(t4), this.m_pathstr = void 0, this.m_path = void 0, this.m_transform2 = void 0);
    }
    updateFrames() {
        let t4 = this._save_frame.x !== this.m_frame.x || this._save_frame.y !== this.m_frame.y || this._save_frame.width !== this.m_frame.width || this._save_frame.height !== this.m_frame.height;
        t4 && (this._save_frame.x = this.m_frame.x, this._save_frame.y = this.m_frame.y, this._save_frame.width = this.m_frame.width, this._save_frame.height = this.m_frame.height);
        const e = this.getBorders();
        let i = 0;
        e.forEach((t5) => {
            t5.position === ht.Outer ? i = Math.max(t5.thickness, i) : t5.position === ht.Center && (i = Math.max(t5.thickness / 2, i));
        });
        const s = this.getShadows();
        let r = 0, n2 = 0, o2 = 0, a2 = 0;
        s.forEach((t5) => {
            if (!t5.isEnabled) return;
            if (t5.position !== zt.Outer) return;
            const e2 = t5.blurRadius + t5.spread;
            o2 = Math.max(-t5.offsetX + e2, o2), a2 = Math.max(t5.offsetX + e2, a2), r = Math.max(-t5.offsetY + e2, r), n2 = Math.max(t5.offsetY + e2, n2);
        });
        const h2 = Math.max(i, o2), c2 = Math.max(i, r), l2 = Math.max(i, a2), d2 = Math.max(i, n2);
        zh(this.m_visibleFrame, this.frame.x - h2, this.frame.y - c2, this.frame.width + h2 + l2, this.frame.height + c2 + d2) && (t4 = true), zh(this.m_outerFrame, this.m_visibleFrame.x, this.m_visibleFrame.y, this.m_visibleFrame.width, this.m_visibleFrame.height) && (t4 = true);
        const p2 = (t5, e2) => {
            const i2 = this.transform;
            if (this.isNoTransform()) return zh(e2, t5.x + i2.translateX, t5.y + i2.translateY, t5.width, t5.height);
            const s2 = t5, r2 = i2, n3 = [{ x: s2.x, y: s2.y }, { x: s2.x + s2.width, y: s2.y }, { x: s2.x + s2.width, y: s2.y + s2.height }, { x: s2.x, y: s2.y + s2.height }].map((t6) => r2.computeCoord(t6)), o3 = n3.reduce((t6, e3) => Math.min(t6, e3.x), n3[0].x), a3 = n3.reduce((t6, e3) => Math.max(t6, e3.x), n3[0].x), h3 = n3.reduce((t6, e3) => Math.min(t6, e3.y), n3[0].y);
            return zh(e2, o3, h3, a3 - o3, n3.reduce((t6, e3) => Math.max(t6, e3.y), n3[0].y) - h3);
        };
        return p2(this.m_frame, this._p_frame) && (t4 = true), p2(this.m_visibleFrame, this._p_visibleFrame) && (t4 = true), p2(this.m_outerFrame, this._p_outerFrame) && (t4 = true), t4 && this.m_ctx.addNotifyLayout(this), t4;
    }
    layoutChilds(t4, e, i) {
    }
    _layout(t4, e, i, s) {
        const r = t4.transform;
        if (!s || 1 === s.x && 1 === s.y) {
            let e2 = this.frame;
            return this.hasSize() && (e2 = this.data.frame), this.updateLayoutArgs(r, e2, t4.fixedRadius), void this.layoutChilds(i, this.frame);
        }
        const n2 = (t5, e2) => {
            let i2 = r;
            if (t5 !== e2) {
                i2 = i2.clone(), i2.scale(t5, e2);
                const s2 = ki(i2);
                s2.clearScaleSize(), i2 = Ei(s2);
            }
            return i2;
        }, o2 = t4.resizingConstraint ?? 0;
        if (!(this.hasSize() || 0 !== o2 && e)) {
            let e2 = this.frame;
            const o3 = r.clone();
            o3.scale(s.x, s.y);
            const a3 = o3.computeCoord(0, 0), h3 = n2(s.x, s.y).clone(), c3 = h3.computeCoord(0, 0), l3 = a3.x - c3.x, d3 = a3.y - c3.y;
            return h3.trans(l3, d3), this.updateLayoutArgs(h3, e2, t4.fixedRadius), void this.layoutChilds(i, void 0, s);
        }
        const a2 = this.data.frame, h2 = Nh(r, a2), c2 = h2.width, l2 = h2.height;
        let d2 = s.x, p2 = s.y;
        e && 0 !== o2 ? (Rh(t4, e, h2, d2, p2), d2 = h2.width / c2, p2 = h2.height / l2) : (h2.x *= s.x, h2.y *= s.y, h2.width *= s.x, h2.height *= s.y);
        const u = n2(d2, p2).clone(), f2 = u.computeCoord(0, 0);
        u.trans(h2.x - f2.x, h2.y - f2.y);
        const g2 = u.inverse.computeCoord(h2.x + h2.width, h2.y + h2.height), m2 = new _e(0, 0, g2.x, g2.y);
        this.updateLayoutArgs(u, m2, t4.fixedRadius), this.layoutChilds(i, this.frame, { x: d2, y: p2 });
    }
    updateLayoutProps(t4, e) {
        if (t4.data.id !== this.m_data.id) throw new Error("id not match");
        const i = c(t4.data) !== c(this.m_data);
        i && this.setData(t4.data);
        const s = Eh(t4.scale, this.m_scale), r = Ah(t4.varsContainer, this.varsContainer);
        return !!(e || i || s || r) && (s && (this.m_scale = t4.scale), r && (this.m_ctx.removeDirty(this), this.varsContainer = t4.varsContainer, this.id), true);
    }
    layout(t4) {
        const e = this.m_ctx.removeReLayout(this);
        if (t4 && !this.updateLayoutProps(t4, e)) return;
        const i = this.parent, s = (i == null ? void 0 : i.hasSize()) ? i.frame : void 0;
        this.m_ctx.setDirty(this), this._layout(this.m_data, s, this.varsContainer, this.m_scale), this.m_ctx.addNotifyLayout(this);
    }
    renderFills() {
        let t4 = this.getFills();
        return this.mask && (t4 = t4.map((t5) => {
            var _a2;
            const e = Kn(ir(t5));
            return e.fillType === xt.Gradient && ((_a2 = e.gradient) == null ? void 0 : _a2.gradientType) === wt.Angular && (e.fillType = xt.SolidColor), e;
        })), th(Da, t4, this.size, this.getPathStr());
    }
    renderBorders() {
        let t4 = this.getBorders();
        return this.mask && (t4 = t4.map((t5) => {
            var _a2;
            const e = Jn(er(t5));
            return e.fillType === xt.Gradient && ((_a2 = e.gradient) == null ? void 0 : _a2.gradientType) === wt.Angular && (e.fillType = xt.SolidColor), e;
        })), _h(Da, t4, this.size, this.getPathStr(), this.m_data);
    }
    renderShadows(t4) {
        return wh(Da, t4, this.getShadows(), this.getPathStr(), this.frame, this.getFills(), this.getBorders(), this.m_data.type, this.blur);
    }
    renderBlur(t4) {
        return this.blur ? function(t5, e, i, s, r, n2, o2) {
            if (!e || !e.isEnabled) return [];
            const a2 = Sh[e.type](t5, e, i, s, r, n2, o2);
            return a2 ? [a2] : [];
        }(Da, this.blur, t4, this.frame, this.getFills(), this.getBorders(), this.getPathStr()) : [];
    }
    renderProps() {
        const t4 = {}, e = {};
        e.transform = this.transform.toString();
        const i = this.contextSettings;
        return i && (void 0 !== i.opacity && (t4.opacity = i.opacity), e["mix-blend-mode"] = i.blenMode), t4.style = e, t4;
    }
    renderStaticProps() {
        const t4 = this.frame, e = {};
        if (this.isNoTransform()) t4.width > t4.height ? e.transform = `translate(0, ${(t4.width - t4.height) / 2})` : e.transform = `translate(${(t4.height - t4.width) / 2}, 0)`;
        else {
            const t5 = this.boundingBox();
            let i2 = 0, s = 0;
            t5.width > t5.height ? s = (t5.width - t5.height) / 2 : i2 = (t5.height - t5.width) / 2;
            const r = this.transform.clone();
            r.m02 = i2, r.m12 = s, e.style = { transform: r.toString() };
        }
        const i = this.style.contextSettings;
        return i && (e.style ? e.style["mix-blend-mode"] = i.blenMode : e.style = { "mix-blend-mode": i.blenMode }), e;
    }
    renderContents() {
        const t4 = this.m_children;
        return t4.forEach((t5) => t5.render()), t4;
    }
    checkAndResetDirty() {
        return this.m_ctx.removeDirty(this);
    }
    asyncRender() {
        const t4 = this.renderContents;
        this.renderContents = () => this.m_children;
        const e = this.render();
        return this.renderContents = t4, e;
    }
    render() {
        var _a2;
        if (!this.checkAndResetDirty()) return this.m_render_version;
        const t4 = this.masked;
        if (t4) return (_a2 = this.getPage().getView(t4.id)) == null ? void 0 : _a2.render(), this.reset("g"), ++this.m_render_version;
        if (!this.isVisible) return this.reset("g"), ++this.m_render_version;
        const e = this.renderFills(), i = this.renderBorders(), s = this.renderContents(), r = `${c(this)}`, n2 = this.renderShadows(r), o2 = `blur_${c(this)}`, a2 = this.renderBlur(o2);
        let h2 = this.renderProps(), l2 = [...e, ...s, ...i];
        if (n2.length) {
            let t5 = "";
            const e2 = bh(r, this.getShadows());
            t5 = `url(#pd_outer-${r}) `, e2.length && (t5 += e2.join(" ")), l2 = [...n2, Da("g", { filter: t5 }, l2)];
        }
        if (a2.length) {
            let t5 = "";
            t5 = `url(#${o2})`, l2 = [...a2, Da("g", { filter: t5 }, l2)];
        }
        const d2 = this.renderMask();
        if (d2) {
            Object.assign(h2.style, { transform: d2.toString() });
            const t5 = `mask-base-${c(this)}`, e2 = Da("g", { style: { transform: this.transformFromMask } }, l2);
            this.bleach(e2), l2 = [e2];
            l2 = [Da("mask", { id: t5 }, l2), Da("g", { mask: `url(#${t5})` }, this.relyLayers)];
        }
        return this.reset("g", h2, l2), ++this.m_render_version;
    }
    renderStatic() {
        var _a2, _b;
        const t4 = this.renderFills() || [], e = this.renderContents(), i = this.renderBorders() || [], s = this.renderStaticProps(), r = `${c(this)}`, n2 = this.renderShadows(r), o2 = `blur_${c(this)}`, a2 = this.renderBlur(o2), h2 = {}, l2 = this.style.contextSettings;
        if (l2) {
            const t5 = { "mix-blend-mode": l2.blenMode };
            a2.length ? (h2.style = t5, h2.opacity = s.opacity, delete s.opacity) : s.style ? s.style["mix-blend-mode"] = l2.blenMode : s.style = t5;
        }
        if (n2.length) {
            const c2 = Object.assign({}, s);
            delete s.style, delete s.transform, delete s.opacity;
            const l3 = bh(r, this.getShadows());
            s.filter = `url(#pd_outer-${r}) `, a2.length && ((_a2 = this.blur) == null ? void 0 : _a2.type) === ot.Gaussian && (s.filter += `url(#${o2}) `), l3.length && (s.filter += l3.join(" "));
            const d2 = Da("g", s, [...t4, ...e, ...i]);
            if (a2.length) {
                const t5 = Da("g", h2, [...n2, d2]);
                return Da("g", c2, [...a2, t5]);
            }
            return Da("g", c2, [...n2, ...a2, d2]);
        }
        if (a2.length && ((_b = this.blur) == null ? void 0 : _b.type) === ot.Gaussian && (s.filter = `url(#${o2})`), a2.length) {
            const r2 = Da("g", h2, [...t4, ...e, ...i]);
            return Da("g", s, [...a2, r2]);
        }
        return Da("g", s, [...a2, ...t4, ...e, ...i]);
    }
    get isContainer() {
        return this.m_data.isContainer;
    }
    get pathType() {
        return this.m_data.pathType;
    }
    get isPathIcon() {
        return this.m_data.isPathIcon;
    }
    get radius() {
        return this.m_data.radius;
    }
    get radiusType() {
        return this.m_data.radiusType;
    }
    get isStraight() {
        return this.m_data.isStraight;
    }
    get isImageFill() {
        return this.m_data.isImageFill;
    }
    get prototypeStartPoint() {
        return this.m_data.prototypeStartingPoint;
    }
    get prototypeInterActions() {
        const t4 = this._findOVAll(Et.ProtoInteractions, jt.ProtoInteractions);
        if (!t4) return this.m_data.prototypeInteractions;
        const e = new G();
        t4.reverse().forEach((t5) => {
            t5.value.slice(0).reverse().forEach((t6) => {
                e.find((e2) => e2.id === t6.id) || e.push(t6);
            });
        }), e.reverse();
        const i = e.filter((t5) => !!t5.isDeleted), s = this.m_data.prototypeInteractions || [], r = new G();
        return s.forEach((t5) => {
            if (t5.isDeleted) return;
            if (i.find((e2) => e2.id === t5.id)) return;
            const s2 = e.find((e2) => e2.id === t5.id);
            r.push(s2 || t5);
        }), e.forEach((t5) => {
            t5.isDeleted || s.find((e2) => e2.id === t5.id) || r.push(t5);
        }), r;
    }
    get overlayPosition() {
        return this.m_data.overlayPosition;
    }
    get overlayBackgroundInteraction() {
        return this.m_data.overlayBackgroundInteraction;
    }
    get overlayBackgroundAppearance() {
        return this.m_data.overlayBackgroundAppearance;
    }
    get scrollDirection() {
        return this.m_data.scrollDirection;
    }
    get relyLayers() {
        if (this.m_transform_form_mask || (this.m_transform_form_mask = this.renderMask()), !this.m_transform_form_mask) return;
        const t4 = this.m_mask_group || [];
        if (t4.length < 2) return;
        const e = ki(this.m_transform_form_mask).getInverse(), i = [];
        for (let s = 1; s < t4.length; s++) {
            const r = t4[s], n2 = r.dom;
            n2.elattr.style || (n2.elattr.style = {}), n2.elattr.style.transform = Ei(r.transform2.clone().addTransform(e)).toString(), i.push(n2);
        }
        return i;
    }
    get transformFromMask() {
        if (this.m_transform_form_mask = this.renderMask(), !this.m_transform_form_mask) return;
        const t4 = ki(this.m_transform_form_mask).getInverse();
        return Ei(this.transform2.clone().addTransform(t4)).toString();
    }
    renderMask() {
        if (!this.mask) return;
        const t4 = this.parent;
        if (!t4) return;
        const e = t4.childs;
        let i = e.findIndex((t5) => t5.id === this.id);
        if (-1 === i) return;
        const s = [this];
        this.m_mask_group = s;
        for (let t5 = i + 1; t5 < e.length; t5++) {
            const i2 = e[t5];
            if (!i2 || i2.mask) break;
            s.push(i2);
        }
        let r = 1 / 0, n2 = 1 / 0;
        return s.forEach((t5) => {
            const e2 = t5.boundingBox();
            e2.x < r && (r = e2.x), e2.y < n2 && (n2 = e2.y);
        }), new Ii(1, 0, r, 0, 1, n2);
    }
    bleach(t4) {
        if (t4.elattr.fill && "none" !== t4.elattr.fill && !t4.elattr.fill.startsWith("url") && (t4.elattr.fill = "#FFF"), t4.elattr.stroke && "none" !== t4.elattr.stroke && !t4.elattr.stroke.startsWith("url") && (t4.elattr.stroke = "#FFF"), "feColorMatrix" === t4.eltag && t4.elattr.result) {
            let e = t4.elattr.values;
            e && (e = e.split(" ")), e[3] && (e[3] = 1), e[8] && (e[8] = 1), e[13] && (e[13] = 1), t4.elattr.values = e.join(" ");
        }
        Array.isArray(t4.elchilds) && t4.elchilds.forEach((t5) => this.bleach(t5));
    }
    get dom() {
        var _a2;
        const t4 = this.renderFills(), e = this.renderContents(), i = this.renderBorders(), s = `${c(this)}`, r = this.renderShadows(s), n2 = `blur_${c(this)}`, o2 = this.renderBlur(n2), a2 = this.style.contextSettings, h2 = {};
        a2 && (void 0 !== a2.opacity && (h2.opacity = a2.opacity), h2.style = { "mix-blend-mode": a2.blenMode });
        let l2 = [...t4, ...e, ...i];
        if (r.length) {
            let t5 = "";
            const e2 = bh(s, this.getShadows());
            this.type === Vt.Rectangle || this.type === Vt.Oval ? e2.length && (t5 = `${e2.join(" ")}`) : (t5 = `url(#pd_outer-${s}) `, e2.length && (t5 += e2.join(" "))), l2 = [...r, Da("g", { filter: t5 }, l2)];
        }
        if (o2.length) {
            let t5 = "";
            ((_a2 = this.blur) == null ? void 0 : _a2.type) === ot.Gaussian && (t5 = `url(#${n2})`), l2 = [...o2, Da("g", { filter: t5 }, l2)];
        }
        return Da("g", h2, l2);
    }
    reloadImage(t4) {
        this.getFills().forEach((e) => {
            e.fillType === xt.Pattern && (t4 ? t4.has(e.imageRef || "") && e.reloadImage() : e.reloadImage());
        }), this.m_ctx.setDirty(this);
    }
}
class Dh extends Vh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "maskMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_need_updatechilds", false);
        this._bubblewatcher = this._bubblewatcher.bind(this), this.m_data.bubblewatch(this._bubblewatcher), this.updateMaskMap();
    }
    get data() {
        return this.m_data;
    }
    _bubblewatcher(...t4) {
        this.onChildChange(...t4);
    }
    onChildChange(...t4) {
        (t4.includes("fills") || t4.includes("borders")) && this.notify(...t4);
    }
    updateMaskMap() {
        const t4 = this.maskMap;
        t4.clear();
        const e = this.getDataChilds();
        let i;
        const s = [];
        for (let r = 0; r < e.length; r++) {
            const n2 = e[r];
            n2.mask ? (i = n2, s.push(n2)) : i && t4.set(n2.id, i);
        }
        this.childs.forEach((t5) => {
            t5.mask || t5.m_ctx.setDirty(t5);
        }), s.forEach((t5) => t5.notify("rerender-mask")), this.notify("mask-env-change");
    }
    onDestory() {
        super.onDestory(), this.m_data.bubbleunwatch(this._bubblewatcher);
    }
    getDataChilds() {
        return this.m_data.childs;
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), t4.includes("childs") && (this.updateMaskMap(), this.m_need_updatechilds = true);
    }
    _layout(t4, e, i, s) {
        super._layout(t4, e, i, s), this.m_need_updatechilds && (this.notify("childs"), this.m_need_updatechilds = false);
    }
    renderFills() {
        return [];
    }
    renderBorders() {
        return [];
    }
    renderContents() {
        const t4 = this.m_children;
        return t4.forEach((t5) => t5.render()), t4;
    }
    layoutChild(t4, e, i, s, r, n2) {
        let o2 = r.get(t4.id);
        const a2 = { data: t4, scale: i, varsContainer: s, isVirtual: this.m_isVirtual };
        if (o2) return this.moveChild(o2, e), o2.layout(a2);
        if (o2 = n2 && n2.getView(Ba(t4.id, s)), o2) {
            const t5 = o2.parent;
            return t5 && t5.removeChild(o2), this.addChild(o2, e), o2.layout(a2);
        }
        const h2 = this.m_ctx.comsMap;
        o2 = new (h2.get(t4.type) || h2.get(Vt.Rectangle))(this.m_ctx, a2), this.addChild(o2, e);
    }
    layoutChilds(t4, e, i) {
        const s = this.getDataChilds(), r = /* @__PURE__ */ new Map();
        this.m_children.forEach((t5) => r.set(t5.data.id, t5));
        const n2 = this.getRootView();
        for (let e2 = 0, o3 = s.length; e2 < o3; e2++) this.layoutChild(s[e2], e2, i, t4, r, n2);
        const o2 = this.removeChilds(s.length, Number.MAX_VALUE);
        n2 ? n2.addDelayDestory(o2) : o2.forEach((t5) => t5.destory());
    }
    updateFrames() {
        const t4 = this.m_children.map((t5) => t5._p_frame), e = this.m_children.map((t5) => t5._p_visibleFrame), i = this.m_children.map((t5) => t5._p_outerFrame), s = (t5, e2, i2) => (0 === i2 ? (t5.minx = e2.x, t5.maxx = e2.x + e2.width, t5.miny = e2.y, t5.maxy = e2.y + e2.height) : (t5.minx = Math.min(t5.minx, e2.x), t5.maxx = Math.max(t5.maxx, e2.x + e2.width), t5.miny = Math.min(t5.miny, e2.y), t5.maxy = Math.max(t5.maxy, e2.y + e2.height)), t5), r = t4.reduce(s, { minx: 0, miny: 0, maxx: 0, maxy: 0 }), n2 = e.reduce(s, { minx: 0, miny: 0, maxx: 0, maxy: 0 }), o2 = i.reduce(s, { minx: 0, miny: 0, maxx: 0, maxy: 0 });
        let a2 = this._save_frame.x !== this.m_frame.x || this._save_frame.y !== this.m_frame.y || this._save_frame.width !== this.m_frame.width || this._save_frame.height !== this.m_frame.height;
        zh(this.m_frame, r.minx, r.miny, r.maxx - r.minx, r.maxy - r.miny) && (this.m_pathstr = void 0, this.m_path = void 0, a2 = true), this._save_frame.x = this.m_frame.x, this._save_frame.y = this.m_frame.y, this._save_frame.width = this.m_frame.width, this._save_frame.height = this.m_frame.height, zh(this.m_visibleFrame, n2.minx, n2.miny, n2.maxx - n2.minx, n2.maxy - n2.miny) && (a2 = true), zh(this.m_outerFrame, o2.minx, o2.miny, o2.maxx - o2.minx, o2.maxy - o2.miny) && (a2 = true);
        const h2 = (t5, e2) => {
            const i2 = this.transform;
            if (this.isNoTransform()) return zh(e2, t5.x + i2.translateX, t5.y + i2.translateY, t5.width, t5.height);
            const s2 = t5, r2 = i2, n3 = [{ x: s2.x, y: s2.y }, { x: s2.x + s2.width, y: s2.y }, { x: s2.x + s2.width, y: s2.y + s2.height }, { x: s2.x, y: s2.y + s2.height }].map((t6) => r2.computeCoord(t6)), o3 = n3.reduce((t6, e3) => Math.min(t6, e3.x), n3[0].x), a3 = n3.reduce((t6, e3) => Math.max(t6, e3.x), n3[0].x), h3 = n3.reduce((t6, e3) => Math.min(t6, e3.y), n3[0].y);
            return zh(e2, o3, h3, a3 - o3, n3.reduce((t6, e3) => Math.max(t6, e3.y), n3[0].y) - h3);
        };
        return h2(this.m_frame, this._p_frame) && (a2 = true), h2(this.m_visibleFrame, this._p_visibleFrame) && (a2 = true), h2(this.m_outerFrame, this._p_outerFrame) && (a2 = true), a2 && this.m_ctx.addNotifyLayout(this), a2;
    }
}
class Hh extends Dh {
    constructor() {
        super(...arguments);
        __publicField(this, "m_inner_transform");
    }
    get innerTransform() {
        return this.m_inner_transform;
    }
    initInnerTransform(t4) {
        this.m_inner_transform = t4, this.m_ctx.setDirty(this);
    }
    innerScrollOffset(t4, e) {
        this.m_inner_transform || (this.m_inner_transform = new Ii()), this.m_inner_transform.trans(t4, e), this.m_ctx.setDirty(this);
    }
    get data() {
        return this.m_data;
    }
    get cornerRadius() {
        return this.data.cornerRadius;
    }
    renderFills() {
        return th(Da, this.getFills(), this.frame, this.getPathStr());
    }
    renderBorders() {
        return _h(Da, this.getBorders(), this.frame, this.getPathStr(), this.data);
    }
    renderProps() {
        const t4 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "xmlns:xhtml": "http://www.w3.org/1999/xhtml", preserveAspectRatio: "xMinYMin meet", overflow: "hidden" }, e = this.frame;
        return t4.width = e.width, t4.height = e.height, t4.viewBox = `0 0 ${e.width} ${e.height}`, t4;
    }
    renderStaticProps() {
        const t4 = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "xmlns:xhtml": "http://www.w3.org/1999/xhtml", preserveAspectRatio: "xMinYMin meet", overflow: "hidden" }, e = this.style.contextSettings;
        e && (t4.style = { "mix-blend-mode": e.blenMode });
        const i = this.frame;
        return i.width > i.height ? t4.transform = `translate(0, ${(i.width - i.height) / 2})` : t4.transform = `translate(${(i.height - i.width) / 2}, 0)`, t4.width = i.width, t4.height = i.height, t4.x = 0, t4.y = 0, t4.viewBox = `0 0 ${i.width} ${i.height}`, t4;
    }
    render() {
        var _a2;
        if (!this.checkAndResetDirty()) return this.m_render_version;
        const t4 = this.masked;
        if (t4) return (_a2 = this.getPage().getView(t4.id)) == null ? void 0 : _a2.render(), this.reset("g"), ++this.m_render_version;
        if (!this.isVisible) return this.reset("g"), ++this.m_render_version;
        const e = this.renderFills(), i = this.renderContents(), s = this.renderBorders(), r = this.renderProps(), n2 = `${c(this)}`, o2 = this.renderShadows(n2), a2 = `blur_${c(this)}`, h2 = this.renderBlur(a2), l2 = this.style.contextSettings;
        let d2 = { style: { transform: this.transform.toString() } }, p2 = [...e, ...i];
        if (this.innerTransform) {
            const t5 = Da("g", { id: this.id, transform: this.innerTransform.toString() }, i);
            p2 = [...e, t5];
        }
        l2 && (d2.opacity = l2.opacity, d2.style["mix-blend-mode"] = l2.blenMode);
        const u = "clippath-artboard-" + c(this), f2 = Da("svg", r, [Xa(Da, u, this.getPathStr()), ...p2]);
        if (p2 = [Da("g", { "clip-path": "url(#" + u + ")" }, [f2]), ...s], o2.length) {
            const t5 = bh(n2, this.getShadows());
            t5.length && (r.filter = t5.join(" ")), p2 = [...o2, ...p2];
        }
        h2.length && (p2 = [...h2, ...p2]);
        const g2 = this.renderMask();
        if (g2) {
            Object.assign(d2.style, { transform: g2.toString() });
            const t5 = `mask-base-${c(this)}`, e2 = Da("g", { style: { transform: this.transformFromMask } }, p2);
            this.bleach(e2), p2 = [e2];
            p2 = [Da("mask", { id: t5 }, p2), Da("g", { mask: `url(#${t5})` }, this.relyLayers)];
        }
        return this.reset("g", d2, p2), ++this.m_render_version;
    }
    get guides() {
        return this.m_data.guides;
    }
    updateFrames() {
        let t4 = this._save_frame.x !== this.m_frame.x || this._save_frame.y !== this.m_frame.y || this._save_frame.width !== this.m_frame.width || this._save_frame.height !== this.m_frame.height;
        t4 && (this._save_frame.x = this.m_frame.x, this._save_frame.y = this.m_frame.y, this._save_frame.width = this.m_frame.width, this._save_frame.height = this.m_frame.height);
        const e = this.getBorders();
        let i = 0;
        e.forEach((t5) => {
            t5.position === ht.Outer ? i = Math.max(t5.thickness, i) : t5.position === ht.Center && (i = Math.max(t5.thickness / 2, i));
        });
        const s = this.getShadows();
        let r = 0, n2 = 0, o2 = 0, a2 = 0;
        s.forEach((t5) => {
            if (!t5.isEnabled) return;
            if (t5.position !== zt.Outer) return;
            const e2 = t5.blurRadius + t5.spread;
            o2 = Math.max(-t5.offsetX + e2, o2), a2 = Math.max(t5.offsetX + e2, a2), r = Math.max(-t5.offsetY + e2, r), n2 = Math.max(t5.offsetY + e2, n2);
        });
        const h2 = Math.max(i, o2), c2 = Math.max(i, r), l2 = Math.max(i, a2), d2 = Math.max(i, n2);
        zh(this.m_visibleFrame, this.frame.x - h2, this.frame.y - c2, this.frame.width + h2 + l2, this.frame.height + c2 + d2) && (t4 = true);
        const p2 = this.m_children.map((t5) => t5._p_outerFrame), u = this.m_visibleFrame, f2 = p2.reduce((t5, e2, i2) => (t5.minx = Math.min(t5.minx, e2.x), t5.maxx = Math.max(t5.maxx, e2.x + e2.width), t5.miny = Math.min(t5.miny, e2.y), t5.maxy = Math.max(t5.maxy, e2.y + e2.height), t5), { minx: u.x, miny: u.y, maxx: u.x + u.width, maxy: u.y + u.height });
        zh(this.m_outerFrame, f2.minx, f2.miny, f2.maxx - f2.minx, f2.maxy - f2.miny) && (t4 = true);
        const g2 = (t5, e2) => {
            const i2 = this.transform;
            if (this.isNoTransform()) return zh(e2, t5.x + i2.translateX, t5.y + i2.translateY, t5.width, t5.height);
            const s2 = t5, r2 = i2, n3 = [{ x: s2.x, y: s2.y }, { x: s2.x + s2.width, y: s2.y }, { x: s2.x + s2.width, y: s2.y + s2.height }, { x: s2.x, y: s2.y + s2.height }].map((t6) => r2.computeCoord(t6)), o3 = n3.reduce((t6, e3) => Math.min(t6, e3.x), n3[0].x), a3 = n3.reduce((t6, e3) => Math.max(t6, e3.x), n3[0].x), h3 = n3.reduce((t6, e3) => Math.min(t6, e3.y), n3[0].y);
            return zh(e2, o3, h3, a3 - o3, n3.reduce((t6, e3) => Math.max(t6, e3.y), n3[0].y) - h3);
        };
        return g2(this.m_frame, this._p_frame) && (t4 = true), g2(this.m_visibleFrame, this._p_visibleFrame) && (t4 = true), g2(this.m_outerFrame, this._p_outerFrame) && (t4 = true), t4 && this.m_ctx.addNotifyLayout(this), t4;
    }
}
const Wh = {};
function $h(t4, e, i, s, r) {
    return Wh[s](t4, e, i, r);
}
function Xh(t4, e, i, s, r, n2, o2) {
    const a2 = { d: s, fill: "none", stroke: "", "stroke-width": i.sideSetting.thicknessTop }, { length: h2, gap: l2 } = i.borderStyle;
    (h2 || l2) && (a2["stroke-dasharray"] = `${h2}, ${l2}`);
    const d2 = i.fillType;
    if (d2 === xt.SolidColor) {
        const t5 = i.color;
        a2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    } else if (d2 === xt.Gradient) {
        const t5 = i.color;
        a2.stroke = "rgba(" + t5.red + "," + t5.green + "," + t5.blue + "," + t5.alpha + ")";
    }
    const p2 = [t4("path", a2)];
    if (o2 !== Ct.Line || n2 !== Ct.Line) {
        if (o2 && o2 !== Ct.Line) {
            const s2 = "e-" + c(r);
            p2.unshift($h(t4, e, i, o2, s2)), a2["marker-end"] = `url(#arrow-${s2})`;
        }
        if (n2 && n2 !== Ct.Line) {
            const s2 = "s-" + c(r);
            p2.unshift($h(t4, e, i, n2, s2)), a2["marker-start"] = `url(#arrow-${s2})`;
        }
        return p2;
    }
    return t4("path", a2);
}
Wh[Ct.FilledArrow] = function(t4, e, i, s) {
    const r = i.color;
    return t4("marker", { id: "arrow-" + s, viewBox: "0 0 10 10", refX: 5, refY: 5, markerWidth: 10, markerHeight: 10, orient: "auto-start-reverse" }, [t4("path", { d: "M 2 2 L 8 5 L 2 8 Z", stroke: "none", fill: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")" })]);
}, Wh[Ct.OpenArrow] = function(t4, e, i, s) {
    const r = i.color;
    return t4("marker", { id: "arrow-" + s, viewBox: "0 0 10 10", refX: 7.5, refY: 5, markerWidth: 10, markerHeight: 10, orient: "auto-start-reverse" }, [t4("polyline", { points: "4,2 8,5 4,8", stroke: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")", "stroke-linecap": "round", "stroke-linejoin": "round", fill: "none" })]);
}, Wh[Ct.FilledCircle] = function(t4, e, i, s) {
    const r = i.color, n2 = i.sideSetting.thicknessTop, o2 = { id: "arrow-" + s, viewBox: `0 0 ${6 * n2} ${6 * n2}`, refX: "5", refY: "5", markerWidth: 6 * n2, markerHeight: 6 * n2, orient: "auto-start-reverse" };
    n2 <= 1 && (delete o2.viewBox, o2.markerWidth = 12, o2.markerHeight = 12);
    return t4("marker", o2, [t4("circle", { cx: 5, cy: 5, r: 3, stroke: "none", fill: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")" })]);
}, Wh[Ct.FilledSquare] = function(t4, e, i, s) {
    const r = i.color;
    return t4("marker", { id: "arrow-" + s, viewBox: "0 0 10 10", refX: 5, refY: 5, markerWidth: 10, markerHeight: 10, orient: "auto-start-reverse" }, [t4("path", { d: "M5 2 L8 5 L5 8 L2 5 z", stroke: "none", fill: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")" })]);
}, Wh[Ct.Square] = function(t4, e, i, s) {
    const r = i.color, n2 = i.sideSetting.thicknessTop, o2 = { id: "arrow-" + s, viewBox: `0 0 ${6 * n2} ${6 * n2}`, refX: "3", refY: "3", markerWidth: n2, markerHeight: n2, orient: "auto-start-reverse" };
    n2 <= 1 && (o2.markerWidth = 2, o2.markerHeight = 2, o2.viewBox = "0 0 12 12");
    return t4("marker", o2, [t4("rect", { width: 6, height: 6, stroke: "none", fill: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")" })]);
}, Wh[Ct.Round] = function(t4, e, i, s) {
    const r = i.color, n2 = i.sideSetting.thicknessTop, o2 = { id: "arrow-" + s, viewBox: `0 0 ${6 * n2} ${6 * n2}`, refX: "5", refY: "5", markerWidth: n2, markerHeight: n2, orient: "auto-start-reverse" };
    n2 <= 1 && (o2.markerWidth = 2, o2.markerHeight = 2, o2.viewBox = "0 0 12 12");
    return t4("marker", o2, [t4("circle", { cx: 5, cy: 5, r: 3, stroke: "none", fill: i.fillType === xt.Gradient ? "white" : "rgb(" + r.red + "," + r.green + "," + r.blue + ")" })]);
};
const Gh = Ji.DefaultColor;
function Yh(t4, e) {
    const i = e.position, s = e.color || Gh;
    return t4("stop", { offset: 100 * i + "%", "stop-color": "rgba(" + s.red + "," + s.green + "," + s.blue + "," + s.alpha + ")", "stop-opacity": s.alpha });
}
function Uh(t4, e, i, s) {
    const r = "gradient" + c(e);
    let n2, o2;
    if (e.gradientType == wt.Linear) {
        const s2 = e.stops.length, n3 = [];
        for (let i2 = 0; i2 < s2; i2++) {
            const s3 = e.stops[i2];
            n3.push(Yh(t4, s3));
        }
        o2 = t4("linearGradient", { id: r, x1: e.from.x * i.width, y1: e.from.y * i.height, x2: e.to.x * i.width, y2: e.to.y * i.height, gradientUnits: "userSpaceOnUse" }, n3);
    } else if (e.gradientType == wt.Radial) {
        const s2 = e.stops.length, n3 = [];
        for (let i2 = 0; i2 < s2; i2++) {
            const s3 = e.stops[i2];
            n3.push(Yh(t4, s3));
        }
        const a2 = Math.sqrt((e.to.y * i.height - e.from.y * i.height) ** 2 + (e.to.x * i.width - e.from.x * i.width) ** 2), h2 = a2, c2 = e.elipseLength ? e.elipseLength * a2 * i.width / i.height : 0, l2 = Math.atan2(e.to.y * i.height - e.from.y * i.height, e.to.x * i.width - e.from.x * i.width) / Math.PI * 180;
        o2 = t4("radialGradient", { id: r, cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(" + e.from.x * i.width + "," + e.from.y * i.height + ") rotate(" + l2 + ") scale(" + h2 + " " + c2 + ")" }, n3);
    } else if (e.gradientType == wt.Angular) {
        let t5 = "";
        const r2 = e.stops.length, o3 = () => {
            const t6 = e.stops[0], i2 = e.stops[r2 - 1], s2 = 1 - i2.position, n3 = t6.position, o4 = t6.color || Gh, a2 = i2.color || Gh, h2 = 1 / (n3 + s2), c2 = s2 * h2, l2 = n3 * h2;
            let d2 = o4.red * c2 + a2.red * l2, p2 = o4.green * c2 + a2.green * l2, u = o4.blue * c2 + a2.blue * l2, f2 = o4.alpha * c2 + a2.alpha * l2;
            return d2 = Math.min(Math.max(Math.round(d2), 0), 255), p2 = Math.min(Math.max(Math.round(p2), 0), 255), u = Math.min(Math.max(Math.round(u), 0), 255), f2 = Math.min(Math.max(f2, 0), 1), { r: d2, g: p2, b: u, a: f2 };
        };
        if (r2 > 0 && e.stops[0].position > 0) {
            const { r: e2, g: i2, b: s2, a: r3 } = o3();
            t5 = "rgba(" + e2 + "," + i2 + "," + s2 + "," + r3 + ") 0deg";
        }
        for (let i2 = 0; i2 < r2; i2++) {
            const s2 = e.stops[i2], r3 = s2.color || Gh, n3 = "rgba(" + r3.red + "," + r3.green + "," + r3.blue + "," + r3.alpha + ")", o4 = Math.round(360 * s2.position);
            t5.length > 0 && (t5 += ","), t5 = t5 + n3 + " " + o4 + "deg";
        }
        if (r2 > 0 && e.stops[r2 - 1].position < 1) {
            const { r: e2, g: i2, b: s2, a: r3 } = o3();
            t5 = t5 + ",rgba(" + e2 + "," + i2 + "," + s2 + "," + r3 + ") 360deg";
        }
        n2 = "background: conic-gradient(" + ("from " + (Math.atan2(e.to.y * i.height - e.from.y * i.height, e.to.x * i.width - e.from.x * i.width) / Math.PI * 180 + 90) + "deg at " + (e.from.x * i.width + 6 * s) + "px " + (e.from.y * i.height + 6 * s) + "px") + "," + t5 + ");height:-webkit-fill-available;width:-webkit-fill-available;";
    }
    return { id: r, style: n2, node: o2 };
}
function Zh(t4, e, i, s, r, n2, o2) {
    var _a2;
    const a2 = i.sideSetting.thicknessTop, h2 = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": a2 };
    let l2;
    r instanceof Vi && r.pathsegs.length > 1 && (n2 === Ct.Round || o2 === Ct.Round ? h2["stroke-linecap"] = "round" : n2 !== Ct.Square && o2 !== Ct.Square || (h2["stroke-linecap"] = "square"));
    const { length: d2, gap: p2 } = i.borderStyle;
    (d2 || p2) && (h2["stroke-dasharray"] = `${d2}, ${p2}`);
    if (i.fillType === xt.SolidColor) {
        const t5 = i.color;
        h2.stroke = "rgb(" + t5.red + "," + t5.green + "," + t5.blue + ")", h2.opacity = i.color.alpha;
    } else {
        l2 = $a(t4, i.gradient, r.size);
        const e2 = (_a2 = i.gradient) == null ? void 0 : _a2.gradientOpacity;
        h2.opacity = void 0 === e2 ? 1 : e2, h2.stroke = "url(#" + l2.id + ")";
    }
    if (o2 && o2 !== Ct.Line || n2 && n2 !== Ct.Line) {
        let s2;
        delete h2.opacity, i.fillType === xt.Gradient && (s2 = Uh(t4, i.gradient, r.size, a2));
        const l3 = [t4("path", h2)];
        if (o2 && o2 !== Ct.Line) {
            const s3 = Ya(), n3 = "e-" + c(r) + "-" + s3;
            l3.unshift($h(t4, e, i, o2, n3)), h2["marker-end"] = `url(#arrow-${n3})`;
        }
        if (n2 && n2 !== Ct.Line) {
            const s3 = Ya(), o3 = "s-" + c(r) + "-" + s3;
            l3.unshift($h(t4, e, i, n2, o3)), h2["marker-start"] = `url(#arrow-${o3})`;
        }
        if (s2) {
            h2.stroke = "white";
            const e2 = r.size, n3 = "mask-line-" + c(i) + Ya(), o3 = t4("mask", { id: n3 }, l3), d3 = -6 * a2, p3 = t4("rect", { x: d3, y: d3, width: e2.width + 12 * a2, height: e2.height + 12 * a2, fill: "url(#" + s2.id + ")", mask: "url(#" + n3 + ")" });
            return t4("g", [s2.node, o3, p3]);
        }
        return t4("g", { opacity: i.color.alpha }, l3);
    }
    if (l2 && l2.node) {
        delete h2.opacity;
        const e2 = [t4("path", h2)];
        return e2.unshift(l2.node), t4("g", e2);
    }
    return t4("path", h2);
}
function jh(t4, e, i, s, r, n2, o2) {
    const a2 = i.sideSetting.thicknessTop;
    i.gradient;
    let h2 = Uh(t4, i.gradient, r.size, a2);
    const l2 = "mask-line-" + c(i) + Ya(), d2 = { d: s, fill: "none", stroke: "", "stroke-linejoin": i.cornerType, "stroke-width": a2 };
    r instanceof Vi && r.pathsegs.length > 1 && (n2 === Ct.Round || o2 === Ct.Round ? d2["stroke-linecap"] = "round" : n2 !== Ct.Square && o2 !== Ct.Square || (d2["stroke-linecap"] = "square"));
    const p2 = new Array(), u = r.size, f2 = t4("foreignObject", { width: u.width + 12 * a2, height: u.height + 12 * a2, x: -6 * a2, y: -6 * a2, mask: "url(#" + l2 + ")" }, t4("div", { width: "100%", height: "100%", style: "overflow: hidden; height: 100%" }, [t4("div", { width: "100%", height: "100%", style: h2.style })])), { length: g2, gap: m2 } = i.borderStyle;
    (g2 || m2) && (d2["stroke-dasharray"] = `${g2}, ${m2}`), d2.stroke = "white";
    const _2 = t4("mask", { id: l2 }, [t4("path", d2)]);
    if (p2.push(_2), p2.push(f2), o2 && o2 !== Ct.Line || n2 && n2 !== Ct.Line) {
        delete d2.opacity;
        const s2 = [t4("path", d2)];
        if (o2 && o2 !== Ct.Line) {
            const n3 = Ya(), a3 = "e-" + c(r) + "-" + n3;
            s2.unshift($h(t4, e, i, o2, a3)), d2["marker-end"] = `url(#arrow-${a3})`;
        }
        if (n2 && n2 !== Ct.Line) {
            const o3 = Ya(), a3 = "s-" + c(r) + "-" + o3;
            s2.unshift($h(t4, e, i, n2, a3)), d2["marker-start"] = `url(#arrow-${a3})`;
        }
        if (h2 && h2.style) {
            d2.stroke = "white";
            const e2 = t4("mask", { id: l2 }, s2);
            return t4("g", [e2, f2]);
        }
        {
            const e2 = i.color;
            return d2.stroke = "rgb(" + e2.red + "," + e2.green + "," + e2.blue + ")", t4("g", s2);
        }
    }
    return t4("g", p2);
}
function Jh(t4, e, i, s, r, n2, o2) {
    const a2 = i.length;
    let h2 = new Array();
    const c2 = s, l2 = r;
    for (let s2 = 0; s2 < a2; s2++) {
        const r2 = i[s2];
        if (!r2.isEnabled) continue;
        const a3 = r2.fillType, d2 = r2.gradient && r2.gradient.gradientType;
        a3 == xt.Gradient && d2 == wt.Angular && void h2.push(jh(t4, e, r2, n2, o2, c2, l2)) || (a3 == xt.SolidColor || a3 == xt.Gradient && d2 !== wt.Angular) && h2.push(Zh(t4, e, r2, n2, o2, c2, l2));
    }
    return h2;
}
class Kh extends Vh {
    constructor() {
        super(...arguments);
        __publicField(this, "m_pathsegs");
    }
    get segments() {
        return this.m_pathsegs || this.m_data.pathsegs;
    }
    get data() {
        return this.m_data;
    }
    get isClosed() {
        return this.data.isClosed;
    }
    _layout(t4, e, i, s) {
        this.m_pathsegs = void 0, super._layout(t4, e, i, s);
    }
    renderBorders() {
        return 1 === this.segments.length && !this.segments[0].isClosed || this.segments.length > 1 ? Jh(Da, this.data.style, this.getBorders(), this.startMarkerType, this.endMarkerType, this.getPathStr(), this.m_data) : _h(Da, this.getBorders(), this.frame, this.getPathStr(), this.m_data);
    }
    render() {
        var _a2, _b;
        if (!this.checkAndResetDirty()) return this.m_render_version;
        const t4 = this.masked;
        if (t4) return (_a2 = this.getPage().getView(t4.id)) == null ? void 0 : _a2.render(), this.reset("g"), ++this.m_render_version;
        if (!this.isVisible) return this.reset("g"), ++this.m_render_version;
        const e = this.renderFills() || [], i = this.renderBorders() || [], s = `${c(this)}`, r = this.renderShadows(s), n2 = `blur_${c(this)}`, o2 = this.renderBlur(n2);
        let a2 = this.renderProps(), h2 = [...e, ...i];
        if (r.length) {
            let t5 = "";
            const e2 = bh(s, this.getShadows());
            this.type === Vt.Rectangle || this.type === Vt.Oval ? e2.length && (t5 = `${e2.join(" ")}`) : (t5 = `url(#pd_outer-${s}) `, e2.length && (t5 += e2.join(" "))), h2 = [...r, Da("g", { filter: t5 }, h2)];
        }
        if (o2.length) {
            let t5 = "";
            ((_b = this.blur) == null ? void 0 : _b.type) === ot.Gaussian && (t5 = `url(#${n2})`), h2 = [...o2, Da("g", { filter: t5 }, h2)];
        }
        const l2 = this.renderMask();
        if (l2) {
            Object.assign(a2.style, { transform: l2.toString() });
            const t5 = `mask-base-${c(this)}`, e2 = Da("g", { style: { transform: this.transformFromMask } }, h2);
            this.bleach(e2), h2 = [e2];
            h2 = [Da("mask", { id: t5 }, h2), Da("g", { mask: `url(#${t5})` }, this.relyLayers)];
        }
        return this.reset("g", a2, h2), ++this.m_render_version;
    }
    get relyLayers() {
        if (this.m_transform_form_mask || (this.m_transform_form_mask = this.renderMask()), !this.m_transform_form_mask) return;
        const t4 = this.m_mask_group || [];
        if (t4.length < 2) return;
        const e = ki(this.m_transform_form_mask).getInverse(), i = [];
        for (let s = 1; s < t4.length; s++) {
            const r = t4[s], n2 = r.dom;
            n2.elattr.style = { transform: Ei(r.transform2.clone().addTransform(e)).toString() }, i.push(n2);
        }
        return i;
    }
    get transformFromMask() {
        if (this.m_transform_form_mask = this.renderMask(), !this.m_transform_form_mask) return;
        const t4 = ki(this.m_transform_form_mask).getInverse();
        return Ei(this.transform2.clone().addTransform(t4)).toString();
    }
    renderMask() {
        if (!this.mask) return;
        const t4 = this.parent;
        if (!t4) return;
        const e = t4.childs;
        let i = e.findIndex((t5) => t5.id === this.id);
        if (-1 === i) return;
        const s = [this];
        this.m_mask_group = s;
        for (let t5 = i + 1; t5 < e.length; t5++) {
            const i2 = e[t5];
            if (!i2 || i2.mask) break;
            s.push(i2);
        }
        let r = 1 / 0, n2 = 1 / 0;
        return s.forEach((t5) => {
            const e2 = t5.boundingBox();
            e2.x < r && (r = e2.x), e2.y < n2 && (n2 = e2.y);
        }), new Ii(1, 0, r, 0, 1, n2);
    }
    bleach(t4) {
        if (t4.elattr.fill && "none" !== t4.elattr.fill && !t4.elattr.fill.startsWith("url(#gradient") && (t4.elattr.fill = "#FFF"), t4.elattr.stroke && "none" !== t4.elattr.stroke && !t4.elattr.stroke.startsWith("url(#gradient") && (t4.elattr.stroke = "#FFF"), "feColorMatrix" === t4.eltag && t4.elattr.result) {
            let e = t4.elattr.values;
            e && (e = e.split(" ")), e[3] && (e[3] = 1), e[8] && (e[8] = 1), e[13] && (e[13] = 1), t4.elattr.values = e.join(" ");
        }
        Array.isArray(t4.elchilds) && t4.elchilds.forEach((t5) => this.bleach(t5));
    }
    renderStatic() {
        var _a2, _b, _c2, _d2;
        const t4 = this.renderFills() || [], e = this.renderContents(), i = this.renderBorders() || [], s = this.renderStaticProps(), r = `${c(this)}`, n2 = this.renderShadows(r), o2 = `blur_${c(this)}`, a2 = this.renderBlur(o2);
        if (n2.length > 0) {
            const h2 = Object.assign({}, s);
            delete s.style, delete s.transform, delete s.opacity;
            const c2 = bh(r, this.getShadows());
            this.type === Vt.Rectangle || this.type === Vt.Oval ? a2.length && c2.length ? (s.filter = `${c2.join(" ")}`, ((_a2 = this.blur) == null ? void 0 : _a2.type) === ot.Gaussian && (s.filter += ` url(#${o2})`)) : (c2.length && (s.filter = c2.join(" ")), a2.length && ((_b = this.blur) == null ? void 0 : _b.type) === ot.Gaussian && (s.filter = `url(#${o2})`)) : (s.filter = `url(#pd_outer-${r}) `, a2.length && ((_c2 = this.blur) == null ? void 0 : _c2.type) === ot.Gaussian && (s.filter += `url(#${o2}) `), c2.length && (s.filter += c2.join(" ")));
            const l2 = Da("g", s, [...t4, ...e, ...i]);
            return Da("g", h2, [...n2, ...a2, l2]);
        }
        return a2.length && ((_d2 = this.blur) == null ? void 0 : _d2.type) === ot.Gaussian && (s.filter = `url(#${o2})`), Da("g", s, [...a2, ...t4, ...e, ...i]);
    }
}
class qh extends Kh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "from");
        __publicField(this, "to");
        __publicField(this, "fromparents", []);
        __publicField(this, "toparents", []);
        __publicField(this, "page");
        this.watcher_sides = this.watcher_sides.bind(this), this.updateApex();
    }
    get data() {
        return this.m_data;
    }
    get fromAndto() {
        return { from: this.from, to: this.to };
    }
    watcher_sides(...t4) {
        this.updateApex(), this.m_path = void 0, this.m_pathstr = void 0, this.m_ctx.setDirty(this);
    }
    unwatchApex(t4, e) {
        t4.unwatch(this.watcher_sides), e.forEach((t5) => {
            t5.unwatch(this.watcher_sides);
        }), e.length = 0;
    }
    watchApex(t4, e) {
        t4.watch(this.watcher_sides);
        let i = t4.parent;
        for (; i && i.type !== Vt.Page; ) i.watch(this.watcher_sides), e.push(i), i = i.parent;
    }
    getPageShape() {
        return this.page || (this.page = this.m_data.getPage()), this.page;
    }
    modify_from_side_watch(t4) {
        if (!t4) return void (this.from && (this.unwatchApex(this.from, this.fromparents), this.from = void 0));
        const e = this.getPageShape().getShape(t4.shapeId);
        e ? this.from ? (this.unwatchApex(this.from, this.fromparents), this.from = e, this.watchApex(this.from, this.fromparents)) : (this.from = e, this.watchApex(this.from, this.fromparents)) : this.from && (this.unwatchApex(this.from, this.fromparents), this.from = void 0);
    }
    modify_to_side_watch(t4) {
        if (!t4) return void (this.to && (this.unwatchApex(this.to, this.toparents), this.to = void 0));
        const e = this.getPageShape().getShape(t4.shapeId);
        e ? this.to ? (this.unwatchApex(this.to, this.toparents), this.to = e, this.watchApex(this.to, this.toparents)) : (this.to = e, this.watchApex(this.to, this.toparents)) : this.to && (this.unwatchApex(this.to, this.toparents), this.to = void 0);
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), t4.includes("points") || t4.includes("shape-frame") || this.updateApex();
    }
    updateApex() {
        const t4 = this.m_data;
        this.modify_from_side_watch(t4.from), this.modify_to_side_watch(t4.to);
    }
    onDestory() {
        super.onDestory(), this.from && (this.unwatchApex(this.from, this.fromparents), this.from = void 0), this.to && (this.unwatchApex(this.to, this.toparents), this.to = void 0);
    }
    renderFills() {
        return [];
    }
    renderBorders() {
        return this.m_data.style.borders.length > 0 ? function(t4, e, i, s) {
            const r = e.borders.length;
            let n2 = new Array();
            const o2 = e.startMarkerType, a2 = e.endMarkerType;
            for (let h2 = 0; h2 < r; h2++) {
                const r2 = e.borders[h2];
                r2.isEnabled && (r2.fillType, n2 = n2.concat(Xh(t4, e, r2, i, s, o2, a2)));
            }
            return n2;
        }(Da, this.m_data.style, this.getPathStr(), this.m_data) : [];
    }
    getPoints() {
        return this.data.getPoints();
    }
}
class Qh extends Kh {
    get data() {
        return this.m_data;
    }
}
class ec extends Kh {
    renderFills() {
        return [];
    }
    renderBorders() {
        return this.m_data.style.borders.length > 0 ? Jh(Da, this.m_data.style, this.getBorders(), this.startMarkerType, this.endMarkerType, this.getPathStr(), this.m_data) : [];
    }
}
class ic extends Vh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "m_pathsegs");
    }
    get segments() {
        return this.m_pathsegs || this.m_data.pathsegs;
    }
    _layout(t4, e, i, s) {
        this.m_pathsegs = void 0, super._layout(t4, e, i, s);
    }
    renderBorders() {
        return _h(Da, this.getBorders(), this.frame, this.getPathStr(), this.m_data, false);
    }
}
class sc extends Dh {
    get data() {
        return this.m_data;
    }
    get cornerRadius() {
        return this.data.cornerRadius;
    }
    get variables() {
        return this.data.variables;
    }
    get isSymbolUnionShape() {
        return this.data.isSymbolUnionShape;
    }
    get symtags() {
        return this.data.symtags;
    }
    renderFills() {
        return th(Da, this.getFills(), this.frame, this.getPathStr());
    }
    renderBorders() {
        return _h(Da, this.getBorders(), this.frame, this.getPathStr(), this.data);
    }
    layoutChild(t4, e, i, s, r, n2) {
        let o2 = r.get(t4.id);
        const a2 = { data: t4, scale: i, varsContainer: s = [...s || [], this.data], isVirtual: this.m_isVirtual };
        if (o2) return this.moveChild(o2, e), void o2.layout(a2);
        if (o2 = n2 && n2.getView(Ba(t4.id, s)), o2) {
            const t5 = o2.parent;
            return t5 && t5.removeChild(o2), this.addChild(o2, e), void o2.layout(a2);
        }
        const h2 = this.m_ctx.comsMap;
        o2 = new (h2.get(t4.type) || h2.get(Vt.Rectangle))(this.m_ctx, a2), this.addChild(o2, e);
    }
    get guides() {
        return this.m_data.guides;
    }
    updateFrames() {
        let t4 = this._save_frame.x !== this.m_frame.x || this._save_frame.y !== this.m_frame.y || this._save_frame.width !== this.m_frame.width || this._save_frame.height !== this.m_frame.height;
        t4 && (this._save_frame.x = this.m_frame.x, this._save_frame.y = this.m_frame.y, this._save_frame.width = this.m_frame.width, this._save_frame.height = this.m_frame.height);
        const e = this.getBorders();
        let i = 0;
        e.forEach((t5) => {
            t5.position === ht.Outer ? i = Math.max(t5.thickness, i) : t5.position === ht.Center && (i = Math.max(t5.thickness / 2, i));
        });
        const s = this.getShadows();
        let r = 0, n2 = 0, o2 = 0, a2 = 0;
        s.forEach((t5) => {
            if (!t5.isEnabled) return;
            if (t5.position !== zt.Outer) return;
            const e2 = t5.blurRadius + t5.spread;
            o2 = Math.max(-t5.offsetX + e2, o2), a2 = Math.max(t5.offsetX + e2, a2), r = Math.max(-t5.offsetY + e2, r), n2 = Math.max(t5.offsetY + e2, n2);
        });
        const h2 = Math.max(i, o2), c2 = Math.max(i, r), l2 = Math.max(i, a2), d2 = Math.max(i, n2);
        zh(this.m_visibleFrame, this.frame.x - h2, this.frame.y - c2, this.frame.width + h2 + l2, this.frame.height + c2 + d2) && (t4 = true);
        const p2 = this.m_children.map((t5) => t5._p_outerFrame), u = this.m_visibleFrame, f2 = p2.reduce((t5, e2, i2) => (t5.minx = Math.min(t5.minx, e2.x), t5.maxx = Math.max(t5.maxx, e2.x + e2.width), t5.miny = Math.min(t5.miny, e2.y), t5.maxy = Math.max(t5.maxy, e2.y + e2.height), t5), { minx: u.x, miny: u.y, maxx: u.x + u.width, maxy: u.y + u.height });
        zh(this.m_outerFrame, f2.minx, f2.miny, f2.maxx - f2.minx, f2.maxy - f2.miny) && (t4 = true);
        const g2 = (t5, e2) => {
            const i2 = this.transform;
            if (this.isNoTransform()) return zh(e2, t5.x + i2.translateX, t5.y + i2.translateY, t5.width, t5.height);
            const s2 = t5, r2 = i2, n3 = [{ x: s2.x, y: s2.y }, { x: s2.x + s2.width, y: s2.y }, { x: s2.x + s2.width, y: s2.y + s2.height }, { x: s2.x, y: s2.y + s2.height }].map((t6) => r2.computeCoord(t6)), o3 = n3.reduce((t6, e3) => Math.min(t6, e3.x), n3[0].x), a3 = n3.reduce((t6, e3) => Math.max(t6, e3.x), n3[0].x), h3 = n3.reduce((t6, e3) => Math.min(t6, e3.y), n3[0].y);
            return zh(e2, o3, h3, a3 - o3, n3.reduce((t6, e3) => Math.max(t6, e3.y), n3[0].y) - h3);
        };
        return g2(this.m_frame, this._p_frame) && (t4 = true), g2(this.m_visibleFrame, this._p_visibleFrame) && (t4 = true), g2(this.m_outerFrame, this._p_outerFrame) && (t4 = true), t4 && this.m_ctx.addNotifyLayout(this), t4;
    }
}
const rc = "ref-id-cf76c6c6-beed-4c33-ae71-134ee876b990";
class nc extends Vh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "maskMap", /* @__PURE__ */ new Map());
        __publicField(this, "m_sym");
        __publicField(this, "m_union");
        this.symwatcher = this.symwatcher.bind(this), this.loadsym(), this.updateMaskMap();
    }
    onMounted() {
        if (!this.m_sym) return void super.onMounted();
        const t4 = (this.varsContainer || []).concat(this.m_data);
        this.m_sym.parent instanceof zi && t4.push(this.m_sym.parent), t4.push(this.m_sym);
        const e = this.parent, i = (e == null ? void 0 : e.hasSize()) ? e.frame : void 0;
        this._layout(this.m_data, i, t4, this.m_scale), this.updateFrames();
    }
    getDataChilds() {
        return this.m_sym ? this.m_sym.childs : [];
    }
    getRefId() {
        const t4 = this.getSessionRefId();
        if (t4) return t4;
        const e = this._findOV(Et.SymbolID, jt.SymbolRef);
        return e ? e.value : this.m_data.refId;
    }
    getSessionRefId() {
        const t4 = window.location.pathname, e = sessionStorage.getItem(rc);
        if (!t4.includes("document") && e) {
            const t5 = JSON.parse(e), i = new Map(t5);
            return i.has(this.id) && i.get(this.id) || false;
        }
        return false;
    }
    updateMaskMap() {
        const t4 = this.maskMap;
        t4.clear();
        const e = this.getDataChilds();
        let i;
        const s = [];
        for (let r = 0; r < e.length; r++) {
            const n2 = e[r];
            n2.mask ? (i = n2, s.push(n2)) : i && t4.set(n2.id, i);
        }
        this.childs.forEach((t5) => {
            t5.mask || t5.m_ctx.setDirty(t5);
        }), s.forEach((t5) => t5.notify("rerender-mask")), this.notify("mask-env-change");
    }
    get symData() {
        return this.m_sym;
    }
    get refId() {
        return this.getRefId();
    }
    get data() {
        return this.m_data;
    }
    get variables() {
        return this.data.variables;
    }
    get overrides() {
        return this.data.overrides;
    }
    get isCustomSize() {
        return this.data.isCustomSize;
    }
    getPath() {
        return this.m_path || (this.m_path = Bi(this.frame, this.cornerRadius, this.m_fixedRadius), this.m_path.freeze()), this.m_path;
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), this.loadsym(), t4.includes("childs") && this.updateMaskMap();
    }
    symwatcher(...t4) {
        this.m_ctx.setReLayout(this);
    }
    findOverride(t4, e) {
        return bs(t4, e, (this.varsContainer || []).concat(this.data) || []);
    }
    findVar(t4, e) {
        ws(t4, e, (this.varsContainer || []).concat(this.data) || []);
    }
    loadsym() {
        var _a2, _b;
        const t4 = this.m_data.getSymbolMgr();
        if (!t4) return;
        const e = this.getRefId(), i = t4.get(e);
        if (!i) return;
        if (this.m_sym && c(this.m_sym) === c(i)) return;
        this.m_sym && this.m_sym.unwatch(this.symwatcher), this.m_sym = i, this.m_sym && this.m_sym.watch(this.symwatcher);
        const s = ((_a2 = this.m_sym) == null ? void 0 : _a2.parent) instanceof zi ? this.m_sym.parent : void 0;
        ((_b = this.m_union) == null ? void 0 : _b.id) !== (s == null ? void 0 : s.id) && (this.m_union && this.m_union.unwatch(this.symwatcher), this.m_union = s, this.m_union && this.m_union.watch(this.symwatcher)), this.m_ctx.setReLayout(this);
    }
    onDestory() {
        super.onDestory(), this.m_union && this.m_union.unwatch(this.symwatcher), this.m_sym && this.m_sym.unwatch(this.symwatcher);
    }
    layoutChild(t4, e, i, s, r, n2) {
        let o2 = r.get(t4.id);
        const a2 = { data: t4, scale: i, varsContainer: s, isVirtual: true };
        if (o2) {
            const t5 = this.moveChild(o2, e);
            return o2.layout(a2), t5;
        }
        if (o2 = n2 && n2.getView(Ba(t4.id, s)), o2) {
            const t5 = o2.parent;
            return t5 && t5.removeChild(o2), this.addChild(o2, e), o2.layout(a2), true;
        }
        const h2 = this.m_ctx.comsMap;
        return o2 = new (h2.get(t4.type) || h2.get(Vt.Rectangle))(this.m_ctx, a2), this.addChild(o2, e), true;
    }
    layout(t4) {
        const e = this.m_ctx.removeReLayout(this);
        if (t4 && !this.updateLayoutProps(t4, e)) return;
        this.m_ctx.setDirty(this), this.m_ctx.addNotifyLayout(this);
        const i = (this.varsContainer || []).concat(this.m_data);
        this.m_sym && (this.m_sym.parent instanceof zi && i.push(this.m_sym.parent), i.push(this.m_sym));
        const s = this.parent, r = (s == null ? void 0 : s.hasSize()) ? s.frame : void 0;
        this._layout(this.data, r, i, this.m_scale);
    }
    _layout(t4, e, i, s) {
        if (!this.m_sym) return this.updateLayoutArgs(t4.transform, t4.frame, 0), void this.removeChilds(0, this.m_children.length).forEach((t5) => t5.destory());
        const r = { x: (s == null ? void 0 : s.x) ?? 1, y: (s == null ? void 0 : s.y) ?? 1 }, n2 = { x: r.x, y: r.y }, o2 = { x: n2.x, y: n2.y };
        this.m_data.isCustomSize ? (o2.x *= this.m_data.size.width / this.m_sym.size.width, o2.y *= this.m_data.size.height / this.m_sym.size.height) : (n2.x *= this.m_sym.size.width / this.m_data.size.width, n2.y *= this.m_sym.size.height / this.m_data.size.height);
        const a2 = t4.transform;
        if (1 === n2.x && 1 === n2.y) {
            let t5 = this.data.frame;
            return this.updateLayoutArgs(a2, t5, 0), void this.layoutChilds(i, this.frame, o2);
        }
        const h2 = (t5, e2) => {
            let i2 = a2;
            if (t5 !== e2) {
                i2 = i2.clone(), i2.scale(t5, e2);
                const s2 = ki(i2);
                s2.clearScaleSize(), i2 = Ei(s2);
            }
            return i2;
        }, c2 = t4.resizingConstraint ?? 0;
        if (!(this.hasSize() || 0 !== c2 && e)) {
            let t5 = this.frame;
            const e2 = a2.clone();
            e2.scale(n2.x, n2.y);
            const s2 = e2.computeCoord(0, 0), r2 = h2(n2.x, n2.y).clone(), c3 = r2.computeCoord(0, 0), l3 = s2.x - c3.x, d3 = s2.y - c3.y;
            return r2.trans(l3, d3), this.updateLayoutArgs(r2, t5, 0), void this.layoutChilds(i, void 0, o2);
        }
        const l2 = this.data.frame, d2 = Nh(a2, l2), p2 = d2.width, u = d2.height;
        let f2 = n2.x, g2 = n2.y;
        e && 0 !== c2 ? (Rh(t4, e, d2, f2, g2), f2 = d2.width / p2, g2 = d2.height / u) : (d2.x *= r.x, d2.y *= r.y, d2.width *= n2.x, d2.height *= n2.y);
        const m2 = h2(f2, g2).clone(), _2 = m2.computeCoord(0, 0);
        m2.trans(d2.x - _2.x, d2.y - _2.y);
        const y2 = m2.inverse.computeCoord(d2.x + d2.width, d2.y + d2.height), x2 = new _e(0, 0, y2.x, y2.y);
        this.updateLayoutArgs(m2, x2, 0), o2.x = x2.width / this.m_sym.size.width, o2.y = x2.height / this.m_sym.size.height, this.layoutChilds(i, this.frame, o2);
    }
    layoutChilds(t4, e, i) {
        const s = this.getDataChilds(), r = /* @__PURE__ */ new Map();
        this.m_children.forEach((t5) => r.set(t5.data.id, t5));
        const n2 = this.getRootView();
        let o2 = false;
        for (let e2 = 0, a2 = s.length; e2 < a2; e2++) {
            const a3 = s[e2];
            this.layoutChild(a3, e2, i, t4, r, n2) && (o2 = true);
        }
        if (this.m_children.length > s.length) {
            const t5 = this.removeChilds(s.length, Number.MAX_VALUE);
            n2 ? n2.addDelayDestory(t5) : t5.forEach((t6) => t6.destory()), o2 = true;
        }
        o2 && this.notify("childs");
    }
    _findOV2(t4, e) {
        const i = this.data, s = bs("", t4, (this.varsContainer || []).concat(i));
        if (!s) return;
        const r = s[s.length - 1];
        return r && r.type === e ? r : void 0;
    }
    _findOV2All(t4, e) {
        const i = this.data;
        return Ms("", t4, (this.varsContainer || []).concat(i));
    }
    get contextSettings() {
        var _a2;
        const t4 = this._findOV2(Et.ContextSettings, jt.ContextSettings);
        return t4 ? t4.value : (_a2 = this.m_sym) == null ? void 0 : _a2.style.contextSettings;
    }
    getFills() {
        var _a2;
        const t4 = this._findOV2(Et.Fills, jt.Fills);
        return t4 ? t4.value : ((_a2 = this.m_sym) == null ? void 0 : _a2.style.fills) || [];
    }
    getBorders() {
        var _a2;
        const t4 = this._findOV2(Et.Borders, jt.Borders);
        return t4 ? t4.value : ((_a2 = this.m_sym) == null ? void 0 : _a2.style.borders) || [];
    }
    get startMarkerType() {
        var _a2;
        const t4 = this._findOV2(Et.StartMarkerType, jt.MarkerType);
        return t4 ? t4.value : (_a2 = this.m_sym) == null ? void 0 : _a2.style.startMarkerType;
    }
    get endMarkerType() {
        var _a2;
        const t4 = this._findOV2(Et.EndMarkerType, jt.MarkerType);
        return t4 ? t4.value : (_a2 = this.m_sym) == null ? void 0 : _a2.style.endMarkerType;
    }
    getShadows() {
        var _a2;
        const t4 = this._findOV2(Et.Shadows, jt.Shadows);
        return t4 ? t4.value : ((_a2 = this.m_sym) == null ? void 0 : _a2.style.shadows) || [];
    }
    get cornerRadius() {
        var _a2;
        const t4 = this._findOV2(Et.CornerRadius, jt.CornerRadius);
        return t4 ? t4.value : (_a2 = this.m_sym) == null ? void 0 : _a2.cornerRadius;
    }
    get prototypeInterActions() {
        const t4 = this._findOV2All(Et.ProtoInteractions, jt.ProtoInteractions);
        if (!t4) return this.inheritPrototypeInterActions;
        const e = new G();
        t4.reverse().forEach((t5) => {
            t5.value.slice(0).reverse().forEach((t6) => {
                e.find((e2) => e2.id === t6.id) || e.push(t6);
            });
        }), e.reverse();
        const i = e.filter((t5) => !!t5.isDeleted), s = this.inheritPrototypeInterActions || [], r = new G();
        return s.forEach((t5) => {
            if (t5.isDeleted) return;
            if (i.find((e2) => e2.id === t5.id)) return;
            const s2 = e.find((e2) => e2.id === t5.id);
            r.push(s2 || t5);
        }), e.forEach((t5) => {
            t5.isDeleted || s.find((e2) => e2.id === t5.id) || r.push(t5);
        }), r;
    }
    get inheritPrototypeInterActions() {
        var _a2, _b;
        return this.m_data.prototypeInteractions ? this.m_data.prototypeInteractions.slice(0).concat(...((_a2 = this.m_sym) == null ? void 0 : _a2.prototypeInteractions) || []) : (_b = this.m_sym) == null ? void 0 : _b.prototypeInteractions;
    }
}
function oc(t4) {
    switch (t4) {
        case 9:
        case 10:
        case 32:
            return true;
    }
    return false;
}
function ac(t4, e, i) {
    const s = p.text.getTextPath, { yOffset: r, xOffset: n2, paras: o2 } = t4, a2 = o2.length, h2 = new pi();
    for (let t5 = 0; t5 < a2; t5++) {
        const a3 = o2[t5];
        for (let t6 = 0, o3 = a3.length; t6 < o3; t6++) {
            const o4 = a3[t6], c2 = e + n2 + a3.xOffset + o4.x, l2 = i + r + a3.yOffset + o4.y;
            for (let t7 = 0, e2 = o4.length; t7 < e2; t7++) {
                const e3 = o4[t7], i2 = e3.attr, r2 = (i2 == null ? void 0 : i2.fontName) || "", n3 = (i2 == null ? void 0 : i2.fontSize) || 0, a4 = l2 + o4.lineHeight - (o4.lineHeight - o4.maxFontSize) / 2 - o4.actualBoundingBoxDescent, d2 = (i2 == null ? void 0 : i2.weight) || 400, p2 = !!(i2 == null ? void 0 : i2.italic);
                h2.push(...e3.map((t8) => {
                    if (oc(t8.char.charCodeAt(0))) return new pi();
                    const e4 = s(r2, n3, p2, d2, t8.char.charCodeAt(0)), i3 = new pi(e4);
                    return i3.translate(t8.x + c2, a4), i3;
                }));
            }
        }
    }
    return h2;
}
function hc(t4, e, i, s, r) {
    if (i === s - 1) {
        const i2 = e[e.length - 1];
        if (i2.color.equals(r)) {
            const e2 = t4[t4.length - 1], s2 = e2.x + e2.cw;
            return void (i2.end = s2);
        }
    }
    const n2 = t4[0], o2 = t4[t4.length - 1], a2 = n2.x, h2 = o2.x + o2.cw;
    e.push({ start: a2, end: h2, color: r });
}
function cc(t4, e, i, s, r) {
    for (let n2 = 0, o2 = s.length; n2 < o2; n2++) {
        const o3 = s[n2], a2 = "M" + (e + o3.start) + " " + i + " L" + (e + o3.end) + " " + i, h2 = { "fill-opacity": 1 };
        h2.d = a2, h2.fill = "none", h2.stroke = o3.color.toRGBA(), h2["stroke-width"] = 1, r.push(t4("path", h2));
    }
}
function lc(t4, e, i, s, r, n2) {
    for (let o2 = 0, a2 = r.length; o2 < a2; o2++) {
        const a3 = r[o2], h2 = "M" + (e + a3.start) + " " + i + " L" + (e + a3.end) + " " + i + " L" + (e + a3.end) + " " + (i + s) + " L " + (e + a3.start) + " " + (i + s) + "Z", c2 = { "fill-opacity": 1 };
        c2.d = h2, c2.fill = a3.color.toRGBA(), c2.stroke = "none", c2["stroke-width"] = 1, n2.push(t4("path", c2));
    }
}
const dc = {};
function pc(t4) {
    const e = [];
    let i = 0, s = 0, r = t4.length;
    for (; i < r; ++i) {
        const r2 = dc[t4[i]];
        r2 && (i > s && e.push(t4.substring(s, i)), e.push(r2), s = i + 1);
    }
    return e.length > 0 ? (i > s && e.push(t4.substring(s, i)), e.join("")) : t4;
}
function uc(t4, e, i, s) {
    const r = [], { xOffset: n2, yOffset: o2, paras: a2 } = e, h2 = a2.length;
    for (let l2 = 0; l2 < h2; l2++) {
        const h3 = a2[l2];
        for (let a3 = 0, l3 = h3.length; a3 < l3; a3++) {
            const l4 = h3[a3], d2 = l4.x + n2 + h3.xOffset, p2 = o2 + h3.yOffset + l4.y;
            let u = Number.NEGATIVE_INFINITY, f2 = Number.NEGATIVE_INFINITY, g2 = Number.NEGATIVE_INFINITY;
            const m2 = [], _2 = [], y2 = [], x2 = [];
            for (let r2 = 0, a4 = l4.length; r2 < a4; r2++) {
                const a5 = [], h4 = [], w3 = l4[r2], b3 = w3.attr, M2 = (b3 == null ? void 0 : b3.fontSize) || 0, v2 = p2 + l4.lineHeight - (l4.lineHeight - l4.maxFontSize) / 2 - l4.actualBoundingBoxDescent;
                for (let t5 = 0, e2 = w3.length; t5 < e2; t5++) {
                    const e3 = w3[t5];
                    oc(e3.char.charCodeAt(0)) || (a5.push(e3.char), h4.push(e3.x + d2));
                }
                const S2 = b3 == null ? void 0 : b3.fontName, C3 = { font: "normal " + M2 + "px " + S2, "alignment-baseline": "baseline" };
                if (b3) if (C3["font-weight"] = b3.weight || 400, b3.italic && (C3["font-style"] = "italic"), b3.gradient && b3.fillType === xt.Gradient && i) {
                    const e2 = $a(t4, b3.gradient, i), s2 = b3.gradient.gradientOpacity;
                    e2.node && x2.push(e2.node);
                    const r3 = e2.id;
                    C3.fill = "url(#" + r3 + ")", C3["fill-opacity"] = void 0 === s2 ? 1 : s2;
                } else b3.color && (C3.fill = b3.color.toRGBA());
                if (a5.length > 0) {
                    const r3 = pc(a5.join(""));
                    if (b3 && b3.gradient && b3.fillType === xt.Gradient && i) {
                        const s2 = $a(t4, b3.gradient, i);
                        if (s2.style) {
                            const i2 = b3.gradient.gradientOpacity, a6 = "clippath-fill-" + c(b3.gradient) + Ya(), l5 = t4("clipPath", { id: a6 }, [t4("text", { x: h4.join(" "), y: v2, style: C3, "clip-rule": "evenodd" }, r3)]);
                            x2.push(l5), x2.push(t4("foreignObject", { width: e.contentWidth, height: e.contentHeight, x: n2, y: o2, "clip-path": "url(#" + a6 + ")", opacity: void 0 === i2 ? 1 : i2 }, t4("div", { width: "100%", height: "100%", style: s2.style })));
                        } else x2.push(t4("text", { x: h4.join(" "), y: v2, style: C3 }, r3));
                    } else x2.push(t4("text", { x: h4.join(" "), y: v2, style: C3 }, r3));
                    if (s && s.isEnabled && s.type === ot.Background && b3 && fc(b3)) {
                        const i2 = "clip-blur-" + c(s) + Ya(), a6 = t4("clipPath", { id: i2 }, [t4("text", { x: h4.join(" "), y: v2, style: C3, "clip-rule": "evenodd" }, r3)]), l5 = t4("foreignObject", { width: e.contentWidth, height: e.contentHeight, x: n2, y: o2 }, t4("div", { style: { width: "100%", height: "100%", "backdrop-filter": `blur(${s.saturation / 2}px)`, "clip-path": "url(#" + i2 + ")" } })), d3 = t4("g", [a6, l5]);
                        x2.push(d3);
                    }
                }
                if (b3) {
                    const t5 = b3.color ?? Ga;
                    b3.underline && b3.underline !== Zt.None && (hc(w3, m2, u, r2, t5), u = r2), b3.strikethrough && b3.strikethrough !== Ht.None && (hc(w3, _2, f2, r2, t5), f2 = r2), b3.highlight && (hc(w3, y2, g2, r2, b3.highlight), g2 = r2);
                }
            }
            lc(t4, d2, p2, l4.lineHeight, y2, r), r.push(...x2);
            const w2 = p2 + l4.lineHeight / 2, b2 = p2 + l4.lineHeight;
            cc(t4, d2, w2, _2, r), cc(t4, d2, b2, m2, r);
        }
    }
    return r;
}
dc["<"] = "&lt;", dc[">"] = "&gt;", dc["&"] = "&amp;";
const fc = (t4) => (!t4.highlight || 1 !== t4.highlight.alpha) && !!(t4.color && t4.color.alpha > 0 && t4.color.alpha < 1);
class gc {
    constructor() {
        __publicField(this, "index", 0);
        __publicField(this, "before", false);
        __publicField(this, "placeholder", false);
        __publicField(this, "attr");
    }
}
function mc(t4, e, i) {
    var _a2, _b;
    const { xOffset: s, yOffset: r, paras: n2 } = t4, o2 = new gc();
    if (i < r) return o2;
    i -= r, e -= s;
    let a2 = 0, h2 = false;
    for (let t5 = 0, s2 = n2.length; t5 < s2; t5++) {
        const r2 = n2[t5], c2 = r2.yOffset + r2.paraHeight;
        if (i >= c2) {
            if (t5 >= s2 - 1) {
                a2 += r2.charCount;
                continue;
            }
            const e2 = n2[t5 + 1].yOffset;
            if (i >= e2) {
                a2 += r2.charCount;
                continue;
            }
            i -= e2 - c2;
        }
        i -= r2.yOffset, e -= r2.xOffset;
        for (let t6 = 0, s3 = r2.length; t6 < s3; t6++) {
            const s4 = r2[t6];
            if (!(i >= s4.y + s4.lineHeight)) {
                e -= s4.x;
                for (let t7 = 0, i2 = s4.length; t7 < i2; t7++) {
                    const r3 = s4[t7];
                    if (0 === r3.length) throw new Error("layout result error, graph array is empty");
                    const n3 = r3[r3.length - 1];
                    if (e >= n3.x + n3.cw) {
                        a2 += r3.charCount, t7 === i2 - 1 && ("\n" === n3.char ? a2-- : h2 = true);
                        continue;
                    }
                    let c3 = 0, l2 = r3.length - 1, d2 = Math.floor((c3 + l2) / 2);
                    for (; c3 < l2; ) {
                        const t8 = r3[d2];
                        e < t8.x + t8.cw ? l2 = d2 : c3 = d2 + 1, d2 = Math.floor((c3 + l2) / 2);
                    }
                    const p2 = r3[l2];
                    "\n" === p2.char || e > p2.x + p2.cw / 2 && l2++, t7 === i2 - 1 && l2 === r3.length && (h2 = true);
                    for (let t8 = 0; t8 < l2; ++t8) a2 += r3[t8].cc;
                    if (l2 < r3.length) ((_a2 = r3.attr) == null ? void 0 : _a2.placeholder) && (o2.placeholder = true, o2.attr = r3.attr);
                    else if (t7 < i2 - 1) {
                        const e2 = s4[t7 + 1];
                        ((_b = e2.attr) == null ? void 0 : _b.placeholder) && (o2.placeholder = true, o2.attr = e2.attr);
                    }
                    break;
                }
                break;
            }
            a2 += s4.charCount;
        }
        break;
    }
    return o2.index = a2, o2.before = h2, o2;
}
class _c {
    constructor() {
        __publicField(this, "cursorPoints", []);
        __publicField(this, "lineY", 0);
        __publicField(this, "lineHeight", 0);
        __publicField(this, "preLineY", 0);
        __publicField(this, "preLineHeight", 0);
        __publicField(this, "nextLineY", 0);
        __publicField(this, "nextLineHeight", 0);
        __publicField(this, "placeholder", false);
        __publicField(this, "attr");
    }
}
function yc(t4, e, i, s, r) {
    var _a2;
    const n2 = t4.paras, o2 = n2[e], a2 = o2[i], h2 = o2.length, c2 = n2.length, l2 = t4.yOffset + o2.yOffset + a2.y, d2 = a2[s], p2 = new _c();
    if (p2.lineY = l2, ((_a2 = d2.attr) == null ? void 0 : _a2.placeholder) && (p2.placeholder = true, p2.attr = d2.attr), p2.preLineY = l2, p2.nextLineY = l2 + a2.lineHeight, p2.lineHeight = a2.lineHeight, p2.cursorPoints.push(...r), i > 0) {
        const e2 = o2[i - 1], s2 = t4.yOffset + o2.yOffset + e2.y;
        p2.preLineHeight = e2.lineHeight, p2.preLineY = s2;
    } else if (e > 0) {
        const i2 = n2[e - 1], s2 = i2[i2.length - 1], r2 = t4.yOffset + i2.yOffset + s2.y;
        p2.preLineHeight = s2.lineHeight, p2.preLineY = r2;
    }
    if (i < h2 - 1) {
        const e2 = o2[i + 1], s2 = t4.yOffset + o2.yOffset + e2.y;
        p2.nextLineHeight = e2.lineHeight, p2.nextLineY = s2;
    } else if (e < c2 - 1) {
        const i2 = n2[e + 1], s2 = i2[0], r2 = t4.yOffset + i2.yOffset + s2.y;
        p2.nextLineHeight = s2.lineHeight, p2.nextLineY = r2;
    }
    return p2;
}
function xc(t4, e, i) {
    if (e < 0) return;
    const s = t4.paras;
    for (let r = 0, n2 = s.length; r < n2; r++) {
        const n3 = s[r];
        if (e < n3.charCount || i && e === n3.charCount) {
            for (let s2 = 0, o2 = n3.length; s2 < o2; s2++) {
                const o3 = n3[s2], a2 = t4.xOffset + n3.xOffset + o3.x, h2 = t4.yOffset + n3.yOffset + o3.y;
                if (i && e === o3.charCount) {
                    if (0 === o3.length) break;
                    const e2 = o3[o3.length - 1];
                    if (0 === e2.length) break;
                    const i2 = e2[e2.length - 1], n4 = h2 + o3.lineHeight - (o3.lineHeight - o3.maxFontSize) / 2, c2 = a2 + i2.x + i2.cw, l2 = n4 - o3.actualBoundingBoxDescent + Math.round(i2.ch * He), d2 = { x: c2, y: l2 - i2.ch }, p2 = { x: c2, y: l2 };
                    return yc(t4, r, s2, o3.length - 1, [d2, p2]);
                }
                if (!(e >= o3.charCount)) {
                    for (let i2 = 0, n4 = o3.length; i2 < n4; i2++) {
                        const n5 = o3[i2], c2 = n5.charCount;
                        if (e >= c2) {
                            e -= c2;
                            continue;
                        }
                        let l2, d2;
                        if (o3.charCount === o3.graphCount) l2 = n5[e], d2 = n5[e - 1];
                        else {
                            for (let t5 = 0, i3 = e; t5 < n5.length; ++t5) {
                                const e2 = n5[t5];
                                if (i3 <= 0) {
                                    l2 = e2;
                                    break;
                                }
                                d2 = e2, i3 -= e2.cc;
                            }
                            if (!l2) throw new Error();
                        }
                        let p2 = a2 + l2.x;
                        const u = h2 + o3.lineHeight - (o3.lineHeight - o3.maxFontSize) / 2;
                        let f2 = l2;
                        if (e > 0) {
                            if (!d2) throw new Error();
                            p2 = qr(l2.char.charCodeAt(0)) ? a2 + d2.x + d2.cw : a2 + (d2.x + d2.cw + l2.x) / 2, f2 = d2;
                        } else if (i2 > 0) {
                            const t5 = o3[i2 - 1], e2 = t5[t5.length - 1];
                            p2 = qr(l2.char.charCodeAt(0)) ? a2 + e2.x + e2.cw : a2 + (e2.x + e2.cw + l2.x) / 2, f2 = e2;
                        }
                        const g2 = u - o3.actualBoundingBoxDescent + Math.round(f2.ch * He);
                        return yc(t4, r, s2, i2, [{ x: p2, y: g2 - f2.ch }, { x: p2, y: g2 }]);
                    }
                    break;
                }
                e -= o3.charCount;
            }
            break;
        }
        e -= n3.charCount;
    }
}
function wc(t4, e, i, s, r, n2) {
    const o2 = [], a2 = t4.paras;
    for (; n2 > 0 && e < a2.length; ) {
        const h2 = a2[e], c2 = h2[i];
        if (0 === s && 0 === r && c2.charCount <= n2) {
            const s2 = t4.yOffset + h2.yOffset + c2.y, r2 = c2.lineHeight, a3 = c2[0], l3 = c2[c2.length - 1], d3 = a3[0], p3 = l3[l3.length - 1], u2 = t4.xOffset + d3.x + c2.x + h2.xOffset, f3 = p3.x + p3.cw - d3.x;
            o2.push({ x: u2, y: s2 }, { x: u2 + f3, y: s2 }, { x: u2 + f3, y: s2 + r2 }, { x: u2, y: s2 + r2 }), n2 -= c2.charCount, ++i >= h2.length && (e++, i = 0);
            continue;
        }
        const l2 = c2[s];
        let d2, p2 = 0;
        if (c2.charCount === c2.graphCount) d2 = l2[r], p2 = r;
        else {
            for (let t5 = 0, e2 = r; t5 < l2.length && (d2 = l2[t5], p2 = t5, !(e2 <= 0)); ++t5) e2 -= d2.cc;
            if (!d2) throw new Error();
        }
        const u = t4.xOffset + h2.xOffset + c2.x, f2 = t4.yOffset + h2.yOffset + c2.y, g2 = u + d2.x, m2 = f2, _2 = f2 + c2.lineHeight;
        let y2 = u + d2.x + d2.cw;
        for (let t5 = s, e2 = c2.length; t5 < e2 && n2 > 0; t5++) {
            const e3 = c2[t5];
            let i2;
            for (let t6 = p2; t6 < e3.length && (i2 = e3[t6], !((n2 -= i2.cc) <= 0)); ++t6) ;
            if (!i2) throw new Error();
            y2 = u + i2.x + i2.cw, p2 = 0;
        }
        o2.push({ x: g2, y: m2 }, { x: y2, y: m2 }, { x: y2, y: _2 }, { x: g2, y: _2 }), r = 0, s = 0, ++i >= h2.length && (e++, i = 0);
    }
    return o2;
}
function bc(t4, e, i) {
    if (i < e) {
        const t5 = e;
        e = i, i = t5;
    }
    if (e < 0 && (e = 0), i <= e) return [];
    const s = i - e, r = t4.paras;
    for (let i2 = 0, n2 = r.length; i2 < n2; i2++) {
        const n3 = r[i2];
        if (!(e >= n3.charCount)) {
            for (let r2 = 0, o2 = n3.length; r2 < o2; r2++) {
                const o3 = n3[r2];
                if (!(e >= o3.charCount)) {
                    for (let n4 = 0, a2 = o3.length; n4 < a2; n4++) {
                        const a3 = o3[n4].charCount;
                        if (!(e >= a3)) return wc(t4, i2, r2, n4, e, s);
                        e -= a3;
                    }
                    break;
                }
                e -= o3.charCount;
            }
            break;
        }
        e -= n3.charCount;
    }
    return [];
}
function Mc(t4, e) {
    const i = t4.paras;
    for (let t5 = 0, s = i.length; t5 < s; t5++) {
        const s2 = i[t5];
        if (e < s2.charCount) {
            for (let t6 = 0, i2 = s2.length; t6 < i2; t6++) {
                const i3 = s2[t6];
                if (!(e >= i3.charCount)) {
                    for (let t7 = 0, s3 = i3.length; t7 < s3; t7++) {
                        const s4 = i3[t7], r = s4.charCount;
                        if (e >= r) {
                            e -= r;
                            continue;
                        }
                        let n2, o2 = 0;
                        if (i3.charCount === i3.graphCount) n2 = s4[e];
                        else {
                            for (let t8 = 0, i4 = e; t8 < s4.length && (n2 = s4[t8], o2 = i4, i4 -= n2.cc, !(i4 < 0)); ++t8) ;
                            if (!n2) throw new Error();
                        }
                        return { graph: n2, offset: o2 };
                    }
                    break;
                }
                e -= i3.charCount;
            }
            break;
        }
        e -= s2.charCount;
    }
}
function vc(t4, e) {
    if (e <= 1) return 0;
    const i = Mc(t4, e - 1);
    return i ? Math.max(0, e - 1 - i.offset) : e;
}
function Sc(t4, e) {
    if (e < 0) return 0;
    const i = Mc(t4, e);
    return i ? e - i.offset + i.graph.cc : e;
}
class Cc extends Vh {
    constructor(t4, e, i) {
        super(t4, e);
        __publicField(this, "m_imgPH");
        __publicField(this, "m_index");
        __publicField(this, "m_layout");
        __publicField(this, "m_textpath");
        __publicField(this, "__layoutToken");
        __publicField(this, "__preText");
        this.m_imgPH = i;
        const s = e.frame;
        this.m_transform.m02 = s.x, this.m_transform.m12 = s.y, this.m_frame.width = s.width, this.m_frame.height = s.height, this.m_index = e.index;
    }
    onMounted() {
    }
    get data() {
        return this.m_data;
    }
    get index() {
        return this.m_index;
    }
    layout(t4) {
        if (this.m_ctx.removeReLayout(this), !t4) return;
        if (t4.data.id !== this.m_data.id) throw new Error("id not match");
        c(t4.data) !== c(this.m_data) && this.setData(t4.data);
        const e = t4.frame;
        this.m_transform.m02 === e.x && this.m_transform.m12 === e.y && this.frame.width === e.width && this.frame.height === e.height || (this.m_transform.m02 = e.x, this.m_transform.m12 = e.y, this.m_frame.width = e.width, this.m_frame.height = e.height, this.m_textpath = void 0, this.m_layout = void 0, this.m_path = void 0, this.m_pathstr = void 0, this.m_ctx.setDirty(this));
        const i = t4.index;
        i.col === this.m_index.col && i.row === this.m_index.row || (this.m_index = i);
    }
    getText() {
        const t4 = this.m_data.text;
        if (t4) return t4;
        return ia(this.parent.data.textAttr);
    }
    get text() {
        return this.getText();
    }
    get cellType() {
        return this.data.cellType;
    }
    get rowSpan() {
        return this.data.rowSpan;
    }
    get colSpan() {
        return this.data.colSpan;
    }
    get imageRef() {
        return this.data.imageRef;
    }
    getLayout() {
        const t4 = this.getText();
        this.__preText !== t4 && this.__layoutToken && this.__preText && this.__preText.dropLayout(this.__layoutToken, this.id);
        const e = this.frame, i = t4.getLayout3(e, this.id, this.__layoutToken);
        return this.__layoutToken = i.token, this.__preText = t4, this.m_layout !== i.layout && (this.m_textpath = void 0), this.m_layout = i.layout, i.layout;
    }
    locateText(t4, e) {
        return mc(this.getLayout(), t4, e);
    }
    locateRange(t4, e) {
        return bc(this.getLayout(), t4, e);
    }
    locateCursor(t4, e) {
        return xc(this.getLayout(), t4, e);
    }
    locatePrevCursor(t4) {
        return vc(this.getLayout(), t4);
    }
    locateNextCursor(t4) {
        return Sc(this.getLayout(), t4);
    }
    get masked() {
    }
    getTextPath() {
        return this.m_textpath || (this.m_textpath = ac(this.getLayout(), 0, 0)), this.m_textpath;
    }
    get isVisible() {
        return true;
    }
    onDataChange(...t4) {
        var _a2;
        super.onDataChange(...t4), (t4.includes("text") || this.data.cellType !== Wt.Text) && (this.m_layout = void 0, this.m_textpath = void 0), this.renderContents(), (_a2 = this.parent) == null ? void 0 : _a2.bubblewatcher(...t4);
    }
    renderBorders() {
        return [];
    }
    renderContents() {
        const t4 = this.m_data, e = t4.cellType ?? Wt.None;
        if (e === Wt.None) return [];
        const i = this.frame;
        if (e === Wt.Image) {
            return [Da("image", { "xlink:href": t4.peekImage(true) ?? this.m_imgPH, width: i.width, height: i.height, x: 0, y: 0, preserveAspectRatio: "xMidYMid meet" })];
        }
        if (e === Wt.Text) {
            return uc(Da, this.getLayout(), i, this.blur);
        }
        return [];
    }
    onDestory() {
        super.onDestory(), this.__layoutToken && this.__preText && this.__preText.dropLayout(this.__layoutToken, this.id);
    }
    asyncRender() {
        return this.render();
    }
    render() {
        var _a2;
        if (!this.checkAndResetDirty()) return this.m_render_version;
        if (!this.isVisible) return this.reset("g"), ++this.m_render_version;
        const t4 = this.renderFills(), e = this.renderBorders(), i = this.renderContents(), s = `${c(this)}`, r = this.renderShadows(s), n2 = `blur_${c(this)}`, o2 = this.renderBlur(n2);
        let a2 = this.renderProps(), h2 = [...t4, ...i, ...e];
        if (r.length) {
            let t5 = "";
            const e2 = bh(s, this.getShadows());
            t5 = `url(#pd_outer-${s}) `, e2.length && (t5 += e2.join(" ")), h2 = [...r, Da("g", { filter: t5 }, h2)];
        }
        if (o2.length) {
            let t5 = "";
            ((_a2 = this.blur) == null ? void 0 : _a2.type) === ot.Gaussian && (t5 = `url(#${n2})`), h2 = [...o2, Da("g", { filter: t5 }, h2)];
        }
        return this.reset("g", a2, h2), ++this.m_render_version;
    }
}
class Tc extends Vh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "m_cells", /* @__PURE__ */ new Map());
        __publicField(this, "m_layout");
        __publicField(this, "m_savewidth", 0);
        __publicField(this, "m_saveheight", 0);
        this.updateChildren();
    }
    get data() {
        return this.m_data;
    }
    get cells() {
        return this.m_cells;
    }
    bubblewatcher(...t4) {
        t4.includes("text") || ((t4.includes("rowSpan") || t4.includes("colSpan")) && (this.m_layout = void 0), this.updateChildren(), this.m_ctx.setDirty(this));
    }
    getDataChilds() {
        return [];
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), (t4.includes("rowHeights") || t4.includes("colWidths") || t4.includes("variables")) && (this.m_layout = void 0);
    }
    get naviChilds() {
    }
    _layout(t4, e, i, s) {
        super._layout(t4, e, i, s), this.updateChildren();
    }
    _getCellAt2(t4, e) {
        if (t4 < 0 || e < 0 || t4 >= this.rowCount || e >= this.colCount) throw new Error("cell index outof range: " + t4 + " " + e);
        const i = this.rowHeights[t4].id + "," + this.colWidths[e].id, s = bs(this.data.id + "/" + i, Et.TableCell, this.varsContainer || []);
        return s && s.length > 0 ? s[s.length - 1].value : this.data.cells.get(i);
    }
    _getCellAt(t4, e) {
        if (t4 < 0 || e < 0 || t4 >= this.rowCount || e >= this.colCount) throw new Error("cell index outof range: " + t4 + " " + e);
        const i = this.rowHeights[t4].id + "," + this.colWidths[e].id, s = bs(this.data.id + "/" + i, Et.TableCell, this.varsContainer || []);
        if (s && s.length > 0) return s[s.length - 1].value;
        let r = this.data.cells.get(i);
        return r || (r = new ka(new G(), i, "", Vt.TableCell, new Ii(), new is(new G(), new G(), new G()), Wt.Text, ia(this.data.textAttr)), r);
    }
    getLayout() {
        const t4 = this.frame;
        return this.m_layout && this.m_saveheight === t4.height && this.m_savewidth === t4.width || (this.m_layout = function(t5, e, i) {
            const s = new Rr(t5.rowHeights.length, t5.colWidths.length), r = e.width, n2 = e.height, o2 = t5.rowHeights, a2 = t5.rowHeights.reduce((t6, e2) => t6 + e2.value, 0), h2 = t5.colWidths, c2 = t5.colWidths.reduce((t6, e2) => t6 + e2.value, 0);
            let l2 = 0;
            for (let t6 = 0, e2 = o2.length, d2 = 0; t6 < e2; ++t6) {
                const p2 = o2[t6].value / a2 * n2;
                for (let p3 = 0, u = h2.length, f2 = 0; p3 < u; ++p3, ++l2) {
                    const l3 = i(t6, p3), g2 = !s.get(t6, p3), m2 = h2[p3].value / c2 * r;
                    if (!g2) {
                        f2 += m2;
                        continue;
                    }
                    const _2 = { index: { row: t6, col: p3 }, span: { row: 1, col: 1 }, frame: new _e(f2, d2, 0, 0) }, y2 = Math.min((l3 == null ? void 0 : l3.rowSpan) || 1, e2 - t6);
                    let x2 = Math.min((l3 == null ? void 0 : l3.colSpan) || 1, u - p3);
                    for (; ; ) {
                        for (let e3 = p3 + 1, i2 = p3 + x2; e3 < i2; ++e3) if (s.get(t6, e3)) {
                            x2 = e3 - p3;
                            break;
                        }
                        break;
                    }
                    _2.span.row = y2, _2.span.col = x2;
                    let w2 = 0, b2 = 0;
                    for (let e3 = t6, i2 = t6 + y2; e3 < i2; ++e3) {
                        const t7 = o2[e3].value / a2 * n2;
                        let i3 = 0;
                        for (let t8 = p3, n3 = p3 + x2; t8 < n3; ++t8) s.set(e3, t8, _2), 0 === w2 && (i3 += h2[t8].value / c2 * r);
                        0 === w2 && (w2 = i3), b2 += t7;
                    }
                    _2.frame.width = w2, _2.frame.height = b2, f2 += m2;
                }
                d2 += p2;
            }
            return { grid: s, width: r, height: n2, rowHeights: o2.map((t6) => t6.value / a2 * n2), colWidths: h2.map((t6) => t6.value / c2 * r) };
        }(this.data, t4, (t5, e) => this._getCellAt(t5, e)), this.m_saveheight = t4.height, this.m_savewidth = t4.width), this.m_layout;
    }
    updateChildren() {
        const t4 = /* @__PURE__ */ new Map();
        this.m_children.forEach((e2) => {
            t4.set(e2.m_data.id, e2);
        });
        const e = this.m_ctx.comsMap, i = this.getLayout();
        let s = 0;
        for (let r = 0, n2 = i.grid.rowCount; r < n2; ++r) for (let n3 = 0, o2 = i.grid.colCount; n3 < o2; ++n3) {
            const o3 = i.grid.get(r, n3), a2 = o3.index.row, h2 = o3.index.col;
            if (a2 !== r || h2 !== n3) continue;
            const c2 = this.rowHeights[a2].id + "," + this.colWidths[h2].id, l2 = t4.get(c2), d2 = { data: l2 == null ? void 0 : l2.data, scale: this.m_scale, varsContainer: this.varsContainer, frame: o3.frame, isVirtual: this.m_isVirtual, index: o3.index };
            if (l2) {
                const e2 = this._getCellAt2(a2, h2);
                e2 && (d2.data = e2), t4.delete(c2), this.moveChild(l2, s), l2.layout(d2);
            } else {
                const t5 = this._getCellAt(a2, h2);
                d2.data = t5;
                const i2 = new (e.get(t5.type) || e.get(Vt.Rectangle))(this.m_ctx, d2);
                this.addChild(i2, s), this.m_cells.set(i2.id, i2);
            }
            ++s;
        }
        this.m_children.length > s && this.removeChilds(s, this.m_children.length - s).forEach((t5) => {
            this.m_cells.delete(t5.id), t5.destory();
        });
    }
    renderBorders() {
        const t4 = this.m_data, e = this.getLayout(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), r = (t5, e2, i2, s2, r2) => {
            if (0 != s2.length) {
                for (let n3 = 0; n3 < s2.length && t5[r2] < e2[r2]; ++n3) {
                    const o3 = s2[n3];
                    if (t5[r2] < o3.to[r2] && e2[r2] > o3.from[r2]) if (t5[r2] < o3.from[r2]) s2.splice(n3, 0, { from: { x: t5.x, y: t5.y }, to: { x: o3.from.x, y: o3.from.y }, style: i2 }), t5[r2] = o3.from[r2];
                    else {
                        if (t5[r2] === o3.from[r2]) {
                            if (e2[r2] >= o3.to[r2]) {
                                o3.style = i2, t5[r2] = o3.to[r2];
                                continue;
                            }
                            return o3.from[r2] = e2[r2], void s2.splice(n3, 0, { from: t5, to: e2, style: i2 });
                        }
                        if (!(e2[r2] >= o3.to[r2])) return s2.splice(n3 + 1, 0, { from: { x: e2.x, y: e2.y }, to: { x: o3.to.x, y: o3.to.y }, style: o3.style }), s2.splice(n3 + 1, 0, { from: t5, to: e2, style: i2 }), void (o3.to[r2] = t5[r2]);
                        s2.splice(n3 + 1, 0, { from: { x: t5.x, y: t5.y }, to: { x: o3.to.x, y: o3.to.y }, style: i2 }), o3.to[r2] = t5[r2];
                    }
                    else if (t5[r2] < o3.from[r2]) return void s2.splice(n3, 0, { from: t5, to: e2, style: i2 });
                }
                t5[r2] < e2[r2] && s2.push({ from: t5, to: e2, style: i2 });
            } else s2.push({ from: t5, to: e2, style: i2 });
        }, n2 = (t5, e2, i2, s2) => {
            r(t5, e2, i2, s2, "x");
        }, o2 = (t5, e2, i2, s2) => {
            r(t5, e2, i2, s2, "y");
        }, a2 = (t5, e2) => {
            {
                const i2 = { x: t5.x, y: t5.y }, r2 = { x: t5.x, y: t5.y + t5.height };
                let n3 = s.get(i2.x);
                n3 || (n3 = [], s.set(i2.x, n3)), o2(i2, r2, e2, n3);
            }
            {
                const s2 = { x: t5.x, y: t5.y }, r2 = { x: t5.x + t5.width, y: t5.y };
                let o3 = i.get(s2.y);
                o3 || (o3 = [], i.set(s2.y, o3)), n2(s2, r2, e2, o3);
            }
            {
                const i2 = { x: t5.x + t5.width, y: t5.y }, r2 = { x: i2.x, y: t5.y + t5.height };
                let n3 = s.get(i2.x);
                n3 || (n3 = [], s.set(i2.x, n3)), o2(i2, r2, e2, n3);
            }
            {
                const s2 = { x: t5.x, y: t5.y + t5.height }, r2 = { x: t5.x + t5.width, y: s2.y };
                let o3 = i.get(s2.y);
                o3 || (o3 = [], i.set(s2.y, o3)), n2(s2, r2, e2, o3);
            }
        }, h2 = [];
        for (let i2 = 0, s2 = e.grid.rowCount; i2 < s2; ++i2) for (let s3 = 0, r2 = e.grid.colCount; s3 < r2; ++s3) {
            const r3 = e.grid.get(i2, s3);
            if (r3.index.row !== i2 || r3.index.col !== s3) continue;
            const n3 = this._getCellAt2(r3.index.row, r3.index.col), o3 = r3.frame;
            n3 && n3.style.borders.length > 0 ? h2.push({ frame: o3, style: n3.style }) : a2(o3, t4.style);
        }
        h2.forEach((t5) => a2(t5.frame, t5.style));
        const c2 = [], l2 = (e2, i2) => {
            for (let s2 = 0, r2 = e2.length; s2 < r2; ++s2) {
                const n3 = e2[s2], o3 = n3.from, a3 = n3.to, h3 = n3.style;
                for (; s2 < r2 - 1; ) {
                    const t5 = e2[s2 + 1];
                    if (t5.style !== h3) break;
                    if (a3[i2] !== t5.from[i2]) break;
                    a3.x = t5.to.x, a3.y = t5.to.y, ++s2;
                }
                const l3 = "M" + o3.x + " " + o3.y + " L" + a3.x + " " + a3.y;
                c2.push(...Jh(Da, h3, h3.borders, void 0, void 0, l3, t4));
            }
        };
        for (let [t5, e2] of s) l2(e2, "y");
        for (let [t5, e2] of i) l2(e2, "x");
        return c2;
    }
    _getVisibleCells(t4, e, i, s) {
        return function(t5, e2, i2, s2, r, n2, o2) {
            const a2 = [], h2 = /* @__PURE__ */ new Set(), c2 = i2.grid;
            for (let t6 = s2, i3 = c2.rowCount; t6 < i3 && t6 <= r; ++t6) for (let i4 = n2, s3 = c2.colCount; i4 < s3 && i4 <= o2; ++i4) {
                const s4 = c2.get(t6, i4), r2 = e2(s4.index.row, s4.index.col);
                if (r2) {
                    if (h2.has(r2.id)) continue;
                    a2.push({ cell: r2, rowIdx: s4.index.row, colIdx: s4.index.col }), h2.add(r2.id);
                } else a2.push({ cell: void 0, rowIdx: s4.index.row, colIdx: s4.index.col });
            }
            return a2;
        }(this.data, (t5, e2) => this._getCellAt(t5, e2), this.getLayout(), t4, e, i, s);
    }
    getVisibleCells(t4, e, i, s) {
        return this._getVisibleCells(t4, e, i, s).map((t5) => ({ cell: t5.cell ? this.cells.get(Ba(t5.cell.id, this.varsContainer)) : void 0, rowIdx: t5.rowIdx, colIdx: t5.colIdx }));
    }
    _getCells(t4, e, i, s) {
        return function(t5, e2, i2, s2, r, n2) {
            const o2 = t5.rowHeights, a2 = t5.colWidths;
            let h2 = 0;
            const c2 = [];
            h2 += i2 * a2.length;
            for (let t6 = i2, l2 = o2.length; t6 < l2 && t6 <= s2; ++t6) {
                h2 += r;
                for (let i3 = r, s3 = a2.length; i3 < s3 && i3 <= n2; ++i3, ++h2) {
                    const s4 = e2(t6, i3);
                    c2.push({ cell: s4, rowIdx: t6, colIdx: i3 });
                }
                h2 += a2.length - n2 - 1;
            }
            return c2;
        }(this.data, (t5, e2) => this._getCellAt(t5, e2), t4, e, i, s);
    }
    getCells(t4, e, i, s) {
        return this._getCells(t4, e, i, s).map((t5) => ({ cell: t5.cell ? this.cells.get(Ba(t5.cell.id, this.varsContainer)) : void 0, rowIdx: t5.rowIdx, colIdx: t5.colIdx }));
    }
    get heightTotalWeights() {
        return this.rowHeights.reduce((t4, e) => t4 + e.value, 0);
    }
    get widthTotalWeights() {
        return this.colWidths.reduce((t4, e) => t4 + e.value, 0);
    }
    get rowCount() {
        return this.data.rowCount;
    }
    get colCount() {
        return this.data.colCount;
    }
    get rowHeights() {
        return this.data.rowHeights;
    }
    get colWidths() {
        return this.data.colWidths;
    }
    getCellAt(t4, e) {
        if (t4 < 0 || e < 0 || t4 >= this.rowCount || e >= this.colCount) throw new Error("cell index outof range: " + t4 + " " + e);
        const i = Ba(this.rowHeights[t4].id + "," + this.colWidths[e].id, this.varsContainer);
        return this.cells.get(i);
    }
    locateCell(t4, e) {
        const i = function(t5, e2, i2) {
            let s = 0;
            for (let r = 0, n2 = t5.rowHeights.length; r < n2; ++r) {
                if (s += t5.rowHeights[r], i2 > s) continue;
                let n3 = 0;
                for (let i3 = 0, s2 = t5.colWidths.length; i3 < s2; ++i3) if (n3 += t5.colWidths[i3], !(e2 > n3)) return t5.grid.get(r, i3);
                break;
            }
        }(this.getLayout(), t4, e);
        if (i) {
            const t5 = this.getCellAt(i.index.row, i.index.col);
            t5 && (i.cell = t5);
        }
        return i;
    }
    locateCellIndex(t4, e) {
        return function(t5, e2, i) {
            let s = 0;
            for (let r = 0, n2 = t5.rowHeights.length; r < n2; ++r) {
                if (s += t5.rowHeights[r], i > s) continue;
                let n3 = 0;
                for (let i2 = 0, s2 = t5.colWidths.length; i2 < s2; ++i2) if (n3 += t5.colWidths[i2], !(e2 > n3)) return { row: r, col: i2 };
                break;
            }
        }(this.getLayout(), t4, e);
    }
    _indexOfCell2(t4) {
        const e = t4.id.split(",");
        if (2 !== e.length) throw new Error("cell index error");
        const i = this.rowHeights.findIndex((t5) => t5.id === e[0]), s = this.colWidths.findIndex((t5) => t5.id === e[1]);
        if (!(i < 0 || s < 0)) return { rowIdx: i, colIdx: s };
    }
    _indexOfCell(t4) {
        const e = this._indexOfCell2(t4);
        if (!e) return;
        const { rowIdx: i, colIdx: s } = e, r = this.getLayout().grid.get(i, s);
        return { rowIdx: i, colIdx: s, visible: r.index.row === i && r.index.col === s };
    }
    indexOfCell(t4) {
        return t4 instanceof Cc ? this._indexOfCell(t4.data) : this._indexOfCell(t4);
    }
}
class Ic extends Vh {
    constructor() {
        super(...arguments);
        __publicField(this, "__str");
        __publicField(this, "__strText");
        __publicField(this, "m_layout");
        __publicField(this, "m_textpath");
        __publicField(this, "__layoutToken");
        __publicField(this, "__preText");
        __publicField(this, "__origin_frame", new ye());
    }
    getText() {
        const t4 = this._findOV(Et.Text, jt.Text);
        if (t4 && "string" == typeof t4.value) {
            if (this.__str === t4.value) return this.__strText;
            this.__str = t4.value;
            const e2 = t4.value.split("\n"), i = this.m_data.text;
            this.__strText = new Ia(new G()), i.attr && Qo(this.__strText, i.attr);
            const s = i.paras[0], r = s.spans[0];
            for (let t5 = 0; t5 < e2.length; ++t5) {
                let i2 = e2[t5];
                i2.endsWith("\n") || (i2 += "\n");
                const n2 = new Ta(i2, new G());
                n2.spans.push(new Ca(n2.length)), Ko(n2, s), jo(n2.spans[0], r), this.__strText.paras.push(n2);
            }
            return this.__strText;
        }
        const e = t4 ? t4.value : this.m_data.text;
        if ("string" == typeof e) throw new Error("");
        return e;
    }
    get data() {
        return this.m_data;
    }
    get text() {
        return this.getText();
    }
    getLayout() {
        const t4 = this.getText();
        this.__preText && this.__layoutToken && c(this.__preText) !== c(t4) && this.__preText.dropLayout(this.__layoutToken, this.id);
        const e = this.__origin_frame, i = t4.getLayout3(e, this.id, this.__layoutToken);
        return this.__layoutToken = i.token, this.m_layout !== i.layout && (this.m_textpath = void 0), this.m_layout = i.layout, this.isVirtualShape && this.__preText !== t4 && this.updateFrameByLayout(e), this.__preText = t4, i.layout;
    }
    locateText(t4, e) {
        return mc(this.getLayout(), t4, e);
    }
    locateRange(t4, e) {
        return bc(this.getLayout(), t4, e);
    }
    locateCursor(t4, e) {
        return xc(this.getLayout(), t4, e);
    }
    locatePrevCursor(t4) {
        return vc(this.getLayout(), t4);
    }
    locateNextCursor(t4) {
        return Sc(this.getLayout(), t4);
    }
    getTextPath() {
        return this.m_textpath || (this.m_textpath = ac(this.getLayout(), 0, 0)), this.m_textpath;
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), this.m_textpath = void 0;
    }
    asyncRender() {
        return this.render();
    }
    renderContents() {
        return uc(Da, this.getLayout(), this.frame, this.blur);
    }
    forceUpdateOriginFrame() {
        const t4 = this.data.size;
        this.__origin_frame.width = t4.width, this.__origin_frame.height = t4.height;
    }
    updateLayoutArgs(t4, e, i) {
        super.updateLayoutArgs(t4, e, i), this.__origin_frame.width = e.width, this.__origin_frame.height = e.height, this.getLayout(), this.updateFrameByLayout(e);
    }
    updateFrameByLayout(t4) {
        var _a2;
        if (!this.isVirtualShape || !this.m_layout) return;
        const e = this.getText();
        ((_a2 = e.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible;
        $t.Flexible;
    }
    bleach(t4) {
        var _a2, _b;
        if (t4.elattr.fill && (t4.elattr.fill = "#FFF"), t4.elattr.stroke && (t4.elattr.stroke = "#FFF"), "text" === t4.eltag && ((_a2 = t4.elattr) == null ? void 0 : _a2.style).fill && (((_b = t4.elattr) == null ? void 0 : _b.style).fill = "#FFF"), "feColorMatrix" === t4.eltag && t4.elattr.result) {
            let e = t4.elattr.values;
            e && (e = e.split(" ")), e[3] && (e[3] = 1), e[8] && (e[8] = 1), e[13] && (e[13] = 1), t4.elattr.values = e.join(" ");
        }
        Array.isArray(t4.elchilds) && t4.elchilds.forEach((t5) => this.bleach(t5));
    }
    onDestory() {
        super.onDestory(), this.__layoutToken && this.__preText && this.__preText.dropLayout(this.__layoutToken, this.id);
    }
}
class kc extends Kh {
    get data() {
        return this.m_data;
    }
    render() {
        if (!this.checkAndResetDirty()) return this.m_render_version;
        if (!this.isVisible) return this.reset("g"), ++this.m_render_version;
        const t4 = this.renderBorders();
        let e = this.renderProps(), i = [...t4];
        return this.reset("g", e, i), ++this.m_render_version;
    }
}
function Ec(t4) {
    const e = t4.getPathStr(), i = t4.m_data.getPath().toString();
    e !== i && console.error(`path not match: ${e} vs ${i}`, t4.name), t4.m_children.forEach((t5) => Ec(t5));
}
class Ac extends Dh {
    constructor(t4, e) {
        super(t4, e);
        __publicField(this, "m_views", /* @__PURE__ */ new Map());
        __publicField(this, "m_artboards", /* @__PURE__ */ new Map());
        __publicField(this, "m_cutouts", /* @__PURE__ */ new Map());
        __publicField(this, "m_delaydestorys", /* @__PURE__ */ new Map());
        this.onMounted();
        t4.on("nextTick", () => {
            this.m_delaydestorys.forEach((t5) => {
                t5.parent || t5.destory();
            }), this.m_delaydestorys.clear();
        });
    }
    onAddView(t4) {
        const e = (t5) => {
            this.m_views.set(t5.id, t5), t5 instanceof Hh && this.m_artboards.set(t5.id, t5), t5 instanceof kc && this.m_cutouts.set(t5.id, t5), t5.m_children.forEach((t6) => e(t6));
        };
        Array.isArray(t4) ? t4.forEach(e) : e(t4);
    }
    onRemoveView(t4, e) {
        const i = (t5, e2) => {
            var _a2;
            const s = this.m_views.get(e2.id);
            s && ((_a2 = s.parent) == null ? void 0 : _a2.id) !== t5.id || (this.m_views.delete(e2.id), e2 instanceof Hh && this.m_artboards.delete(e2.id), e2 instanceof kc && this.m_cutouts.delete(e2.id), e2.m_children.forEach((t6) => i(e2, t6)));
        };
        Array.isArray(e) ? e.forEach((e2) => i(t4, e2)) : i(t4, e);
    }
    getView(t4) {
        return this.m_views.get(t4) || this.m_delaydestorys.get(t4);
    }
    addDelayDestory(t4) {
        const e = (t5) => {
            if (t5.parent) throw new Error("view has parent, not removed?");
            this.m_delaydestorys.set(t5.id, t5);
        };
        Array.isArray(t4) ? t4.forEach(e) : e(t4);
    }
    get isRootView() {
        return true;
    }
    get data() {
        return this.m_data;
    }
    get shapes() {
        return this.m_views;
    }
    get artboardList() {
        return Array.from(this.m_artboards.values());
    }
    get cutoutList() {
        return Array.from(this.m_cutouts.values());
    }
    getShape(t4) {
        return this.m_views.get(t4);
    }
    get guides() {
        return this.m_data.guides;
    }
    renderProps() {
        return { version: "1.1", xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", "xmlns:xhtml": "http://www.w3.org/1999/xhtml", preserveAspectRatio: "xMinYMin meet", overflow: "visible" };
    }
    render() {
        const t4 = super.render();
        return t4 && (this.eltag = "svg"), t4;
    }
    dbgCheckPath() {
        Ec(this);
    }
    get backgroundColor() {
        return this.data.backgroundColor;
    }
}
function Fc(t4) {
    if (0 === t4.length) return;
    const e = /* @__PURE__ */ new Map();
    t4.forEach((t5) => {
        const i2 = t5.data;
        let s2 = e.get(c(i2));
        if (s2) return void (s2.needupdate = true);
        s2 = { view: i2, childs: [], needupdate: true, parent: void 0, visited: false }, e.set(c(i2), s2);
        let r = s2, n2 = i2.parent;
        for (; n2; ) {
            let t6 = e.get(c(n2));
            t6 || (t6 = { view: n2, childs: [], needupdate: false, parent: void 0, visited: false }, e.set(c(n2), t6)), t6.childs.push(r), r.parent = t6, r = t6, n2 = n2.parent;
        }
    });
    const i = (t5, e2) => {
        const i2 = [t5];
        let s2 = i2[i2.length - 1];
        for (; s2; ) s2.visited || 0 === s2.childs.length ? (e2(s2), i2.pop()) : (s2.visited = true, i2.push(...s2.childs)), s2 = i2[i2.length - 1];
    }, s = [];
    for (let t5 of e.values()) t5.parent || s.push(t5);
    for (let t5 = 0, e2 = s.length; t5 < e2; ++t5) {
        i(s[t5], (t6) => {
            t6.needupdate && t6.view.updateFrames() && t6.parent && (t6.parent.needupdate = true);
        });
    }
}
const _Rc = class _Rc extends y {
    constructor() {
        super(...arguments);
        __publicField(this, "comsMap", /* @__PURE__ */ new Map());
        __publicField(this, "relayoutset", /* @__PURE__ */ new Map());
        __publicField(this, "dirtyset", /* @__PURE__ */ new Map());
        __publicField(this, "needNotify", /* @__PURE__ */ new Map());
        __publicField(this, "focusshape");
        __publicField(this, "__looping", false);
        __publicField(this, "__inframe", false);
        __publicField(this, "requestAnimationFrame");
    }
    setReLayout(t4) {
        this.relayoutset.set(c(t4), t4), this.continueLoop();
    }
    setDirty(t4) {
        this.dirtyset.set(c(t4), t4), this.continueLoop();
    }
    addNotifyLayout(t4) {
        this.needNotify.set(c(t4), t4);
    }
    removeReLayout(t4) {
        const e = c(t4);
        return this.relayoutset.delete(e);
    }
    removeDirty(t4) {
        const e = c(t4);
        return this.dirtyset.delete(e);
    }
    onIdle() {
        return false;
    }
    layoutAll() {
        const t4 = [], e = (t5) => {
            let e2 = 0, i = t5.parent;
            for (; i; ) e2++, i = i.parent;
            return e2;
        };
        this.relayoutset.forEach((i, s) => {
            t4.push({ data: i, level: e(i) });
        }), t4.sort((t5, e2) => t5.level - e2.level);
        for (let e2 = 0; e2 < t4.length; e2++) {
            const i = t4[e2].data;
            this.relayoutset.has(c(i)) && i.layout();
        }
        Fc(t4);
    }
    updateFocus() {
        if (!this.focusshape) return false;
        const t4 = Date.now(), e = [];
        let i = this.focusshape;
        for (; i; ) e.push(c(i)), i = i.parent;
        const s = [];
        this.relayoutset.forEach((t5, e2) => {
            s.push(t5);
        });
        for (let t5 = e.length - 1; t5 >= 0; t5--) {
            const i2 = this.relayoutset.get(e[t5]);
            i2 && i2.layout();
        }
        const r = [];
        for (let t5 = 0, e2 = s.length; t5 < e2; ++t5) this.relayoutset.get(c(s[t5])) || r.push({ data: s[t5] });
        Fc(r);
        for (let t5 = 0, i2 = e.length; t5 < i2; ++t5) {
            const i3 = this.dirtyset.get(e[t5]);
            i3 && i3.asyncRender();
        }
        this.notifyLayout();
        return Date.now() - t4 > _Rc.FRAME_TIME;
    }
    notifyLayout() {
        this.needNotify.forEach((t4) => {
            t4.notify("layout"), t4.emit("layout");
        }), this.needNotify.clear();
    }
    aloop() {
        const t4 = this.relayoutset.size > 0 || this.dirtyset.size > 0;
        let e = Date.now();
        if (this.updateFocus()) return true;
        this.layoutAll();
        const i = Date.now();
        this.emit("nextTick"), Date.now() - i > _Rc.FRAME_TIME && console.error("!!! nextTick too long !!!");
        for (let [t5, i2] of this.dirtyset) {
            i2.asyncRender();
            if (Date.now() - e > _Rc.FRAME_TIME) return true;
        }
        return this.notifyLayout(), (this.relayoutset.size || this.dirtyset.size) && console.log("loop not empty ", this.relayoutset.size, this.dirtyset.size), !!(t4 || this.relayoutset.size > 0 || this.dirtyset.size > 0) || this.onIdle();
    }
    continueLoop() {
        this.__looping && !this.__inframe && this.requestAnimationFrame && this._startLoop(this.requestAnimationFrame);
    }
    _startLoop(t4) {
        const e = () => {
            this.__inframe = false, this.__looping && this.aloop() && (t4(e), this.__inframe = true);
        };
        t4(e), this.__inframe = true;
    }
    loop(t4) {
        this.requestAnimationFrame = t4, this.__looping || (this.__looping = true, this._startLoop(t4));
    }
    stopLoop() {
        this.__looping = false;
    }
};
__publicField(_Rc, "FRAME_TIME", 20);
let Rc = _Rc;
class Oc {
    set(t4, e, i, s) {
        throw new Error(e.toString());
    }
    get(t4, e, i) {
        return Reflect.get(t4, e, i);
    }
    has(t4, e) {
        return t4 instanceof Map || t4 instanceof Set ? t4.has(e) : Reflect.has(t4, e);
    }
}
class Lc extends Oc {
    constructor(t4, e) {
        super();
        __publicField(this, "m_view");
        __publicField(this, "m_parent");
        this.m_view = t4, this.m_parent = e;
    }
    get(t4, e, i) {
        const s = e.toString();
        return "parent" === s || "__parent" === s ? this.m_parent : "fills" === s ? this.m_view.getFills() : "borders" === s ? this.m_view.getBorders() : "shadows" === s ? this.m_view.getShadows() : "contextSettings" === s ? this.m_view.contextSettings : super.get(t4, e, i);
    }
}
const Pc = { isVirtualShape: (t4) => t4.isVirtualShape, id: (t4) => t4.id };
Pc.parent = Pc.__parent = (t4) => {
    const e = t4.parent;
    if (e) return $c(e);
}, Pc.isVisible = (t4) => t4.isVisible, Pc.isLocked = (t4) => t4.isLocked, Pc.size = (t4) => t4.frame, Pc.transform = (t4) => t4.transform, Pc.rotation = (t4) => t4.rotation, Pc.isNoTransform = (t4) => () => t4.isNoTransform(), Pc.getPath = (t4) => () => t4.getPath(), Pc.getPathStr = (t4) => () => t4.getPathStr(), Pc.__isAdapted = (t4) => true;
class Bc extends Oc {
    constructor(t4) {
        super();
        __publicField(this, "m_view");
        __publicField(this, "m_style");
        this.m_view = t4, this.watch = this.watch.bind(this), this.unwatch = this.unwatch.bind(this), this.notify = this.notify.bind(this);
    }
    watch(t4) {
        return this.m_view.watch(t4);
    }
    unwatch(t4) {
        return this.m_view.unwatch(t4);
    }
    notify(...t4) {
        return this.m_view.notify(...t4);
    }
    get(t4, e, i) {
        const s = e.toString(), r = Pc[s];
        if (r) return r(this.m_view);
        if ("style" === s) {
            if (!this.m_style) {
                const t5 = new Lc(this.m_view, i);
                this.m_style = new Proxy(this.m_view.data.style, t5);
            }
            return this.m_style;
        }
        return "watch" === s ? this.watch : "unwatch" === s ? this.unwatch : "notify" === s ? this.notify : super.get(t4, e, i);
    }
}
class Nc extends Bc {
    get view() {
        return this.m_view;
    }
    get(t4, e, i) {
        return super.get(t4, e, i);
    }
}
class zc extends Bc {
    constructor() {
        super(...arguments);
        __publicField(this, "m_childs");
        __publicField(this, "m_naviChilds");
    }
    get(t4, e, i) {
        const s = e.toString();
        if ("childs" === s) {
            if (!this.m_childs) {
                const t5 = this.m_view.childs;
                if (t5) {
                    const e2 = new Vc();
                    this.m_childs = new Proxy(t5, e2);
                }
            }
            return this.m_childs;
        }
        if ("naviChilds" === s) {
            if (!this.m_naviChilds) {
                const t5 = this.m_view.naviChilds;
                if (t5) {
                    const e2 = new Vc();
                    this.m_naviChilds = new Proxy(t5, e2);
                }
            }
            return this.m_naviChilds;
        }
        return super.get(t4, e, i);
    }
}
class Vc extends Oc {
    get(t4, e, i) {
        const s = Reflect.get(t4, e, i);
        return s instanceof Vh ? Wc(s) : s;
    }
}
class Dc extends Bc {
    constructor(t4) {
        super(t4);
        __publicField(this, "m_childs");
        this.findOverride = this.findOverride.bind(this), this.findVar = this.findVar.bind(this);
    }
    get view() {
        return this.m_view;
    }
    findOverride(t4, e) {
        return this.view.findOverride(t4, e);
    }
    findVar(t4, e) {
        return this.view.findVar(t4, e);
    }
    get(t4, e, i) {
        const s = e.toString();
        if ("naviChilds" === s || "childs" === s) {
            if (!this.m_childs) {
                const t5 = this.m_view.childs;
                if (t5) {
                    const e2 = new Vc();
                    this.m_childs = new Proxy(t5, e2);
                }
            }
            return this.m_childs;
        }
        return "symData" === s ? this.view.symData : "refId" === s ? this.view.refId : this.m_view.isVirtualShape ? super.get(t4, e, i) : "__isAdapted" === s || ("style" === s ? super.get(t4, e, i) : Reflect.get(t4, e, i));
    }
    set(t4, e, i, s) {
        return this.m_view.isVirtualShape ? super.set(t4, e, i, s) : Reflect.set(t4, e, i, s);
    }
}
class Hc extends Bc {
    get view() {
        return this.m_view;
    }
    get(t4, e, i) {
        return "text" === e ? this.view.getText() : super.get(t4, e, i);
    }
}
function Wc(t4) {
    const e = t4.data;
    let i;
    return i = e instanceof Li ? new zc(t4) : e instanceof Ar ? new Dc(t4) : e instanceof Gi ? new Hc(t4) : e instanceof Vi ? new Nc(t4) : new Bc(t4), new Proxy(e, i);
}
function $c(t4) {
    if (!(t4 instanceof Vh)) throw new Error("view is not a ShapeView");
    return t4.isVirtualShape || t4 instanceof nc ? Wc(t4) : t4.data;
}
function Xc(t4) {
    return t4.__isAdapted;
}
function Gc(t4, e) {
    for (let r = 0; r < t4.length; r++) if (i = t4[r], s = e, !(i.x > s.x + s.width || i.x + i.width < s.x || i.y > s.y + s.height || i.y + i.height < s.y)) return true;
    var i, s;
    return false;
}
class Yc {
    constructor(t4, e, i, s, r, n2) {
        __publicField(this, "_cellWidth");
        __publicField(this, "_cellHeight");
        __publicField(this, "_cellRowsCount");
        __publicField(this, "_cellColsCount");
        __publicField(this, "_rows", []);
        __publicField(this, "_offsetx");
        __publicField(this, "_offsety");
        this._cellWidth = t4, this._cellHeight = e, this._cellRowsCount = i, this._cellColsCount = s, this._offsetx = r, this._offsety = n2;
    }
    checkIntersectAndPush(t4) {
        return this._checkIntersectAndPush(t4, false);
    }
    push(t4) {
        this._checkIntersectAndPush(t4, true);
    }
    _checkIntersectAndPush(t4, e) {
        const i = t4.x - this._offsetx, s = t4.x + t4.width - this._offsetx, r = t4.y - this._offsety, n2 = t4.y + t4.height - this._offsety, o2 = Math.max(0, i / this._cellWidth), a2 = Math.max(1, s / this._cellWidth);
        for (let i2 = Math.floor(o2); i2 < a2 && i2 < this._cellColsCount; ++i2) {
            const s2 = Math.max(0, r / this._cellHeight), o3 = Math.max(1, n2 / this._cellHeight);
            let a3 = this._rows[i2];
            a3 || (a3 = [], this._rows[i2] = a3);
            for (let i3 = Math.floor(s2); i3 < o3 && i3 < this._cellRowsCount; ++i3) {
                let s3 = a3[i3];
                !e && s3 && (e = Gc(s3, t4)), s3 || (s3 = [], a3[i3] = s3), s3.push(t4);
            }
        }
        return e;
    }
}
const Uc = 1;
function Zc(t4, e, i, s, r, n2) {
    let a2 = n2 || new o();
    if (!n2) {
        const t5 = i.size.width, e2 = i.size.height;
        if (0 === t5 || 0 === e2) throw new Error();
        a2.multiAtLeft(i.matrix2Root()), a2.preScale(t5, e2), a2 = new o(a2.inverse);
    }
    const h2 = i.pathsegs[0].points[s];
    if (!h2) return false;
    const c2 = h2.x, l2 = h2.y, d2 = a2.computeCoord3(r);
    t4.shapeModifyCurvPoint(e, i, s, d2, 0);
    const p2 = d2.x - c2, u = d2.y - l2;
    (p2 || u) && (h2.hasFrom && t4.shapeModifyCurvFromPoint(e, i, s, { x: (h2.fromX || 0) + p2, y: (h2.fromY || 0) + u }, 0), h2.hasTo && t4.shapeModifyCurvToPoint(e, i, s, { x: (h2.toX || 0) + p2, y: (h2.toY || 0) + u }, 0));
}
function jc(e, i, s, r) {
    let n2 = r.length, a2 = [...r];
    if (0 === s) {
        const s2 = i.from;
        if (!s2) {
            const e2 = a2[0];
            return a2.splice(1, 0, new se([1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const r2 = e.getShape(s2.shapeId);
        if (!r2) {
            const e2 = a2[0];
            return a2.splice(1, 0, new se([1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const n3 = as(r2);
        if (!n3) {
            const e2 = a2[0];
            return a2.splice(1, 0, new se([1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const { xy1: h2, xy2: c2 } = n3;
        let l2 = hs(r2, s2.contactType, r2.matrix2Root(), h2, c2);
        if (!l2) {
            const e2 = a2[0];
            return a2.splice(1, 0, new se([1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const d2 = i.matrix2Root(), p2 = i.size;
        d2.preScale(p2.width, p2.height);
        l2 = new o(d2.inverse).computeCoord3(l2);
        const u = new se([1], v4(), l2.x, l2.y, ft.Straight), f2 = new se([2], v4(), l2.x, l2.y, ft.Straight);
        a2.splice(1, 0, u, f2);
    }
    if (s === n2 - 2) {
        n2 = a2.length;
        const s2 = i.to;
        if (!s2) {
            const e2 = r[r.length - 1];
            return a2.splice(n2 - 1, 0, new se([n2 - 1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const h2 = e.getShape(s2.shapeId);
        if (!h2) {
            const e2 = r[r.length - 1];
            return a2.splice(n2 - 1, 0, new se([n2 - 1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const c2 = as(h2);
        if (!c2) {
            const e2 = r[r.length - 1];
            return a2.splice(n2 - 1, 0, new se([n2 - 1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const { xy1: l2, xy2: d2 } = c2;
        let p2 = hs(h2, s2.contactType, h2.matrix2Root(), l2, d2);
        if (!p2) {
            const e2 = r[r.length - 1];
            return a2.splice(n2 - 1, 0, new se([n2 - 1], v4(), e2.x, e2.y, ft.Straight)), a2;
        }
        const u = i.matrix2Root(), f2 = i.size;
        u.preScale(f2.width, f2.height);
        p2 = new o(u.inverse).computeCoord3(p2);
        const g2 = new se([n2 - 1], v4(), p2.x, p2.y, ft.Straight), m2 = new se([n2], v4(), p2.x, p2.y, ft.Straight);
        a2.splice(n2 - 1, 0, g2, m2);
    }
    return a2;
}
function Jc(e, i, s, r) {
    const n2 = jc(i, s, r, s.getPoints());
    !function(e2, i2, s2, r2) {
        s2.deletePoints(e2, i2, 0, i2.pathsegs[0].points.length, 0);
        for (let e3 = 0, i3 = r2.length; e3 < i3; e3++) {
            const i4 = un(r2[e3]);
            i4.id = v4(), r2[e3] = i4;
        }
        s2.addPoints(e2, i2, r2, 0);
    }(i, s, e, n2), Kc(e, i, s), e.contactModifyEditState(i, s, true);
}
function Kc(t4, e, i, s = false) {
    const r = i.boundingBox3();
    if (!r) return;
    const n2 = i.matrix2Root(), a2 = i.frame, h2 = a2.width, c2 = a2.height, l2 = new o(i.matrix2Parent());
    l2.preScale(h2, c2);
    const d2 = Math.max(r.width, Uc), p2 = Math.max(r.height, Uc);
    let u = false;
    h2 === d2 && c2 === p2 || (t4.shapeModifyWH(e, i, d2, p2), u = true);
    const f2 = n2.computeCoord3(r), g2 = i.parent.matrix2Root().inverseCoord(f2), m2 = g2.x - i.transform.translateX, _2 = g2.y - i.transform.translateY;
    if ((m2 || _2) && t4.shapeModifyTransform(e, i, Ei(ki(i.transform).setTranslate(E.FromXY(g2.x, g2.y)))), !u && !s) return;
    const y2 = new o(i.matrix2Parent());
    y2.preScale(i.size.width, i.size.height), l2.multiAtLeft(y2.inverse), i.pathsegs.forEach((s2, r2) => function(s3, r3, n3) {
        if (!n3 || !n3.length) return false;
        for (let o2 = 0, a3 = n3.length; o2 < a3; o2++) {
            const a4 = n3[o2];
            a4 && (a4.hasFrom && t4.shapeModifyCurvFromPoint(e, i, o2, r3.computeCoord2(a4.fromX || 0, a4.fromY || 0), s3), a4.hasTo && t4.shapeModifyCurvToPoint(e, i, o2, r3.computeCoord2(a4.toX || 0, a4.toY || 0), s3), t4.shapeModifyCurvPoint(e, i, o2, r3.computeCoord2(a4.x, a4.y), s3));
        }
    }(r2, l2, s2.points));
}
function qc(t4, e) {
    const i = 0 === e ? t4.length - 1 : e - 1, s = e === t4.length - 1 ? 0 : e + 1;
    return { previous: t4[i], next: t4[s], previous_index: i, next_index: s };
}
function Qc(t4, e, i, s, r, n2, o2, a2 = Math.sqrt(2) / 4) {
    var _a2;
    const h2 = e, c2 = (_a2 = h2.pathsegs[o2]) == null ? void 0 : _a2.points;
    if (!(c2 == null ? void 0 : c2.length)) return;
    const l2 = function(t5, e2) {
        const i2 = qc(t5, e2), { previous: s2, next: n3 } = i2, o3 = Math.atan2(n3.x - s2.x, n3.y - s2.y), h3 = a2 * Math.sin(o3), c3 = a2 * Math.cos(o3), l3 = { x: r.x + h3, y: r.y + c3 }, d3 = { x: r.x - h3, y: r.y - c3 };
        return { from: l3, to: d3 };
    }(c2, n2);
    if (!l2) return;
    const { from: d2, to: p2 } = l2;
    3 === t4 ? (s.shapeModifyCurvFromPoint(i, h2, n2, d2, o2), s.shapeModifyCurvToPoint(i, h2, n2, p2, o2), s.modifyPointHasFrom(i, h2, n2, true, o2), s.modifyPointHasTo(i, h2, n2, true, o2)) : (s.shapeModifyCurvFromPoint(i, h2, n2, d2, o2), s.modifyPointHasFrom(i, h2, n2, true, o2));
}
function tl(t4, e, i, s, r) {
    i.shapeModifyCurvFromPoint(e, t4, s, { x: 0, y: 0 }, r), i.shapeModifyCurvToPoint(e, t4, s, { x: 0, y: 0 }, r), i.modifyPointHasFrom(e, t4, s, false, r), i.modifyPointHasTo(e, t4, s, false, r);
}
function el(t4, e, i, s, r, n2) {
    if (void 0 === s.fromX || void 0 === s.fromY) return;
    const o2 = 2 * s.x - s.fromX, a2 = 2 * s.y - s.fromY;
    i.shapeModifyCurvToPoint(e, t4, r, { x: o2, y: a2 }, n2);
}
function il(t4, e, i, s, r, n2) {
    var _a2;
    let o2;
    o2 = (_a2 = t4 == null ? void 0 : t4.pathsegs[n2]) == null ? void 0 : _a2.points[s], o2 && (o2.mode !== ft.Straight || r === ft.Straight ? o2.mode !== ft.Mirrored || r !== ft.Straight ? o2.mode !== ft.Disconnected ? o2.mode === ft.Asymmetric && (r === ft.Straight ? tl(t4, e, i, s, n2) : r === ft.Mirrored && el(t4, e, i, o2, s, n2)) : r === ft.Straight ? tl(t4, e, i, s, n2) : r !== ft.Mirrored && r !== ft.Asymmetric || el(t4, e, i, o2, s, n2) : tl(t4, e, i, s, n2) : Qc(3, t4, e, i, o2, s, n2, Math.sqrt(2) / 4));
}
function sl(t4, e) {
    return t4.hasFrom || e.hasTo;
}
function rl(t4, e) {
    const i = { x: t4.x, y: t4.y }, s = { x: 0, y: 0 }, r = { x: 0, y: 0 }, n2 = { x: e.x, y: e.y };
    return t4.hasFrom ? (s.x = t4.fromX || 0, s.y = t4.fromY || 0) : (s.x = t4.x, s.y = t4.y), e.hasTo ? (r.x = e.toX || 0, r.y = e.toY || 0) : (r.x = e.x, r.y = e.y), { start: i, from: s, to: r, end: n2 };
}
function nl(t4, e) {
    if (sl(t4, e)) {
        const { start: a2, from: h2, to: c2, end: l2 } = rl(t4, e);
        return i = 0.5, s = a2, r = h2, n2 = c2, o2 = l2, { x: Math.pow(1 - i, 3) * s.x + 3 * Math.pow(1 - i, 2) * i * r.x + 3 * (1 - i) * Math.pow(i, 2) * n2.x + Math.pow(i, 3) * o2.x, y: Math.pow(1 - i, 3) * s.y + 3 * Math.pow(1 - i, 2) * i * r.y + 3 * (1 - i) * Math.pow(i, 2) * n2.y + Math.pow(i, 3) * o2.y };
    }
    return { x: (t4.x + e.x) / 2, y: (t4.y + e.y) / 2 };
    var i, s, r, n2, o2;
}
function ol(t4, e, i, s, r) {
    var _a2;
    let n2 = r, o2 = (_a2 = i == null ? void 0 : i.pathsegs[r]) == null ? void 0 : _a2.points;
    if (!o2) return;
    const { previous: a2, next: h2, previous_index: c2, next_index: l2 } = qc(o2, s), d2 = nl(a2, h2);
    if (e.shapeModifyCurvPoint(t4, i, s, d2, n2), !sl(a2, h2)) return;
    e.modifyPointCurveMode(t4, i, s, ft.Asymmetric, n2);
    const { start: p2, from: u, to: f2, end: g2 } = rl(a2, h2), m2 = function(t5, e2, i2, s2) {
        const r2 = { x: (t5.x + e2.x) / 2, y: (t5.y + e2.y) / 2 }, n3 = (e2.x + i2.x) / 2, o3 = (e2.y + i2.y) / 2, a3 = { x: (i2.x + s2.x) / 2, y: (i2.y + s2.y) / 2 }, h3 = { x: (r2.x + n3) / 2, y: (r2.y + o3) / 2 }, c3 = { x: (n3 + a3.x) / 2, y: (o3 + a3.y) / 2 }, l3 = { x: (h3.x + c3.x) / 2, y: (h3.y + c3.y) / 2 };
        return [[t5, r2, h3, l3], [l3, c3, a3, s2]];
    }(p2, u, f2, g2);
    !function(t5, e2, i2, s2, r2, n3, o3) {
        r2.mode !== ft.Straight && r2.hasFrom && (r2.mode === ft.Mirrored && e2.modifyPointCurveMode(t5, i2, n3, ft.Asymmetric, o3), e2.shapeModifyCurvFromPoint(t5, i2, n3, s2[1], o3));
    }(t4, e, i, m2[0], a2, c2, n2), function(t5, e2, i2, s2, r2, n3, o3) {
        r2.mode !== ft.Straight && r2.hasTo && (r2.mode === ft.Mirrored && e2.modifyPointCurveMode(t5, i2, n3, ft.Asymmetric, o3), e2.shapeModifyCurvToPoint(t5, i2, n3, s2[2], o3));
    }(t4, e, i, m2[1], h2, l2, n2), function(t5, e2, i2, s2, r2, n3) {
        e2.modifyPointHasTo(t5, i2, r2, true, n3), e2.modifyPointHasFrom(t5, i2, r2, true, n3), e2.shapeModifyCurvToPoint(t5, i2, r2, s2[0][2], n3), e2.shapeModifyCurvFromPoint(t5, i2, r2, s2[1][1], n3);
    }(t4, e, i, m2, s, n2);
}
function al(t4) {
    if (!(t4 instanceof Vi || t4.type === Vt.Contact)) return false;
    const e = t4.pathsegs[0].points;
    return 2 === e.length && !e[0].hasFrom && !e[1].hasTo;
}
function hl(t4, e) {
    const i = 0.5, s = 0.5, r = 2 * Math.PI / t4;
    let n2 = [{ x: 0.5, y: 0 }];
    for (let o2 = 1; o2 < t4; o2++) {
        const t5 = o2 * r;
        let a2 = i + 0 * Math.cos(t5) - -0.5 * Math.sin(t5), h2 = s + 0 * Math.sin(t5) + -0.5 * Math.cos(t5);
        if (o2 % 2 == 1 && e) {
            a2 = i + (a2 - i) * e, h2 = s + (h2 - s) * e;
        }
        n2.push({ x: a2, y: h2 });
    }
    return n2;
}
function cl(e, i) {
    const s = new G();
    for (let r = 0; r < e.length; r++) {
        const n2 = e[r], o2 = new se([r], v4(), n2.x, n2.y, ft.Straight);
        i && (o2.radius = i), s.push(o2);
    }
    return s;
}
function ll(t4, e) {
    const i = 0.5, s = 0.5;
    return { x: i + (i + 0 * Math.cos(e) - -0.5 * Math.sin(e) - i) * t4, y: s + (s + 0 * Math.sin(e) + -0.5 * Math.cos(e) - s) * t4 };
}
function dl(t4, e) {
    const i = [], s = (t5) => (i.push(p.makePalPath(t5)), i[i.length - 1]), r = (t5) => t5.dash(10, 10, 1), n2 = e.position, a2 = e.sideSetting, h2 = e.borderStyle.gap, c2 = t4.startMarkerType, u = t4.endMarkerType, f2 = t4.frame.width, g2 = t4.frame.height, m2 = t4 instanceof Kh && !(!c2 && !u) && 1 === t4.segments.length && !t4.segments[0].isClosed, _2 = (a2.thicknessTop + a2.thicknessRight + a2.thicknessBottom + a2.thicknessLeft) / 4 === a2.thicknessLeft;
    let y2 = "";
    const x2 = (() => {
        const t5 = e.cornerType;
        return t5 === ut.Round ? l.ROUND : t5 === ut.Bevel ? l.BEVEL : l.MITER;
    })(), w2 = (() => {
        const e2 = t4.style.endMarkerType, i2 = t4.style.startMarkerType;
        return e2 === Ct.Round && i2 === Ct.Round ? d.ROUND : e2 === Ct.Square && i2 === Ct.Square ? d.SQUARE : d.BUTT;
    })(), b2 = { join: { value: x2 }, cap: { value: w2 } }, M2 = t4.getPathStr(), v2 = a2.thicknessTop;
    if (m2) {
        const e2 = s(M2);
        h2 && r(e2), e2.stroke(Object.assign(b2, { width: v2 }));
        const i2 = function() {
            if (c2 !== Ct.Round && c2 !== Ct.Square) return;
            const t5 = s(M2), e3 = c2 === Ct.Round ? d.ROUND : d.SQUARE;
            return t5.stroke({ cap: { value: e3 }, width: v2, join: { value: x2 } }), t5;
        }();
        i2 && e2.union(i2);
        const n3 = function() {
            if (u !== Ct.Round && u !== Ct.Square) return;
            const t5 = s(M2), e3 = u === Ct.Round ? d.ROUND : d.SQUARE;
            return t5.stroke({ cap: { value: e3 }, width: v2, join: { value: x2 } }), t5;
        }();
        n3 && e2.union(n3);
        const a3 = function() {
            if (!c2) return;
            let e3 = t4.segments[0].points;
            t4 instanceof qh && (e3 = t4.getPoints());
            const i3 = e3[0], r2 = e3[1];
            if (c2 === Ct.OpenArrow) {
                const t5 = S2(i3, r2), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4 + 3.5 * v2, y: n4 - 3 * v2 }, { x: e4 - 0.5 * v2, y: n4 }, { x: e4 + 3.5 * v2, y: n4 + 3 * v2 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, p3, u2] = a4, m3 = `M${c3.x} ${c3.y} L${p3.x} ${p3.y} L${u2.x} ${u2.y}`, _3 = s(m3), y3 = { res_scale: 1e4, width: v2, cap: { value: d.ROUND }, join: { value: l.ROUND } };
                return _3.stroke(y3), _3;
            }
            if (c2 === Ct.FilledArrow) {
                const t5 = S2(i3, r2), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4 + 3 * v2, y: n4 - 3 * v2 }, { x: e4 - 3 * v2, y: n4 }, { x: e4 + 3 * v2, y: n4 + 3 * v2 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, l2, d2] = a4, p3 = `M${c3.x} ${c3.y} L${l2.x} ${l2.y} L${d2.x} ${d2.y} z`;
                return s(p3);
            }
            if (c2 === Ct.FilledCircle) {
                const t5 = i3.x * f2, e4 = i3.y * g2, r3 = 3 * v2;
                return s(`M${t5} ${e4} h ${-r3} a${r3} ${r3} 0 1 0 ${2 * r3} 0 a${r3} ${r3} 0 1 0 ${-2 * r3} 0`);
            }
            if (c2 === Ct.FilledSquare) {
                const t5 = S2(i3, r2), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4, y: n4 - 3 * v2 }, { x: e4 - 3 * v2, y: n4 }, { x: e4, y: n4 + 3 * v2 }, { x: e4 + 3 * v2, y: n4 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, l2, d2, p3] = a4, u2 = `M${c3.x} ${c3.y} L${l2.x} ${l2.y} L${d2.x} ${d2.y} L${p3.x} ${p3.y} z`;
                return s(u2);
            }
        }();
        a3 && e2.union(a3);
        const p2 = function() {
            if (!u) return;
            let e3 = t4.segments[0].points;
            t4 instanceof qh && (e3 = t4.getPoints());
            const i3 = e3[e3.length - 1], r2 = e3[e3.length - 2];
            if (u === Ct.OpenArrow) {
                const t5 = S2(r2, i3, true), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4 - 3.5 * v2, y: n4 - 3 * v2 }, { x: e4 + 0.5 * v2, y: n4 }, { x: e4 - 3.5 * v2, y: n4 + 3 * v2 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, p3, u2] = a4, m3 = `M${c3.x} ${c3.y} L${p3.x} ${p3.y} L${u2.x} ${u2.y}`, _3 = s(m3);
                return _3.stroke({ width: v2, cap: { value: d.ROUND }, join: { value: l.ROUND } }), _3;
            }
            if (u === Ct.FilledArrow) {
                const t5 = S2(r2, i3, true), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4 - 3 * v2, y: n4 - 3 * v2 }, { x: e4 + 3 * v2, y: n4 }, { x: e4 - 3 * v2, y: n4 + 3 * v2 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, l2, d2] = a4, p3 = `M${c3.x} ${c3.y} L${l2.x} ${l2.y} L${d2.x} ${d2.y} z`;
                return s(p3);
            }
            if (u === Ct.FilledCircle) {
                const t5 = i3.x * f2, e4 = i3.y * g2, r3 = 3 * v2;
                return s(`M${t5} ${e4} h ${-r3} a${r3} ${r3} 0 1 0 ${2 * r3} 0 a${r3} ${r3} 0 1 0 ${-2 * r3} 0`);
            }
            if (u === Ct.FilledSquare) {
                const t5 = S2(r2, i3, true), e4 = i3.x * f2, n4 = i3.y * g2, a4 = [{ x: e4, y: n4 - 3 * v2 }, { x: e4 + 3 * v2, y: n4 }, { x: e4, y: n4 + 3 * v2 }, { x: e4 - 3 * v2, y: n4 }], h3 = new o();
                h3.rotate(t5, e4, n4), a4.forEach((t6) => {
                    const e5 = h3.computeCoord3(t6);
                    t6.x = e5.x, t6.y = e5.y;
                });
                const [c3, l2, d2, p3] = a4, u2 = `M${c3.x} ${c3.y} L${l2.x} ${l2.y} L${d2.x} ${d2.y} L${p3.x} ${p3.y} z`;
                return s(u2);
            }
        }();
        p2 && e2.union(p2), y2 = e2.toSVGString();
    } else if (_2) {
        if (t4 instanceof Kh && t4.segments.some((t5) => !t5.isClosed)) {
            const t5 = s(M2);
            h2 && r(t5), t5.stroke(Object.assign(b2, { width: v2 })), y2 = t5.toSVGString();
        } else if (n2 === ht.Outer) {
            const t5 = s(M2), e2 = s(M2);
            h2 && r(t5), t5.stroke(Object.assign(b2, { width: 2 * v2 })), t5.subtract(e2), y2 = t5.toSVGString();
        } else if (n2 === ht.Center) {
            const t5 = s(M2);
            h2 && r(t5), t5.stroke(Object.assign(b2, { width: v2 })), y2 = t5.toSVGString();
        } else {
            const e2 = t4.getPathStr(), i2 = s(e2), n3 = s(e2);
            h2 && r(i2), i2.stroke(Object.assign(b2, { width: 2 * v2 })), i2.intersection(n3), y2 = i2.toSVGString();
        }
    } else if (!t4.data.haveEdit) {
        const t5 = function() {
            let t6 = C3(a2.thicknessTop, `M0 0 h${f2}`);
            const i2 = C3(a2.thicknessRight, `M${f2} 0 L${f2} ${g2}`);
            i2 && t6 ? t6.union(i2) : i2 && (t6 = i2);
            const r2 = C3(a2.thicknessBottom, `M${f2} ${g2} L0 ${g2}`);
            r2 && t6 ? t6.union(r2) : r2 && (t6 = r2);
            const n3 = C3(a2.thicknessLeft, `M0 ${g2} L0 0`);
            n3 && t6 ? t6.union(n3) : n3 && (t6 = n3);
            const o2 = function() {
                const t7 = e.cornerType;
                if (e.position === ht.Inner) return;
                let { thicknessBottom: i3, thicknessRight: r3, thicknessLeft: n4, thicknessTop: o3 } = a2;
                e.position === ht.Center && (i3 /= 2, r3 /= 2, n4 /= 2, o3 /= 2);
                const h3 = f2, c3 = g2;
                let l2 = "";
                t7 === ut.Bevel ? (o3 && r3 && (l2 += `M${h3} ${-o3} L${h3 + r3} 0 h${-r3} z`), r3 && i3 && (l2 += `M${h3 + r3} ${c3} L${h3} ${c3 + i3} v${-i3} z`), i3 && n4 && (l2 += `M0 ${c3 + i3} L${-n4} ${c3} h${n4} z`), n4 && o3 && (l2 += `M${-n4} 0 L0 ${-o3} v${o3} z`)) : t7 === ut.Round ? (o3 && r3 && (l2 += o3 > r3 ? `M${h3} ${-o3} a${r3} ${r3} 0 0 1 ${r3} ${r3} L${h3 + r3} 0 h${-r3} z` : `M${h3} ${-o3} L${h3 + r3 - o3} ${-o3} a${o3} ${o3} 0 0 1 ${o3} ${o3} h${-r3} z`), r3 && i3 && (l2 += r3 > i3 ? `M${h3 + r3} ${c3} a${i3} ${i3} 0 0 1 ${-i3} ${i3} L${h3} ${c3 + i3} v${-i3}z` : `M${h3 + r3} ${c3} L${h3 + r3} ${c3 + i3 - r3} a${r3} ${r3} 0 0 1 ${-r3} ${r3} v${-i3} z`), i3 && n4 && (l2 += i3 > n4 ? `M0 ${c3 + i3} a${n4} ${n4} 0 0 1 ${-n4} ${-n4} L${-n4} ${c3} h${n4} z` : `M0 ${c3 + i3} h${-n4 + i3} a${i3} ${i3} 0 0 1 ${-i3} ${-i3} h${n4} z`), n4 && o3 && (l2 += n4 > o3 ? `M${-n4} 0 a${o3} ${o3} 0 0 1 ${o3} ${-o3} L0 ${-o3} v${o3} z` : `M${-n4} 0 L${-n4} ${-o3 + n4} a${n4} ${n4} 0 0 1 ${n4} ${-n4} v${o3}`)) : (o3 && r3 && (l2 += `M${h3} ${-o3} h${r3} v${o3} h${-r3} z`), r3 && i3 && (l2 += `M${h3 + r3} ${c3} v${i3} h${-r3} v${-i3} z`), i3 && n4 && (l2 += `M0 ${c3 + i3} h${-n4} v${-i3} h${n4} z`), n4 && o3 && (l2 += `M${-n4} 0 v${-o3} h${n4} v${o3} z`));
                if (l2) return s(l2);
            }();
            t6 && o2 && t6.union(o2);
            return t6;
        }();
        t5 && (y2 = t5.toSVGString());
    }
    return i.forEach((t5) => t5 == null ? void 0 : t5.delete()), new pi(y2);
    function S2(t5, e2, i2) {
        if (t5.hasFrom || e2.hasTo) {
            const s2 = { x: t5.x * f2, y: t5.y * g2 }, r2 = { x: e2.x * f2, y: e2.y * g2 };
            return function(i3, s3, r3, n3, o2) {
                if (void 0 !== t5.fromX && void 0 !== e2.toX) {
                    const t6 = { x: 3 * (1 - o2) ** 2 * (s3.x - i3.x) + 6 * (1 - o2) * o2 * (r3.x - s3.x) + 3 * o2 ** 2 * (n3.x - r3.x), y: 3 * (1 - o2) ** 2 * (s3.y - i3.y) + 6 * (1 - o2) * o2 * (r3.y - s3.y) + 3 * o2 ** 2 * (n3.y - r3.y) };
                    return Math.atan2(t6.y, t6.x);
                }
                if (void 0 !== e2.toX) {
                    let t6 = 2 * ((1 - o2) * (r3.x - i3.x) + o2 * (n3.x - r3.x)), e3 = 2 * ((1 - o2) * (r3.y - i3.y) + o2 * (n3.y - r3.y));
                    return Math.atan2(e3, t6);
                }
                {
                    let t6 = 2 * ((1 - o2) * (s3.x - i3.x) + o2 * (n3.x - s3.x)), e3 = 2 * ((1 - o2) * (s3.y - i3.y) + o2 * (n3.y - s3.y));
                    return Math.atan2(e3, t6);
                }
            }(s2, { x: (t5.fromX || t5.x) * f2, y: (t5.fromY || t5.y) * g2 }, { x: (e2.toX || e2.x) * f2, y: (e2.toY || e2.y) * g2 }, r2, i2 ? 1 : 0);
        }
        {
            const i3 = (e2.x - t5.x) * f2, s2 = (e2.y - t5.y) * g2;
            return Math.atan2(s2, i3);
        }
    }
    function C3(e2, i2) {
        if (e2 > 0) {
            if (n2 === ht.Inner) {
                const n3 = s(t4.getPathStr()), o2 = s(i2);
                return h2 && r(o2), o2.stroke(Object.assign(b2, { width: 2 * e2 })), o2.intersection(n3), o2;
            }
            if (n2 === ht.Center) {
                const t5 = s(i2);
                return h2 && r(t5), t5.stroke(Object.assign(b2, { width: e2 })), t5;
            }
            {
                const n3 = s(t4.getPathStr()), o2 = s(i2);
                return h2 && r(o2), o2.stroke(Object.assign(b2, { width: 2 * e2 })), o2.subtract(n3), o2;
            }
        }
    }
}
function pl(t4, e, i, s) {
    switch (t4) {
        case at.Diff:
            s ? e.difference(i) : e.addPath(i);
            break;
        case at.Intersect:
            if (!s) return p.makePalPath("");
            e.intersection(i);
            break;
        case at.Subtract:
            s && e.subtract(i);
            break;
        case at.Union:
            s ? e.union(i) : e.addPath(i);
    }
    return e;
}
function ul(t4, e = at.None) {
    const i = t4 instanceof Dh;
    let s;
    if (i && (s = t4.fixedRadius), !i) return t4.isVisible ? t4 instanceof Ic ? t4.getTextPath().clone() : !(t4.data instanceof Vi) || t4.data.isClosed && function(t5) {
        const e2 = t5.getFills();
        if (0 === e2.length) return false;
        for (let t6 = 0, i2 = e2.length; t6 < i2; ++t6) if (e2[t6].isEnabled) return true;
        return false;
    }(t4) ? t4.getPath().clone() : function(t5, e2) {
        let i2 = 0, s2 = 0;
        if (e2.forEach((t6) => {
            if (!t6.isEnabled) return;
            const e3 = t6.sideSetting, r2 = (e3.thicknessBottom + e3.thicknessLeft + e3.thicknessTop + e3.thicknessRight) / 4;
            t6.position === ht.Center ? (i2 = Math.max(i2, r2 / 2), s2 = Math.max(s2, r2 / 2)) : t6.position === ht.Inner ? i2 = Math.max(i2, r2) : t6.position === ht.Outer && (s2 = Math.max(s2, r2));
        }), 0 === i2 && 0 === s2) return new pi();
        if (i2 === s2) {
            const e3 = t5.getPath(), r2 = p.makePalPath(e3.toString()), n3 = r2.stroke({ width: i2 + s2 });
            return r2.delete(), new pi(n3);
        }
        if (0 === i2) {
            const e3 = t5.getPathStr(), i3 = p.makePalPath(e3), r2 = p.makePalPath(e3);
            i3.stroke({ width: 2 * s2 }), i3.subtract(r2);
            const n3 = i3.toSVGString();
            return i3.delete(), r2.delete(), new pi(n3);
        }
        if (0 === s2) {
            const e3 = t5.getPathStr(), s3 = p.makePalPath(e3), r2 = p.makePalPath(e3);
            s3.stroke({ width: 2 * i2 }), s3.intersection(r2);
            const n3 = s3.toSVGString();
            return s3.delete(), r2.delete(), new pi(n3);
        }
        {
            const e3 = t5.getPathStr(), r2 = p.makePalPath(e3), n3 = p.makePalPath(e3), o3 = p.makePalPath(e3);
            r2.stroke({ width: 2 * i2 }), n3.stroke({ width: 2 * s2 }), i2 > s2 ? r2.intersection(o3) : n3.subtract(o3), r2.union(n3);
            const a3 = r2.toSVGString();
            return r2.delete(), n3.delete(), o3.delete(), new pi(a3);
        }
    }(t4, t4.getBorders()) : new pi();
    if (0 === t4.childs.length) return new pi();
    let r = 0;
    for (let e2 = 0; e2 < t4.m_children.length; ++e2) if (t4.m_children[e2].isVisible) {
        r = e2;
        break;
    }
    const n2 = t4.m_children.length;
    if (r >= n2) return new pi();
    const o2 = t4.m_children[r];
    let a2;
    const h2 = ul(o2);
    if (o2.isNoTransform()) h2.translate(o2.transform.translateX, o2.transform.translateY), a2 = new _e(o2.transform.translateX, o2.transform.translateY, o2.frame.width, o2.frame.height);
    else {
        h2.transform(o2.matrix2Parent());
        const t5 = h2.calcBounds();
        a2 = new _e(t5.minX, t5.minY, t5.maxX - t5.minX, t5.maxY - t5.minY);
    }
    const c2 = function(t5) {
        let e2 = 0, i2 = 0, s2 = 0, r2 = 0;
        return t5.childs.forEach((t6, n3) => {
            const o3 = t6._p_frame;
            0 === n3 ? (e2 = o3.x, i2 = o3.x + o3.width, s2 = o3.y, r2 = o3.y + o3.height) : (e2 = Math.min(e2, o3.x), i2 = Math.max(i2, o3.x + o3.width), s2 = Math.min(s2, o3.y), r2 = Math.max(r2, o3.y + o3.height));
        }), new _e(e2, s2, i2 - e2, r2 - s2);
    }(t4), l2 = Math.ceil(Math.sqrt(n2)), d2 = new Yc(c2.width / l2, c2.height / l2, l2, l2, c2.x, c2.y);
    d2.push(a2);
    let u = p.makePalPath(h2.toString());
    for (let i2 = r + 1; i2 < n2; i2++) {
        const s2 = t4.m_children[i2];
        if (!s2.isVisible) continue;
        let r2;
        const n3 = ul(s2);
        if (s2.isNoTransform()) n3.translate(s2.transform.translateX, s2.transform.translateY), r2 = new _e(s2.transform.translateX, s2.transform.translateY, s2.frame.width, s2.frame.height);
        else {
            n3.transform(s2.matrix2Parent());
            const t5 = n3.calcBounds();
            r2 = new _e(t5.minX, t5.minY, t5.maxX - t5.minX, t5.maxY - t5.minY);
        }
        const o3 = s2.m_data.boolOp ?? e, a3 = p.makePalPath(n3.toString());
        if (o3 === at.None) d2.push(r2), u.addPath(a3);
        else {
            const t5 = pl(o3, u, a3, d2.checkIntersectAndPush(r2));
            t5 !== u && (u.delete(), u = t5);
        }
        a3.delete();
    }
    const f2 = u.toSVGString();
    let g2;
    if (u.delete(), s && s > 0) {
        const e2 = t4.frame, i2 = new pi(f2).toCurvePoints(e2.width, e2.height), r2 = [];
        i2.forEach((t5) => {
            r2.push(...vi(t5.points, !!t5.isClosed, e2.width, e2.height, s));
        }), g2 = new pi(r2);
    } else g2 = new pi(f2);
    return g2;
}
class fl extends Dh {
    get data() {
        return this.m_data;
    }
    getBoolOp() {
        return this.data.getBoolOp();
    }
    _bubblewatcher(...t4) {
        super._bubblewatcher(...t4), this.m_path = void 0, this.m_pathstr = void 0, this.m_ctx.setDirty(this);
    }
    onDataChange(...t4) {
        super.onDataChange(...t4), t4.includes("variables") && (this.m_path = void 0, this.m_pathstr = void 0);
    }
    renderFills() {
        return th(Da, this.getFills(), this.frame, this.getPathStr());
    }
    renderBorders() {
        return _h(Da, this.getBorders(), this.frame, this.getPathStr(), this.data);
    }
    getPath() {
        return this.m_path || (this.m_path = ul(this), this.m_path.freeze()), this.m_path;
    }
    renderContents() {
        return [];
    }
    asyncRender() {
        return this.render();
    }
    updateFrames() {
        const t4 = this.getBorders();
        let e = 0;
        t4.forEach((t5) => {
            t5.position === ht.Outer ? e = Math.max(t5.thickness, e) : t5.position === ht.Center && (e = Math.max(t5.thickness / 2, e));
        });
        let i = this._save_frame.x !== this.m_frame.x || this._save_frame.y !== this.m_frame.y || this._save_frame.width !== this.m_frame.width || this._save_frame.height !== this.m_frame.height;
        const s = this.getPath().calcBounds();
        zh(this.m_frame, s.minX, s.minY, s.maxX - s.minX, s.maxY - s.minY) && (this._save_frame.x = this.m_frame.x, this._save_frame.y = this.m_frame.y, this._save_frame.width = this.m_frame.width, this._save_frame.height = this.m_frame.height, i = true), zh(this.m_visibleFrame, this.frame.x - e, this.frame.y - e, this.frame.width + 2 * e, this.frame.height + 2 * e) && (i = true);
        const r = this.m_children.map((t5) => t5._p_outerFrame).reduce((t5, e2, i2) => (0 === i2 ? (t5.minx = e2.x, t5.maxx = e2.x + e2.width, t5.miny = e2.y, t5.maxy = e2.y + e2.height) : (t5.minx = Math.min(t5.minx, e2.x), t5.maxx = Math.max(t5.maxx, e2.x + e2.width), t5.miny = Math.min(t5.miny, e2.y), t5.maxy = Math.max(t5.maxy, e2.y + e2.height)), t5), { minx: 0, miny: 0, maxx: 0, maxy: 0 });
        zh(this.m_outerFrame, r.minx, r.miny, r.maxx - r.minx, r.maxy - r.miny) && (i = true);
        const n2 = (t5, e2) => {
            const i2 = this.transform;
            if (this.isNoTransform()) return zh(e2, t5.x + i2.translateX, t5.y + i2.translateY, t5.width, t5.height);
            const s2 = t5, r2 = i2, n3 = [{ x: s2.x, y: s2.y }, { x: s2.x + s2.width, y: s2.y }, { x: s2.x + s2.width, y: s2.y + s2.height }, { x: s2.x, y: s2.y + s2.height }].map((t6) => r2.computeCoord(t6)), o2 = n3.reduce((t6, e3) => Math.min(t6, e3.x), n3[0].x), a2 = n3.reduce((t6, e3) => Math.max(t6, e3.x), n3[0].x), h2 = n3.reduce((t6, e3) => Math.min(t6, e3.y), n3[0].y);
            return zh(e2, o2, h2, a2 - o2, n3.reduce((t6, e3) => Math.max(t6, e3.y), n3[0].y) - h2);
        };
        return n2(this.m_frame, this._p_frame) && (i = true), n2(this.m_visibleFrame, this._p_visibleFrame) && (i = true), n2(this.m_outerFrame, this._p_outerFrame) && (i = true), i;
    }
}
class gl extends Kh {
    get data() {
        return this.m_data;
    }
    get radiusType() {
        return De.Fixed;
    }
    get counts() {
        return this.data.counts;
    }
}
class ml extends Kh {
    get data() {
        return this.m_data;
    }
    get radiusType() {
        return De.Fixed;
    }
    get counts() {
        return this.data.counts;
    }
    get innerAngle() {
        return this.data.innerAngle;
    }
}
const hd = new Int32Array(1);
new Uint8Array(hd.buffer);
new Uint32Array(hd.buffer);
var fd = { typeId: "group-shape", id: "7B35A2C4-87A6-7033-A030-87CDE15F803B", crdtidx: [], name: "Group", type: "group", transform: { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }, size: { width: 0, height: 0 }, style: { typeId: "style", borders: [], fills: [], shadows: [] }, childs: [] }, gd = { typeId: "bool-shape", id: "", crdtidx: [], name: "BoolShape", type: "bool-shape", boolOp: "none", transform: { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }, size: { width: 0, height: 0 }, style: { typeId: "style", borders: [], fills: [], shadows: [] }, childs: [] }, md = { typeId: "page", id: "3ACF7DAD-0728-4510-81D0-CFA1C0FAB148", crdtidx: [], type: "page", boolOp: "none", isFixedToViewport: false, isFlippedHorizontal: false, isFlippedVertical: false, isLocked: false, isVisible: true, name: "页面 1", nameIsFixed: false, resizingConstraint: 63, resizingType: "stretch", rotation: 0, shouldBreakMaskChain: false, exportOptions: { typeId: "export-options", includedChildIds: [], childOptions: 0, shouldTrim: false, exportFormats: [], trimTransparent: false, canvasBackground: false, unfold: false }, transform: { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }, size: { width: 600, height: 800 }, clippingMaskMode: 0, hasClippingMask: false, style: { typeId: "style", borders: [], fills: [], shadows: [] }, childs: [], guides: [] }, _d = { typeId: "artboard", id: "7B35A2C4-87A6-7033-A030-87CDE15F803B", crdtidx: [], name: "Group", type: "artboard", boolOp: "none", transform: { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }, size: { width: 0, height: 0 }, style: { typeId: "style", borders: [], fills: [], shadows: [] }, childs: [], leftTopRadius: 0, rightTopRadius: 0, rightBottomRadius: 0, leftBottomRadius: 0 }, yd = { typeId: "text-shape", id: "7B35A2C4-87A6-7033-A030-87CDE15F803B", crdtidx: [], name: "Text", type: "text", boolOp: "none", transform: { m00: 1, m01: 0, m02: 0, m10: 0, m11: 1, m12: 0 }, size: { width: 0, height: 0 }, style: { typeId: "style", borders: [], fills: [], shadows: [] }, text: { typeId: "text", paras: [{ text: "\n", spans: [{ length: 1, fontName: "PingFang SC", fontSize: 14, color: { typeId: "color", alpha: 1, red: 51, green: 51, blue: 51 } }], attr: { minimumLineHeight: 24 } }] } };
function xd(t4) {
    if (Number.isNaN(t4) || !Number.isFinite(t4)) throw new Error(String(t4));
}
function wd(t4) {
    if (0 === t4.width || 0 === t4.height) throw new Error();
    xd(t4.width), xd(t4.height);
}
function bd(t4) {
    const e = ki(t4.transform);
    e.setRotateZ(0), Fi(t4.transform, e), t4.isVisible = true, t4.isLocked = false, t4.constrainerProportions = false, t4.nameIsFixed = false, t4.resizingConstraint = Ne.Default;
}
function Md(e, i) {
    const s = v4(), r = new G();
    return new Oa(s, e, "", "", r, new Y(), i);
}
function vd(e) {
    md.id = v4(), md.name = e;
    const i = zo(md);
    return i.backgroundColor = new Ji(1, 239, 239, 239), i;
}
function Sd(e, i) {
    fd.id = v4(), fd.name = e;
    const s = Bo(fd);
    return i && (s.style = i), bd(s), s;
}
function Cd(e, i) {
    gd.id = v4(), gd.name = e;
    const s = Oo(gd);
    return i && (s.style = i), bd(s), s;
}
function Td() {
    const e = new Ji(1, 216, 216, 216);
    return new es(new G(), v4(), true, xt.SolidColor, e);
}
function Id() {
    const t4 = new G(), e = Td(), i = new G(), s = new is(t4, i, new G());
    return s.fills.push(e), s;
}
function kd() {
    const t4 = new G(), e = new G(), i = new G();
    return new is(t4, e, i);
}
function Ed(e, i, s) {
    wd(i), _d.id = v4(), _d.name = e;
    const r = new ye(i.width, i.height), n2 = new Ii();
    n2.m02 = i.x, n2.m12 = i.y, _d.size = r, _d.transform = n2;
    const o2 = Fo(_d);
    return s && o2.style.fills.push(s), bd(o2), o2.fixedRadius = 0, o2;
}
function Ad(e, i, s, r) {
    i.width = i.width || 1, i.height = i.height || 1, r = r || Id();
    const n2 = v4(), o2 = s.toCurvePoints(i.width, i.height), a2 = new G();
    o2.forEach((e2, i2) => {
        const s2 = e2.points, r2 = e2.isClosed || false, n3 = new G(...s2);
        a2.push(new pe([i2], v4(), n3, r2));
    });
    const h2 = new Ii();
    h2.m02 = i.x, h2.m12 = i.y;
    const c2 = new ye(i.width, i.height), l2 = new Vi(new G(), n2, e, Vt.Path, h2, r, c2, a2);
    return bd(l2), l2;
}
function Fd(e, i) {
    wd(i);
    const s = Id(), r = new G(), n2 = v4(), o2 = new se([0], v4(), 0, 0, ft.Straight), a2 = new se([1], v4(), 1, 0, ft.Straight), h2 = new se([2], v4(), 1, 1, ft.Straight), c2 = new se([3], v4(), 0, 1, ft.Straight);
    r.push(o2, a2, h2, c2);
    const l2 = new pe([0], v4(), r, true), d2 = new Ii();
    d2.m02 = i.x, d2.m12 = i.y;
    const p2 = new ye(i.width, i.height), u = new Hi(new G(), n2, e, Vt.Rectangle, d2, s, p2, new G(l2));
    return bd(u), u;
}
function Rd(e, i) {
    wd(i);
    const s = Id(), r = new G(), n2 = v4(), o2 = new re(0, 0, 0, 0), a2 = new se([0], v4(), 0.5, 1, ft.Mirrored);
    a2.hasFrom = true, a2.hasTo = true, a2.fromX = 0.775892388889507, a2.fromY = 1, a2.toX = 0.224107611110493, a2.toY = 1;
    const h2 = new se([1], v4(), 1, 0.5, ft.Mirrored);
    h2.hasFrom = true, h2.hasTo = true, h2.fromX = 1, h2.fromY = 0.224107611110493, h2.toX = 1, h2.toY = 0.775892388889507;
    const c2 = new se([2], v4(), 0.5, 0, ft.Mirrored);
    c2.hasFrom = true, c2.hasTo = true, c2.fromX = 0.224107611110493, c2.fromY = 0, c2.toX = 0.775892388889507, c2.toY = 0;
    const l2 = new se([3], v4(), 0, 0.5, ft.Mirrored);
    l2.hasFrom = true, l2.hasTo = true, l2.fromX = 0, l2.fromY = 0.775892388889507, l2.toX = 0, l2.toY = 0.224107611110493, r.push(a2, h2, c2, l2);
    const d2 = new pe([0], v4(), r, true), p2 = new Ii();
    p2.m02 = i.x, p2.m12 = i.y;
    const u = new ye(i.width, i.height), f2 = new $i([4], n2, e, Vt.Oval, p2, s, u, new G(d2), o2);
    return bd(f2), f2;
}
function Od(e, i) {
    wd(i);
    const s = Id(), r = v4(), n2 = cl(hl(3)), o2 = new pe([0], v4(), n2, true), a2 = new Ii();
    a2.m02 = i.x, a2.m12 = i.y;
    const h2 = new ye(i.width, i.height), c2 = new Ui(new G(), r, e, Vt.Polygon, a2, s, h2, new G(o2), 3);
    return bd(c2), c2;
}
function Ld(e, i) {
    wd(i);
    const s = Id(), r = hl(10, 0.382), n2 = v4(), o2 = cl(r), a2 = new pe([0], v4(), o2, true), h2 = new Ii();
    h2.m02 = i.x, h2.m12 = i.y;
    const c2 = new ye(i.width, i.height), l2 = new Zi(new G(), n2, e, Vt.Star, h2, s, c2, new G(a2), 5, 0.382);
    return bd(l2), l2;
}
function Pd(e, i) {
    wd(i);
    const s = kd(), r = new se([0], v4(), 0, 0.5, ft.Straight), n2 = new se([1], v4(), 1, 0.5, ft.Straight);
    i.height = 1;
    const o2 = new G(r, n2), a2 = new Me(Dt.Normal, 1, 1, 1, 1), h2 = new ts([0], v4(), true, xt.SolidColor, new Ji(1, 0, 0, 0), ht.Center, 1, new Kt(0, 0), ut.Miter, a2);
    s.borders.push(h2);
    const c2 = new pe([0], v4(), o2, false), l2 = new Ii();
    l2.m02 = i.x, l2.m12 = i.y;
    const d2 = new ye(i.width, i.height), p2 = new Xi(new G(), v4(), e, Vt.Line, l2, s, d2, new G(c2));
    return bd(p2), p2;
}
function Bd(e, i) {
    wd(i);
    const s = kd();
    s.endMarkerType = Ct.OpenArrow;
    const r = new se([0], v4(), 0, 0.5, ft.Straight), n2 = new se([1], v4(), 1, 0.5, ft.Straight);
    i.height = 1;
    const o2 = new G(r, n2), a2 = new Me(Dt.Normal, 1, 1, 1, 1), h2 = new ts([0], v4(), true, xt.SolidColor, new Ji(1, 0, 0, 0), ht.Center, 1, new Kt(0, 0), ut.Miter, a2);
    s.borders.push(h2);
    const c2 = new pe([0], v4(), o2, false), l2 = new Ii();
    l2.m02 = i.x, l2.m12 = i.y;
    const d2 = new ye(i.width, i.height), p2 = new Xi(new G(), v4(), e, Vt.Line, l2, s, d2, new G(c2));
    return bd(p2), p2;
}
function Nd(e, i, s) {
    s && wd(s), yd.id = v4(), yd.name = e;
    const r = ho(yd);
    return s && (r.transform.m02 = s.x, r.transform.m12 = s.y, r.size.width = s.width, r.size.height = s.height), r.text = ta(i), bd(r), r;
}
function zd(e, i) {
    i && wd(i), yd.id = v4(), yd.name = e;
    const s = ho(yd);
    return i && (s.transform.m02 = i.x, s.transform.m12 = i.y, s.size.width = i.width, s.size.height = i.height), bd(s), s;
}
function Vd(e, i) {
    yd.id = v4(), yd.name = e;
    const s = ho(yd);
    return s.text.insertFormatText(ro(i), 0), bd(s), s;
}
function Dd(e, i, s, r, n2) {
    wd(i);
    const o2 = Id(), a2 = new G(), h2 = v4(), c2 = new se([0], v4(), 0, 0, ft.Straight), l2 = new se([1], v4(), 1, 0, ft.Straight), d2 = new se([2], v4(), 1, 1, ft.Straight), p2 = new se([3], v4(), 0, 1, ft.Straight);
    a2.push(c2, l2, d2, p2);
    const u = new pe([0], v4(), a2, true), f2 = new Ii();
    f2.m02 = i.x, f2.m12 = i.y;
    const g2 = new ye(i.width, i.height), m2 = new Hi(new G(), h2, e, Vt.Rectangle, f2, o2, g2, new G(u));
    bd(m2);
    const _2 = new Ji(1, 216, 216, 216), y2 = new es(new G(), v4(), true, xt.Pattern, _2);
    y2.imageRef = n2, y2.originalImageWidth = r.width, y2.originalImageHeight = r.height, y2.imageScaleMode = Mt.Fill, y2.setImageMgr(s);
    const x2 = new G();
    return x2.push(y2), m2.style.fills = x2, m2;
}
function Hd(e, i, s, r, n2) {
    wd(i);
    const o2 = new Ii();
    o2.m02 = i.x, o2.m12 = i.y;
    const a2 = new ye(i.width, i.height), h2 = new Ea(new G(), v4(), e, Vt.Table, o2, Id(), a2, new Y(), new G(), new G());
    for (let e2 = 0; e2 < s; e2++) h2.rowHeights.push(new Ce(v4(), [e2], 1));
    for (let e2 = 0; e2 < r; e2++) h2.colWidths.push(new Ce(v4(), [e2], 1));
    h2.transform.m02 = i.x, h2.transform.m12 = i.y, h2.size.width = i.width, h2.size.height = i.height, h2.style.borders.push(new ts([0], v4(), true, xt.SolidColor, new Ji(0.5, 0, 0, 0), ht.Center, 1, new Kt(0, 0), ut.Miter, new Me(Dt.Normal, 1, 1, 1, 1))), bd(h2);
    const c2 = new Ji(1, 255, 255, 255), l2 = new es([0], v4(), true, xt.SolidColor, c2), d2 = new G();
    return d2.push(l2), h2.style.fills = d2, h2.setImageMgr(n2), h2;
}
function Wd(e, i, s) {
    wd(i);
    const r = kd();
    r.endMarkerType = Ct.OpenArrow;
    const n2 = new se([0], v4(), 0, 0, ft.Straight), o2 = new se([1], v4(), 0, 0, ft.Straight), a2 = new G(n2, o2), h2 = new Me(Dt.Normal, 2, 2, 2, 2), c2 = new ts([0], v4(), true, xt.SolidColor, new Ji(1, 128, 128, 128), ht.Center, 2, new Kt(0, 0), ut.Miter, h2);
    r.borders.push(c2);
    const l2 = new Ia(new G()), d2 = new Ta("添加文本\n", new G());
    d2.attr = new Ma(), d2.attr.minimumLineHeight = 24, l2.paras.push(d2);
    const p2 = new Ca(d2.length);
    p2.fontName = Ss() ? "PingFang SC" : "微软雅黑", p2.fontSize = 14, p2.color = new Ji(0.85, 0, 0, 0), d2.spans.push(p2);
    const u = new pe([0], v4(), a2, false), f2 = new Ii();
    f2.m02 = i.x, f2.m12 = i.y;
    const g2 = new ye(i.width, i.height), m2 = new Cs(new G(), v4(), e, Vt.Contact, f2, r, g2, new G(u), false, l2, false);
    return m2.from = s, m2.to = void 0, m2.fixedRadius = 12, bd(m2), m2;
}
function $d(e, i) {
    wd(i);
    const s = new G(), r = new G(), n2 = new is(s, r, new G()), o2 = new G(), a2 = v4(), h2 = new se([0], v4(), 0, 0, ft.Straight), c2 = new se([1], v4(), 1, 0, ft.Straight), l2 = new se([2], v4(), 1, 1, ft.Straight), d2 = new se([3], v4(), 0, 1, ft.Straight), p2 = new se([4], v4(), 0, 1e-5, ft.Straight);
    o2.push(h2, c2, l2, d2, p2);
    const u = new pe([0], v4(), o2, true), f2 = new Ii();
    f2.m02 = i.x, f2.m12 = i.y;
    const g2 = new ye(i.width, i.height), m2 = new Ie(new G(), 0, false, false, false, false), _2 = new Te(new G(), v4(), 0, gt.Png, "", mt.Prefix, 1, _t.Scale);
    m2.exportFormats.push(_2);
    const y2 = new Yi(new G(), a2, e, Vt.Cutout, f2, n2, g2, new G(u));
    return y2.exportOptions = m2, bd(y2), y2;
}
function Xd(e, i, s) {
    wd(i);
    const r = new Ii();
    r.m02 = i.x, r.m12 = i.y;
    const n2 = new ye(i.width, i.height), o2 = new Ni(new G(), v4(), e, Vt.Symbol, r, kd(), new G(), n2, new Y());
    return s && (o2.style = s), bd(o2), o2;
}
function Gd(e, i) {
    wd(i);
    const s = kd(), r = new Ii();
    r.m02 = i.x, r.m12 = i.y;
    const n2 = new ye(i.width, i.height), o2 = new zi(new G(), v4(), e, Vt.SymbolUnion, r, s, new G(), n2, new Y());
    return bd(o2), o2;
}
function Yd(e, i, s, r) {
    wd(i);
    const n2 = new Ii();
    n2.m02 = i.x, n2.m12 = i.y;
    const o2 = new ye(i.width, i.height), a2 = new Ar(new G(), v4(), e, Vt.SymbolRef, n2, kd(), o2, s, new Y());
    return bd(a2), a2.setSymbolMgr(r), a2;
}
function Ud(t4) {
    const e = { flipH: false, flipV: false, rotation: 0 };
    e.flipH = false, e.flipV = false;
    const i = t4.matrix2Root().inverse, s = new o(i);
    let r = s.m10, n2 = s.m00;
    e.flipH && (r = -r), e.flipV && (n2 = -n2);
    let a2 = Math.asin(r);
    return n2 < 0 && (a2 = r > 0 ? Math.PI - a2 : r < 0 ? -Math.PI - a2 : Math.PI), Number.isNaN(a2) || (e.rotation = a2 / (2 * Math.PI) * 360 % 360), e;
}
function Zd(t4, e) {
    const i = Ud(e), s = ki(t4.transform), r = t4.matrix2Parent().computeCoord2(t4.size.width / 2, t4.size.height / 2);
    i.flipH && s.flipH(r.x), i.flipV && s.flipV(r.y);
    let n2 = i.rotation;
    i.flipH && (n2 -= 180), i.flipV && (n2 -= 180), s.setRotateZ(n2 % 360 / 180 * Math.PI), Fi(t4.transform, s);
}
var jd = Object.freeze({ __proto__: null, addCommonAttr: bd, getTransformByEnv: Ud, initFrame: function(t4, e) {
        wd(e), t4.transform.m02 = e.x, t4.transform.m12 = e.y, t4.size.width = e.width, t4.size.height = e.height;
    }, modifyTransformByEnv: Zd, newArrowShape: Bd, newArtboard: Ed, newArtboard2: function(e, i) {
        wd(i), _d.id = v4(), _d.name = e, _d.transform.m02 = i.x, _d.transform.m12 = i.y, _d.size.width = i.width, _d.size.height = i.height;
        const s = Fo(_d), r = new Ji(1, 255, 255, 255), n2 = new es(new G(), v4(), true, xt.SolidColor, r);
        return s.style.fills.push(n2), bd(s), s.fixedRadius = 0, s;
    }, newBoolShape: Cd, newComment: function(e, i, s, r, n2, o2, a2, h2) {
        const c2 = v4();
        return new rs(s, c2, r, e, i, n2, o2, a2, h2);
    }, newContact: Wd, newCutoutShape: $d, newDefaultTextShape: Nd, newDocument: Md, newGroupShape: Sd, newImageFillShape: Dd, newImageShape: function(e, i, s, r) {
        wd(i);
        const n2 = v4(), o2 = Id(), a2 = new G(), h2 = new se([0], v4(), 0, 0, ft.Straight), c2 = new se([1], v4(), 1, 0, ft.Straight), l2 = new se([2], v4(), 1, 1, ft.Straight), d2 = new se([3], v4(), 0, 1, ft.Straight);
        a2.push(h2, c2, l2, d2);
        const p2 = new pe([0], v4(), a2, true), u = new Ii();
        u.m02 = i.x, u.m12 = i.y;
        const f2 = new ye(i.width, i.height), g2 = new Wi(new G(), n2, e, Vt.Image, u, o2, f2, new G(p2), r || "");
        return g2.setImageMgr(s), bd(g2), g2.style.fills.length = 0, g2;
    }, newLineShape: Pd, newOvalShape: Rd, newPage: vd, newPathShape: Ad, newPolygonShape: Od, newRectShape: Fd, newSolidColorFill: Td, newStellateShape: Ld, newStyle: Id, newSymbolRefShape: Yd, newSymbolShape: Xd, newSymbolShapeUnion: Gd, newTable: Hd, newText: ta, newText2: ea, newTextShape: zd, newTextShapeByText: Vd, newflatStyle: kd, polylinePointsToPathD: function(t4, e) {
        const i = /(-?\d*\.?\d+)[,\s]+(-?\d*\.?\d+)/g, s = [];
        let r;
        for (; null !== (r = i.exec(t4)); ) s.push([parseFloat(r[1]), parseFloat(r[2])]);
        if (!Array.isArray(s) || !e && s.length < 3 || s.length < 2) return "";
        let n2 = "M" + s[0][0] + "," + s[0][1];
        for (let t5 = 1; t5 < s.length; t5++) n2 += " L" + s[t5][0] + "," + s[t5][1];
        return e || (n2 += " Z"), n2;
    } });
class yp {
    constructor(t4) {
        __publicField(this, "storage");
        this.storage = t4;
    }
    loadRaw(t4, e) {
        return this.storage.get(t4, e);
    }
    loadJson(t4, e) {
        return new Promise((i, s) => {
            this.storage.get(t4, e).then((t5) => {
                const e2 = JSON.parse(new TextDecoder().decode(t5));
                i(e2);
            }).catch((t5) => {
                s(t5);
            });
        });
    }
}
class xp {
    constructor(t4, e) {
        __publicField(this, "remoteLoader");
        __publicField(this, "documentPath");
        this.remoteLoader = new yp(t4), this.documentPath = e;
    }
    setStorage(t4) {
        this.remoteLoader = new yp(t4);
    }
    async loadDocumentMeta(t4) {
        return Lo(await this.remoteLoader.loadJson(`${this.documentPath}/document-meta.json`, t4), void 0);
    }
    async loadPage(t4, e, i) {
        return zo(await this.remoteLoader.loadJson(`${this.documentPath}/pages/${e}.json`, i), t4);
    }
    async loadMedia(t4, e, i) {
        const s = await this.remoteLoader.loadRaw(`${this.documentPath}/medias/${e}`, i), r = s;
        let n2 = r.length;
        const o2 = new Array(n2);
        for (; n2--; ) o2[n2] = String.fromCharCode(r[n2]);
        const a2 = m(o2.join(""));
        let h2 = "";
        const c2 = e.substring(e.lastIndexOf(".") + 1);
        return "png" === c2 ? h2 = g("png", a2) : "gif" === c2 ? h2 = g("gif", a2) : "svg" === c2 ? h2 = g("svg", a2) : "jpeg" === c2 ? h2 = g("jpeg", a2) : console.log("imageExt", c2), { buff: s, base64: h2 };
    }
}
async function wp(t4, e, i, s, r) {
    const n2 = new xp(t4, e), o2 = await n2.loadDocumentMeta(s), a2 = new Map(o2.pagesList.map((t5) => [t5.id, t5.versionId])), h2 = o2.fmtVer ?? 0, c2 = new Oa(o2.id, o2.name, s, o2.lastCmdId, o2.pagesList, o2.symbolregist, r, o2.freesymbols);
    return c2.pagesMgr.setLoader((t5) => {
        const e2 = new class {
            constructor() {
                __publicField(this, "document", c2);
                __publicField(this, "curPage", t5);
                __publicField(this, "fmtVer", h2);
            }
        }();
        return n2.loadPage(e2, t5, a2.get(t5));
    }), c2.mediasMgr.setLoader((t5) => {
        const e2 = new class {
            constructor() {
                __publicField(this, "document", c2);
                __publicField(this, "curPage", "");
                __publicField(this, "fmtVer", h2);
            }
        }();
        return n2.loadMedia(e2, t5);
    }), { document: c2, loader: n2 };
}
function Sp(e, i) {
    for (let s = 0, r = e.length; s < r; s++) {
        const r2 = e[s];
        r2 && ((i == null ? void 0 : i.has(r2.id)) || (r2.id = v4()), r2.childs && r2.childs.length && Sp(r2.childs, i));
    }
}
class Cp {
    constructor() {
        __publicField(this, "symbols", /* @__PURE__ */ new Set());
        __publicField(this, "medias", /* @__PURE__ */ new Set());
        __publicField(this, "referenced", /* @__PURE__ */ new Set());
    }
}
function Tp(t4) {
    const e = new Cp(), i = [];
    for (let s = 0; s < t4.length; s++) {
        const r = t4[s], n2 = r.type;
        let o2;
        n2 === Vt.Rectangle ? o2 = gr(r, e) : n2 === Vt.Oval ? o2 = Mr(r, e) : n2 === Vt.Line ? o2 = br(r, e) : n2 === Vt.Image ? o2 = wr(r, e) : n2 === Vt.Text ? o2 = lr(r, e) : n2 === Vt.Path ? o2 = pr(r, e) : n2 === Vt.Path2 ? o2 = ur(r, e) : n2 === Vt.Artboard ? o2 = vr(r, e) : n2 === Vt.Group ? o2 = Cr(r, e) : n2 === Vt.Table ? o2 = cr(r, e) : n2 === Vt.Symbol ? o2 = Ir(r, e) : n2 === Vt.SymbolRef ? o2 = _r(r, e) : n2 === Vt.Contact ? o2 = yr(r, e) : n2 === Vt.Cutout ? o2 = xr(r, e) : n2 === Vt.SymbolUnion ? o2 = kr(r, e) : n2 === Vt.BoolShape ? o2 = Sr(r, e) : n2 === Vt.Star ? o2 = mr(r, e) : n2 === Vt.Polygon && (o2 = fr(r, e)), o2 && i.push(o2);
    }
    return { shapes: i, ctx: e };
}
function Ip(e, i, s, r) {
    const n2 = new class {
        constructor() {
            __publicField(this, "document", e);
            __publicField(this, "curPage", i.id);
            __publicField(this, "fmtVer", rn);
        }
    }(), o2 = [], a2 = function(e2) {
        var _a2, _b;
        const i2 = /* @__PURE__ */ new Set(), s2 = /* @__PURE__ */ new Map(), r2 = [];
        if (function t4(e3) {
            for (let i3 = 0, n4 = e3.length; i3 < n4; i3++) {
                const n5 = e3[i3];
                if (s2.set(n5.id, n5), n5.type === Vt.Contact && r2.push(n5), n5.type === Vt.Group || n5.type === Vt.Artboard) {
                    t4(n5.childs);
                }
            }
        }(e2), !r2.length) return i2;
        const n3 = [];
        for (let t4 = 0, e3 = r2.length; t4 < e3; t4++) {
            const e4 = r2[t4], i3 = s2.get(((_a2 = e4.from) == null ? void 0 : _a2.shapeId) || "") || void 0, o4 = s2.get(((_b = e4.to) == null ? void 0 : _b.shapeId) || "") || void 0;
            n3.push({ contact: e4, from: i3, to: o4 });
        }
        const o3 = /* @__PURE__ */ new Set();
        for (let e3 = 0, s3 = n3.length; e3 < s3; e3++) {
            const { contact: s4, from: r3, to: a3 } = n3[e3];
            r3 ? o3.has(r3) ? s4.from.shapeId = r3.id : (r3.id = v4(), s4.from.shapeId = r3.id, i2.add(r3.id), o3.add(r3)) : s4.from = void 0, a3 ? o3.has(a3) ? s4.to.shapeId = a3.id : (a3.id = v4(), s4.to.shapeId = a3.id, i2.add(a3.id), o3.add(a3)) : s4.to = void 0;
        }
        return i2;
    }(s);
    try {
        for (let i2 = 0, r2 = s.length; i2 < r2; i2++) {
            const r3 = s[i2], h2 = r3.type;
            let c2;
            if (h2 !== Vt.Symbol) {
                if (a2.has(r3.id) || (r3.id = v4()), h2 === Vt.Rectangle) c2 = _o(r3, n2);
                else if (h2 === Vt.Oval) c2 = Eo(r3, n2);
                else if (h2 === Vt.Line) c2 = Io(r3, n2);
                else if (h2 === Vt.Image) c2 = Co(r3, n2);
                else if (h2 === Vt.Text) c2 = ho(r3, n2);
                else if (h2 === Vt.Path) c2 = po(r3, n2);
                else if (h2 === Vt.Path2) c2 = uo(r3, n2);
                else if (h2 === Vt.Artboard) {
                    const t4 = r3.childs;
                    t4 && t4.length && Sp(t4, a2), c2 = Fo(r3, n2);
                } else if (h2 === Vt.Group) {
                    const t4 = r3.childs;
                    t4 && t4.length && Sp(t4, a2), c2 = Bo(r3, n2);
                } else if (h2 === Vt.Table) {
                    const t4 = r3.childs;
                    t4 && t4.length && Sp(t4, a2), c2 = ao(r3, n2);
                } else if (h2 === Vt.SymbolRef) {
                    if (!e.symbolsMgr.get(r3.refId)) continue;
                    c2 = wo(r3, n2);
                } else if (h2 === Vt.Contact) c2 = bo(r3, n2);
                else if (h2 === Vt.Cutout) c2 = vo(r3, n2);
                else if (h2 === Vt.SymbolUnion) {
                    const t4 = r3.childs;
                    if (!Array.isArray(t4)) continue;
                    let i3 = true;
                    for (let s2 = 0; s2 < t4.length; ++s2) {
                        const r4 = t4[s2].id, n3 = e.symbolregist.get(r4), o3 = e.symbolsMgr.get(r4);
                        if (n3 && "freesymbols" !== n3 || !n3 && o3) {
                            i3 = false;
                            break;
                        }
                    }
                    i3 || Sp(t4, a2), c2 = Wo(r3, n2);
                } else if (h2 === Vt.BoolShape) {
                    const t4 = r3.childs;
                    t4 && t4.length && Sp(t4, a2), c2 = Oo(r3, n2);
                } else h2 === Vt.Star ? c2 = xo(r3, n2) : h2 === Vt.Polygon && (c2 = go(r3, n2));
                c2 && o2.push(c2);
            } else {
                const t4 = e.symbolregist.get(r3.id), i3 = e.symbolsMgr.get(r3.id);
                if (!t4 && !i3 || "freesymbols" === t4) {
                    c2 = Do(r3, n2), o2.push(c2);
                    continue;
                }
                if (!i3) continue;
                const s2 = new _e(r3.transform.m02, r3.transform.m12, r3.size.width, r3.size.height);
                if (r3 instanceof zi) {
                    const t5 = r3.childs[0];
                    if (!t5) continue;
                    s2.width = t5.size.width, s2.height = t5.size.height;
                }
                if (c2 = Yd(r3.name, s2, r3.id, e.symbolsMgr), c2) {
                    const t5 = c2.transform, e2 = r3.transform;
                    t5.m00 = e2.m00, t5.m01 = e2.m01, t5.m10 = e2.m10, t5.m11 = e2.m11, o2.push(c2);
                }
            }
        }
        Lp(e, r);
    } catch (t4) {
        console.log(t4);
    }
    return o2;
}
function kp(t4, e, i) {
    return Ip(t4, e, Tp(i).shapes);
}
function Ep(t4) {
    return or(t4);
}
function Ap(t4, e, i) {
    if (i) {
        return Vd(e.paras[0].text || "text", e);
    }
    return ro(e);
}
function Rp(t4) {
    const e = [], i = [];
    for (let s = 0; s < t4.length; s++) e.push(t4[s].x), i.push(t4[s].y);
    return { top: Math.min(...i), bottom: Math.max(...i), left: Math.min(...e), right: Math.max(...e) };
}
function Lp(t4, e) {
    if (!e) return;
    Array.from(Object.keys(e) || []).forEach((i) => {
        const s = e[i];
        if (!s) return;
        if (t4.mediasMgr.getSync(i)) return void delete e[i];
        const r = atob(s.split("base64,")[1]), n2 = new Uint8Array(r.length);
        for (let t5 = 0; t5 < r.length; t5++) n2[t5] = r.charCodeAt(t5);
        const o2 = { base64: s, buff: n2 };
        e[i] = o2, e[i] = o2, t4.mediasMgr.add(i, o2);
    });
}
var Np, zp;
function Vp(t4, e) {
    if (t4.length !== e.length) return true;
    for (let i = 0; i < t4.length; ++i) if (t4[i] !== e[i]) return true;
    return false;
}
function Dp(t4, e) {
    if (t4.shapes.length !== e.shapes.length) return true;
    if (Vp(t4.shapes, e.shapes)) return true;
    if (t4.table === e.table && t4.text === e.text) return false;
    if (t4.table && e.table) {
        const i = t4.table, s = e.table;
        if (i.isRowOrCol !== s.isRowOrCol || i.rows.length !== s.rows.length || i.cols.length !== s.cols.length) return true;
        if (Vp(i.rows, s.rows)) return true;
        if (Vp(i.cols, s.cols)) return true;
    } else if (t4.table !== e.table) return true;
    if (t4.text && e.text) {
        if (t4.text.start !== e.text.start || t4.text.length !== e.text.length) return true;
    } else if (t4.text !== e.text) return true;
    return false;
}
function Hp(t4) {
    return { shapes: t4.shapes, table: t4.table, text: t4.text ? t4.text.clone() : void 0 };
}
!function(t4) {
    t4[t4.None = 0] = "None", t4[t4.TextInsert = 1] = "TextInsert", t4[t4.TextDelete = 2] = "TextDelete";
}(Np || (Np = {})), function(t4) {
    t4[t4.None = 0] = "None", t4[t4.Array = 1] = "Array", t4[t4.Idset = 2] = "Idset", t4[t4.CrdtArr = 3] = "CrdtArr", t4[t4.CrdtTree = 4] = "CrdtTree";
}(zp || (zp = {}));
const Wp = 1e-6, $p = 1e-9, Xp = 2e-9, Gp = 1e9;
function Yp(t4) {
    const e = Math.round(t4 * Gp) / Gp;
    if (!Number.isFinite(e)) throw new Error("Infinity");
    return e;
}
function Up(t4, e) {
    if (e < 0 || e > t4.length) throw new Error("index out of range");
    return function(t5, e2) {
        if (void 0 === t5 && void 0 === e2) {
            const t6 = new G();
            return t6.push(Yp(Math.random())), { valid: true, index: t6 };
        }
        if (void 0 === t5) {
            if (void 0 === e2) throw new Error("nextIndex is undefined");
            const t6 = new G();
            return t6.push(Yp((e2[0] ?? 0) - 1 - Math.random())), { valid: true, index: t6 };
        }
        if (void 0 === e2) {
            if (void 0 === t5) throw new Error("preIndex is undefined");
            const e3 = new G();
            return e3.push(Yp((t5[0] ?? 0) + 1 + Math.random())), { valid: true, index: e3 };
        }
        const i = Math.min(t5.length, e2.length);
        let s = 0;
        for (; s < i && t5[s] === e2[s]; ) ++s;
        if (s === i && t5.length === e2.length) return { valid: false, index: t5.slice(0) };
        const r = t5.slice(0, s);
        if (s === t5.length) {
            if (t5.length > e2.length) throw new Error();
            return r.push(Yp(e2[s] - 1 - Math.random())), { valid: true, index: r };
        }
        if (s === e2.length) return r.push(Yp(t5[s] + 1 + Math.random())), { valid: true, index: r };
        const n2 = e2[s] - t5[s];
        if (n2 >= Wp) {
            const e3 = $p + (n2 - Xp) * Math.random();
            return r.push(Yp(t5[s] + e3)), { valid: true, index: r };
        }
        return r.push(t5[s]), t5.length > s + 1 ? (r.push(Yp(t5[s + 1] + 1 + Math.random())), { valid: true, index: r }) : (r.push(Yp(Math.random())), { valid: true, index: r });
    }(e > 0 ? t4[e - 1].crdtidx : void 0, e < t4.length ? t4[e].crdtidx : void 0);
}
function Zp(t4, e, i) {
    if ("string" == typeof i) throw new Error("import data first!");
    const s = e.id, r = t4.findIndex((t5) => t5.id === s), n2 = t4[r];
    if (!i) {
        if (r < 0) return;
        i = t4[r];
    }
    const o2 = r >= 0 ? i.crdtidx : void 0;
    o2 && t4.splice(r, 1);
    const a2 = e.to;
    if (!a2) return { type: e.type, id: e.id, path: e.path, data: void 0, to: void 0, from: o2, origin: n2, target: t4, data2: void 0 };
    const h2 = function(t5, e2) {
        let i2 = 0, s2 = t5.length;
        for (; i2 < s2; ) {
            const r2 = Math.floor((i2 + s2) / 2);
            Jp(t5[r2].crdtidx, e2) >= 0 ? s2 = r2 : i2 = r2 + 1;
        }
        return i2;
    }(t4, a2);
    return i.crdtidx = a2, t4.splice(h2, 0, i), i = t4[h2], { type: e.type, id: e.id, path: e.path, data: o2 ? void 0 : i, to: a2, from: o2, origin: n2, target: t4, data2: o2 ? void 0 : i };
}
function jp(t4, e, i) {
    if ("string" == typeof i) throw new Error("import data first!");
    const s = e.id, r = i && i.parent, n2 = r ? r.childs.findIndex((t5) => t5.id === s) : -1, o2 = e.to;
    if (!o2) {
        if (n2 < 0) return;
        const s2 = n2;
        r.childs.splice(s2, 1);
        const o3 = i.crdtidx, a3 = { id: r.id, index: o3 };
        return { type: e.type, id: e.id, path: e.path, data: void 0, to: void 0, from: a3, origin: i, target: t4, data2: void 0 };
    }
    const a2 = o2.id, h2 = t4.getShape(a2);
    if (h2) {
        let t5 = h2;
        for (; t5; ) {
            if (t5.id === s) return;
            t5 = t5.parent;
        }
    }
    let c2;
    if (n2 >= 0) {
        const t5 = n2;
        r.childs.splice(t5, 1);
        const e2 = i.crdtidx;
        c2 = { id: r.id, index: e2 };
    }
    if (!h2) {
        if (!c2) return;
        return { type: e.type, id: e.id, path: e.path, data: void 0, to: void 0, from: c2, origin: i, target: t4, data2: void 0 };
    }
    if (!h2.childs) throw new Error("toParent.childs is undefined");
    const l2 = Zp(h2.childs, { id: e.id, path: e.path, type: zp.CrdtArr, data: i, to: o2.index }, i);
    if (!l2) {
        if (!c2) return;
        return { type: e.type, id: e.id, path: e.path, data: void 0, to: void 0, from: c2, origin: i, target: t4, data2: void 0 };
    }
    return { type: e.type, id: e.id, path: e.path, data: c2 ? void 0 : l2.data, to: l2.to ? o2 : void 0, from: c2, origin: l2.origin, target: t4, data2: l2.data };
}
function Jp(t4, e) {
    const i = Math.min(t4.length, e.length);
    for (let s = 0; s < i; s++) if (t4[s] !== e[s]) return t4[s] - e[s];
    return (t4[i] ?? 0) - (e[i] ?? 0);
}
const Kp = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
class qp {
    constructor(t4, e = Kp) {
        __publicField(this, "radix");
        __publicField(this, "radixChars");
        __publicField(this, "radixCharsMap");
        if (t4 < 2 || t4 > e.length) throw new Error("radix的取值必须在2-RadixChars.length之间");
        this.radix = t4, this.radixChars = e, this.radixCharsMap = /* @__PURE__ */ new Map();
        for (let t5 = 0; t5 < e.length; t5++) this.radixCharsMap.set(e[t5], t5);
    }
    from(t4) {
        let e = BigInt(t4);
        if (0n === e) return this.radixChars[0];
        if (e < 0n) return "-" + this.from(-e);
        let i = "";
        for (; e > 0n; ) i = this.radixChars[Number(e % BigInt(this.radix))] + i, e /= BigInt(this.radix);
        return i;
    }
    to(t4) {
        if ("-" === t4[0]) return -this.to(t4.slice(1));
        let e = BigInt(0);
        for (let i = 0; i < t4.length; i++) e = e * BigInt(this.radix) + BigInt(this.radixCharsMap.get(t4[i]) || 0);
        return e;
    }
}
var Qp, tu;
!function(t4) {
    const e = Kp, i = new qp(e.length, e);
    t4.MAX_SAFE_INTEGER = "HXmza2ckz6v";
    const s = {};
    for (let t5 = 0; t5 < e.length; ++t5) s[e[t5]] = t5;
    function r(t5, e2) {
        if (0 === t5.length || 1 === t5.length && "0" === t5[0]) {
            if (0 === e2.length) return 0;
            if (1 === e2.length && "0" === e2[0]) return 0;
        }
        if (t5.length === e2.length) for (let i2 = 0; i2 < t5.length; ++i2) {
            const r2 = s[t5[i2]] - s[e2[i2]];
            if (0 !== r2) return r2;
        }
        return t5.length - e2.length;
    }
    t4.comp = function(t5, e2) {
        return "-" === t5[0] ? "-" === e2[0] ? -r(t5.slice(1), e2.slice(1)) : -1 : "-" === e2[0] ? 1 : r(t5, e2);
    }, t4.minus = function(t5, e2) {
        return i.from(i.to(t5) - BigInt(e2));
    }, t4.toString = function(t5) {
        if (0 === t5) return "0";
        const i2 = e.length, s2 = t5 < 0;
        s2 && (t5 = -t5);
        const r2 = [];
        for (; t5 > 0; ) {
            const s3 = t5 % i2;
            r2.push(e[s3]), t5 = Math.floor(t5 / i2);
        }
        return s2 && r2.push("-"), r2.reverse().join("");
    };
}(Qp || (Qp = {})), function(t4) {
    t4[t4.None = 0] = "None", t4[t4.Insert = 1] = "Insert", t4[t4.Remove = 2] = "Remove", t4[t4.Attr = 3] = "Attr", t4[t4.Selection = 4] = "Selection";
}(tu || (tu = {}));
class eu {
    constructor(t4, e, i, s, r, n2) {
        __publicField(this, "id");
        __publicField(this, "path");
        __publicField(this, "type");
        __publicField(this, "order");
        __publicField(this, "start");
        __publicField(this, "length");
        __publicField(this, "type1");
        this.id = t4, this.path = e, this.type = zp.Array, this.order = i, this.start = s, this.length = r, this.type1 = n2;
    }
    transBy(t4) {
        return this;
    }
}
class iu extends eu {
    constructor(t4, e, i) {
        super(t4, e, i, -1, 0, tu.None);
    }
}
class su extends eu {
    constructor(t4, e, i, s, r) {
        super(t4, e, i, s, r, tu.Insert);
    }
    clone() {
        return new su(this.id, this.path, this.order, this.start, this.length);
    }
    _transByInsert(t4) {
        const e = t4.start;
        let i = this.start;
        if (e > i) return this;
        if (e < i) i += t4.length;
        else {
            const e2 = Qp.comp(t4.order, this.order);
            if (e2 < 0) i += t4.length;
            else if (0 === e2) throw new Error();
        }
        const s = this.clone();
        return s.start = i, s;
    }
    _transByRemove(t4) {
        const e = t4.start, i = t4.length, s = this.start;
        if (e >= s) return this;
        if (e + i <= s) {
            const t5 = this.clone();
            return t5.start -= i, t5;
        }
        return new iu(this.id, this.path, this.order);
    }
    _transByAttr(t4) {
        return this;
    }
    _transBySelection(t4) {
        return this;
    }
    transBy(t4) {
        switch (t4.type1) {
            case tu.None:
                return this;
            case tu.Insert:
                return this._transByInsert(t4);
            case tu.Remove:
                return this._transByRemove(t4);
            case tu.Attr:
                return this._transByAttr(t4);
            case tu.Selection:
                return this._transBySelection(t4);
        }
    }
}
class ru extends eu {
    constructor(t4, e, i, s, r) {
        super(t4, e, i, s, r, tu.Remove);
    }
    clone() {
        return new ru(this.id, this.path, this.order, this.start, this.length);
    }
    _transByInsert(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = s + this.length;
        if (e <= s) {
            const t5 = this.clone();
            return t5.start += i, t5;
        }
        if (e < r) {
            const t5 = this.clone();
            return t5.length += i, t5;
        }
        return this;
    }
    _transByRemove(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = this.length;
        if (e + i <= s) {
            const t5 = this.clone();
            return t5.start -= i, t5;
        }
        if (e >= s + r) return this;
        if (e <= s && e + i >= s + r) return new iu(this.id, this.path, this.order);
        if (e >= s && e + i <= s + r) {
            const t5 = this.clone();
            return t5.length -= i, t5;
        }
        if (e < s) {
            const r2 = this.clone(), n2 = e + i - s;
            return r2.start -= t4.length - n2, r2.length -= n2, r2;
        }
        if (e > s) {
            const t5 = this.clone(), i2 = s + r - e;
            return t5.length -= i2, t5;
        }
        throw new Error("Cant be here");
    }
    _transByAttr(t4) {
        return this;
    }
    _transBySelection(t4) {
        return this;
    }
    transBy(t4) {
        switch (t4.type1) {
            case tu.None:
                return this;
            case tu.Insert:
                return this._transByInsert(t4);
            case tu.Remove:
                return this._transByRemove(t4);
            case tu.Attr:
                return this._transByAttr(t4);
            case tu.Selection:
                return this._transBySelection(t4);
        }
    }
}
class nu extends eu {
    constructor(t4, e, i, s, r) {
        super(t4, e, i, s, r, tu.Attr);
    }
    clone() {
        return new nu(this.id, this.path, this.order, this.start, this.length);
    }
    _transByInsert(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = this.length;
        if (e > s && e < s + r) {
            const t5 = this.clone();
            return t5.length += i, t5;
        }
        if (e <= s) {
            const t5 = this.clone();
            return t5.start += i, t5;
        }
        return this;
    }
    _transByRemove(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = this.length;
        if (e + i <= s) {
            const t5 = this.clone();
            return t5.start -= i, t5;
        }
        if (e >= s + r) return this;
        if (e <= s && e + i >= s + r) return new iu(this.id, this.path, this.order);
        if (e >= s && e + i <= s + r) {
            const t5 = this.clone();
            return t5.length -= i, t5;
        }
        if (e < s) {
            const r2 = this.clone(), n2 = e + i - s;
            return r2.start -= t4.length - n2, r2.length -= n2, r2;
        }
        if (e > s) {
            const t5 = this.clone(), r2 = e + i - s;
            return t5.length -= r2, t5;
        }
        throw new Error("Cant be here");
    }
    _transByAttr(t4) {
        return this;
    }
    _transBySelection(t4) {
        return this;
    }
    transBy(t4) {
        switch (t4.type1) {
            case tu.None:
                return this;
            case tu.Insert:
                return this._transByInsert(t4);
            case tu.Remove:
                return this._transByRemove(t4);
            case tu.Attr:
                return this._transByAttr(t4);
            case tu.Selection:
                return this._transBySelection(t4);
        }
    }
}
class ou extends eu {
    constructor(t4, e, i, s, r) {
        super(t4, e, i, s, r, tu.Selection);
    }
    clone() {
        return new ou(this.id, this.path, this.order, this.start, this.length);
    }
    _transByInsert(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = this.length;
        if (e > s && e < s + r) {
            const t5 = this.clone();
            return t5.length += i, t5;
        }
        if (e <= s) {
            const t5 = this.clone();
            return t5.start += i, t5;
        }
        return this;
    }
    _transByRemove(t4) {
        const e = t4.start, i = t4.length, s = this.start, r = this.length;
        if (e + i <= s) {
            const t5 = this.clone();
            return t5.start -= i, t5;
        }
        if (e >= s + r) return this;
        if (e <= s && e + i >= s + r) return new ou(this.id, this.path, this.order, e, 0);
        if (e >= s && e + i <= s + r) {
            const t5 = this.clone();
            return t5.length -= i, t5;
        }
        if (e < s) {
            const r2 = this.clone(), n2 = e + i - s;
            return r2.start -= t4.length - n2, r2.length -= n2, r2;
        }
        if (e > s) {
            const t5 = this.clone(), r2 = e + i - s;
            return t5.length -= r2, t5;
        }
        throw new Error("Cant be here");
    }
    _transByAttr(t4) {
        return this;
    }
    _transBySelection(t4) {
        return this;
    }
    transBy(t4) {
        switch (t4.type1) {
            case tu.None:
                return this;
            case tu.Insert:
                return this._transByInsert(t4);
            case tu.Remove:
                return this._transByRemove(t4);
            case tu.Attr:
                return this._transByAttr(t4);
            case tu.Selection:
                return this._transBySelection(t4);
        }
    }
}
class au extends su {
    constructor(t4, e, i, s, r, n2) {
        super(t4, e, i, s, r);
        __publicField(this, "text");
        this.text = n2;
    }
    clone() {
        return new au(this.id, this.path, this.order, this.start, this.length, this.text);
    }
    static parse(t4) {
        const e = t4.text;
        let i;
        if ("simple" === e.type) {
            let t5;
            e.props && (e.props.attr || e.props.paraAttr) && (t5 = {}, e.props.attr && (t5.attr = Un(e.props.attr)), e.props.paraAttr && (t5.paraAttr = Qn(e.props.paraAttr))), i = { type: "simple", text: e.text, props: t5 };
        } else i = { type: "complex", text: ro(e.text) };
        return new au(t4.id, t4.path, t4.order, t4.start, t4.length, i);
    }
}
class hu extends au {
    constructor(t4, e, i, s, r, n2, o2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "target");
        this.target = o2;
    }
    clone() {
        return new hu(this.id, this.path, this.order, this.start, this.length, this.text, this.target);
    }
}
class cu extends ru {
    clone() {
        return new cu(this.id, this.path, this.order, this.start, this.length);
    }
    static parse(t4) {
        return new cu(t4.id, t4.path, t4.order, t4.start, t4.length);
    }
}
class lu extends cu {
    constructor(t4, e, i, s, r, n2, o2) {
        super(t4, e, i, s, r);
        __publicField(this, "text");
        __publicField(this, "target");
        this.text = n2, this.target = o2;
    }
    clone() {
        return new lu(this.id, this.path, this.order, this.start, this.length, this.text, this.target);
    }
}
class du extends nu {
    constructor(t4, e, i, s, r, n2) {
        super(t4, e, i, s, r);
        __publicField(this, "props");
        this.props = n2;
    }
    clone() {
        return new du(this.id, this.path, this.order, this.start, this.length, this.props);
    }
    static parse(t4) {
        return new du(t4.id, t4.path, t4.order, t4.start, t4.length, t4.props);
    }
}
class pu extends du {
    constructor(t4, e, i, s, r, n2, o2, a2) {
        super(t4, e, i, s, r, n2);
        __publicField(this, "origin");
        __publicField(this, "target");
        this.target = a2;
        const h2 = o2.findIndex((t5) => t5.value !== n2.value), c2 = [];
        if (h2 >= 0) {
            c2.push(o2[h2]);
            let t5 = o2[h2];
            for (let e2 = h2 + 1; e2 < o2.length; ++e2) {
                const i2 = o2[e2];
                i2.index === t5.index + t5.len && i2.value === t5.value ? t5.len += i2.len : i2.value !== n2.value && (c2.push(i2), t5 = i2);
            }
        }
        this.origin = c2;
    }
    _cloneOrigin() {
        return this.origin.map((t4) => ({ index: t4.index, len: t4.len, value: t4.value }));
    }
    _clone(t4) {
        return new pu(this.id, this.path, this.order, this.start, this.length, this.props, t4, this.target);
    }
    clone() {
        return this._clone(this._cloneOrigin());
    }
    _transByInsert(t4) {
        const e = super._transByInsert(t4), i = t4.start, s = t4.length;
        let r = e.origin;
        for (let t5 = 0; t5 < r.length; ++t5) {
            const e2 = r[t5], n2 = e2.index, o2 = e2.len;
            if (i > n2 && i < n2 + o2) {
                r === this.origin && (r = this._cloneOrigin());
                r[t5].len += s;
            } else if (i <= n2) {
                r === this.origin && (r = this._cloneOrigin());
                r[t5].index += s;
            } else ;
        }
        return e !== this ? e : r === this.origin ? this : this._clone(r);
    }
    _transByRemove(t4) {
        const e = super._transByRemove(t4);
        if (e.type1 !== tu.Attr) return e;
        const i = t4.start, s = t4.length;
        let r = e.origin;
        for (let e2 = 0; e2 < r.length; ++e2) {
            const n2 = r[e2], o2 = n2.index, a2 = n2.len;
            if (i + s <= o2) {
                r === this.origin && (r = this._cloneOrigin());
                r[e2].index -= s;
            } else if (!(i >= o2 + a2)) if (i <= o2 && i + s >= o2 + a2) {
                r === this.origin && (r = this._cloneOrigin());
                const t5 = r[e2];
                t5.index = -1, t5.len = -1;
            } else if (i >= o2 && i + s <= o2 + a2) {
                r === this.origin && (r = this._cloneOrigin());
                r[e2].len -= s;
            } else if (i < o2) {
                r === this.origin && (r = this._cloneOrigin());
                const n3 = r[e2], a3 = i + s - o2;
                n3.index -= t4.length - a3, n3.len -= a3;
            } else {
                if (!(i > o2)) throw new Error("Cant be here");
                {
                    r === this.origin && (r = this._cloneOrigin());
                    const t5 = i + s - o2;
                    r[e2].len -= t5;
                }
            }
        }
        return e !== this ? e : r === this.origin ? this : this._clone(r);
    }
}
function uu(t4) {
    return JSON.stringify(t4, (t5, e) => {
        if (!t5.startsWith("__")) return "childs" === t5 && Array.isArray(e) && e.length > 0 && e[0] instanceof Oi ? [] : e;
    });
}
function fu(t4, e, i) {
    console.log("_crdtFixShapeIndex", e, i);
    const s = [], r = e.childs[i];
    if (!r) return;
    let n2 = Up(e.childs, i + 1);
    if (!n2.valid) {
        const r2 = fu(t4, e, i + 1);
        if (Array.isArray(r2) ? s.push(...r2) : r2 && s.push(r2), n2 = Up(e.childs, i + 1), !n2.valid) throw new Error();
    }
    const o2 = r.crdtidx;
    return r.crdtidx = n2.index, s.push({ id: r.id, type: zp.CrdtTree, path: t4.getCrdtPath(), data: void 0, from: { id: e.id, index: o2 }, to: { id: e.id, index: n2.index }, origin: void 0, target: t4, data2: r }), s;
}
function gu(t4, e, i) {
    let s;
    return t4 instanceof Map ? (s = t4.get(e), void 0 !== i ? t4.set(e, i) : t4.delete(e)) : t4 instanceof Z ? (s = t4.getSync(e), void 0 !== i && t4.add(e, i)) : (s = t4[e], t4[e] = i), { id: e, type: zp.Idset, path: t4.getCrdtPath().concat(e), data: "object" == typeof i ? JSON.stringify(i, (t5, e2) => t5.startsWith("__") ? void 0 : e2) : i, origin: s, target: t4, data2: i };
}
function mu(t4) {
    const e = new Ia(new G()), i = new Ta(t4 + "\n", new G());
    e.paras.push(i);
    const s = new Ca(i.length);
    return i.spans.push(s), e;
}
function _u(t4, e, i, s, r) {
    if ("string" == typeof e) {
        if (!(t4 instanceof Ri)) throw new Error("something wrong");
        e = mu(e), t4.value = e;
    }
    return "simple" === ("string" == typeof s ? "simple" : "complex") ? (e.insertText(s, i, r), new hu("", e.getCrdtPath(), Qp.MAX_SAFE_INTEGER, i, s.length, { type: "simple", text: s, props: r }, e)) : (e.insertFormatText(s, i), new hu("", e.getCrdtPath(), Qp.MAX_SAFE_INTEGER, i, s.length, { type: "complex", text: s }, e));
}
function yu(t4, e, i, s, r, n2) {
    if ("string" == typeof e) {
        if (!(t4 instanceof Ri)) throw new Error("something wrong");
        e = mu(e), t4.value = e;
    }
    s = Math.min(e.length, s);
    const o2 = e.formatText(i, s, r, n2);
    return new pu("", e.getCrdtPath(), Qp.MAX_SAFE_INTEGER, i, s, { target: "span", key: r, value: n2 }, o2, e);
}
function xu(t4, e, i, s, r, n2) {
    if (s = Math.min(e.length, s), "string" == typeof e) {
        if (!(t4 instanceof Ri)) throw new Error("something wrong");
        e = mu(e), t4.value = e;
    }
    let o2;
    return o2 = "bulletNumbersType" === r ? e.setBulletNumbersType(n2, i, s) : "bulletNumbersStart" === r ? e.setBulletNumbersStart(n2, i, s) : "bulletNumbersBehavior" === r ? e.setBulletNumbersBehavior(n2, i, s) : "indent" === r ? e.setParaIndent(n2, i, s) : e.formatPara(i, s, r, n2), new pu("", e.getCrdtPath(), Qp.MAX_SAFE_INTEGER, i, s, { target: "para", key: r, value: n2 }, o2, e);
}
function wu(t4, e, i) {
    if (e < 0 || e > t4.length) throw new Error("index out of range");
    const s = [];
    let r = Up(t4, e);
    if (!r.valid) {
        const i2 = vu(t4, e);
        if (Array.isArray(i2) ? s.push(...i2) : i2 && s.push(i2), r = Up(t4, e), !r.valid) throw new Error();
    }
    return i.crdtidx = r.index, t4.splice(e, 0, i), s.push({ id: i.id, type: zp.CrdtArr, path: t4.getCrdtPath(), data: "object" == typeof i ? JSON.stringify(i, (t5, e2) => t5.startsWith("__") ? void 0 : e2) : i, from: void 0, to: r.index, origin: void 0, target: t4, data2: i }), s;
}
function bu(t4, e) {
    if (e < 0 || e >= t4.length) throw new Error("index out of range");
    const i = t4[e];
    if (!i) return;
    const s = i.crdtidx;
    return t4.splice(e, 1), { id: i.id, type: zp.CrdtArr, path: t4.getCrdtPath(), data: void 0, from: s, to: void 0, origin: i, target: t4, data2: void 0 };
}
function Mu(t4, e, i) {
    if (e < 0 || e >= t4.length) throw new Error("index out of range");
    if (i < 0 || i > t4.length) throw new Error("index out of range");
    const s = t4[e];
    if (!s || Math.abs(e - i) <= 0) return;
    const r = [], n2 = s.crdtidx;
    let o2 = Up(t4, i);
    if (!o2.valid) {
        const e2 = vu(t4, i);
        if (Array.isArray(e2) ? r.push(...e2) : e2 && r.push(e2), o2 = Up(t4, i), !o2.valid) throw new Error();
    }
    return t4.splice(e, 1), e < i && --i, t4.splice(i, 0, s), r.push({ id: s.id, type: zp.CrdtArr, path: t4.getCrdtPath(), data: void 0, from: n2, to: o2.index, origin: void 0, target: t4, data2: void 0 }), r;
}
function vu(t4, e) {
    if (console.log("_crdtFixArrayIndex", t4, e), e < 0 || e > t4.length) throw new Error("index out of range");
    const i = t4[e];
    if (!i) return;
    const s = [];
    let r = Up(t4, e + 1);
    if (!r.valid) {
        const i2 = vu(t4, e + 1);
        if (Array.isArray(i2) ? s.push(...i2) : i2 && s.push(i2), r = Up(t4, e + 1), !r.valid) throw new Error();
    }
    const n2 = i.crdtidx;
    return i.crdtidx = r.index, s.push({ id: i.id, type: zp.CrdtArr, path: t4.getCrdtPath(), data: void 0, from: n2, to: r.index, origin: void 0, target: t4, data2: void 0 }), s;
}
function Su(t4, e, i) {
    return wu(t4, i, e);
}
function Cu(t4, e) {
    return bu(t4, e);
}
function Tu(t4, e, i) {
    return wu(t4, i, e);
}
function Iu(t4, e, i) {
    return wu(t4, i, e);
}
function ku(t4, e, i, s) {
    var _a2;
    const r = (_a2 = t4 == null ? void 0 : t4.pathsegs[s]) == null ? void 0 : _a2.points;
    if (r) return wu(r, i, e);
}
function Eu(t4, e, i) {
    let s;
    return t4 instanceof Oi ? (t4.exportOptions || (t4.exportOptions = new Ie(new G(), 0, false, false, false, false)), s = t4.exportOptions) : s = t4.value, wu(s.exportFormats, i, e);
}
function Au(t4, e) {
    return bu(t4.exportFormats, e);
}
function Fu(t4, e, i) {
    const s = t4.exportFormats[e];
    if (s) return gu(s, "scale", i);
}
function Ru(t4, e, i) {
    const s = t4.exportFormats[e];
    if (s) return gu(s, "name", i);
}
function Ou(t4, e, i) {
    const s = t4.exportFormats[e];
    if (s) return gu(s, "namingScheme", i);
}
function Lu(t4, e, i) {
    const s = t4.exportFormats[e];
    if (s) return gu(s, "fileFormat", i);
}
function Pu(t4, e, i) {
    return gu(t4.symbolregist, e, i);
}
function Bu(t4) {
    if (Number.isNaN(t4) || !Number.isFinite(t4)) throw new Error(String(t4));
}
function Nu(t4, e, i, s, r) {
    !function(t5) {
        if (!t5.hasSize()) return;
        const e2 = t5.size;
        if (0 === e2.width || 0 === e2.height) throw new Error();
        Bu(e2.width), Bu(e2.height);
    }(s);
    const n2 = [], o2 = (i2, s2, r2) => {
        let a2;
        s2 instanceof Li && (a2 = s2.childs.slice(0), s2.childs.length = 0);
        const h2 = function(t5, e2, i3, s3) {
            const r3 = [];
            let n3 = Up(e2.childs, s3);
            if (!n3.valid) {
                const i4 = fu(t5, e2, s3);
                if (Array.isArray(i4) ? r3.push(...i4) : i4 && r3.push(i4), n3 = Up(e2.childs, s3), !n3.valid) throw new Error();
            }
            return i3.crdtidx = n3.index, i3 = e2.addChildAt(i3, s3), r3.push({ id: i3.id, type: zp.CrdtTree, path: t5.getCrdtPath(), data: uu(i3), from: void 0, to: { id: e2.id, index: i3.crdtidx }, origin: void 0, target: t5, data2: i3 }), r3;
        }(e, i2, s2, r2);
        if (e.onAddShape(h2[h2.length - 1].data2, false), n2.push(...h2), a2) for (let t5 = 0; t5 < a2.length; ++t5) o2(s2, a2[t5], t5);
        s2 instanceof Ni && !(s2 instanceof zi) && (n2.push(Pu(t4, s2.id, e.id)), t4.freesymbols && t4.freesymbols.has(s2.id) && n2.push(gu(t4.freesymbols, s2.id, void 0)), t4.symbolsMgr.clearDuplicate(s2.id));
    };
    return o2(i, s, r), n2;
}
function zu(t4, e, i, s) {
    const r = [], n2 = (i2, s2, o3, a2) => {
        let h2;
        if (s2 instanceof Ni && !(a2 > 0 && i2 instanceof Ni)) {
            const i3 = new class {
                constructor() {
                    __publicField(this, "document", t4);
                    __publicField(this, "curPage", e.id);
                    __publicField(this, "fmtVer", rn);
                }
            }();
            h2 = s2 instanceof zi ? Wo(s2, i3) : Do(s2, i3);
        }
        if (s2 instanceof Li) {
            const t5 = s2.childs;
            for (let e2 = t5.length - 1; e2 >= 0; --e2) {
                const i3 = t5[e2];
                n2(s2, i3, e2, a2 + 1);
            }
        }
        const c2 = function(t5, e2, i3) {
            const s3 = e2.removeChildAt(i3);
            if (s3) return { id: s3.id, type: zp.CrdtTree, path: t5.getCrdtPath(), data: void 0, from: { id: e2.id, index: s3.crdtidx }, to: void 0, origin: s3, target: t5, data2: void 0 };
        }(e, i2, o3);
        c2 && (r.push(c2), s2 instanceof Ni && !(s2 instanceof zi) && (r.push(Pu(t4, s2.id, "freesymbols")), t4.symbolsMgr.clearDuplicate(s2.id)), h2 && (t4.freesymbols || (t4.freesymbols = new Y()), r.push(gu(t4.freesymbols, h2.id, h2)), t4.symbolsMgr.clearDuplicate(h2.id)), e.onRemoveShape(c2.origin, false));
    }, o2 = i.childs[s];
    return n2(i, o2, s, 0), r;
}
function Vu(t4, e, i, s, r) {
    const n2 = function(t5, e2, i2, s2, r2) {
        if (i2 === r2 && e2.id === s2.id) return;
        const n3 = e2.childs.splice(i2, 1)[0];
        if (!n3) return;
        const o2 = [];
        let a2 = Up(s2.childs, r2);
        if (!a2.valid) {
            const i3 = fu(t5, s2, r2);
            if (Array.isArray(i3) ? o2.push(...i3) : i3 && o2.push(i3), a2 = Up(e2.childs, r2), !a2.valid) throw new Error();
        }
        const h2 = n3.crdtidx;
        return n3.crdtidx = a2.index, s2.childs.splice(r2, 0, n3), o2.push({ id: n3.id, type: zp.CrdtTree, path: t5.getCrdtPath(), data: void 0, from: { id: e2.id, index: h2 }, to: { id: s2.id, index: a2.index }, origin: void 0, target: t5, data2: n3 }), o2;
    }(t4, e, i, s, r);
    return n2;
}
function Du(t4) {
    if (Number.isNaN(t4) || !Number.isFinite(t4)) throw new Error(String(t4));
}
function Hu(t4, e, i) {
    const s = [];
    return s.push(gu(e.transform, "m00", i.m00)), s.push(gu(e.transform, "m10", i.m10)), s.push(gu(e.transform, "m01", i.m01)), s.push(gu(e.transform, "m11", i.m11)), s.push(gu(e.transform, "m02", i.m02)), s.push(gu(e.transform, "m12", i.m12)), s;
}
function Wu(t4, e, i, s, r) {
    return _u(t4, e, s, i, r);
}
function $u(t4, e, i, s) {
    return _u(t4, e, s, i);
}
function Xu(t4, e, i, s) {
    return function(t5, e2, i2, s2) {
        if ("string" == typeof e2) {
            if (!(t5 instanceof Ri)) throw new Error("something wrong");
            e2 = mu(e2), t5.value = e2;
        }
        const r = e2.deleteText(i2, s2);
        return r && new lu("", e2.getCrdtPath(), Qp.MAX_SAFE_INTEGER, i2, r.length, r, e2);
    }(t4, e, i, s);
}
function Gu(t4, e) {
    e instanceof Vh && (e = e.data);
    const i = (e = e instanceof Oi ? e instanceof ka ? e.parent : e : function(t5) {
        let e2 = t5.parent;
        for (; e2 && !(e2 instanceof Oi); ) e2 = e2.parent;
        return e2;
    }(e)).id;
    if (!t4.getShape(i)) throw new Error("shape not inside page");
}
class Yu {
    constructor(t4) {
        __publicField(this, "repo");
        this.repo = t4;
    }
    get(t4, e, i) {
        const s = Reflect.get(t4, e, i);
        return "function" != typeof s ? s : (...e2) => {
            const i2 = this.repo.transactCtx.settrap;
            this.repo.transactCtx.settrap = false;
            try {
                return s.apply(t4, e2);
            } finally {
                this.repo.transactCtx.settrap = i2;
            }
        };
    }
}
class Uu {
    constructor() {
        __publicField(this, "cmd");
    }
    static create(t4) {
        return new Proxy(new Uu(), new Yu(t4));
    }
    start(t4, e, i = "") {
        this.cmd = { id: "", mergetype: Np.None, delay: 500, version: Qp.MAX_SAFE_INTEGER, previousVersion: "", baseVer: "", batchId: "", ops: [], isRecovery: false, description: i, time: 0, posttime: 0, saveselection: t4, selectionupdater: e, dataFmtVer: rn };
    }
    updateTextSelectionPath(t4) {
        var _a2, _b;
        ((_b = (_a2 = this.cmd) == null ? void 0 : _a2.saveselection) == null ? void 0 : _b.text) && (this.cmd.saveselection.text.path = t4);
    }
    updateTextSelectionRange(t4, e) {
        var _a2, _b;
        if ((_b = (_a2 = this.cmd) == null ? void 0 : _a2.saveselection) == null ? void 0 : _b.text) {
            const i = this.cmd.saveselection.text;
            i.start = t4, i.length = e;
        }
    }
    isNeedCommit() {
        return void 0 !== this.cmd && this.cmd.ops.length > 0;
    }
    rollback() {
        this.cmd = void 0;
    }
    commit(e = Np.None) {
        var _a2;
        const i = this.cmd;
        if (i && 0 !== i.ops.length) {
            if (i.id = v4(), i.time = Date.now(), i.mergetype = e, this.cmd = void 0, i.ops.length > 1) {
                const t4 = [], e2 = /* @__PURE__ */ new Map();
                for (let s = 0; s < i.ops.length; s++) {
                    const r = i.ops[s];
                    if (r.type === zp.Idset) {
                        const t5 = r.path.join(","), i2 = e2.get(t5);
                        i2 ? i2.data = r.data : e2.set(t5, r);
                    } else t4.push(r);
                }
                if (e2.size > 0) for (let [i2, s] of e2) {
                    const e3 = s;
                    e3.data !== e3.origin && t4.push(s);
                }
                if (t4.length < i.ops.length && (i.ops = t4), 0 === i.ops.length) return;
            }
            return ((_a2 = i.saveselection) == null ? void 0 : _a2.text) && i.ops.unshift(i.saveselection.text), i;
        }
    }
    addOp(t4) {
        if (!this.cmd) throw new Error("need start first");
        if (Array.isArray(t4)) this.cmd.ops.push(...t4);
        else {
            if (!t4) return false;
            this.cmd.ops.push(t4);
        }
        return true;
    }
    pageInsert(t4, e, i) {
        this.addOp(function(t5, e2, i2) {
            if (i2 < 0) return;
            const s = t5.pagesList;
            i2 >= s.length && (i2 = s.length);
            const r = [], n2 = new G();
            let o2;
            return o2 = wu(s, i2, new le(n2, e2.id, e2.name)), Array.isArray(o2) ? r.push(...o2) : o2 && r.push(o2), o2 = gu(t5.pagesMgr, e2.id, e2), o2 && r.push(o2), r;
        }(t4, e, i));
    }
    pageDelete(t4, e) {
        this.addOp(function(t5, e2) {
            const i = t5.pagesList;
            if (e2 < 0 || e2 >= i.length) return;
            if (i.length <= 1) return;
            const s = [], r = i[e2];
            let n2;
            return n2 = bu(i, e2), n2 && s.push(n2), n2 = gu(t5.pagesMgr, r.id, void 0), n2 && s.push(n2), s;
        }(t4, e));
    }
    pageModifyName(t4, e, i) {
        this.addOp(function(t5, e2, i2) {
            const s = t5.pagesList.find((t6) => t6.id === e2);
            return s && gu(s, "name", i2);
        }(t4, e, i));
    }
    pageModifyBackground(t4, e, i) {
        const s = t4.pagesMgr.getSync(e);
        s && this.addOp(gu(s, "backgroundColor", i));
    }
    pageMove(t4, e, i, s) {
        this.addOp(function(t5, e2, i2) {
            return Mu(t5.pagesList, e2, i2);
        }(t4, i, s));
    }
    insertGuideToPage(t4, e) {
        return t4.guides || (t4.guides = new G()), this.addOp(wu(t4.guides, t4.guides.length, e)), t4.guides.length - 1;
    }
    deleteGuideFromPage(t4, e) {
        if (!t4.guides) return;
        const i = t4.guides[e];
        return i ? (this.addOp(bu(t4.guides, e)), i) : void 0;
    }
    insertGuide(t4, e) {
        if (!t4.isContainer) return -1;
        let i = t4.guides;
        return i || (t4.guides = new G(), i = t4.guides), this.addOp(wu(i, i.length, e)), i.length - 1;
    }
    deleteGuide(t4, e) {
        if (!t4.isContainer) return;
        let i = t4.guides;
        const s = i == null ? void 0 : i[e];
        return s ? (this.addOp(bu(i, e)), s) : void 0;
    }
    modifyGuideOffset(t4, e, i) {
        if (!t4.isContainer) return;
        let s = t4.guides;
        const r = s == null ? void 0 : s[e];
        r && this.addOp(gu(r, "offset", i));
    }
    shapeInsert(t4, e, i, s, r) {
        return this.addOp(Nu(t4, e, i, s, r)), e.getShape(s.id);
    }
    shapeDelete(t4, e, i, s) {
        this.addOp(zu(t4, e, i, s));
    }
    shapeMove(t4, e, i, s, r) {
        this.addOp(Vu(t4, e, i, s, r));
    }
    shapeModifyX(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            if (Du(i2), i2 !== e2.transform.m02) return gu(e2.transform, "m02", i2);
        }(0, e, i));
    }
    shapeModifyY(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            if (Du(i2), i2 !== e2.transform.m12) return gu(e2.transform, "m12", i2);
        }(0, e, i));
    }
    shapeModifyWH(t4, e, i, s) {
        this.shapeModifyWidth(t4, e, i), this.shapeModifyHeight(t4, e, s);
    }
    shapeModifyWidth(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            if (Number.isNaN(i2) || !Number.isFinite(i2)) throw new Error(String(i2));
            if (e2.hasSize() && e2.size.width !== i2) return gu(e2.size, "width", i2);
        }(0, e, i));
    }
    shapeModifyHeight(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            if (Number.isNaN(i2) || !Number.isFinite(i2)) throw new Error(String(i2));
            if (e2.hasSize() && i2 !== e2.size.height) return gu(e2.size, "height", i2);
        }(0, e, i));
    }
    shapeModifyCounts(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (Number.isNaN(e2) || !Number.isFinite(e2)) throw new Error(String(e2));
            if (e2 !== t5.counts) return gu(t5, "counts", e2);
        }(e, i));
    }
    shapeModifyInnerAngle(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (Number.isNaN(e2)) throw new Error(String(e2));
            if ((e2 = Math.min(Math.max(e2, 1e-3), 1)) !== t5.innerAngle) return gu(t5, "innerAngle", e2);
        }(e, i));
    }
    shapeModifyStartMarkerType(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            const i2 = t5.style;
            if (e2 !== i2.startMarkerType) return gu(i2, "startMarkerType", e2);
        }(e, i));
    }
    shapeModifyEndMarkerType(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            const i2 = t5.style;
            if (e2 !== i2.endMarkerType) return gu(i2, "endMarkerType", e2);
        }(e, i));
    }
    shapeModifyContactFrom(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "from", i));
    }
    shapeModifyContactTo(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "to", i));
    }
    contactModifyEditState(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "isEdited", i));
    }
    shapeModifyTransform(t4, e, i) {
        Gu(t4, e), this.addOp(Hu(0, e, i));
    }
    shapeModifyRotate(t4, e, i) {
        Gu(t4, e), this.addOp(Hu(0, e, i));
    }
    shapeModifyConstrainerProportions(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (t5.constrainerProportions !== e2) return gu(t5, "constrainerProportions", e2);
        }(e, i));
    }
    shapeModifyName(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "name", i));
    }
    shapeModifyNameFixed(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (t5.nameIsFixed !== e2) return gu(t5, "nameIsFixed", e2);
        }(e, i));
    }
    shapeModifyVariable(t4, e, i) {
        if (e.value instanceof Ia) {
            const s = i.toString(), r = e.value.length;
            return this.deleteText(t4, e, 0, r), void this.insertSimpleText(t4, e, 0, s);
        }
        Gu(t4, e), this.addOp(gu(e, "value", i));
    }
    shapeModifyVariableName(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "name", i));
    }
    shapeAddVariable(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            return e2.variables || (e2.variables = new Y()), gu(e2.variables, i2.id, i2);
        }(0, e, i));
    }
    shapeRemoveVariable(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            if (e2.variables) return gu(e2.variables, i2, void 0);
        }(0, e, i));
    }
    shapeRemoveOverride(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (t5.overrides) return gu(t5.overrides, e2, void 0);
        }(e, i));
    }
    shapeBindVar(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            return e2.varbinds || (e2.varbinds = new Y()), gu(e2.varbinds, i2, s2);
        }(0, e, i, s));
    }
    shapeUnbinVar(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            if (t5.varbinds) return gu(t5.varbinds, e2, void 0);
        }(e, i));
    }
    shapeAddOverride(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            return e2.overrides || (e2.overrides = new Y()), gu(e2.overrides, i2, s2);
        }(0, e, i, s));
    }
    _shapeModifyAttr(t4, e, i, s) {
        Gu(t4, e), this.addOp(gu(e, i, s));
    }
    shapeModifyVartag(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            return e2.symtags || (e2.symtags = new Y()), gu(e2.symtags, i2, s2);
        }(0, e, i, s));
    }
    shapeModifyVisible(t4, e, i) {
        this._shapeModifyAttr(t4, e, "isVisible", i);
    }
    shapeModifyMask(t4, e, i) {
        this._shapeModifyAttr(t4, e, "mask", i);
    }
    shapeModifySymRef(t4, e, i) {
        this._shapeModifyAttr(t4, e, "refId", i);
    }
    shapeModifyLock(t4, e, i) {
        this._shapeModifyAttr(t4, e, "isLocked", i);
    }
    shapeModifyHFlip(t4, e) {
        Gu(t4, e), this.addOp(function(t5, e2, i) {
            const s = ki(e2.transform), r = e2.matrix2Parent().computeCoord2(e2.size.width / 2, e2.size.height / 2);
            s.flipH(r.x), Fi(e2.transform, s);
            const n2 = [];
            return n2.push(gu(e2.transform, "m00", s.m00)), n2.push(gu(e2.transform, "m10", s.m10)), n2.push(gu(e2.transform, "m01", s.m01)), n2.push(gu(e2.transform, "m11", s.m11)), n2.push(gu(e2.transform, "m02", s.m03)), n2.push(gu(e2.transform, "m12", s.m13)), n2;
        }(0, e));
    }
    shapeModifyVFlip(t4, e) {
        Gu(t4, e), this.addOp(function(t5, e2, i) {
            const s = ki(e2.transform), r = e2.matrix2Parent().computeCoord2(e2.size.width / 2, e2.size.height / 2);
            s.flipV(r.y), Fi(e2.transform, s);
            const n2 = [];
            return n2.push(gu(e2.transform, "m00", s.m00)), n2.push(gu(e2.transform, "m10", s.m10)), n2.push(gu(e2.transform, "m01", s.m01)), n2.push(gu(e2.transform, "m11", s.m11)), n2.push(gu(e2.transform, "m02", s.m03)), n2.push(gu(e2.transform, "m12", s.m13)), n2;
        }(0, e));
    }
    shapeModifyContextSettingsOpacity(t4, e, i) {
        let s;
        Gu(t4, e), e instanceof Oi ? (e.style.contextSettings || (e.style.contextSettings = new ee(nt.Normal, 1)), s = e.style.contextSettings) : s = e.value, this.addOp(gu(s, "opacity", i));
    }
    shapeModifyContextSettingsBlendMode(t4, e, i) {
        let s;
        Gu(t4, e), e instanceof Oi ? (e.style.contextSettings || (e.style.contextSettings = new ee(nt.Normal, 1)), s = e.style.contextSettings) : s = e.value, this.addOp(gu(s, "blenMode", i));
    }
    setShapeProtoStart(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "prototypeStartingPoint", i));
    }
    delShapeProtoStart(t4, e) {
        Gu(t4, e), this.addOp(gu(e, "prototypeStartingPoint", void 0));
    }
    insertShapeprototypeInteractions(t4, e, i) {
        Gu(t4, e);
        let s = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!s && e instanceof Oi && (e.prototypeInteractions = new G(), s = e.prototypeInteractions), !s) throw new Error();
        this.addOp(wu(s, s.length, i));
    }
    deleteShapePrototypeInteractions(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!s) return;
        const r = s == null ? void 0 : s.findIndex((t5) => t5.id === i);
        this.addOp(bu(s, r));
    }
    shapeModifyPrototypeActionDeleted(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions, n2 = r == null ? void 0 : r.find((t5) => t5.id === i);
        n2 && !!n2.isDeleted !== s && this.addOp(gu(n2, "isDeleted", s));
    }
    shapeModifyPrototypeActionEvent(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions, n2 = r == null ? void 0 : r.find((t5) => t5.id === i);
        n2 && this.addOp(gu(n2.event, "interactionType", s));
    }
    shapeModifyPrototypeActionEventTime(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions, n2 = r == null ? void 0 : r.find((t5) => t5.id === i);
        n2 && this.addOp(gu(n2.event, "transitionTimeout", s));
    }
    shapeModifyPrototypeActionConnNav(t4, e, i, s, r) {
        var _a2;
        Gu(t4, e);
        const n2 = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!n2) return;
        const o2 = (_a2 = n2 == null ? void 0 : n2.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        o2 && (this.addOp(gu(o2, "connectionType", s)), this.addOp(gu(o2, "navigationType", r)));
    }
    shapeModifyPrototypeActionTargetNodeID(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "targetNodeID", s));
    }
    shapeModifyPrototypeActionTransitionType(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "transitionType", s));
    }
    shapeModifyPrototypeActionTransitionDuration(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "transitionDuration", s));
    }
    shapeModifyPrototypeActionEasingType(t4, e, i, s, r) {
        var _a2;
        Gu(t4, e);
        const n2 = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!n2) return;
        const o2 = (_a2 = n2 == null ? void 0 : n2.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        o2 && (this.addOp(gu(o2, "easingType", s)), this.addOp(gu(o2, "easingFunction", r)));
    }
    shapeModifyPrototypeActionConnectionURL(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "connectionURL", s));
    }
    shapeModifyPrototypeActionOpenUrlInNewTab(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "openUrlInNewTab", s));
    }
    shapeModifyPrototypeActionEasingFunction(t4, e, i, s) {
        var _a2;
        Gu(t4, e);
        const r = e instanceof Ri ? e.value : e.prototypeInteractions;
        if (!r) return;
        const n2 = (_a2 = r == null ? void 0 : r.find((t5) => t5.id === i)) == null ? void 0 : _a2.actions;
        n2 && this.addOp(gu(n2, "easingFunction", s));
    }
    shapeModifyPrototypeExtraScrollOffsetX(e, i, s, r) {
        var _a2;
        Gu(e, i);
        const n2 = i instanceof Ri ? i.value : i.prototypeInteractions;
        if (!n2) return;
        const o2 = (_a2 = n2 == null ? void 0 : n2.find((t4) => t4.id === s)) == null ? void 0 : _a2.actions;
        if (!o2) return;
        let a2 = o2.extraScrollOffset;
        a2 || (v4(), a2 = new fe(0, 0), this.addOp(gu(o2, "extraScrollOffset", a2))), this.addOp(gu(a2, "x", r));
    }
    shapeModifyPrototypeExtraScrollOffsetY(e, i, s, r) {
        var _a2;
        Gu(e, i);
        const n2 = i instanceof Ri ? i.value : i.prototypeInteractions;
        if (!n2) return;
        const o2 = (_a2 = n2 == null ? void 0 : n2.find((t4) => t4.id === s)) == null ? void 0 : _a2.actions;
        if (!o2) return;
        let a2 = o2.extraScrollOffset;
        a2 || (v4(), a2 = new fe(0, 0), this.addOp(gu(o2, "extraScrollOffset", a2))), this.addOp(gu(a2, "y", r));
    }
    shapeModifyOverlayPositionType(t4, e, i) {
        Gu(t4, e);
        let s = e.overlayPosition;
        if (!s && e instanceof Oi && (s = new he(kt.CENTER, new ae()), e.overlayPosition = s), !s) throw new Error();
        this.addOp(gu(s, "position", i));
        const r = s.margin;
        r && (r.top && this.addOp(gu(r, "top", 0)), r.bottom && this.addOp(gu(r, "bottom", 0)), r.left && this.addOp(gu(r, "left", 0)), r.right && this.addOp(gu(r, "right", 0)));
    }
    shapeModifyOverlayPositionTypeMarginTop(t4, e, i) {
        Gu(t4, e);
        const s = e.overlayPosition, r = s == null ? void 0 : s.margin;
        r && this.addOp(gu(r, "top", i));
    }
    shapeModifyOverlayPositionTypeMarginBottom(t4, e, i) {
        Gu(t4, e);
        const s = e.overlayPosition, r = s == null ? void 0 : s.margin;
        r && this.addOp(gu(r, "bottom", i));
    }
    shapeModifyOverlayPositionTypeMarginLeft(t4, e, i) {
        Gu(t4, e);
        const s = e.overlayPosition, r = s == null ? void 0 : s.margin;
        r && this.addOp(gu(r, "left", i));
    }
    shapeModifyOverlayPositionTypeMarginRight(t4, e, i) {
        Gu(t4, e);
        const s = e.overlayPosition, r = s == null ? void 0 : s.margin;
        r && this.addOp(gu(r, "right", i));
    }
    shapeModifyOverlayBackgroundInteraction(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "overlayBackgroundInteraction", i));
    }
    shapeModifyOverlayBackgroundAppearance(t4, e, i) {
        if (Gu(t4, e), e.overlayBackgroundAppearance) this.addOp(gu(e, "overlayBackgroundAppearance", i));
        else {
            const t5 = new ke(It.SOLIDCOLOR, new Ji(0.25, 0, 0, 0));
            this.addOp(gu(e, "overlayBackgroundAppearance", t5));
        }
    }
    shapeModifyscrollDirection(t4, e, i) {
        Gu(t4, e), this.addOp(gu(e, "scrollDirection", i));
    }
    shapeModifyResizingConstraint(t4, e, i) {
        this._shapeModifyAttr(t4, e, "resizingConstraint", i);
    }
    shapeModifyRadius(t4, e, i, s, r, n2) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2, r2) {
            const n3 = t5.pathsegs[0].points;
            if (4 === n3.length) return [gu(n3[0], "radius", e2), gu(n3[1], "radius", i2), gu(n3[2], "radius", s2), gu(n3[3], "radius", r2)];
        }(e, i, s, r, n2));
    }
    shapeModifyRadius2(t4, e, i, s, r, n2) {
        Gu(t4, e);
        const o2 = e instanceof Ri ? e.value : e.cornerRadius;
        this.addOp(function(t5, e2, i2, s2, r2, n3) {
            if (!e2) {
                if (t5 instanceof Ri) throw new Error();
                t5.cornerRadius = new ie(0, 0, 0, 0), e2 = t5.cornerRadius;
            }
            const o3 = [];
            return e2.lt !== i2 && i2 >= 0 && o3.push(gu(e2, "lt", i2)), e2.rt !== s2 && s2 >= 0 && o3.push(gu(e2, "rt", s2)), e2.lb !== n3 && n3 >= 0 && o3.push(gu(e2, "lb", n3)), e2.rb !== r2 && r2 >= 0 && o3.push(gu(e2, "rb", r2)), o3;
        }(e, o2, i, s, r, n2));
    }
    shapeModifyFixedRadius(t4, e, i) {
        this._shapeModifyAttr(t4, e, "fixedRadius", i);
    }
    shapeModifyCurvPoint(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            if (Du(i2.x), Du(i2.y), s2 > -1) {
                const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
                if (r2) return [gu(r2, "x", i2.x), gu(r2, "y", i2.y)];
            }
        }(e, i, s, r));
    }
    shapeModifyCurvFromPoint(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            Du(i2.x), Du(i2.y);
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return [gu(r2, "fromX", i2.x), gu(r2, "fromY", i2.y)];
        }(e, i, s, r));
    }
    shapeModifyCurvToPoint(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            Du(i2.x), Du(i2.y);
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return [gu(r2, "toX", i2.x), gu(r2, "toY", i2.y)];
        }(e, i, s, r));
    }
    shapeModifyBoolOp(t4, e, i) {
        this._shapeModifyAttr(t4, e, "boolOp", i);
    }
    shapeModifyIsCustomSize(t4, e, i) {
        this._shapeModifyAttr(t4, e, "isCustomSize", !!i || void 0);
    }
    addFillAt(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.fills : e.value;
        this.addOp(Su(r, i, s));
    }
    addFills(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.fills : e.value;
        for (let t5 = 0; t5 < i.length; t5++) {
            const e2 = i[t5];
            this.addOp(Su(s, e2, t5));
        }
    }
    addBorderAt(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(Tu(r, i, s));
    }
    addBorders(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.borders : e.value;
        for (let t5 = 0; t5 < i.length; t5++) {
            const e2 = i[t5];
            this.addOp(Tu(s, e2, t5));
        }
    }
    deleteFillAt(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.fills : e.value;
        this.addOp(Cu(s, i));
    }
    deleteFills(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.fills : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = [];
            for (let r2 = e2 + i2 - 1; r2 >= e2; r2--) {
                const e3 = bu(t5, r2);
                e3 && s2.push(e3);
            }
            return s2;
        }(r, i, s));
    }
    deleteBorderAt(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(Cu(s, i));
    }
    deleteBorders(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = [];
            for (let r2 = e2 + i2 - 1; r2 >= e2; r2--) {
                const e3 = bu(t5, r2);
                e3 && s2.push(e3);
            }
            return s2;
        }(r, i, s));
    }
    setFillColor(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "color", s));
    }
    setFillEnable(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "isEnabled", s));
    }
    setFillType(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "fillType", s));
    }
    setFillScaleMode(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "imageScaleMode", s));
    }
    setFillImageRef(t4, e, i, s, r, n2) {
        Gu(e, i);
        const o2 = (i instanceof Oi ? i.style.fills : i.value)[s];
        o2 && (t4.mediasMgr.add(r, n2), o2.setImageMgr(t4.mediasMgr), this.addOp(gu(o2, "imageRef", r)));
    }
    setFillImageOriginWidth(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "originalImageWidth", s));
    }
    setFillImageOriginHeight(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "originalImageHeight", s));
    }
    setFillImageScale(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "scale", s));
    }
    setFillEdit(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && r.startEditImage(s);
    }
    setFillImageRotate(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "rotation", s));
    }
    setFillImageFilter(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = (e instanceof Oi ? e.style.fills : e.value)[i];
        if (n2) if (n2.paintFilter) this.addOp(gu(n2.paintFilter, s, r));
        else {
            const t5 = new de(0, 0, 0, 0, 0, 0, 0);
            t5[s] = r, this.addOp(gu(n2, "paintFilter", t5));
        }
    }
    setBorderFillType(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.borders : e.value)[i];
        r && this.addOp(gu(r, "fillType", s));
    }
    setFillGradient(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.fills : e.value)[i];
        r && this.addOp(gu(r, "gradient", s));
    }
    setBorderGradient(t4, e, i, s) {
        Gu(t4, e);
        const r = (e instanceof Oi ? e.style.borders : e.value)[i];
        r && this.addOp(gu(r, "gradient", s));
    }
    setBorderColor(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "color", s));
    }
    setBorderEnable(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "isEnabled", s));
    }
    setBorderThickness(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "thickness", s));
    }
    setBorderPosition(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "position", s));
    }
    setBorderStyle(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "borderStyle", s));
    }
    moveFill(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.fills : e.value;
        this.addOp(function(t5, e2, i2) {
            return Mu(t5, e2, i2);
        }(r, i, s));
    }
    moveBorder(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(function(t5, e2, i2) {
            return Mu(t5, e2, i2);
        }(r, i, s));
    }
    setBorderCornerType(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "cornerType", s));
    }
    setBorderSide(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        r[i] && this.addOp(gu(r[i], "sideSetting", s));
    }
    setBorderThicknessTop(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(gu(r[i].sideSetting, "thicknessTop", s));
    }
    setBorderThicknessLeft(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(gu(r[i].sideSetting, "thicknessLeft", s));
    }
    setBorderThicknessBottom(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(gu(r[i].sideSetting, "thicknessBottom", s));
    }
    setBorderThicknessRight(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.borders : e.value;
        this.addOp(gu(r[i].sideSetting, "thicknessRight", s));
    }
    addPointAt(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(ku(e, s, i, r));
    }
    addSegmentAt(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            return wu(t5.pathsegs, i2, e2);
        }(e, s, i));
    }
    deletePoints(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            const r2 = [];
            for (let n2 = e2 + i2 - 1; n2 >= e2; n2--) {
                const e3 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points;
                if (!e3) continue;
                const i3 = bu(e3, n2);
                i3 && r2.push(i3);
            }
            return r2;
        }(e, i, s, r));
    }
    deletePoint(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            var _a2;
            const s2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[i2]) == null ? void 0 : _a2.points;
            if (s2) return bu(s2, e2);
        }(e, i, s));
    }
    addPoints(t4, e, i, s) {
        Gu(t4, e);
        for (let t5 = 0; t5 < i.length; t5++) {
            const r = i[t5];
            this.addOp(ku(e, r, t5, s));
        }
    }
    shapeEditPoints(t4, e, i) {
        this._shapeModifyAttr(t4, e, "haveEdit", i);
    }
    modifyPointCurveMode(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return gu(r2, "mode", i2);
        }(e, i, s, r));
    }
    modifyPointHasFrom(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return gu(r2, "hasFrom", i2);
        }(e, i, s, r));
    }
    modifyPointHasTo(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return gu(r2, "hasTo", i2);
        }(e, i, s, r));
    }
    modifyPointCornerRadius(t4, e, i, s, r) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            var _a2;
            const r2 = (_a2 = t5 == null ? void 0 : t5.pathsegs[s2]) == null ? void 0 : _a2.points[e2];
            if (r2) return gu(r2, "radius", i2);
        }(e, i, s, r));
    }
    setCloseStatus(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            const s2 = t5 == null ? void 0 : t5.pathsegs[i2];
            if (s2) return gu(s2, "isClosed", e2);
        }(e, i, s));
    }
    insertSegmentAt(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2) {
            return wu(t5.pathsegs, e2, i2);
        }(e, i, s));
    }
    deleteSegmentAt(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return bu(t5.pathsegs, e2);
        }(e, i));
    }
    addContactAt(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.contacts || (t5.contacts = new G()), wu(t5.contacts, t5.contacts.length, e2);
        }(e.style, i));
    }
    removeContactRoleAt(t4, e, i) {
        Gu(t4, e), e.style.contacts && e.style.contacts[i] && this.addOp(function(t5, e2) {
            if (t5.contacts) return bu(t5.contacts, e2);
        }(e.style, i));
    }
    addShadows(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.shadows : e.value;
        for (let t5 = 0; t5 < i.length; t5++) {
            const e2 = i[t5];
            this.addOp(Iu(s, e2, t5));
        }
    }
    addShadow(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(Iu(r, i, s));
    }
    deleteShadows(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = [];
            for (let r2 = e2 + i2 - 1; r2 >= e2; r2--) {
                const e3 = bu(t5, r2);
                e3 && s2.push(e3);
            }
            return s2;
        }(r, i, s));
    }
    deleteShadowAt(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2) {
            return bu(t5, e2);
        }(s, i));
    }
    setShadowEnable(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "isEnabled", i2);
        }(r, i, s));
    }
    setShadowOffsetX(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "offsetX", i2);
        }(r, i, s));
    }
    setShadowOffsetY(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "offsetY", i2);
        }(r, i, s));
    }
    setShadowBlur(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "blurRadius", i2);
        }(r, i, s));
    }
    setShadowSpread(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "spread", i2);
        }(r, i, s));
    }
    setShadowColor(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "color", i2);
        }(r, i, s));
    }
    setShadowPosition(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.style.shadows : e.value;
        this.addOp(function(t5, e2, i2) {
            const s2 = t5[e2];
            if (s2) return gu(s2, "position", i2);
        }(r, i, s));
    }
    shapeModifyBlur(t4, e, i) {
        let s;
        Gu(t4, e), e instanceof Oi ? (e.style.contextSettings || (e.style.contextSettings = new ee(nt.Normal, 1)), s = e.style.contextSettings) : s = e.value, this.addOp(gu(s, "blenMode", i));
    }
    addBlur(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style : e.value;
        this.addOp(gu(s, "blur", i));
    }
    deleteBlur(t4, e) {
        Gu(t4, e);
        const i = e instanceof Oi ? e.style : e.value;
        this.addOp(gu(i, "blur", void 0));
    }
    shapeModifyBlurSaturation(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.blur : e.value;
        this.addOp(gu(s, "saturation", i));
    }
    shapeModifyBlurType(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.blur : e.value;
        this.addOp(gu(s, "type", i));
    }
    shapeModifyBlurMotionAngle(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.blur : e.value;
        this.addOp(gu(s, "motionAngle", i));
    }
    shapeModifyBlurRadius(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.blur : e.value;
        this.addOp(gu(s, "radius", i));
    }
    shapeModifyBlurEdabled(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.style.blur : e.value;
        this.addOp(gu(s, "isEnabled", i));
    }
    deleteExportFormatAt(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.exportOptions : e.value;
        s && this.addOp(Au(s, i));
    }
    deletePageExportFormatAt(t4, e) {
        t4.exportOptions && this.addOp(Au(t4.exportOptions, e));
    }
    deleteExportFormats(t4, e, i, s) {
        Gu(t4, e), e.exportOptions && this.addOp(function(t5, e2, i2) {
            const s2 = [];
            for (let r = e2 + i2 - 1; r >= e2; r--) {
                const e3 = bu(t5.exportFormats, r);
                e3 && s2.push(e3);
            }
            return s2;
        }(e.exportOptions, i, s));
    }
    addExportFormats(t4, e, i) {
        Gu(t4, e);
        for (let t5 = 0; t5 < i.length; t5++) {
            const s = i[t5];
            this.addOp(Eu(e, s, t5));
        }
    }
    addExportFormat(t4, e, i, s) {
        Gu(t4, e), this.addOp(Eu(e, i, s));
    }
    addPageExportFormat(t4, e, i) {
        this.addOp(function(t5, e2, i2) {
            return Eu(t5, e2, i2);
        }(t4, e, i));
    }
    setExportFormatScale(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.exportOptions : e.value;
        r && this.addOp(Fu(r, i, s));
    }
    setPageExportFormatScale(t4, e, i) {
        t4.exportOptions && this.addOp(function(t5, e2, i2) {
            return Fu(t5, e2, i2);
        }(t4.exportOptions, e, i));
    }
    setExportFormatName(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.exportOptions : e.value;
        r && this.addOp(Ru(r, i, s));
    }
    setPageExportFormatName(t4, e, i) {
        t4.exportOptions && this.addOp(function(t5, e2, i2) {
            return Ru(t5, e2, i2);
        }(t4.exportOptions, e, i));
    }
    setExportFormatFileFormat(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.exportOptions : e.value;
        r && this.addOp(Lu(r, i, s));
    }
    setPageExportFormatFileFormat(t4, e, i) {
        t4.exportOptions && this.addOp(function(t5, e2, i2) {
            return Lu(t5, e2, i2);
        }(t4.exportOptions, e, i));
    }
    setExportFormatPerfix(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Oi ? e.exportOptions : e.value;
        r && this.addOp(Ou(r, i, s));
    }
    setPageExportFormatPerfix(t4, e, i) {
        t4.exportOptions && this.addOp(Ou(t4.exportOptions, e, i));
    }
    setExportTrimTransparent(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.exportOptions : e.value;
        s && this.addOp(function(t5, e2) {
            return gu(t5, "trimTransparent", e2);
        }(s, i));
    }
    setExportCanvasBackground(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.exportOptions : e.value;
        s && this.addOp(function(t5, e2) {
            return gu(t5, "canvasBackground", e2);
        }(s, i));
    }
    setExportPreviewUnfold(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Oi ? e.exportOptions : e.value;
        s && this.addOp(function(t5, e2) {
            return gu(t5, "unfold", e2);
        }(s, i));
    }
    setPageExportPreviewUnfold(t4, e, i) {
        const s = t4.pagesMgr.getSync(e);
        s && s.exportOptions && this.addOp(function(t5, e2) {
            return gu(t5, "unfold", e2);
        }(s.exportOptions, i));
    }
    insertSimpleText(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(Wu(e, n2, s, i, { attr: r }));
    }
    insertComplexText(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Vh ? e.text : e.value;
        if (!(r && r instanceof Ia)) throw Error();
        this.addOp($u(e, r, s, i));
    }
    insertSimpleText2(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e.text;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(Wu(e, n2, s, i, { attr: r }));
    }
    insertComplexText2(t4, e, i, s) {
        Gu(t4, e);
        const r = e.text;
        if (!(r && r instanceof Ia)) throw Error();
        this.addOp($u(e, r, s, i));
    }
    deleteText(t4, e, i, s) {
        Gu(t4, e);
        const r = e instanceof Vh ? e.text : e.value;
        if (!(r && r instanceof Ia)) throw Error();
        this.addOp(Xu(e, r, i, s));
    }
    deleteText2(t4, e, i, s) {
        Gu(t4, e);
        const r = e.text;
        if (!(r && r instanceof Ia)) throw Error();
        this.addOp(Xu(e, r, i, s));
    }
    textModifyColor(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "color", r2);
        }(e, n2, i, s, r));
    }
    textModifyFontName(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "fontName", r2);
        }(e, n2, i, s, r));
    }
    textModifyFontSize(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "fontSize", r2);
        }(e, n2, i, s, r));
    }
    shapeModifyTextBehaviour(t4, e, i) {
        if (Gu(t4, e.parent), !(e && e instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2) {
            const s = e2;
            if (i2 !== $t.Flexible || s.attr && s.attr.textBehaviour && s.attr.textBehaviour !== $t.Flexible) return e2.attr || (e2.attr = new va()), gu(e2.attr, "textBehaviour", i2);
        }(0, e, i));
    }
    shapeModifyTextVerAlign(t4, e, i) {
        Gu(t4, e);
        const s = e instanceof Vh ? e.text : e.value;
        if (!(s && s instanceof Ia)) throw Error();
        this.addOp(function(t5, e2) {
            const i2 = t5;
            if (e2 !== Ut.Top || i2.attr && i2.attr.verAlign && i2.attr.verAlign !== Ut.Top) return t5.attr || (t5.attr = new va()), gu(t5.attr, "verAlign", e2);
        }(s, i));
    }
    textModifyHighlightColor(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "highlight", r2);
        }(e, n2, i, s, r));
    }
    textModifyUnderline(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "underline", i2);
        }(e, n2, i, s, r));
    }
    textModifyStrikethrough(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "strikethrough", i2);
        }(e, n2, i, s, r));
    }
    textModifyWeight(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "weight", i2);
        }(e, n2, i, s, r));
    }
    textModifyItalic(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "italic", i2);
        }(e, n2, i, s, r));
    }
    textModifyFillType(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "fillType", r2);
        }(e, n2, s, r, i));
    }
    _textModifyRemoveBulletNumbers(t4, e, i, s) {
        const r = [], n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        Yo(n2.paras, i, s, (t5, e2, s2, n3, o2) => {
            i -= n3, "*" === s2.text[0] && s2.spans[0].bulletNumbers && 1 === s2.spans[0].length && r.push(i - n3), i += s2.length;
        });
        for (let t5 = 0, i2 = r.length; t5 < i2; t5++) this.addOp(Xu(e, n2, r[t5] - t5, 1));
        r.length > 0 && n2.reLayout();
    }
    _textModifySetBulletNumbers(t4, e, i, s, r) {
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "bulletNumbersType", i2);
        }(e, n2, i, s, r));
        const o2 = [];
        Yo(n2.paras, s, r, (t5, e2, i2, r2, n3) => {
            s -= r2, "*" === i2.text[0] && i2.spans[0].bulletNumbers && 1 === i2.spans[0].length || o2.push(s - r2), s += i2.length;
        });
        for (let t5 = 0, s2 = o2.length; t5 < s2; t5++) {
            const s3 = new ba();
            s3.placeholder = true, s3.bulletNumbers = new qt(i), this.addOp(Wu(e, n2, "*", o2[t5] + t5, { attr: s3 }));
        }
        o2.length > 0 && n2.reLayout();
    }
    textModifyBulletNumbers(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = n2.alignParaRange(s, r);
        s = o2.index, r = o2.len, void 0 === i || i === lt.None ? this._textModifyRemoveBulletNumbers(t4, e, s, r) : this._textModifySetBulletNumbers(t4, e, i, s, r);
    }
    textModifyBulletNumbersStart(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "bulletNumbersStart", i2);
        }(e, n2, i, s, r));
    }
    textModifyBulletNumbersInherit(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = i ? ct.Inherit : ct.Renew;
        this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "bulletNumbersBehavior", i2);
        }(e, n2, o2, s, r));
    }
    textModifyHorAlign(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = n2.alignParaRange(s, r);
        s = o2.index, r = o2.len, this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "alignment", i2);
        }(e, n2, i, s, r));
    }
    textModifyParaIndent(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "indent", i2);
        }(e, n2, i, s, r));
    }
    textModifyMinLineHeight(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = n2.alignParaRange(s, r);
        s = o2.index, r = o2.len, this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "minimumLineHeight", i2);
        }(e, n2, i, s, r));
    }
    textModifyMaxLineHeight(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = n2.alignParaRange(s, r);
        s = o2.index, r = o2.len, this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "maximumLineHeight", i2);
        }(e, n2, i, s, r));
    }
    textModifyKerning(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "kerning", i2);
        }(e, n2, i, s, r));
    }
    textModifyParaSpacing(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        const o2 = n2.alignParaRange(s, r);
        s = o2.index, r = o2.len, this.addOp(function(t5, e2, i2, s2, r2) {
            return xu(t5, e2, s2, r2, "paraSpacing", i2);
        }(e, n2, i, s, r));
    }
    textModifyTransform(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        if (i === Yt.UppercaseFirst) {
            const t5 = n2.alignParaRange(s, r);
            s = t5.index, r = t5.len;
        }
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, s2, r2, "transform", i2);
        }(e, n2, i, s, r));
    }
    setTextGradient(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = e instanceof Vh ? e.text : e.value;
        if (!(n2 && n2 instanceof Ia)) throw Error();
        this.addOp(function(t5, e2, i2, s2, r2) {
            return yu(t5, e2, i2, s2, "gradient", r2);
        }(e, n2, s, r, i));
    }
    tableInitCell(t4, e, i, s) {
        return Gu(t4, e), this.addOp(function(t5, e2, i2) {
            const s2 = t5.rowHeights[e2].id + "," + t5.colWidths[i2].id;
            if (t5.cells.has(s2)) return;
            new ye();
            const r = new Ii(), n2 = new ka(new G(), s2, "", Vt.TableCell, r, new is(new G(), new G(), new G()), Wt.Text, ia(t5.textAttr));
            return gu(t5.cells, s2, n2);
        }(e, i, s));
    }
    tableSetCellContentType(t4, e, i, s) {
        if (Gu(t4, e), this.addOp(function(t5, e2) {
            if (e2 = e2 === Wt.None ? void 0 : e2, t5.cellType !== e2) return gu(t5, "cellType", e2);
        }(i.data, s)), s !== Wt.Text && i.data.text) {
            const t5 = i.data.text.length;
            t5 > 1 && this.addOp(Xu(i, i.data.text, 0, t5 - 1));
        }
    }
    tableSetCellContentImage(t4, e, i, s) {
        Gu(t4, e);
        i.imageRef !== s && this.addOp(function(t5, e2) {
            return gu(t5, "imageRef", e2);
        }(i.data, s));
    }
    tableModifyColWidth(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            const r = e2.colWidths;
            return r[i2] && gu(r[i2], "value", s2);
        }(0, e, i, s));
    }
    tableModifyRowHeight(t4, e, i, s) {
        Gu(t4, e), this.addOp(function(t5, e2, i2, s2) {
            const r = e2.rowHeights;
            return r[i2] && gu(r[i2], "value", s2);
        }(0, e, i, s));
    }
    tableInsertRow(e, i, s, r) {
        Gu(e, i), this.addOp(function(e2, i2, s2) {
            return wu(e2.rowHeights, i2, new Ce(v4(), new G(), s2));
        }(i, s, r));
    }
    tableRemoveRow(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            const i2 = t5.rowHeights[e2].id, s = [];
            t5.cells.forEach((t6, e3) => {
                e3.startsWith(i2) && s.push(e3);
            });
            const r = s.map((e3) => gu(t5.cells, e3, void 0)), n2 = bu(t5.rowHeights, e2);
            return n2 && r.push(n2), r;
        }(e, i));
    }
    tableInsertCol(e, i, s, r) {
        Gu(e, i), this.addOp(function(e2, i2, s2) {
            return wu(e2.colWidths, i2, new Ce(v4(), new G(), s2));
        }(i, s, r));
    }
    tableRemoveCol(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            const i2 = t5.colWidths[e2].id, s = [];
            t5.cells.forEach((t6, e3) => {
                e3.endsWith(i2) && s.push(e3);
            });
            const r = s.map((e3) => gu(t5.cells, e3, void 0)), n2 = bu(t5.colWidths, e2);
            return n2 && r.push(n2), r;
        }(e, i));
    }
    tableModifyCellSpan(t4, e, i, s, r) {
        Gu(t4, e);
        const n2 = i.rowSpan, o2 = i.colSpan;
        (n2 ?? 1) === s && (o2 ?? 1) === r || this.addOp(function(t5, e2, i2) {
            return i2 = i2 && i2 <= 1 ? void 0 : i2, [gu(t5, "rowSpan", e2 = e2 && e2 <= 1 ? void 0 : e2), gu(t5, "colSpan", i2)];
        }(i.data, s, r));
    }
    tableModifyTextColor(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "color", e2);
        }(e, i));
    }
    tableModifyTextHighlightColor(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "highlight", e2);
        }(e, i));
    }
    tableModifyTextFontName(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "fontName", e2);
        }(e, i));
    }
    tableModifyTextFontSize(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "fontSize", e2);
        }(e, i));
    }
    tableModifyTextVerAlign(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "verAlign", e2);
        }(e, i));
    }
    tableModifyTextHorAlign(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "alignment", e2);
        }(e, i));
    }
    tableModifyTextMinLineHeight(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "minimumLineHeight", e2);
        }(e, i));
    }
    tableModifyTextMaxLineHeight(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "maximumLineHeight", e2);
        }(e, i));
    }
    tableModifyTextKerning(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "kerning", e2);
        }(e, i));
    }
    tableModifyTextParaSpacing(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "paraSpacing", e2);
        }(e, i));
    }
    tableModifyTextUnderline(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "underline", e2);
        }(e, i));
    }
    tableModifyTextStrikethrough(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "strikethrough", e2);
        }(e, i));
    }
    tableModifyTextWeight(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "weight", e2);
        }(e, i));
    }
    tableModifyTextItalic(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "italic", e2);
        }(e, i));
    }
    tableModifyTextTransform(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "transform", e2);
        }(e, i));
    }
    tableModifyTextFillType(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "filltype", e2);
        }(e, i));
    }
    tableModifyTextGradient(t4, e, i) {
        Gu(t4, e), this.addOp(function(t5, e2) {
            return t5.textAttr || (t5.textAttr = new va()), gu(t5.textAttr, "gradient", e2);
        }(e, i));
    }
}
class Zu {
    constructor(t4, e) {
        __publicField(this, "type");
        __publicField(this, "ops", []);
        __publicField(this, "localops", []);
        __publicField(this, "parent");
        this.type = t4, this.parent = e;
    }
    unshift(t4) {
        this.ops.unshift(...t4);
    }
}
class ju {
    constructor(t4, e) {
        __publicField(this, "id");
        __publicField(this, "baseVer", "");
        __publicField(this, "node");
        __publicField(this, "childs", /* @__PURE__ */ new Map());
        __publicField(this, "parent");
        this.parent = t4, this.id = e;
    }
    buildAndGet(t4, e, i) {
        if (0 === e.length) {
            if (this.node || (this.node = i(this, t4)), this.node.type !== t4.type) throw new Error("wrong node, expect node type: " + t4.type + ", but get: " + this.node.type);
            return this.node;
        }
        let s = this.childs.get(e[0]);
        return s || (s = new ju(this, e[0]), this.childs.set(e[0], s)), s.buildAndGet(t4, e.slice(1), i);
    }
    get(t4) {
        if (0 === t4.length) return this.node;
        const e = this.childs.get(t4[0]);
        return e && e.get(t4.slice(1));
    }
    get2(t4) {
        if (0 === t4.length) return this;
        const e = this.childs.get(t4[0]);
        return e && e.get2(t4.slice(1));
    }
    get3(t4) {
        if (0 === t4.length) return this;
        let e = this.childs.get(t4[0]);
        return e || (e = new ju(this, t4[0]), this.childs.set(t4[0], e)), e.get3(t4.slice(1));
    }
    undoLocals() {
        const t4 = (e) => {
            var _a2;
            (_a2 = e.node) == null ? void 0 : _a2.undoLocals(), e.childs.forEach(t4);
        };
        t4(this);
    }
    redoLocals() {
        const t4 = (e) => {
            var _a2;
            (_a2 = e.node) == null ? void 0 : _a2.redoLocals(), e.childs.forEach(t4);
        };
        t4(this);
    }
    roll2Version(t4, e) {
        const i = (t5, s) => {
            let r;
            if (s = Qp.comp(s, t5.baseVer) < 0 ? t5.baseVer : s, t5.node) try {
                r = t5.node.roll2Version(s, e);
            } catch (t6) {
                console.error(t6);
            }
            t5.childs.forEach((t6) => {
                r && r.has(t6.id) && (t6.baseVer = r.get(t6.id)), i(t6, s);
            });
        };
        i(this, t4);
    }
}
const Ju = {};
function Ku(t4, e, i) {
    let s = i.data;
    if ("string" == typeof s) {
        const e2 = new class {
            constructor() {
                __publicField(this, "document", t4);
                __publicField(this, "curPage", "");
                __publicField(this, "fmtVer", rn);
            }
        }(), i2 = JSON.parse(s), r = i2.typeId, n2 = Ju[r];
        if (!n2) throw new Error("need import " + r);
        s = n2(i2, e2);
    }
    return Zp(e, i, s);
}
function qu(t4, e, i) {
    return Zp(t4, e, i);
}
function Qu(t4, e, i) {
    const s = Ku(t4, e, i);
    if (s == null ? void 0 : s.data) {
        const t5 = s.data;
        s.data = "object" == typeof t5 ? JSON.stringify(t5, (t6, e2) => t6.startsWith("__") ? void 0 : e2) : t5;
    }
    return s;
}
function tf(t4, e) {
    return e.target && Ku(t4, e.target, ef(e));
}
function ef(t4) {
    return { from: t4.to, to: t4.from, type: t4.type, data: t4.origin, id: t4.id, path: t4.path, origin: t4.data, target: void 0, data2: void 0 };
}
function sf(t4) {
    return "object" == typeof t4.data && (t4.data = JSON.stringify(t4.data, (t5, e) => t5.startsWith("__"))), t4;
}
Ju.fill = Kn, Ju.border = Jn, Ju.shadow = kn, Ju["export-format"] = Vn, Ju["curve-point"] = un, Ju.stop = Fn, Ju["contact-role"] = Nn, Ju["crdt-number"] = zn, Ju["path-segment"] = Mn, Ju["page-list-item"] = wn, Ju.guide = mn, Ju["prototype-inter-action"] = Gn;
class rf extends Zu {
    constructor(t4, e) {
        super(zp.CrdtArr, t4);
        __publicField(this, "document");
        this.document = e;
    }
    getOpTarget(t4) {
        if (t4[0] === this.document.id) return this.document.getOpTarget(t4);
        const e = this.document.pagesMgr.getSync(t4[0]);
        return e ? e.getOpTarget(t4) : void 0;
    }
    undoLocals() {
        for (let t4 = this.localops.length - 1; t4 >= 0; t4--) {
            const e = this.localops[t4].op, i = e.target, s = ef(e);
            i && qu(i, s, e.origin);
        }
    }
    redoLocals() {
        if (0 !== this.localops.length) for (let t4 = 0; t4 < this.localops.length; t4++) {
            const e = this.localops[t4].op, i = e.target;
            i && qu(i, e, e.data2);
        }
    }
    receive(t4) {
        if (0 === t4.length) throw new Error();
        for (let t5 = this.localops.length - 1; t5 >= 0; t5--) {
            const e2 = this.localops[t5];
            tf(this.document, e2.op);
        }
        const e = this.getOpTarget(t4[0].op.path);
        for (let i = 0; i < t4.length; i++) {
            const s = t4[i], r = e && Qu(this.document, e, s.op);
            if (r) {
                const t5 = s.cmd.ops.indexOf(s.op);
                if (s.op = r, t5 < 0) throw new Error();
                s.cmd.ops.splice(t5, 1, r);
            }
        }
        if (this.ops.push(...t4), e) for (let t5 = 0; t5 < this.localops.length; t5++) {
            const i = this.localops[t5], s = Qu(this.document, e, i.op);
            if (s) {
                const t6 = i.cmd.ops.indexOf(i.op);
                if (i.op = s, t6 < 0) throw new Error();
                i.cmd.ops.splice(t6, 1, s);
            } else {
                const e2 = i.cmd.ops.indexOf(i.op);
                if (e2 < 0) throw new Error();
                i.cmd.ops.splice(e2, 1), this.localops.splice(t5, 1), --t5;
            }
        }
        else for (let t5 = 0; t5 < this.localops.length; t5++) {
            this.localops[t5].op.target = void 0;
        }
    }
    receiveLocal(t4) {
        if (0 === t4.length) throw new Error();
        if (t4.length > this.localops.length) throw new Error();
        this.getOpTarget(t4[0].op.path);
        for (let e = 0; e < t4.length; e++) {
            const i = t4[e], s = this.localops.shift();
            if (i.cmd.id !== (s == null ? void 0 : s.cmd.id)) throw new Error("op not match");
            this.ops.push(s);
        }
    }
    commit(t4) {
        this.localops.push(...t4);
    }
    popLocal(t4) {
        if (this.localops.length < t4.length) throw new Error();
        for (let e = t4.length - 1; e >= 0; e--) {
            const i = t4[e], s = this.localops.pop();
            if (i.cmd !== (s == null ? void 0 : s.cmd)) throw new Error("op not match");
        }
    }
    dropOps(t4) {
    }
    undo(t4, e) {
        if (0 === t4.length) throw new Error();
        const i = e ? void 0 : t4.map((t5) => ({ cmd: t5.cmd, op: t5.op }));
        t4.reverse();
        for (let e2 = 0; e2 < t4.length; ++e2) {
            if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
            const i2 = (s = this.document, (r = t4[e2].op).target && Qu(s, r.target, ef(r)));
            t4[e2].op = i2 || sf(ef(t4[e2].op));
        }
        var s, r;
        if (e) this.commit(t4.map((t5) => (e.ops.push(t5.op), { op: t5.op, cmd: e })));
        else {
            this.popLocal(i);
            for (let e2 = 0; e2 < t4.length; e2++) {
                const s2 = t4[e2], r2 = i[e2], n2 = s2.cmd.ops.indexOf(r2.op);
                if (n2 < 0) throw new Error();
                s2.cmd.ops.splice(n2, 1);
            }
            t4[0].cmd.ops.push(...t4.map((t5) => t5.op));
        }
    }
    redo(t4, e) {
        if (0 === t4.length) throw new Error();
        t4.reverse();
        const i = this.getOpTarget(t4[0].op.path), s = e ? void 0 : t4.map((t5) => t5.op);
        for (let e2 = 0; e2 < t4.length; ++e2) {
            if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
            const s2 = ef(t4[e2].op), r = i && Qu(this.document, i, s2);
            t4[e2].op = r || sf(s2);
        }
        if (e) this.commit(t4.map((t5) => (e.ops.push(t5.op), { op: t5.op, cmd: e })));
        else {
            for (let e2 = 0; e2 < t4.length; e2++) {
                const i2 = t4[e2], r = s[e2], n2 = i2.cmd.ops.indexOf(r);
                if (n2 < 0) throw new Error();
                i2.cmd.ops.splice(n2, 1);
            }
            t4[0].cmd.ops.push(...t4.map((t5) => t5.op)), this.commit(t4);
        }
    }
    roll2Version(t4, e) {
        if (Qp.comp(t4, e) > 0) throw new Error();
        const i = this.ops.concat(...this.localops);
        if (0 === i.length) return;
        const s = i.findIndex((e2) => Qp.comp(e2.cmd.version, t4) > 0);
        if (s < 0) return;
        const r = this.getOpTarget(i[0].op.path);
        if (!r) return;
        let n2 = i.findIndex((t5) => Qp.comp(t5.cmd.version, e) > 0);
        n2 < 0 && (n2 = i.length);
        const o2 = /* @__PURE__ */ new Map();
        for (let t5 = s; t5 < n2; t5++) {
            const e2 = i[t5];
            let s2;
            try {
                s2 = Qu(this.document, r, e2.op), (s2 == null ? void 0 : s2.data) && s2.data.id && o2.set(s2.data.id, e2.cmd.version);
            } catch (t6) {
                console.error(t6);
            }
            if (s2) {
                const t6 = e2.cmd.ops.indexOf(e2.op);
                if (e2.op = s2, t6 < 0) throw new Error();
                e2.cmd.ops.splice(t6, 1, s2);
            }
        }
        return o2;
    }
}
const nf = {};
function of(t4, e, i) {
    let s, r = i.data;
    if ("string" == typeof i.data && ("{" === i.data[0] || "[" === i.data[0])) {
        const e2 = new class {
            constructor() {
                __publicField(this, "document", t4);
                __publicField(this, "curPage", "");
                __publicField(this, "fmtVer", rn);
            }
        }(), s2 = JSON.parse(i.data), n2 = s2.typeId, o2 = nf[n2];
        if (Array.isArray(s2)) s2.forEach((t5) => {
            if ("number" != typeof t5) throw new Error();
        }), r = new G(...s2);
        else {
            if (!o2) throw new Error("need import " + n2);
            r = o2(s2, e2);
        }
    }
    if ("object" == typeof r && !$(r)) throw new Error("need import: " + (r == null ? void 0 : r.typeId));
    return e instanceof Map ? (s = e.get(i.id), r ? e.set(i.id, r) : e.delete(i.id)) : e instanceof Z ? (s = e.getSync(i.id), r && e.add(i.id, r)) : (s = e[i.id], e[i.id] = r), { data: "object" == typeof r ? JSON.stringify(r, (t5, e2) => t5.startsWith("__") ? void 0 : e2) : r, id: i.id, type: i.type, path: i.path, origin: s, target: e, data2: r };
}
function af(t4, e, i) {
    if ("object" == typeof i && !$(i)) throw new Error("need import: " + (i == null ? void 0 : i.typeId));
    t4 instanceof Map ? (t4.get(e.id), i ? t4.set(e.id, i) : t4.delete(e.id)) : t4 instanceof Z ? (t4.getSync(e.id), i && t4.add(e.id, i)) : (t4[e.id], t4[e.id] = i);
}
function hf(t4) {
    return { data: t4.origin, id: t4.id, type: t4.type, path: t4.path, origin: t4.data, target: void 0, data2: void 0 };
}
function cf(t4) {
    return "object" == typeof t4.data && (t4.data = JSON.stringify(t4.data, (t5, e) => t5.startsWith("__"))), t4;
}
nf["table-cell"] = oo, nf.variable = co, nf.page = zo, nf.color = cn, nf["contact-form"] = Bn, nf["border-style"] = hn, nf.gradient = Hn, nf["border-side-setting"] = Pn, nf.blur = Ln, nf["symbol-shape"] = Do, nf["symbol-union-shape"] = Wo, nf["prototype-starting-point"] = Tn, nf["overlay-background-appearance"] = Wn, nf["prototype-extrascrolloffset"] = Cn, nf["prototype-actions"] = Xn, nf["paint-filter"] = bn, nf["overlay-position"] = xn;
class lf extends Zu {
    constructor(t4, e) {
        super(zp.Idset, t4);
        __publicField(this, "document");
        __publicField(this, "savedOrigin", false);
        __publicField(this, "origin");
        this.document = e;
    }
    getOpTarget(t4) {
        if (t4[0] === this.document.id) return this.document.getOpTarget(t4);
        const e = this.document.pagesMgr.getSync(t4[0]);
        return e ? e.getOpTarget(t4) : void 0;
    }
    saveOrigin(t4, e) {
        this.savedOrigin || t4 && (0 === this.localops.length ? this.origin = t4[e[0].op.id] : this.origin = this.localops[0].op.origin, this.savedOrigin = true);
    }
    undoLocals() {
        if (0 === this.localops.length) return;
        const t4 = this.localops[0].op, e = t4.target, i = hf(t4);
        e && af(e, i, t4.origin);
    }
    redoLocals() {
        if (0 !== this.localops.length) for (let t4 = this.localops.length - 1; t4 >= 0; --t4) {
            const e = this.localops[t4].op, i = e.target;
            if (i) {
                af(i, e, e.data2);
                break;
            }
        }
    }
    receive(t4) {
        if (0 === t4.length) throw new Error();
        const e = t4[0].op, i = this.getOpTarget(e.path.slice(0, e.path.length - 1));
        this.saveOrigin(i, t4), this.ops.push(...t4), i ? 0 === this.localops.length && of(this.document, i, this.ops[this.ops.length - 1].op) : (this.undoLocals(), this.localops.forEach((t5) => t5.op.target = void 0));
    }
    receiveLocal(t4) {
        if (0 === t4.length) throw new Error();
        if (t4.length > this.localops.length) throw new Error();
        for (let e = 0; e < t4.length; e++) {
            const i = t4[e], s = this.localops.shift();
            if (i.cmd.id !== (s == null ? void 0 : s.cmd.id)) throw new Error("op not match");
            this.ops.push(s);
        }
    }
    commit(t4) {
        if (0 === t4.length) throw new Error();
        this.localops.push(...t4);
    }
    popLocal(t4) {
        if (this.localops.length < t4.length) throw new Error();
        for (let e = t4.length - 1; e >= 0; e--) {
            const i = t4[e], s = this.localops.pop();
            if (i.cmd !== (s == null ? void 0 : s.cmd)) throw console.log("ops", t4), console.log("op2", s, e), console.log("localops", this.localops), new Error("op not match");
        }
    }
    dropOps(t4) {
    }
    undo(t4, e) {
        if (1 !== t4.length) throw new Error(JSON.stringify(t4, (t5, e2) => t5.startsWith("__")));
        const i = t4[0].op, s = i.target, r = hf(i), n2 = s && of(this.document, s, r) || cf(r);
        if (e) e.ops.push(n2), this.commit([{ cmd: e, op: n2 }]);
        else {
            this.popLocal(t4);
            const e2 = t4[0].cmd.ops.indexOf(i);
            if (e2 < 0) throw new Error();
            t4[0].cmd.ops.splice(e2, 1, n2);
        }
    }
    redo(t4, e) {
        if (1 !== t4.length) throw new Error(JSON.stringify(t4, (t5, e2) => t5.startsWith("__")));
        const i = t4[0].op, s = this.getOpTarget(i.path.slice(0, i.path.length - 1)), r = t4[t4.length - 1].op, n2 = hf(r), o2 = s && of(this.document, s, n2) || cf(n2);
        if (e) e.ops.push(o2), this.commit([{ cmd: e, op: o2 }]);
        else {
            this.commit([{ cmd: t4[0].cmd, op: o2 }]);
            const e2 = t4[0].cmd.ops.indexOf(r);
            if (e2 < 0) throw new Error();
            t4[0].cmd.ops.splice(e2, 1, o2);
        }
    }
    roll2Version(t4, e) {
        if (Qp.comp(t4, e) > 0) throw new Error();
        const i = this.ops.concat(...this.localops);
        if (0 === i.length) return;
        if (i.findIndex((e2) => Qp.comp(e2.cmd.version, t4) > 0) < 0) return;
        const s = i[0].op, r = this.getOpTarget(s.path.slice(0, s.path.length - 1));
        if (!r) return;
        let n2, o2, a2 = i.findIndex((t5) => Qp.comp(t5.cmd.version, e) > 0);
        if (a2 < 0 && (a2 = i.length), 0 === a2) {
            const t5 = i[a2];
            n2 = t5.cmd.version;
            const e2 = t5.op;
            let s2;
            s2 = this.savedOrigin ? this.origin : e2.origin, o2 = of(this.document, r, { data: s2, id: e2.id, type: e2.type, path: e2.path });
        } else {
            const t5 = i[a2 - 1];
            if (!t5) throw new Error("not found");
            n2 = t5.cmd.version, o2 = of(this.document, r, t5.op);
        }
        if (n2 && o2 && "object" == typeof o2.data2 && o2.data2.id) {
            const t5 = /* @__PURE__ */ new Map();
            return t5.set(o2.data2.id, n2), t5;
        }
    }
}
const df = {};
function pf(t4, e, i, s = 0) {
    const r = e.getShape(i.id);
    let n2 = r || i.data;
    if ("string" == typeof n2) {
        n2 = function(t5, e2, i2, s2 = rn) {
            const r2 = "string" == typeof t5 ? JSON.parse(t5) : t5, n3 = new class {
                constructor() {
                    __publicField(this, "document", e2);
                    __publicField(this, "curPage", i2.id);
                    __publicField(this, "fmtVer", s2);
                }
            }(), o3 = df[r2.typeId];
            if (o3) return o3(r2, n3);
            throw new Error("unknow shape type: " + r2.typeId);
        }(JSON.parse(n2), t4, e, s);
    }
    const o2 = jp(e, i, n2);
    return o2 && (r && !o2.to ? e.onRemoveShape(r) : !r && o2.to && o2.data && e.onAddShape(o2.data2)), o2;
}
function uf(t4, e, i) {
    const s = t4.getShape(e.id), r = jp(t4, e, s || i);
    return r && (s && !r.to ? t4.onRemoveShape(s) : !s && r.to && r.data && t4.onAddShape(r.data2)), r;
}
function ff(t4, e, i, s = 0) {
    const r = pf(t4, e, i, s);
    if (r == null ? void 0 : r.data) {
        const t5 = r.data;
        r.data = "object" == typeof t5 ? JSON.stringify(t5, (t6, e2) => t6.startsWith("__") ? void 0 : e2) : t5;
    }
    return r;
}
function gf(t4, e, i = 0) {
    return e.target && ff(t4, e.target, _f(e), i);
}
function mf(t4, e, i = 0) {
    return e.target && pf(t4, e.target, _f(e), i);
}
function _f(t4) {
    return { id: t4.id, type: t4.type, path: t4.path, data: t4.origin, from: t4.to, to: t4.from, origin: t4.data, target: void 0, data2: void 0 };
}
function yf(t4) {
    return "object" == typeof t4.data && (t4.data = JSON.stringify(t4.data, (t5, e) => t5.startsWith("__"))), t4;
}
df["bool-shape"] = Oo, df["group-shape"] = Bo, df["image-shape"] = Co, df["path-shape"] = po, df["path-shape2"] = uo, df["rect-shape"] = _o, df["symbol-ref-shape"] = wo, df["text-shape"] = ho, df.artboard = Fo, df["line-shape"] = Io, df["oval-shape"] = Eo, df["table-shape"] = ao, df["table-cell"] = oo, df["contact-shape"] = bo, df["symbol-shape"] = Do, df["symbol-union-shape"] = Wo, df["cutout-shape"] = vo, df["polygon-shape"] = go, df["star-shape"] = xo;
class xf extends Zu {
    constructor(t4, e) {
        super(zp.CrdtTree, t4);
        __publicField(this, "document");
        this.document = e;
    }
    undoLocals() {
        for (let t4 = this.localops.length - 1; t4 >= 0; t4--) {
            const e = this.localops[t4].op, i = e.target, s = _f(e);
            i && uf(i, s, e.origin);
        }
    }
    redoLocals() {
        if (0 !== this.localops.length) for (let t4 = 0; t4 < this.localops.length; t4++) {
            const e = this.localops[t4].op, i = e.target;
            i && uf(i, e, e.data2);
        }
    }
    receive(t4) {
        if (0 === t4.length) throw new Error();
        for (let t5 = this.localops.length - 1; t5 >= 0; t5--) {
            const e2 = this.localops[t5];
            mf(this.document, e2.op, e2.cmd.dataFmtVer);
        }
        const e = this.document.pagesMgr.getSync(t4[0].op.path[0]);
        for (let i = 0; i < t4.length; i++) {
            const s = t4[i], r = e && ff(this.document, e, s.op, s.cmd.dataFmtVer);
            if (r) {
                const t5 = s.cmd.ops.indexOf(s.op);
                if (s.op = r, t5 < 0) throw new Error();
                s.cmd.ops.splice(t5, 1, r);
            }
        }
        if (this.ops.push(...t4), e) for (let t5 = 0; t5 < this.localops.length; t5++) {
            const i = this.localops[t5], s = ff(this.document, e, i.op, i.cmd.dataFmtVer);
            if (s) {
                const t6 = i.cmd.ops.indexOf(i.op);
                if (i.op = s, t6 < 0) throw new Error();
                i.cmd.ops.splice(t6, 1, s);
            } else {
                const e2 = i.cmd.ops.indexOf(i.op);
                if (e2 < 0) throw new Error();
                i.cmd.ops.splice(e2, 1), this.localops.splice(t5, 1), --t5;
            }
        }
        else for (let t5 = 0; t5 < this.localops.length; t5++) {
            this.localops[t5].op.target = void 0;
        }
    }
    receiveLocal(t4) {
        if (0 === t4.length) throw new Error();
        if (t4.length > this.localops.length) throw new Error();
        this.document.pagesMgr.getSync(t4[0].op.path[0]);
        for (let e = 0; e < t4.length; e++) {
            const i = t4[e], s = this.localops.shift();
            if (i.cmd.id !== (s == null ? void 0 : s.cmd.id)) throw new Error("op not match");
            this.ops.push(s);
        }
    }
    commit(t4) {
        this.localops.push(...t4);
    }
    popLocal(t4) {
        if (this.localops.length < t4.length) throw new Error();
        for (let e = t4.length - 1; e >= 0; e--) {
            const i = t4[e], s = this.localops.pop();
            if (i.cmd !== (s == null ? void 0 : s.cmd)) throw new Error("op not match");
        }
    }
    dropOps(t4) {
    }
    undo(t4, e) {
        if (0 === t4.length) throw new Error();
        const i = e ? void 0 : t4.map((t5) => ({ cmd: t5.cmd, op: t5.op }));
        t4.reverse();
        for (let e2 = 0; e2 < t4.length; ++e2) {
            if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
            const i2 = gf(this.document, t4[e2].op, t4[e2].cmd.dataFmtVer);
            t4[e2].op = i2 || yf(_f(t4[e2].op));
        }
        if (e) this.commit(t4.map((t5) => (e.ops.push(t5.op), { op: t5.op, cmd: e })));
        else {
            this.popLocal(i);
            for (let e2 = 0; e2 < t4.length; e2++) {
                const s = t4[e2], r = i[e2], n2 = s.cmd.ops.indexOf(r.op);
                if (n2 < 0) throw new Error();
                s.cmd.ops.splice(n2, 1);
            }
            t4[0].cmd.ops.push(...t4.map((t5) => t5.op));
        }
    }
    redo(t4, e) {
        if (0 === t4.length) throw new Error();
        t4.reverse();
        const i = this.document.pagesMgr.getSync(t4[0].op.path[0]), s = e ? void 0 : t4.map((t5) => t5.op);
        for (let e2 = 0; e2 < t4.length; ++e2) {
            if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
            const s2 = _f(t4[e2].op), r = i && ff(this.document, i, s2, t4[e2].cmd.dataFmtVer);
            t4[e2].op = r || yf(s2);
        }
        if (e) this.commit(t4.map((t5) => (e.ops.push(t5.op), { op: t5.op, cmd: e })));
        else {
            for (let e2 = 0; e2 < t4.length; e2++) {
                const i2 = t4[e2], r = s[e2], n2 = i2.cmd.ops.indexOf(r);
                if (n2 < 0) throw new Error();
                i2.cmd.ops.splice(n2, 1);
            }
            t4[0].cmd.ops.push(...t4.map((t5) => t5.op)), this.commit(t4);
        }
    }
    roll2Version(t4, e) {
        if (Qp.comp(t4, e) > 0) throw new Error();
        const i = this.ops.concat(...this.localops);
        if (0 === i.length) return;
        const s = i.findIndex((e2) => Qp.comp(e2.cmd.version, t4) > 0);
        if (s < 0) return;
        const r = this.document.pagesMgr.getSync(i[0].op.path[0]);
        if (!r) return;
        let n2 = i.findIndex((t5) => Qp.comp(t5.cmd.version, e) > 0);
        n2 < 0 && (n2 = i.length);
        const o2 = /* @__PURE__ */ new Map();
        for (let t5 = s; t5 < n2; t5++) {
            const e2 = i[t5];
            let s2;
            try {
                s2 = ff(this.document, r, e2.op, e2.cmd.dataFmtVer), (s2 == null ? void 0 : s2.data) && s2.data.id && o2.set(s2.data.id, e2.cmd.version);
            } catch (t6) {
                console.error(t6);
            }
            if (s2) {
                const t6 = e2.cmd.ops.indexOf(e2.op);
                if (e2.op = s2, t6 < 0) throw new Error();
                e2.cmd.ops.splice(t6, 1, s2);
            }
        }
        return o2;
    }
}
function wf(t4, e) {
    if (0 === t4.length || 0 === e.length) return { lhs: t4, rhs: e };
    const i = [t4], s = [], r = e.length, n2 = t4.length;
    for (let o2 = 0; o2 < r; ++o2) {
        t4 = i[o2];
        let r2 = e[o2];
        const a2 = [], h2 = [];
        i.push(a2), s.push(h2);
        for (let e2 = 0; e2 < n2; ++e2) {
            const i2 = t4[e2];
            a2.push(i2.transBy(r2)), h2.push(r2.transBy(i2)), r2 = h2[h2.length - 1];
        }
    }
    return e = s.reduce((t5, e2) => (t5.push(e2[e2.length - 1]), t5), []), { lhs: i[i.length - 1], rhs: e };
}
function bf(t4, e, i) {
    var _a2, _b, _c2, _d2;
    if (i.type !== zp.Array) throw new Error("not array op");
    switch (i.type1) {
        case tu.None:
            break;
        case tu.Insert:
            if (!(i instanceof au)) throw new Error("not text insert op");
            if ("simple" === i.text.type) {
                const t6 = ((_a2 = i.text.props) == null ? void 0 : _a2.attr) ? Un((_b = i.text.props) == null ? void 0 : _b.attr) : void 0, s2 = ((_c2 = i.text.props) == null ? void 0 : _c2.paraAttr) ? Qn((_d2 = i.text.props) == null ? void 0 : _d2.paraAttr) : void 0;
                e.insertText(i.text.text, i.start, { attr: t6, paraAttr: s2 });
            } else {
                if ("complex" !== i.text.type) throw new Error("not valid text insert op");
                {
                    const t6 = ro(i.text.text);
                    e.insertFormatText(t6, i.start);
                }
            }
            return new hu(i.id, i.path, i.order, i.start, i.length, i.text, e);
        case tu.Remove:
            const t5 = e.deleteText(i.start, i.length);
            if (t5) return new lu(i.id, i.path, i.order, i.start, i.length, t5, e);
            break;
        case tu.Attr:
            if (!(i instanceof du)) throw new Error("not text attr op");
            const s = i.props.key;
            let r = i.props.value;
            const n2 = i.start, o2 = i.length;
            if ("object" == typeof r && r.typeId) if ("color" === r.typeId) r = cn(r);
            else {
                if ("gradient" !== r.typeId) throw new Error("need import " + r.typeId);
                r = Hn(r);
            }
            if ("span" === i.props.target) {
                const t6 = e.formatText(n2, o2, s, r);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            } else if ("bulletNumbersType" === s) {
                const t6 = e.setBulletNumbersType(r, n2, o2);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            } else if ("bulletNumbersStart" === s) {
                const t6 = e.setBulletNumbersStart(r, n2, o2);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            } else if ("bulletNumbersBehavior" === s) {
                const t6 = e.setBulletNumbersBehavior(r, n2, o2);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            } else if ("indent" === s) {
                const t6 = e.setParaIndent(r, n2, o2);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            } else {
                const t6 = e.formatPara(n2, o2, s, r);
                if (t6.length > 0) return new pu(i.id, i.path, i.order, i.start, i.length, i.props, t6, e);
            }
        case tu.Selection:
    }
}
function Mf(t4) {
    if (t4.op.type !== zp.Array) throw new Error("not array op");
    return vf(t4.op);
}
function vf(t4) {
    switch (t4.type1) {
        case tu.None:
            return t4;
        case tu.Insert:
            if (!(t4 instanceof hu)) throw new Error("not text insert op");
            return new cu("", t4.path, Qp.MAX_SAFE_INTEGER, t4.start, t4.length);
        case tu.Remove:
            if (!(t4 instanceof lu)) throw new Error("not text remove op");
            return new au("", t4.path, Qp.MAX_SAFE_INTEGER, t4.start, t4.length, { type: "complex", text: t4.text });
        case tu.Attr:
            if (!(t4 instanceof pu)) throw new Error("not text attr op");
            const e = t4.origin, i = t4.props.key, s = [];
            return e.forEach((e2) => {
                s.push(new du("", t4.path, Qp.MAX_SAFE_INTEGER, e2.index, e2.len, { target: t4.props.target, key: i, value: e2.value }));
            }), s;
        case tu.Selection:
            return t4.clone();
    }
}
function Sf(t4) {
    switch (t4.type1) {
        case tu.None:
            return;
        case tu.Insert:
            if (!(t4 instanceof hu)) throw new Error("not text insert op");
            return t4.target;
        case tu.Remove:
            if (!(t4 instanceof lu)) throw new Error("not text remove op");
            return t4.target;
        case tu.Attr:
            if (!(t4 instanceof pu)) throw new Error("not text attr op");
            return t4.target;
        case tu.Selection:
            return;
    }
}
function Cf(t4, e) {
    const i = [], s = vf(e);
    if (s instanceof ou) i.push(s);
    else if (Array.isArray(s)) {
        const t5 = Sf(e);
        for (let e2 = 0; e2 < s.length; ++e2) {
            const r = s[e2], n2 = t5 && bf(0, t5, r);
            if (!n2) throw new Error();
            i.push(n2);
        }
    } else if (s) {
        const t5 = Sf(e), r = t5 && bf(0, t5, s);
        if (!r) throw new Error();
        i.push(r);
    }
    return i;
}
class Tf extends Zu {
    constructor(t4, e, i) {
        super(zp.Array, t4);
        __publicField(this, "document");
        __publicField(this, "selection");
        __publicField(this, "popedOps", []);
        this.document = e, this.selection = i;
    }
    getOpTarget(t4) {
        const e = this.document.pagesMgr.getSync(t4[0]);
        if (e) return e.getOpTarget(t4);
    }
    _otreceive(t4) {
        const e = [];
        for (let i = 0; i < t4.length; ) {
            const s = [];
            e.push(s);
            const r = t4[i].cmd.batchId;
            for (s.push(t4[i]), ++i; i < t4.length && t4[i].cmd.batchId === r; ++i) s.push(t4[i]);
        }
        for (let t5 = 0; t5 < e.length; ++t5) {
            const i = e[t5], s = i[0].cmd.baseVer, r = this.ops.findIndex((t6) => Qp.comp(t6.cmd.version, s) > 0);
            if (r >= 0) {
                const t6 = wf(this.ops.slice(r).map((t7) => t7.op), i.map((t7) => t7.op)).rhs;
                for (let e2 = 0; e2 < t6.length; e2++) {
                    const s2 = i[e2].op, r2 = i[e2].cmd, n2 = t6[e2];
                    i[e2].op = n2;
                    const o2 = r2.ops.indexOf(s2);
                    if (o2 < 0) throw new Error();
                    r2.ops.splice(o2, 1, n2);
                }
            }
            this.ops.push(...i);
        }
    }
    undoLocals() {
        for (let t4 = this.localops.length - 1; t4 >= 0; t4--) {
            const e = this.localops[t4];
            Cf(this.document, e.op);
        }
    }
    redoLocals() {
        for (let t4 = 0; t4 < this.localops.length; t4++) {
            const e = this.localops[t4], i = Sf(e.op);
            i && bf(this.document, i, e.op);
        }
    }
    receive(t4) {
        var _a2, _b;
        if (0 === t4.length) return;
        this._otreceive(t4);
        for (let t5 = this.localops.length - 1; t5 >= 0; t5--) {
            const e2 = this.localops[t5];
            Cf(this.document, e2.op);
        }
        const e = this.getOpTarget(t4[0].op.path);
        if (e) for (let i2 = 0; i2 < t4.length; i2++) {
            const s2 = t4[i2], r2 = bf(this.document, e, s2.op);
            if (r2) {
                const t5 = s2.cmd.ops.indexOf(s2.op);
                if (s2.op = r2, t5 < 0) throw new Error();
                s2.cmd.ops.splice(t5, 1, r2);
            }
        }
        let i = (_a2 = this.selection) == null ? void 0 : _a2.saveText(t4[0].op.path);
        const s = t4.map((t5) => t5.op), r = this.localops.map((t5) => t5.op);
        i && r.push(i);
        const { lhs: n2, rhs: o2 } = wf(s, r);
        i && (i = o2.pop());
        for (let t5 = 0; t5 < this.localops.length; t5++) {
            const e2 = this.localops[t5], i2 = e2.cmd, s2 = e2.op;
            if (s2.type1 === tu.Selection) {
                const e3 = s2, i3 = o2[t5];
                e3.start = i3.start, e3.length = i3.length;
                continue;
            }
            e2.op = o2[t5];
            const r2 = i2.ops.indexOf(s2);
            i2.ops.splice(r2, 1, e2.op);
        }
        if (e) for (let t5 = 0; t5 < this.localops.length; t5++) {
            const i2 = this.localops[t5];
            if (i2.op.type1 === tu.Selection) continue;
            const s2 = bf(this.document, e, i2.op);
            if (s2) {
                const t6 = i2.cmd.ops.indexOf(i2.op);
                if (i2.op = s2, t6 < 0) throw new Error();
                i2.cmd.ops.splice(t6, 1, s2);
            } else {
                const e2 = i2.cmd.ops.indexOf(i2.op);
                if (e2 < 0) throw new Error();
                i2.cmd.ops.splice(e2, 1), this.localops.splice(t5, 1), --t5;
            }
        }
        else for (let t5 = 0; t5 < this.localops.length; t5++) {
            this.localops[t5].op.target = void 0;
        }
        i && ((_b = this.selection) == null ? void 0 : _b.restoreText(i));
    }
    receiveLocal(t4) {
        if (0 === t4.length) throw new Error();
        if (t4.length > this.localops.length) throw new Error();
        for (let e = 0; e < t4.length; ) {
            const i = t4[e];
            let s = 1, r = 0;
            for (let r2 = e + 1; r2 < t4.length; ++r2) {
                if (t4[r2].cmd.id !== i.cmd.id) break;
                ++s;
            }
            for (; this.localops.length > 0 && this.localops[0].cmd.id === i.cmd.id; ) {
                const t5 = this.localops.shift();
                ++r, t5.op.type1 !== tu.Selection && this.ops.push(t5);
            }
            if (s !== r) throw new Error("op not match");
            e += s;
        }
    }
    commit(t4) {
        this.localops.push(...t4);
    }
    _popLocal(t4) {
        if (this.localops.length < t4.length) throw console.log(this.localops, t4), new Error();
        const e = { cmd: t4[0].cmd, ops: [], otpath: [], refIdx: this.ops.length - 1 };
        for (let i = t4.length - 1; i >= 0; i--) {
            const s = t4[i], r = this.localops.pop();
            if (s.cmd !== (r == null ? void 0 : r.cmd)) throw new Error("op not match");
            e.ops.unshift(r.op);
        }
        e.otpath = this.localops.slice(0), this.popedOps.push(e);
    }
    dropOps(t4) {
        this.popedOps.length = 0;
    }
    undo(t4, e) {
        if (0 === t4.length) throw new Error();
        let i = 0;
        for (let e2 = 0; e2 < t4.length; e2++) {
            if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
            t4[e2].op.type1 !== tu.Selection && ++i;
        }
        const s = this.ops.concat(...this.localops.filter((t5) => t5.op.type1 !== tu.Selection));
        if (0 === s.length) throw new Error();
        if (s.length < i) throw new Error();
        const r = s.findLastIndex((e2) => e2.cmd.id === t4[0].cmd.id) - i + 1;
        if (r < 0) throw new Error("not find ops");
        for (let e2 = 0; e2 < i; e2++) if (s[r + e2].cmd.id !== t4[0].cmd.id) throw new Error("cmd");
        let n2 = t4.map((t5) => {
            const e2 = Mf(t5);
            return Array.isArray(e2) ? e2.forEach((e3) => e3.target = t5.op.target) : e2.target = t5.op.target, e2;
        }).reverse().reduce((t5, e2) => (Array.isArray(e2) ? t5.push(...e2.slice(0).reverse()) : t5.push(e2), t5), []);
        const o2 = s.slice(r + i).map((t5) => t5.op);
        if (o2.length > 0) {
            let t5 = 0;
            for (let e3 = o2.length - 1; e3 >= 0 && o2[e3].order === Qp.MAX_SAFE_INTEGER; --e3) ++t5, o2[e3].order = Qp.minus(Qp.MAX_SAFE_INTEGER, o2.length - e3);
            const { lhs: e2, rhs: i2 } = wf(o2, n2);
            i2.forEach((t6, e3) => t6.target = n2[e3].target), n2 = i2;
            for (let e3 = o2.length - t5; e3 < o2.length; ++e3) o2[e3].order = Qp.MAX_SAFE_INTEGER;
        }
        const a2 = n2.map((t5) => t5.target && bf(this.document, t5.target, t5) || t5);
        if (e) e.ops.push(...a2), this.commit(a2.map((t5) => ({ cmd: e, op: t5 })));
        else {
            this._popLocal(t4);
            for (let e2 = 0; e2 < t4.length; e2++) {
                const i2 = t4[e2], s2 = i2.cmd.ops.indexOf(i2.op);
                if (s2 < 0) throw new Error();
                i2.cmd.ops.splice(s2, 1);
            }
            t4[0].cmd.ops.push(...a2);
        }
    }
    redo(t4, e) {
        if (e) return this.undo(t4, e);
        if (0 === t4.length) throw new Error();
        for (let e2 = 1; e2 < t4.length; e2++) if (t4[e2].cmd !== t4[0].cmd) throw new Error("not single cmd");
        if (0 === this.popedOps.length) throw new Error();
        const i = t4[0].cmd, s = this.popedOps.findIndex((t5) => t5.cmd === i);
        if (s < 0) throw new Error("not find ops");
        const r = this.popedOps.splice(s, 1)[0];
        if (!r) throw new Error("not find ops");
        const n2 = t4.map(Mf).reduce((t5, e2) => (Array.isArray(e2) ? t5.push(...e2.slice(0).reverse()) : t5.push(e2), t5), []).reverse(), o2 = this.ops.slice(r.refIdx + 1).concat(...this.localops), a2 = r.otpath;
        let h2 = a2.map((t5) => t5.op).concat(...n2);
        for (let t5 = 0; t5 < a2.length; t5++) {
            const e2 = a2[t5].cmd, i2 = o2.findIndex((t6) => t6.cmd === e2);
            if (i2 < 0) throw new Error();
            const s2 = wf(h2, o2.slice(0, i2).map((t6) => t6.op));
            let r2 = 1;
            for (; t5 < a2.length - 1 && a2[t5 + 1].cmd === e2; ) {
                if (o2[i2 + r2].cmd !== e2) throw new Error();
                ++r2, ++t5;
            }
            o2.splice(0, i2 + r2), h2 = s2.lhs, h2.splice(0, r2);
        }
        if (o2.length > 0) {
            h2 = wf(h2, o2.map((t5) => t5.op)).lhs;
        }
        if (h2.length !== n2.length) throw new Error();
        const c2 = this.getOpTarget(t4[0].op.path), l2 = c2 ? h2.map((t5) => bf(this.document, c2, t5) || t5) : h2;
        for (let e2 = 0; e2 < t4.length; e2++) {
            const i2 = t4[e2], s2 = i2.cmd.ops.indexOf(i2.op);
            if (s2 < 0) throw new Error();
            i2.cmd.ops.splice(s2, 1);
        }
        t4[0].cmd.ops.push(...l2), this.commit(l2.map((e2) => ({ cmd: t4[0].cmd, op: e2 })));
    }
    roll2Version(t4, e) {
        if (Qp.comp(t4, e) > 0) throw new Error();
        const i = this.ops.concat(...this.localops);
        if (0 === i.length) return;
        const s = i.findIndex((e2) => Qp.comp(e2.cmd.version, t4) > 0);
        if (s < 0) return;
        const r = this.getOpTarget(i[0].op.path);
        if (!r) return;
        let n2 = i.findIndex((t5) => Qp.comp(t5.cmd.version, e) > 0);
        n2 < 0 && (n2 = i.length);
        for (let t5 = s; t5 < n2; t5++) {
            const e2 = i[t5];
            let s2;
            try {
                s2 = bf(this.document, r, e2.op);
            } catch (t6) {
                console.error(t6);
            }
            if (s2) {
                const t6 = e2.cmd.ops.indexOf(e2.op);
                if (e2.op = s2, t6 < 0) throw new Error();
                e2.cmd.ops.splice(t6, 1, s2);
            }
        }
    }
}
function If(t4, e) {
    return (i, s) => {
        switch (s.type) {
            case zp.Array:
                return new Tf(i, t4, e);
            case zp.CrdtArr:
                return new rf(i, t4);
            case zp.CrdtTree:
                return new xf(i, t4);
            case zp.Idset:
                return new lf(i, t4);
            case zp.None:
                throw new Error("op none?");
        }
    };
}
class kf {
    constructor(t4, e, i, s) {
        __publicField(this, "pullTasks", []);
        __publicField(this, "net");
        __publicField(this, "baseVer");
        __publicField(this, "lastVer");
        __publicField(this, "receive");
        __publicField(this, "__pulling", false);
        this.net = t4, this.baseVer = e, this.lastVer = i, this.receive = s;
    }
    setNet(t4) {
        this.net = t4;
    }
    pull(t4, e) {
        console.log("pull cmds, from: " + t4 + " to: " + e), this.pullTasks.push({ from: t4, to: e });
        for (let t5 = 1; t5 < this.pullTasks.length; ++t5) this._merge(t5);
        this._pull();
    }
    updateVer(t4, e) {
        this.baseVer = t4, this.lastVer = e;
    }
    get pulling() {
        return this.__pulling;
    }
    _merge(t4) {
        let { from: e, to: i } = this.pullTasks[t4];
        for (let s = t4 + 1; s < this.pullTasks.length; ) {
            const t5 = this.pullTasks[s];
            (void 0 === t5.to || Qp.comp(t5.to, e) >= 0) && (void 0 === i || Qp.comp(t5.from, i) <= 0) ? (Qp.comp(e, t5.from) > 0 && (e = t5.from), void 0 === t5.to ? i = void 0 : void 0 !== i && Qp.comp(i, t5.to) < 0 && (i = t5.to), this.pullTasks.splice(s, 1)) : ++s;
        }
        return Qp.comp(e, this.baseVer) >= 0 && Qp.comp(e, this.lastVer) <= 0 && (e = this.lastVer), void 0 !== i && Qp.comp(i, this.baseVer) >= 0 && Qp.comp(i, this.lastVer) <= 0 && (i = this.baseVer), void 0 !== i && Qp.comp(e, i) > 0 ? (this.pullTasks.splice(t4, 1), false) : (this.pullTasks[t4].from = e, this.pullTasks[t4].to = i, true);
    }
    _pull() {
        if (this.__pulling) return;
        if (0 === this.pullTasks.length) return;
        if (!this._merge(0)) return void this._pull();
        let { from: t4, to: e } = this.pullTasks[0];
        "" === t4 && (t4 = "0"), this.__pulling = true, this.net.pullCmds(t4, e).then((t5) => {
            console.log("pull back"), this.__pulling = false, this.pullTasks.shift(), this.receive(t5), this._pull();
        }).catch((t5) => {
            this.__pulling = false, this._pull();
        });
    }
}
const Ef = 5e3;
function Af(t4) {
    const e = [], i = /* @__PURE__ */ new Map();
    for (let s = 0; s < t4.length; s++) {
        const r = t4[s];
        for (let t5 = 0; t5 < r.ops.length; ++t5) {
            const s2 = r.ops[t5];
            if (s2 instanceof eu && s2.order !== r.version) throw new Error("op.order !== cmd.version");
            const n2 = s2.path.join("/");
            let o2 = i.get(n2);
            o2 || (o2 = [], i.set(n2, o2), e.push(n2)), o2.push({ op: s2, cmd: r });
        }
    }
    return e.map((t5) => ({ k: t5, v: i.get(t5) }));
}
function Ff(t4) {
    const e = t4.ops;
    for (let t5 = 0; t5 < e.length; ++t5) {
        const i = e[t5];
        switch (i.type) {
            case zp.None:
            case zp.Array:
                break;
            case zp.CrdtArr:
            case zp.CrdtTree:
                const t6 = i;
                if (!t6.from && t6.to && "string" == typeof t6.data && ("{" === t6.data[0] || "[" === t6.data[0])) return false;
                break;
            case zp.Idset:
                if ("string" == typeof i.data && ("{" === i.data[0] || "[" === i.data[0])) return false;
        }
    }
    return true;
}
class Rf {
    constructor(t4, e, i) {
        __publicField(this, "nettask");
        __publicField(this, "repo");
        __publicField(this, "nodecreator");
        __publicField(this, "net");
        __publicField(this, "document");
        __publicField(this, "baseVer", "");
        __publicField(this, "dataVer", "");
        __publicField(this, "cmds", []);
        __publicField(this, "pendingcmds", []);
        __publicField(this, "posttime", 0);
        __publicField(this, "postingcmds", []);
        __publicField(this, "nopostcmds", []);
        __publicField(this, "nopostcmdidx", 0);
        __publicField(this, "repotrees", /* @__PURE__ */ new Map());
        __publicField(this, "onProcessCmdsEnd", () => {
        });
        __publicField(this, "__processTimeToken");
        this.document = t4, this.repo = e, this.nodecreator = If(t4, void 0), this.net = i, this.net.watchCmds(this.receive.bind(this)), this.net.watchError(this.receiveErr.bind(this)), this.nettask = new kf(i, this.baseVer, this.baseVer, this.receive.bind(this));
    }
    setSelection(t4) {
        this.nodecreator = If(this.document, t4);
    }
    setNet(t4) {
        this.net = t4, this.nettask.setNet(t4), this.net.watchCmds(this.receive.bind(this)), this.net.watchError(this.receiveErr.bind(this));
    }
    setBaseVer(t4) {
        this.baseVer = t4, this.dataVer = t4;
    }
    hasPendingSyncCmd() {
        return this.postingcmds.length > 0 || this.nopostcmdidx > 0;
    }
    getRepoTree(t4) {
        let e = this.repotrees.get(t4);
        return e || (e = new ju(void 0, t4), this.repotrees.set(t4, e)), e;
    }
    __receive(t4) {
        for (; t4.length > 0; ) {
            const e = t4[0].batchId;
            let i = 1;
            for (; i < t4.length && t4[i].batchId === e; ) ++i;
            const s = Af(t4.splice(0, i));
            for (let { k: t5, v: e2 } of s) {
                const t6 = e2[0].op, i2 = t6.path[0];
                const s2 = this.getRepoTree(i2).buildAndGet(t6, t6.path.slice(1), this.nodecreator);
                try {
                    s2.receive(e2);
                } catch (t7) {
                    console.error(t7);
                }
            }
        }
    }
    __receiveRecovery(t4) {
        const e = Af([t4]);
        for (let { k: i, v: s } of e) {
            const e2 = s[0].op, i2 = e2.path[0];
            let r = this.getRepoTree(i2);
            const n2 = r.buildAndGet(e2, e2.path.slice(1), this.nodecreator);
            try {
                n2.receive(s);
            } catch (t5) {
                console.error(t5);
            }
            const o2 = s[0].op;
            switch (o2.type) {
                case zp.None:
                case zp.Array:
                    break;
                case zp.CrdtArr:
                case zp.CrdtTree:
                {
                    const e3 = o2, i3 = r.get3(e3.path.slice(1).concat(e3.id));
                    i3.baseVer = t4.baseVer;
                    try {
                        i3.roll2Version(t4.baseVer, Qp.MAX_SAFE_INTEGER);
                    } catch (t5) {
                        console.error(t5);
                    }
                }
                    break;
                case zp.Idset: {
                    const e3 = o2, i3 = r.get3(e3.path.slice(1));
                    i3.baseVer = t4.baseVer;
                    try {
                        i3.roll2Version(t4.baseVer, Qp.MAX_SAFE_INTEGER);
                    } catch (t5) {
                        console.error(t5);
                    }
                }
            }
        }
    }
    _receive(t4) {
        for (; t4.length > 0; ) {
            const e = t4.findIndex((t5) => t5.isRecovery);
            if (e < 0) {
                this.__receive(t4);
                break;
            }
            e > 0 && this.__receive(t4.slice(0, e));
            const i = t4[e];
            t4.splice(0, e + 1), this.__receiveRecovery(i);
        }
    }
    _receiveLocal(t4) {
        const e = Af(t4);
        for (let { k: t5, v: i } of e) {
            const t6 = i[0].op, e2 = t6.path[0], s = this.getRepoTree(e2).buildAndGet(t6, t6.path.slice(1), this.nodecreator);
            try {
                s.receiveLocal(i);
            } catch (t7) {
                console.error(t7);
            }
        }
    }
    watchProcessCmdsEnd(t4) {
        this.onProcessCmdsEnd = t4;
    }
    processCmds(t4 = true) {
        const e = (t5) => {
            this.__processTimeToken || (this.__processTimeToken = setTimeout(() => {
                this.__processTimeToken = void 0, this.processCmds(false);
            }, t5));
        };
        if (this.nettask.pulling) e(Ef);
        else if (this.repo.isInTransact()) e(1e3);
        else if (t4) e(1);
        else {
            if (this.pendingcmds.length > 0) {
                const t5 = this.pendingcmds, i = t5.reduce((t6, e2) => Qp.comp(t6, e2.baseVer) > 0 ? e2.baseVer : t6, t5[0].baseVer);
                if (Qp.comp(this.baseVer, i) > 0) return this.nettask.pull(i, this.baseVer), void e(Ef);
            }
            if (this.__processTimeToken && (clearTimeout(this.__processTimeToken), this.__processTimeToken = void 0), this.pendingcmds.length > 0) {
                this.repo.start("processCmds");
                const t5 = this.repo.transactCtx.settrap;
                try {
                    this.repo.transactCtx.settrap = false, this._processCmds(), this.repo.commit();
                } catch (t6) {
                    console.error(t6), this.repo.rollback();
                } finally {
                    this.repo.transactCtx.settrap = t5;
                }
            }
            this.onProcessCmdsEnd(), this._postcmds(e);
        }
    }
    _processCmds() {
        var _a2;
        const t4 = (_a2 = this.postingcmds[0]) == null ? void 0 : _a2.id, e = t4 ? this.pendingcmds.findIndex((e2) => e2.id === t4) : -1;
        if (e >= 0) {
            if (e > 0) {
                const t6 = this.pendingcmds.slice(0, e);
                this._receive(t6);
            }
            const t5 = this.pendingcmds.slice(e, e + this.postingcmds.length);
            for (let e2 = 0; e2 < t5.length; ++e2) this.postingcmds[e2].batchId = t5[e2].batchId, this.postingcmds[e2].version = t5[e2].version, this.postingcmds[e2].ops.forEach((i) => {
                i instanceof eu && (i.order = t5[e2].version);
            });
            if (this._receiveLocal(this.postingcmds.splice(0, t5.length)), this.pendingcmds.length > e + t5.length) {
                const i = this.pendingcmds.slice(e + t5.length);
                this._receive(i);
            }
            if (this.cmds.push(...this.pendingcmds), this.pendingcmds.length = 0, this.postingcmds.length > 0) for (let t6 = 0; t6 < this.postingcmds.length; ++t6) this.postingcmds[t6].batchId = this.postingcmds[0].id;
        }
        this.pendingcmds.length > 0 && (this._receive(this.pendingcmds.slice(0)), this.cmds.push(...this.pendingcmds), this.pendingcmds.length = 0);
    }
    _commit(t4) {
        var _a2;
        this.nopostcmds.length = this.nopostcmdidx;
        for (let e2 = 0; e2 < this.nopostcmds.length; ++e2) if (this.nopostcmds[e2].id === t4.id) throw new Error("duplicate cmd id");
        this.nopostcmds.push(t4), ++this.nopostcmdidx;
        const e = Af([t4]);
        for (let { k: i, v: s } of e) {
            if (1 === s.length && s[0].op === ((_a2 = t4.saveselection) == null ? void 0 : _a2.text)) {
                const e3 = t4.ops.indexOf(s[0].op);
                e3 >= 0 && t4.ops.splice(e3, 1), t4.saveselection.text = void 0;
                continue;
            }
            const e2 = s[0].op, i2 = e2.path[0];
            this.getRepoTree(i2).buildAndGet(e2, e2.path.slice(1), this.nodecreator).commit(s);
        }
        this.processCmds();
    }
    _commit2(t4) {
        this.nopostcmds.length = this.nopostcmdidx;
        for (let e = 0; e < this.nopostcmds.length; ++e) if (this.nopostcmds[e].id === t4.id) throw new Error("duplicate cmd id");
        this.nopostcmds.push(t4), ++this.nopostcmdidx, this.processCmds();
    }
    commit(t4) {
        this._commit(t4);
    }
    undo(e) {
        var _a2, _b, _c2;
        const i = e.posttime > 0 ? { id: v4(), mergetype: e.mergetype, delay: 500, version: Qp.MAX_SAFE_INTEGER, previousVersion: "", baseVer: "", batchId: "", ops: [], isRecovery: true, description: e.description, time: Date.now(), posttime: 0, saveselection: e.saveselection && Hp(e.saveselection), selectionupdater: e.selectionupdater, dataFmtVer: rn } : void 0;
        ((_a2 = i == null ? void 0 : i.saveselection) == null ? void 0 : _a2.text) && (i.saveselection.text.order = Qp.MAX_SAFE_INTEGER);
        const s = Af([e]);
        for (let { k: t4, v: r } of s) {
            const t5 = r[0].op, s2 = t5.path[0], n2 = this.repotrees.get(s2), o2 = n2 && n2.get(t5.path.slice(1));
            if (!o2) throw new Error("cmd");
            i ? o2.undo(r, i) : e === this.nopostcmds[this.nopostcmdidx] ? o2.redo(r, void 0) : e === this.nopostcmds[this.nopostcmdidx - 1] ? o2.undo(r, void 0) : o2.redo(r, void 0);
        }
        if (i) {
            if ((_b = i.saveselection) == null ? void 0 : _b.text) {
                const t4 = i.saveselection.text, e2 = i.ops.findIndex((e3) => e3.id === t4.id);
                if (e2 < 0) throw new Error();
                i.ops.splice(e2, 1, t4);
            }
            this._commit2(i);
        } else {
            if ((_c2 = e.saveselection) == null ? void 0 : _c2.text) {
                const t4 = e.saveselection.text, i2 = e.ops.findIndex((e2) => e2.id === t4.id);
                if (i2 < 0) throw new Error();
                e.saveselection.text = e.ops[i2];
            }
            e === this.nopostcmds[this.nopostcmdidx] ? ++this.nopostcmdidx : e === this.nopostcmds[this.nopostcmdidx - 1] ? --this.nopostcmdidx : this._commit2(e), this.processCmds();
        }
        return i ?? e;
    }
    redo(e) {
        var _a2, _b, _c2;
        const i = e.posttime > 0 ? { id: v4(), mergetype: e.mergetype, delay: 500, version: Qp.MAX_SAFE_INTEGER, previousVersion: "", batchId: "", baseVer: "", ops: [], isRecovery: true, description: e.description, time: Date.now(), posttime: 0, saveselection: e.saveselection && Hp(e.saveselection), selectionupdater: e.selectionupdater, dataFmtVer: rn } : void 0;
        ((_a2 = i == null ? void 0 : i.saveselection) == null ? void 0 : _a2.text) && (i.saveselection.text.order = Qp.MAX_SAFE_INTEGER);
        const s = Af([e]);
        for (let { k: t4, v: r } of s) {
            const t5 = r[0].op, s2 = t5.path[0], n2 = this.repotrees.get(s2), o2 = n2 && n2.get(t5.path.slice(1));
            if (!o2) throw new Error("cmd");
            i ? o2.redo(r, i) : e === this.nopostcmds[this.nopostcmdidx] ? o2.redo(r, void 0) : e === this.nopostcmds[this.nopostcmdidx - 1] ? o2.undo(r, void 0) : o2.redo(r, void 0);
        }
        if (i) {
            if ((_b = i.saveselection) == null ? void 0 : _b.text) {
                const t4 = i.saveselection.text, e2 = i.ops.findIndex((e3) => e3.id === t4.id);
                if (e2 < 0) throw new Error();
                i.ops.splice(e2, 1, t4);
            }
            this._commit2(i);
        } else {
            if ((_c2 = e.saveselection) == null ? void 0 : _c2.text) {
                const t4 = e.saveselection.text, i2 = e.ops.findIndex((e2) => e2.id === t4.id);
                if (i2 < 0) throw new Error();
                e.saveselection.text = e.ops[i2];
            }
            e === this.nopostcmds[this.nopostcmdidx] ? ++this.nopostcmdidx : e === this.nopostcmds[this.nopostcmdidx - 1] ? --this.nopostcmdidx : this._commit2(e), this.processCmds();
        }
        return i ?? e;
    }
    receiveErr(t4) {
        this.postingcmds.length > 1 ? this.nettask.pull(t4.duplicateCmd.version) : this.receive([t4.duplicateCmd]);
    }
    receive(t4) {
        var _a2;
        console.log("receive", t4);
        let e = this.baseVer;
        if (this.pendingcmds.length > 0 ? e = this.pendingcmds[this.pendingcmds.length - 1].version : this.cmds.length > 0 && (e = this.cmds[this.cmds.length - 1].version), t4.length > 0) {
            const e2 = t4[0];
            Qp.comp(e2.previousVersion, e2.baseVer) < 0 && (e2.previousVersion = e2.baseVer);
        }
        const i = [], s = [];
        for (let r2 = 0; r2 < t4.length; ) {
            const n2 = t4[r2], o2 = Qp.comp(n2.previousVersion, e);
            if (o2 < 0 && 0 === r2) i.push(n2), t4.shift();
            else {
                if (0 !== o2) {
                    s.push(...t4.splice(r2, t4.length - r2));
                    break;
                }
                e = n2.version, ++r2;
            }
        }
        let r = false;
        if (i.length > 0) {
            const t5 = i.findIndex((t6) => t6.version === this.baseVer);
            if (t5 >= 0) {
                r = true;
                const e2 = [];
                let s2 = this.baseVer;
                for (let r2 = t5; r2 >= 0; --r2) {
                    const t6 = i[r2];
                    if (t6.version !== s2) break;
                    e2.push(t6), s2 = t6.previousVersion;
                }
                i.splice(t5 - e2.length + 1, e2.length), e2.reverse(), e2.forEach((t6) => {
                    t6.ops.forEach((e3) => {
                        e3 instanceof eu && (e3.order = t6.version);
                    });
                }), this.baseVer = e2[0].previousVersion, this.cmds.unshift(...e2);
                const n2 = Af(e2);
                for (let { k: t6, v: e3 } of n2) {
                    const t7 = e3[0].op, i2 = t7.path[0];
                    this.getRepoTree(i2).buildAndGet(t7, t7.path.slice(1), this.nodecreator).unshift(e3);
                }
            }
            i.length > 0 && console.log("abort head cmds: ", i);
        }
        if (s.length > 0 && (console.log("abort received cmds: ", s, "lastVer: " + e, "cmds: ", this.cmds, "pendingcmds: ", this.pendingcmds), 0 === t4.length)) {
            const t5 = s[s.length - 1].version;
            Qp.comp(e, t5) < 0 && this.nettask.pull(e);
        }
        (0 !== t4.length || r) && (t4.forEach((t5) => {
            t5.ops.forEach((e2) => {
                e2 instanceof eu && (e2.order = t5.version);
            });
        }), function(t5) {
            t5.forEach((t6) => {
                (t6.dataFmtVer ?? 0) < sn && t6.ops.forEach((t7) => {
                    if (t7.type === zp.Idset) switch (t7.id) {
                        case "x":
                            "frame" === t7.path[t7.path.length - 2] && (t7.path[t7.path.length - 2] = "transform", t7.id = "m02", t7.path[t7.path.length - 1] = "m02");
                            break;
                        case "y":
                            "frame" === t7.path[t7.path.length - 2] && (t7.path[t7.path.length - 2] = "transform", t7.id = "m12", t7.path[t7.path.length - 1] = "m12");
                            break;
                        case "width":
                        case "height":
                            "frame" === t7.path[t7.path.length - 2] && (t7.path[t7.path.length - 2] = "size");
                    }
                });
            });
        }(t4), this.pendingcmds.push(...t4), this.nettask.updateVer(this.baseVer, ((_a2 = t4[t4.length - 1]) == null ? void 0 : _a2.version) ?? e), this.processCmds(false));
    }
    _postcmds(t4) {
        if (this.postingcmds.length > 0) {
            const e2 = Date.now();
            if (e2 - this.posttime > Ef) {
                const t5 = /* @__PURE__ */ new Set();
                for (let e3 = 0; e3 < this.postingcmds.length; ++e3) {
                    const i2 = this.postingcmds[e3].id;
                    if (t5.has(i2)) throw new Error("duplicate cmd id");
                    t5.add(i2);
                }
                this.net.postCmds(this.postingcmds), this.posttime = e2;
            }
            return void t4(Ef);
        }
        if (!this.net.hasConnected()) return void t4(Ef);
        if (0 === this.nopostcmdidx) return;
        const e = this.cmds.length > 0 ? this.cmds[this.cmds.length - 1].version : this.baseVer;
        let i = Ef;
        const s = Date.now(), r = this.nopostcmdidx;
        for (let t5 = 0; t5 < r; t5++) {
            const n2 = this.nopostcmds[t5];
            if (!(t5 < r - 1 || s - n2.time > n2.delay)) {
                i = n2.delay;
                break;
            }
            if (n2.isRecovery) if (Ff(n2)) n2.isRecovery = false;
            else {
                if (this.postingcmds.length > 0) break;
                {
                    this.repo.start("_alignDataVersion");
                    const t6 = this.repo.transactCtx.settrap;
                    try {
                        this.repo.transactCtx.settrap = false, this._alignDataVersion(n2), this.repo.commit();
                    } catch (t7) {
                        console.error(t7), this.repo.rollback();
                    } finally {
                        this.repo.transactCtx.settrap = t6;
                    }
                }
            }
            if (this.postingcmds.push(n2), n2.baseVer = e, n2.posttime = s, n2.batchId = this.postingcmds[0].id, n2.isRecovery) break;
        }
        if (this.postingcmds.length > 0) {
            this.posttime = s, this.nopostcmds.splice(0, this.postingcmds.length), this.nopostcmdidx -= this.postingcmds.length;
            const t5 = /* @__PURE__ */ new Set();
            for (let e2 = 0; e2 < this.postingcmds.length; ++e2) {
                const i2 = this.postingcmds[e2].id;
                if (t5.has(i2)) throw new Error("duplicate cmd id");
                t5.add(i2);
            }
            this.net.postCmds(this.postingcmds);
        }
        t4(i);
    }
    _alignDataVersion(t4) {
        if (t4 !== this.nopostcmds[0]) throw new Error();
        const e = t4.ops;
        for (let t5 = 0; t5 < e.length; ++t5) {
            const i = e[t5];
            switch (i.type) {
                case zp.None:
                case zp.Array:
                    break;
                case zp.CrdtArr:
                {
                    const t6 = i;
                    if (!t6.from && t6.to && "string" == typeof t6.data && ("{" === t6.data[0] || "[" === t6.data[0])) {
                        if (!t6.data2) throw new Error();
                        const e2 = t6.path[0], i2 = this.repotrees.get(e2), s = i2 && i2.get2(t6.path.slice(1).concat(t6.id));
                        s && (s.undoLocals(), t6.data = JSON.stringify(t6.data2, (t7, e3) => t7.startsWith("__") ? void 0 : e3), s.redoLocals());
                    }
                }
                    break;
                case zp.CrdtTree:
                {
                    const t6 = i;
                    if (!t6.from && t6.to && "string" == typeof t6.data && ("{" === t6.data[0] || "[" === t6.data[0])) {
                        if (!t6.data2) throw new Error();
                        const e2 = t6.path[0], i2 = this.repotrees.get(e2), s = i2 && i2.get2(t6.path.slice(1).concat(t6.id));
                        s && (s.undoLocals(), t6.data = uu(t6.data2), s.redoLocals());
                    }
                }
                    break;
                case zp.Idset: {
                    const t6 = i;
                    if ("string" == typeof t6.data && ("{" === t6.data[0] || "[" === t6.data[0])) {
                        if (!t6.data2) throw new Error();
                        const e2 = t6.path[0], i2 = this.repotrees.get(e2), s = i2 && i2.get2(t6.path.slice(1));
                        s && (s.undoLocals(), t6.data = JSON.stringify(t6.data2, (t7, e3) => t7.startsWith("__") ? void 0 : e3), s.redoLocals());
                    }
                }
            }
        }
    }
    _roll2NewVersion(t4) {
        const e = /* @__PURE__ */ new Set();
        for (let i = 0; i < t4.length; i++) {
            const s = t4[i];
            if (e.has(s)) throw new Error("duplicate blockId");
            e.add(s);
            const r = this.repotrees.get(s);
            if (!r) return;
            try {
                r.roll2Version(this.dataVer, Qp.MAX_SAFE_INTEGER);
            } catch (t5) {
                console.error(t5);
            }
        }
    }
    roll2NewVersion(t4) {
        if (this.repo.isInTransact()) return void this._roll2NewVersion(t4);
        this.repo.start("roll2NewVersion");
        const e = this.repo.transactCtx.settrap;
        try {
            this.repo.transactCtx.settrap = false, this._roll2NewVersion(t4), this.repo.commit();
        } catch (t5) {
            console.error(t5), this.repo.rollback();
        } finally {
            this.repo.transactCtx.settrap = e;
        }
    }
}
function Of(t4, e) {
    const i = /* @__PURE__ */ new Map();
    for (let e2 = 0; e2 < t4.ops.length; e2++) {
        const s = t4.ops[e2];
        if (s.type === zp.Idset) {
            const t5 = s.path.join(",");
            i.set(t5, s);
        }
    }
    for (let t5 = 0; t5 < e.ops.length; t5++) {
        const s = e.ops[t5];
        if (s.type === zp.Idset) {
            const t6 = s.path.join(",");
            if (!i.get(t6)) return false;
        }
    }
    for (let t5 = 0; t5 < e.ops.length; t5++) {
        const s = e.ops[t5];
        if (s.type === zp.Idset) {
            const t6 = s.path.join(","), e2 = i.get(t6);
            if (!e2) throw new Error();
            e2.data = s.data;
        }
    }
    return true;
}
class Lf {
    constructor(t4, e, i) {
        __publicField(this, "cmdsync");
        __publicField(this, "localcmds", []);
        __publicField(this, "localindex", 0);
        this.cmdsync = new Rf(t4, e, i);
    }
    commit(t4) {
        if (this.localcmds.length > this.localindex) {
            const t5 = Af(this.localcmds.splice(this.localindex));
            for (let { k: e2, v: i } of t5) {
                const t6 = i[0].op, e3 = t6.path[0], s = this.cmdsync.repotrees.get(e3), r = s && s.get(t6.path.slice(1));
                if (!r) throw new Error("op not found");
                r.dropOps(i);
            }
        }
        const e = this.localcmds[this.localcmds.length - 1];
        if (e && 0 === e.posttime && e.mergetype !== Np.None && e.mergetype === t4.mergetype && e.time + e.delay > Date.now()) {
            if (e.mergetype === Np.TextDelete && function(t5, e2) {
                const i = (t6) => {
                    let e3 = true;
                    for (let i2 = 0; i2 < t6.length; ++i2) {
                        const s2 = t6[i2];
                        if (s2.type !== zp.Array && s2.type !== zp.Idset) {
                            e3 = false;
                            break;
                        }
                    }
                    return e3;
                };
                if (!i(t5.ops) || !i(e2.ops)) return false;
                const s = t5.ops.find((t6) => t6 instanceof lu), r = e2.ops.find((t6) => t6 instanceof lu);
                return !(!s || !r || s.start !== r.start + r.length && s.start + s.length !== r.start || Vp(s.path, r.path) || !Of(t5, e2) || (s.start === r.start + r.length ? s.text.insertFormatText(r.text, 0) : (r.text.insertFormatText(s.text, 0), s.text = r.text), s.start = Math.min(s.start, r.start), s.length = s.length + r.length, t5.time = e2.time, console.log("merge localcmd: ", t5), 0));
            }(e, t4)) return e;
            if (e.mergetype === Np.TextInsert && function(t5, e2) {
                const i = (t6) => {
                    let e3 = true;
                    for (let i2 = 0; i2 < t6.length; ++i2) {
                        const s2 = t6[i2];
                        if (s2.type !== zp.Array && s2.type !== zp.Idset) {
                            e3 = false;
                            break;
                        }
                    }
                    return e3;
                };
                if (!i(t5.ops) || !i(e2.ops)) return false;
                const s = t5.ops.find((t6) => t6 instanceof hu), r = e2.ops.find((t6) => t6 instanceof hu);
                if (!s || !r || s.start + s.length !== r.start) return false;
                if (Vp(s.path, r.path)) return false;
                if (!Of(t5, e2)) return false;
                if ("simple" !== s.text.type || "simple" !== r.text.type || s.text.props && (s.text.props.attr || s.text.props.paraAttr) || r.text.props && (r.text.props.attr || r.text.props.paraAttr)) {
                    if ("complex" !== s.text.type || "complex" !== r.text.type) return false;
                    {
                        const t6 = r.text.text;
                        t6.insertFormatText(s.text.text, 0), s.text.text = t6;
                    }
                } else s.text.text += r.text.text;
                return s.start = Math.min(s.start, r.start), s.length = s.length + r.length, t5.time = e2.time, console.log("merge localcmd: ", t5), true;
            }(e, t4)) return e;
        }
        return console.log("commit localcmd: ", t4), this.localcmds.push(t4), ++this.localindex, this.cmdsync.commit(t4), t4;
    }
    canUndo() {
        return this.localindex > 0;
    }
    canRedo() {
        return this.localindex < this.localcmds.length;
    }
    undo() {
        if (!this.canUndo()) return;
        const t4 = this.localcmds[this.localindex - 1], e = this.cmdsync.undo(t4);
        return e !== t4 && this.localcmds.splice(this.localindex - 1, 1, e), --this.localindex, console.log("undo", e ?? t4), e ?? t4;
    }
    redo() {
        if (!this.canRedo()) return;
        const t4 = this.localcmds[this.localindex], e = this.cmdsync.redo(t4);
        return e !== t4 && this.localcmds.splice(this.localindex, 1, e), ++this.localindex, console.log("redo", e ?? t4), e ?? t4;
    }
    roll2NewVersion(t4) {
        return this.cmdsync.roll2NewVersion(t4);
    }
    hasPendingSyncCmd() {
        return this.cmdsync.hasPendingSyncCmd();
    }
    setNet(t4) {
        return this.cmdsync.setNet(t4);
    }
    setBaseVer(t4) {
        return this.cmdsync.setBaseVer(t4);
    }
    watchProcessCmdsEnd(t4) {
        return this.cmdsync.watchProcessCmdsEnd(t4);
    }
    receive(t4) {
        return this.cmdsync.receive(t4);
    }
    setSelection(t4) {
        return this.cmdsync.setSelection(t4);
    }
}
class Pf {
    hasConnected() {
        return false;
    }
    async pullCmds(t4, e) {
        return [];
    }
    async postCmds(t4) {
        return false;
    }
    watchCmds(t4) {
    }
    watchError(t4) {
    }
}
function Bf(t4, e, i) {
    if (!i.saveselection) return;
    let s = i.saveselection;
    if (!e && s.text) {
        const t5 = s.text, e2 = i.ops.indexOf(t5);
        if (e2 < 0) throw new Error();
        const r = i.ops.slice(e2 + 1).reduce((e3, i2) => (Vp(i2.path, t5.path) || e3.push(i2), e3), []), n2 = wf([t5], r);
        s = Hp(s), s.text = n2.lhs[0];
    }
    Dp(t4.save(), s) && t4.restore(s);
}
class Nf {
    constructor(t4, e) {
        __publicField(this, "__repo");
        __publicField(this, "__cmdrepo");
        __publicField(this, "__api");
        __publicField(this, "selection");
        __publicField(this, "__initingDoc", false);
        this.__repo = e, this.__api = Uu.create(e), this.__cmdrepo = new Lf(t4, e, new Pf()), t4.pagesMgr.setUpdater((t5) => {
            this.__cmdrepo.roll2NewVersion([t5.id]);
        });
    }
    setInitingDocument(t4) {
        this.__initingDoc = t4;
    }
    hasPendingSyncCmd() {
        return this.__cmdrepo.hasPendingSyncCmd();
    }
    setNet(t4) {
        this.__cmdrepo.setNet(t4);
    }
    setBaseVer(t4) {
        this.__cmdrepo.setBaseVer(t4);
    }
    setProcessCmdsTrigger(t4) {
        this.__cmdrepo.watchProcessCmdsEnd(t4);
    }
    receive(t4) {
        this.__cmdrepo.receive(t4);
    }
    setSelection(t4) {
        this.selection = t4, this.__cmdrepo.setSelection(t4);
    }
    get repo() {
        return this.__repo;
    }
    get transactCtx() {
        return this.__repo.transactCtx;
    }
    isInTransact() {
        return this.__repo.isInTransact();
    }
    undo() {
        this.__repo.start("undo");
        const t4 = this.__repo.transactCtx.settrap;
        try {
            this.__repo.transactCtx.settrap = false;
            const t5 = this.__cmdrepo.undo();
            t5 && this.selection && t5.selectionupdater(this.selection, true, t5), this.__repo.commit();
        } catch (t5) {
            throw this.__repo.rollback(), t5;
        } finally {
            this.__repo.transactCtx.settrap = t4;
        }
    }
    redo() {
        this.__repo.start("redo");
        const t4 = this.__repo.transactCtx.settrap;
        try {
            this.__repo.transactCtx.settrap = false;
            const t5 = this.__cmdrepo.redo();
            t5 && this.selection && t5.selectionupdater(this.selection, false, t5), this.__repo.commit();
        } catch (t5) {
            throw this.__repo.rollback(), t5;
        } finally {
            this.__repo.transactCtx.settrap = t4;
        }
    }
    canUndo() {
        return this.__cmdrepo.canUndo();
    }
    canRedo() {
        return this.__cmdrepo.canRedo();
    }
    start(t4, e = Bf) {
        var _a2;
        return this.__repo.start(t4), this.__api.start((_a2 = this.selection) == null ? void 0 : _a2.save(), e, t4), this.__api;
    }
    updateTextSelectionPath(t4) {
        const e = (t4 == null ? void 0 : t4.getCrdtPath()) || [];
        this.__api.updateTextSelectionPath(e);
    }
    updateTextSelectionRange(t4, e) {
        this.__api.updateTextSelectionRange(t4, e);
    }
    isNeedCommit() {
        return this.__api.isNeedCommit();
    }
    commit(t4 = Np.None) {
        if (!this.isNeedCommit()) return void this.rollback("commit");
        if (void 0 === this.__repo.transactCtx.transact) throw new Error("not inside transact!");
        let e = this.__api.commit(t4);
        e ? (this.__repo.commit(), this.__initingDoc || (e = this.__cmdrepo.commit(e)), this.selection && e.selectionupdater(this.selection, false, e)) : this.rollback("commit");
    }
    rollback(t4 = "") {
        this.__api.rollback(), this.__repo.rollback(t4);
    }
}
class Vf {
    constructor(t4, e) {
        __publicField(this, "__repo");
        __publicField(this, "__document");
        if (!(e instanceof Nf)) throw new Error("repo wrong");
        if (!(t4 instanceof Oa)) throw new Error("document wrong");
        this.__repo = e, this.__document = t4;
    }
    delete(t4) {
        const e = this.__document.indexOfPage(t4);
        if (e < 0) return false;
        const i = this.__repo.start("deletepage");
        try {
            i.pageDelete(this.__document, e), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return true;
    }
    insert(t4, e) {
        const i = this.__repo.start("insertpage");
        try {
            i.pageInsert(this.__document, e, t4), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return true;
    }
    create(t4) {
        return vd(t4);
    }
    copy(e, i) {
        const s = Tr(e);
        s.name = i;
        const r = [], n2 = [], o2 = [], a2 = [], h2 = /* @__PURE__ */ new Map(), c2 = /* @__PURE__ */ new Map(), l2 = (e2) => {
            var _a2, _b;
            const i2 = v4();
            "symbol-ref-shape" === e2.typeId && r.push(e2), "contact-shape" === e2.typeId && n2.push(e2), ((_a2 = e2.style.contacts) == null ? void 0 : _a2.length) && o2.push(e2), ((_b = e2.prototypeInteractions) == null ? void 0 : _b.length) && a2.push(e2), h2.set(e2.id, i2), c2.set(i2, e2.id), e2.id = i2;
            const s2 = e2;
            Array.isArray(s2.childs) && s2.childs.forEach((t4) => l2(t4));
        };
        l2(s), r.forEach((t4) => {
            const e2 = t4.refId, i2 = h2.get(e2);
            i2 && (t4.refId = i2);
        }), n2.forEach((t4) => {
            if (t4.from) {
                const e2 = h2.get(t4.from.shapeId);
                e2 && (t4.from.shapeId = e2);
            }
            if (t4.to) {
                const e2 = h2.get(t4.to.shapeId);
                e2 && (t4.to.shapeId = e2);
            }
        }), o2.forEach((t4) => {
            var _a2;
            ((_a2 = t4.style.contacts) == null ? void 0 : _a2.length) && t4.style.contacts.forEach((t5) => {
                const e2 = h2.get(t5.shapeId);
                e2 && (t5.shapeId = e2);
            });
        }), a2.forEach((t4) => {
            var _a2;
            ((_a2 = t4.prototypeInteractions) == null ? void 0 : _a2.length) && t4.prototypeInteractions.forEach((t5) => {
                if (t5.actions.targetNodeID) {
                    const e2 = h2.get(t5.actions.targetNodeID);
                    e2 && (t5.actions.targetNodeID = e2);
                }
            });
        });
        const d2 = this.__document, p2 = new class {
            constructor() {
                __publicField(this, "document", d2);
                __publicField(this, "curPage", s.id);
                __publicField(this, "fmtVer", rn);
            }
        }();
        return zo(s, p2);
    }
    move(t4, e) {
        const i = this.__repo.start("pagemove");
        try {
            const s = this.__document.getPageIndexById(t4.id), r = s >= e ? e : e + 1;
            e !== s && i.pageMove(this.__document, t4.id, s, r), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return true;
    }
    pageListDrag(t4, e, i) {
        const s = this.__document.pagesList, r = s.findIndex((e2) => e2.id === t4);
        let n2 = s.findIndex((t5) => t5.id === e);
        if (!(r < 0 || n2 < 0)) try {
            const e2 = this.__repo.start("pagemove");
            n2 = i ? n2 + 1 : n2, e2.pageMove(this.__document, t4, r, n2), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    insertPage(t4, e) {
        const i = vd(t4);
        if (this.insert(e, i)) return i;
    }
    setPageName(t4, e) {
        const i = this.__repo.start("setPageName");
        try {
            i.pageModifyName(this.__document, e, t4), this.__repo.commit();
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
}
function Df(t4, e, i) {
    var _a2, _b;
    if (!i.text || i.isVirtualShape) return;
    const s = i instanceof Gi ? i : $c(i);
    switch (((_a2 = i.text.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible) {
        case $t.FixWidthAndHeight:
            break;
        case $t.Fixed: {
            const r = i.getLayout(), n2 = ((_b = i.text.attr) == null ? void 0 : _b.fontSize) ?? Ia.DefaultFontSize, o2 = Math.ceil(Math.max(n2, r.contentHeight));
            t4.shapeModifyWH(e, s, i.size.width, o2);
            break;
        }
        case $t.Flexible: {
            const r = i.getLayout(), n2 = Math.ceil(r.contentWidth), o2 = Math.ceil(r.contentHeight);
            t4.shapeModifyWH(e, s, n2, o2);
            break;
        }
    }
}
function Hf(t4, e, i, s) {
    if (!i.text || i.isVirtualShape) return;
    const r = s.indexOfCell(i);
    if (!r) return;
    const n2 = Math.max(i.rowSpan ?? 1, 1), o2 = Math.max(i.colSpan ?? 1, 1);
    let a2 = s.colWidths[r.colIdx].value;
    for (let t5 = 1; t5 < o2; ++t5) a2 += s.colWidths[r.colIdx + t5].value;
    let h2 = s.rowHeights[r.rowIdx].value;
    for (let t5 = 1; t5 < n2; ++t5) h2 += s.rowHeights[r.rowIdx + t5].value;
    const c2 = a2 / s.widthTotalWeights * s.frame.width, l2 = h2 / s.heightTotalWeights * s.frame.height, d2 = i.text.getLayout2(new _e(0, 0, c2, l2));
    if (d2.contentHeight > l2 + We) {
        const i2 = r.rowIdx + n2 - 1, o3 = s.rowHeights[i2].value / s.heightTotalWeights * s.frame.height, a3 = (o3 + d2.contentHeight - l2) / o3 * s.rowHeights[i2].value;
        t4.tableModifyRowHeight(e, s.data, i2, a3), t4.shapeModifyWH(e, s.data, s.frame.width, s.frame.height + d2.contentHeight - l2);
    }
}
function Wf(t4) {
    if (!(t4 instanceof zi)) return;
    const e = t4.childs;
    if (!e.length) return;
    let i = -1, s = -1;
    for (let t5 = 0, r = e.length; t5 < r; t5++) {
        const r2 = e[t5], n2 = r2.matrix2Parent(), o2 = r2.size, a2 = [{ x: 0, y: 0 }, { x: o2.width, y: 0 }, { x: o2.width, y: o2.height }, { x: 0, y: o2.height }].map((t6) => n2.computeCoord3(t6));
        for (let t6 = 0; t6 < 4; t6++) a2[t6].x > s && (s = a2[t6].x), a2[t6].y > i && (i = a2[t6].y);
    }
    return { x: s, y: i };
}
function $f(t4, e, i, s) {
    if (!i.parent) return;
    const r = i.parent;
    if (!r.variables) return;
    const n2 = Array.from(r.variables.values());
    for (let r2 = 0, o3 = n2.length; r2 < o3; r2++) {
        const o4 = n2[r2];
        if (o4.type !== jt.Status) continue;
        const a2 = Xf(i, o4, s) || s;
        t4.shapeModifyVartag(e, i, o4.id, a2);
        break;
    }
    const o2 = function(t5) {
        if (!t5.parent) return false;
        if (!(t5.parent instanceof zi)) return false;
        if (!t5.parent.variables) return false;
        if (!t5.symtags) return false;
        const e2 = t5.parent.variables;
        let i2 = [];
        return e2.forEach((e3, s2) => {
            var _a2;
            if (e3.type !== jt.Status) return;
            const r2 = ((_a2 = t5.symtags) == null ? void 0 : _a2.get(s2)) || e3.value;
            r2 && i2.push(r2);
        }), i2.toString();
    }(i);
    o2 && t4.shapeModifyName(e, i, o2);
}
function Xf(t4, e, i) {
    var _a2;
    if (!t4.parent) return false;
    if (!t4.parent.variables) return false;
    const s = t4.parent.childs;
    let r = 2, n2 = i, o2 = 2;
    const a2 = new RegExp(`^${i}[0-9]*$`), h2 = /* @__PURE__ */ new Set();
    for (let t5 = 0, r2 = s.length; t5 < r2; t5++) {
        const r3 = (_a2 = s[t5].symtags) == null ? void 0 : _a2.get(e.id);
        if (r3 && a2.test(r3)) {
            const t6 = Number(r3.split(i)[1]);
            h2.add(t6), t6 > o2 && (o2 = t6);
        }
    }
    for (; r <= o2 && h2.has(r); ) r++;
    return `${n2}${r}`;
}
function Gf(t4) {
    return t4.type === Vt.Symbol && (t4 == null ? void 0 : t4.parent) instanceof zi;
}
function Yf(t4, e, i) {
    const s = [];
    if (t4 instanceof zi) {
        const r = t4.childs;
        for (let n2 = 0, o2 = r.length; n2 < o2; n2++) {
            Kf(t4, r[n2], Jf(i), e, s);
        }
    } else Kf(t4, t4, Jf(i), e, s);
    return s;
}
function Uf(t4) {
    let e = t4;
    for (; e && e.type !== Vt.Symbol; ) e = e.parent;
    if (e) return Gf(e) ? e.parent : e;
}
function Zf(t4, e, i, s, r) {
    e.varbinds && e.varbinds.forEach((i2, n2) => {
        var _a2;
        ((_a2 = t4.variables) == null ? void 0 : _a2.get(i2)) && (s !== i2 || r.push(e));
    });
}
function jf(t4) {
    return t4 === jt.SymbolRef ? Et.SymbolID : t4 === jt.Text ? Et.Text : void 0;
}
function Jf(t4) {
    return t4 === Et.Visible ? jt.Visible : t4 === Et.Text ? jt.Text : t4 === Et.SymbolID ? jt.SymbolRef : void 0;
}
function Kf(t4, e, i, s, r) {
    var _a2;
    const n2 = e.childs;
    var o2, a2;
    if (n2 == null ? void 0 : n2.length) if (i === jt.Visible) for (let e2 = 0, o3 = n2.length; e2 < o3; e2++) {
        const o4 = n2[e2];
        Zf(t4, o4, Et.Visible, s, r), o4.childs && o4.childs.length && o4.type !== Vt.Table && Kf(t4, o4, i, s, r);
    }
    else {
        if (a2 = e, !((_a2 = a2.childs) == null ? void 0 : _a2.length) || a2.type === Vt.Table || a2.type === Vt.SymbolRef) return;
        for (let e2 = 0, a3 = n2.length; e2 < a3; e2++) {
            const a4 = n2[e2];
            a4.type === ((o2 = i) === jt.SymbolRef ? Vt.SymbolRef : o2 === jt.Text ? Vt.Text : void 0) ? Zf(t4, a4, jf(i), s, r) : a4.childs && a4.childs.length && a4.type !== Vt.Table && Kf(t4, a4, i, s, r);
        }
    }
}
function qf(t4, e, i, s) {
    const r = t4 instanceof qi ? t4 : t4.data;
    if (!e.varbinds) return;
    const n2 = e.varbinds.get(Et.Visible);
    if (n2) {
        Yf(i, n2, Et.Visible).length < 2 && s.shapeRemoveVariable(r, i, n2);
    }
    const o2 = e.varbinds.get(Et.SymbolID);
    if (o2) {
        Yf(i, o2, Et.SymbolID).length < 2 && s.shapeRemoveVariable(r, i, o2);
    }
    const a2 = e.varbinds.get(Et.Text);
    if (a2) {
        Yf(i, a2, Et.Text).length < 2 && s.shapeRemoveVariable(r, i, a2);
    }
}
function Qf(t4, e, i, s, r) {
    for (let n2 = 0, o2 = i.length; n2 < o2; n2++) {
        let o3 = i[n2];
        if (o3.type === Vt.Symbol) {
            r.push(o3);
            const i2 = o3.parent;
            if (!i2) throw new Error("wrong data: invaild parent");
            const n3 = i2.indexOfChild(o3);
            if (s.shapeMove(e, i2, n3, e, e.childs.length), o3 instanceof zi) continue;
            const { x: a3, y: h2, width: c2, height: l2 } = o3.frame, d2 = new _e(a3, h2, c2, l2), p2 = Yd(o3.name, d2, o3.id, t4.symbolsMgr);
            s.shapeInsert(t4, e, i2, p2, n3);
            continue;
        }
        const a2 = o3.childs;
        o3.type !== Vt.Table && (a2 == null ? void 0 : a2.length) && Qf(t4, e, o3.childs, s, r);
    }
}
function tg(t4, e, i, s) {
    return t4.indexOfChild(e) < t4.indexOfChild(i) ? s - 1 : s;
}
function eg(t4) {
    var _a2, _b;
    return t4 instanceof Oi ? ((t4 == null ? void 0 : t4.type) === Vt.Group || t4 instanceof zi) && !((_a2 = t4 == null ? void 0 : t4.childs) == null ? void 0 : _a2.length) : ((t4 == null ? void 0 : t4.type) === Vt.Group || t4.data instanceof zi) && !((_b = (t4 == null ? void 0 : t4.data).childs) == null ? void 0 : _b.length);
}
const ig = 0.01;
function sg(t4, e, i, s, r) {
    var _a2;
    if (!e.hasSize()) return false;
    const n2 = e.size;
    let o2 = false;
    if (i !== n2.width || s !== n2.height) {
        if (e instanceof Gi) {
            const o3 = ((_a2 = e.text.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible;
            s !== n2.height ? o3 !== $t.FixWidthAndHeight && r.shapeModifyTextBehaviour(t4, e.text, $t.FixWidthAndHeight) : o3 === $t.Flexible && r.shapeModifyTextBehaviour(t4, e.text, $t.Fixed), r.shapeModifyWH(t4, e, i, s), Df(r, t4, e);
        } else r.shapeModifyWH(t4, e, i, s);
        o2 = true;
    }
    return o2;
}
function rg(t4, e, i, s, r) {
    const n2 = i.parent;
    if (!n2) return;
    const o2 = n2.matrix2Root(), a2 = i.matrix2Parent(), h2 = o2.inverseCoord(s, r), c2 = a2.computeCoord(0, 0), l2 = h2.x - c2.x, d2 = h2.y - c2.y;
    t4.shapeModifyX(e, i, i.transform.translateX + l2), t4.shapeModifyY(e, i, i.transform.translateY + d2);
}
function ng(t4, e, i, s, r, n2 = true) {
    const o2 = i.frame2Root();
    o2.x, o2.y, rg(t4, e, i, o2.x + s, o2.y + r);
}
function og(t4, e, i, s, r, n2) {
    r < ig && (r = ig), n2 < ig && (n2 = ig);
    let o2 = false;
    o2 = (s.isNoTransform(), sg(i, s, r, n2, t4)), !o2 && s.hasSize() || hg(t4, e, i, s);
}
function ag(t4, e, i, s, r, n2, o2 = true) {
    const a2 = s.size;
    a2.width, a2.height, og(t4, e, i, s, a2.width + r, a2.height + n2);
}
function hg(t4, e, i, s) {
    if (s instanceof Ni && !(s instanceof zi)) {
        const i2 = s.id, r = e.symbolsMgr.getRefs(i2);
        if (!r) return;
        for (let [e2, i3] of r) {
            if (i3.isCustomSize) continue;
            const e3 = i3.getPage();
            if (!e3) throw new Error();
            t4.shapeModifyWH(e3, i3, s.frame.width, s.frame.height);
        }
    } else s instanceof Ar && t4.shapeModifyIsCustomSize(i, s, true);
}
class cg {
    constructor(t4, e, i) {
        __publicField(this, "__repo");
        __publicField(this, "__document");
        __publicField(this, "api");
        __publicField(this, "page");
        __publicField(this, "exception", false);
        this.__repo = t4, this.__document = e, this.page = $c(i), this.api = this.start();
    }
    start() {
        return this.__repo.start("");
    }
    updateView() {
        this.__repo.transactCtx.fireNotify();
    }
    commit() {
        this.__repo.isNeedCommit() && !this.exception ? this.__repo.commit() : this.__repo.rollback();
    }
}
function lg(t4, e, i, s, r, n2, o2) {
    var _a2, _b;
    const a2 = r ?? /* @__PURE__ */ new Map(), h2 = n2 ?? /* @__PURE__ */ new Map(), c2 = o2 ?? /* @__PURE__ */ new Map(), l2 = i.childs, { x: d2, y: p2 } = s;
    if (i.type === Vt.Group || i.type === Vt.BoolShape) {
        const i2 = new P().setScale(E.FromXYZ(d2, p2, 1));
        for (const s2 of l2) {
            const r2 = $c(s2), n3 = g2(s2).clone();
            n3.addTransform(i2);
            const o3 = n3.decomposeScale(), l3 = { x: o3.x, y: o3.y }, d3 = f2(s2), p3 = d3.width * Math.abs(l3.x), u2 = d3.height * Math.abs(l3.y);
            if (s2 instanceof Ic) {
                if (p3 !== s2.size.width || u2 !== s2.size.height) {
                    const i3 = ((_a2 = s2.text.attr) == null ? void 0 : _a2.textBehaviour) ?? $t.Flexible;
                    u2 !== s2.size.height ? i3 !== $t.FixWidthAndHeight && t4.shapeModifyTextBehaviour(e, s2.text, $t.FixWidthAndHeight) : i3 === $t.Flexible && t4.shapeModifyTextBehaviour(e, s2.text, $t.Fixed), t4.shapeModifyWH(e, r2, p3, u2), Df(t4, e, s2);
                }
            } else t4.shapeModifyWH(e, r2, p3, u2);
            n3.clearScaleSize(), t4.shapeModifyTransform(e, r2, Ei(n3)), s2 instanceof Dh && lg(t4, e, s2, l3, a2, h2, c2);
        }
    } else for (const s2 of l2) {
        const r2 = s2.resizingConstraint ?? 0, n3 = f2(s2), o3 = { x: 1, y: 1 };
        let l3 = n3.width, w2 = n3.height;
        const b2 = g2(s2).clone();
        if (Ne.isHorizontalScale(r2)) {
            const t5 = new P().setScale(E.FromXYZ(d2, 1, 1));
            b2.addTransform(t5);
            const e2 = b2.decomposeScale();
            o3.x *= Math.abs(e2.x), o3.y *= Math.abs(e2.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize();
        } else if (Ne.isFixedLeftAndRight(r2)) {
            const t5 = u(s2), e2 = m2(s2), r3 = (f2(i).width * d2 - t5.x - e2) / t5.width, a3 = new P().setTranslate(E.FromXY(t5.x, t5.y));
            b2.addTransform(a3.getInverse());
            const h3 = a3.setScale(E.FromXYZ(r3, 1, 1));
            b2.addTransform(h3);
            const c3 = b2.decomposeScale();
            o3.x *= Math.abs(c3.x), o3.y *= Math.abs(c3.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize();
        } else if (Ne.isFlexWidth(r2)) {
            const t5 = new P().setScale(E.FromXYZ(d2, 1, 1));
            b2.addTransform(t5);
            const e2 = b2.decomposeScale();
            if (o3.x *= Math.abs(e2.x), o3.y *= Math.abs(e2.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize(), Ne.isFixedToLeft(r2)) {
                const t6 = u(s2);
                b2.translate(E.FromXY(-(t6.x * d2 - t6.x), 0));
            } else if (Ne.isFixedToRight(r2)) {
                const t6 = m2(s2);
                b2.translate(E.FromXY(t6 * d2 - t6, 0));
            } else if (Ne.isHorizontalJustifyCenter(r2)) {
                const t6 = _2(s2);
                b2.translate(E.FromXY(-(t6 * d2 - t6), 0));
            }
        } else if (Ne.isFixedToRight(r2)) {
            const t5 = f2(i);
            b2.translate(E.FromXY((d2 - 1) * t5.width, 0));
        } else if (Ne.isHorizontalJustifyCenter(r2)) {
            const t5 = f2(i), e2 = t5.width * d2 / 2 - t5.width / 2;
            b2.translate(E.FromXY(e2, 0));
        }
        if (Ne.isVerticalScale(r2)) {
            const t5 = new P().setScale(E.FromXYZ(1, p2, 1));
            b2.addTransform(t5);
            const e2 = b2.decomposeScale();
            o3.x *= Math.abs(e2.x), o3.y *= Math.abs(e2.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize();
        } else if (Ne.isFixedTopAndBottom(r2)) {
            const t5 = u(s2), e2 = y2(s2), r3 = (f2(i).height * p2 - t5.y - e2) / t5.height, a3 = new P().setTranslate(E.FromXY(t5.x, t5.y));
            b2.addTransform(a3.getInverse());
            const h3 = a3.setScale(E.FromXYZ(1, r3, 1));
            b2.addTransform(h3);
            const c3 = b2.decomposeScale();
            o3.x *= Math.abs(c3.x), o3.y *= Math.abs(c3.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize();
        } else if (Ne.isFlexHeight(r2)) {
            const t5 = new P().setScale(E.FromXYZ(1, p2, 1));
            b2.addTransform(t5);
            const e2 = b2.decomposeScale();
            if (o3.x *= Math.abs(e2.x), o3.y *= Math.abs(e2.y), l3 = n3.width * o3.x, w2 = n3.height * o3.y, b2.clearScaleSize(), Ne.isFixedToTop(r2)) {
                const t6 = u(s2);
                b2.translate(E.FromXY(0, -(t6.y * p2 - t6.y)));
            } else if (Ne.isFixedToBottom(r2)) {
                const t6 = y2(s2);
                b2.translate(E.FromXY(0, t6 * p2 - t6));
            } else if (Ne.isVerticalJustifyCenter(r2)) {
                const t6 = x2(s2);
                b2.translate(E.FromXY(0, -(t6 * p2 - t6)));
            }
        } else if (Ne.isFixedToBottom(r2)) {
            const t5 = f2(i);
            b2.translate(E.FromXY(0, (p2 - 1) * t5.height));
        } else if (Ne.isVerticalJustifyCenter(r2)) {
            const t5 = f2(i), e2 = t5.height * p2 / 2 - t5.height / 2;
            b2.translate(E.FromXY(0, e2));
        }
        const M2 = $c(s2);
        if (s2 instanceof Ic) {
            if (l3 !== s2.size.width || w2 !== s2.size.height) {
                const i2 = ((_b = s2.text.attr) == null ? void 0 : _b.textBehaviour) ?? $t.Flexible;
                w2 !== s2.size.height ? i2 !== $t.FixWidthAndHeight && t4.shapeModifyTextBehaviour(e, s2.text, $t.FixWidthAndHeight) : i2 === $t.Flexible && t4.shapeModifyTextBehaviour(e, s2.text, $t.Fixed), t4.shapeModifyWH(e, M2, l3, w2), Df(t4, e, s2);
            }
        } else t4.shapeModifyWH(e, M2, l3, w2);
        t4.shapeModifyTransform(e, M2, Ei(b2)), (n3.width !== l3 || n3.height !== w2) && s2 instanceof Dh && lg(t4, e, s2, o3, a2, h2, c2);
    }
    function u(t5) {
        let e2 = a2.get(t5.id);
        if (e2 || (e2 = {}, a2.set(t5.id, e2)), void 0 === e2.box) {
            const i2 = g2(t5), s2 = f2(t5), r2 = s2.x, n3 = s2.y, o3 = r2 + s2.width, a3 = n3 + s2.height, h3 = i2.transform([E.FromXY(r2, n3), E.FromXY(o3, n3), E.FromXY(o3, a3), E.FromXY(r2, a3)]), c3 = Rp([h3.col0, h3.col1, h3.col2, h3.col3]);
            e2.box = { x: c3.left, y: c3.top, width: c3.right - c3.left, height: c3.bottom - c3.top };
        }
        return e2.box;
    }
    function f2(t5) {
        let e2 = h2.get(t5.id);
        if (!e2) {
            const i2 = t5.frame;
            e2 = { x: i2.x, y: i2.y, width: i2.width, height: i2.height }, h2.set(t5.id, e2);
        }
        return e2;
    }
    function g2(t5) {
        let e2 = c2.get(t5.id);
        return e2 || (e2 = t5.transform2.clone(), c2.set(t5.id, e2)), e2;
    }
    function m2(t5) {
        let e2 = a2.get(t5.id);
        if (e2 || (e2 = {}, a2.set(t5.id, e2)), void 0 === e2.toRight) {
            const i2 = u(t5);
            e2.toRight = t5.parent.size.width - i2.x - i2.width;
        }
        return e2.toRight;
    }
    function _2(t5) {
        let e2 = a2.get(t5.id);
        if (e2 || (e2 = {}, a2.set(t5.id, e2)), void 0 === e2.centerOffsetLeft) {
            const s2 = u(t5);
            e2.centerOffsetLeft = s2.x + s2.width / 2 - i.size.width / 2;
        }
        return e2.centerOffsetLeft;
    }
    function y2(t5) {
        let e2 = a2.get(t5.id);
        if (e2 || (e2 = {}, a2.set(t5.id, e2)), void 0 === e2.toBottom) {
            const i2 = u(t5);
            e2.toBottom = t5.parent.size.height - i2.y - i2.height;
        }
        return e2.toBottom;
    }
    function x2(t5) {
        let e2 = a2.get(t5.id);
        if (e2 || (e2 = {}, a2.set(t5.id, e2)), void 0 === e2.centerOffsetTop) {
            const s2 = u(t5);
            e2.centerOffsetTop = s2.y + s2.height / 2 - i.size.height / 2;
        }
        return e2.centerOffsetTop;
    }
}
function ug(t4, e) {
    let i = [...fg(t4), { shape: e, ref: t4.id }];
    for (; i.length && mg(i); ) i = gg(i, "shape", "ref"), i = gg(i, "ref", "shape");
    return !!i.length;
}
function fg(t4) {
    const e = [], i = t4.type === Vt.SymbolRef ? t4.naviChilds : t4.childs;
    if (!(i == null ? void 0 : i.length)) return [];
    for (let s = 0, r = i.length; s < r; s++) {
        const r2 = i[s], n2 = r2.type === Vt.SymbolRef, o2 = n2 ? r2.naviChilds : r2.childs;
        ((o2 == null ? void 0 : o2.length) || n2) && e.push({ shape: t4.type === Vt.SymbolRef ? t4.refId : t4.id, ref: n2 ? r2.refId : r2.id }), (o2 == null ? void 0 : o2.length) && e.push(...fg(r2));
    }
    return e;
}
function gg(t4, e, i) {
    const s = [], r = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
    for (let o2 = 0, a2 = t4.length; o2 < a2; o2++) {
        const a3 = t4[o2];
        if (r.has(a3[e])) {
            s.push(a3);
            continue;
        }
        if (n2.has(a3[e])) continue;
        let h2 = true;
        for (let n3 = 0, o3 = t4.length; n3 < o3; n3++) if (t4[n3][i] === a3[e]) {
            s.push(a3), r.add(a3[e]), h2 = false;
            break;
        }
        h2 && n2.add(a3[e]);
    }
    return s;
}
function mg(t4) {
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    let s = false;
    for (let s2 = 0, r = t4.length; s2 < r; s2++) {
        const r2 = t4[s2];
        e.add(r2.shape), i.add(r2.ref);
    }
    return e.forEach((t5) => {
        i.has(t5) || (s = true);
    }), !!s || (i.forEach((t5) => {
        e.has(t5) || (s = true);
    }), s);
}
function _g(t4) {
    let e = t4.parent;
    for (; e; ) {
        if (e.type === Vt.SymbolRef) return true;
        e = e.parent;
    }
    return false;
}
function yg(t4) {
    let e = t4;
    for (; e; ) {
        if (e.type === Vt.Symbol) return true;
        e = e.parent;
    }
    return false;
}
function xg(t4) {
    return t4.type === Vt.Symbol && (t4 == null ? void 0 : t4.parent) instanceof zi;
}
function wg(t4) {
    let e = t4.parent;
    for (; e && !(e instanceof Oi); ) e = e.parent;
    return e;
}
function bg(t4) {
    let e = t4.varsContainer;
    return t4.data instanceof Ar && (e = (e || []).concat(t4.data)), e;
}
function Mg(t4, e, i, s, r, n2, o2, a2) {
    const h2 = bg(r);
    if (!h2 || 0 === h2.length) throw new Error();
    const c2 = h2.find((t5) => t5 instanceof Ar);
    if (!(c2 && c2 instanceof Ar)) throw new Error();
    let l2 = n2.length > 0 ? n2 + "/" + t4 : t4;
    for (let t5 = h2.length - 1; t5 >= 0; --t5) {
        const e2 = h2[t5];
        if (e2 === c2) break;
        e2 instanceof Ar && (l2 = e2.id + "/" + l2);
    }
    if (s === jt.Text && "string" == typeof i) throw new Error();
    const d2 = vg(c2, e, i, s, o2, a2);
    return a2.shapeAddOverride(o2, c2, l2, d2.id), d2;
}
function vg(e, i, s, r, n2, o2) {
    const a2 = new Ri(v4(), r, i, s);
    return o2.shapeAddVariable(n2, e, a2), a2;
}
function Sg(t4, e, i, s, r, n2) {
    if (0 === t4.length) throw new Error();
    const o2 = wg(t4[t4.length - 1]);
    if (!o2) throw new Error();
    const a2 = bg(s);
    if (!a2 || 0 === a2.length) return t4[t4.length - 1];
    const h2 = a2.findIndex((t5) => t5.id === o2.id), c2 = a2.findIndex((t5) => t5 instanceof Ar);
    if (c2 < 0) return t4[t4.length - 1];
    if (h2 >= 0 && h2 <= c2) return t4[t4.length - 1];
    return function(t5, e2, i2, s2, r2, n3, o3) {
        var _a2, _b;
        if (t5[0].type === jt.Text && "string" == typeof i2) {
            const e3 = t5[t5.length - 1].value, s3 = ea(e3.attr, (_a2 = e3.paras[0]) == null ? void 0 : _a2.attr, (_b = e3.paras[0]) == null ? void 0 : _b.spans[0]);
            s3.insertText(i2, 0), i2 = s3;
        }
        const a3 = bg(r2);
        if (!a3 || 0 === a3.length) throw new Error();
        let h3 = wg(t5[0]);
        if (!h3) throw new Error();
        if (Xc(h3)) throw new Error();
        let c3 = a3.findIndex((t6) => t6.id === h3.id);
        c3 < 0 && (c3 = a3.length - 1);
        let l2 = t5[0].id;
        for (let t6 = c3; t6 >= 0; --t6) {
            const e3 = a3[t6];
            if (e3 === s2) break;
            e3 instanceof Ar && (l2 = e3.id + "/" + l2);
        }
        const d2 = vg(s2, e2, i2, t5[0].type, n3, o3);
        return o3.shapeAddOverride(n3, s2, l2, d2.id), d2;
    }(t4, e, i(t4[t4.length - 1]), a2[c2], s, r, n2);
}
function Cg(t4, e, i, s, r, n2) {
    const o2 = bg(s);
    if (!o2 || 0 === o2.length) return;
    if (!(s.isVirtualShape || s.data instanceof Ar)) {
        if (s.varbinds && s.varbinds.has(e)) {
            const a3 = [];
            ws(s.varbinds.get(e), a3, o2);
            const h3 = a3[a3.length - 1];
            if (h3 && h3.type === t4) return Sg(a3, h3.name, i, s, r, n2);
        }
        return;
    }
    if (!s.isVirtualShape) switch (e) {
        case Et.Borders:
        case Et.ContextSettings:
        case Et.EndMarkerType:
        case Et.Fills:
        case Et.Shadows:
        case Et.StartMarkerType:
        case Et.CornerRadius:
            break;
        case Et.ExportOptions:
        case Et.Image:
        case Et.Lock:
        case Et.SymbolID:
        case Et.TableCell:
        case Et.Text:
        case Et.Variable:
        case Et.Visible:
            return;
    }
    const a2 = s.data instanceof Ar ? "" : s.data.id, h2 = bs(a2, e, o2);
    if (h2) {
        const e2 = h2[h2.length - 1];
        if (e2 && e2.type === t4) {
            const t5 = wg(e2);
            if (!t5) throw new Error();
            const i2 = o2.findIndex((e3) => e3.id === t5.id), s2 = o2.findIndex((t6) => t6 instanceof Ar);
            if (s2 < 0 || i2 >= 0 && i2 <= s2) return e2;
        }
    }
    if (s.varbinds && s.varbinds.has(e)) {
        const a3 = [];
        ws(s.varbinds.get(e), a3, o2);
        const h3 = a3[a3.length - 1];
        if (h3 && h3.type === t4) return Sg(a3, h3.name, i, s, r, n2);
    }
    return Mg(e, "", i(void 0), t4, s, a2, r, n2);
}
function Tg(t4, e, i, s, r, n2, o2) {
    const a2 = bg(o2);
    if (!a2 || 0 === a2.length) return;
    if (!o2.isVirtualShape) return;
    const h2 = bs(s, i, a2);
    if (h2) {
        const t5 = h2[h2.length - 1];
        if (t5 && t5.type === e) {
            const e2 = wg(t5);
            if (!e2) throw new Error();
            const i2 = a2.findIndex((t6) => t6.id === e2.id), s2 = a2.findIndex((t6) => t6 instanceof Ar);
            if (s2 < 0 || i2 >= 0 && i2 <= s2) return t5;
        }
    }
    return Mg(i, "", r(void 0), e, o2, s, t4, n2);
}
function Ig(t4, e, i) {
    return Cg(jt.ContextSettings, Et.ContextSettings, (t5) => {
        const i2 = (t5 == null ? void 0 : t5.value) ?? e.contextSettings;
        return i2 && ln(i2) || new ee(nt.Normal, 1);
    }, e, i, t4) || e.data;
}
function kg(t4, e, i) {
    return Cg(jt.ExportOptions, Et.ExportOptions, (t5) => {
        const i2 = (t5 == null ? void 0 : t5.value) ?? e.exportOptions;
        return i2 && Dn(i2) || new Ie(new G(), 0, false, false, false, false);
    }, e, i, t4) || e.data;
}
function Eg(t4, e, i, s, r, n2) {
    var _a2, _b;
    const o2 = wg(s);
    if (!o2) throw new Error();
    const a2 = bg(i);
    if (!a2 || 0 === a2.length) return r.name && s.name !== r.name && n2.shapeModifyVariableName(e, s, r.name), void (r.hasOwnProperty("value") && n2.shapeModifyVariable(e, s, r.value));
    let h2 = a2.findIndex((t5) => t5.id === o2.id);
    const c2 = a2.findIndex((t5) => t5 instanceof Ar);
    if (c2 < 0 || h2 >= 0 && h2 <= c2) return r.name && s.name !== r.name && n2.shapeModifyVariableName(e, s, r.name), void (r.hasOwnProperty("value") && n2.shapeModifyVariable(e, s, r.value));
    let l2, d2 = r.value;
    if (s.type === jt.Text && "string" == typeof d2) {
        const t5 = s.value, e2 = ea(t5.attr, (_a2 = t5.paras[0]) == null ? void 0 : _a2.attr, (_b = t5.paras[0]) == null ? void 0 : _b.spans[0]);
        e2.insertText(d2, 0), d2 = e2;
    }
    if (o2 instanceof Ar) {
        const t5 = o2.overrides;
        if (!t5) throw new Error();
        for (let [e2, i3] of t5) if (i3 === s.id) {
            l2 = e2;
            break;
        }
        if (!l2) throw new Error();
        const i2 = l2.lastIndexOf("/"), r2 = i2 >= 0 ? l2.slice(i2 + 1) : l2;
        let p3;
        switch (r2) {
            case Et.Borders:
            case Et.ContextSettings:
            case Et.EndMarkerType:
            case Et.Fills:
            case Et.Image:
            case Et.Lock:
            case Et.Shadows:
            case Et.StartMarkerType:
            case Et.SymbolID:
            case Et.TableCell:
            case Et.Text:
            case Et.Visible:
            case Et.ExportOptions:
            case Et.CornerRadius:
                p3 = r2;
                break;
            default:
                p3 = Et.Variable;
        }
        const u2 = bs(l2, p3, h2 >= 0 ? a2.slice(0, h2) : a2);
        if (u2) {
            const t6 = wg(u2[u2.length - 1]);
            if (!t6) throw new Error();
            const i3 = a2.findIndex((e2) => e2.id === t6.id);
            if (i3 >= 0 && i3 <= c2) return void n2.shapeModifyVariable(e, u2[u2.length - 1], d2);
        }
    } else {
        l2 = s.id;
        const t5 = bs(l2, Et.Variable, h2 >= 0 ? a2.slice(0, h2) : a2);
        if (t5) {
            const i2 = wg(t5[t5.length - 1]);
            if (!i2) throw new Error();
            const s2 = a2.findIndex((t6) => t6.id === i2.id);
            if (s2 >= 0 && s2 <= c2) return void n2.shapeModifyVariable(e, t5[t5.length - 1], d2);
        }
    }
    h2 < 0 && (h2 = a2.length - 1);
    const p2 = a2[c2];
    for (let t5 = h2; t5 >= 0; --t5) {
        const e2 = a2[t5];
        if (e2 === p2) break;
        e2 instanceof Ar && (l2 = e2.id + "/" + l2);
    }
    const u = vg(p2, r.name ?? s.name, d2 ?? function(t5, e2, i2) {
        if (void 0 === t5.value) return;
        const s2 = new class {
            constructor() {
                __publicField(this, "document", e2);
                __publicField(this, "curPage", i2.id);
                __publicField(this, "fmtVer", rn);
            }
        }();
        switch (t5.type) {
            case jt.MarkerType:
                return t5.value;
            case jt.Borders:
                return t5.value.reduce((t6, e3) => (t6.push(Jn(e3)), t6), new G());
            case jt.Color:
                return cn(t5.value);
            case jt.ContextSettings:
                return ln(t5.value);
            case jt.Fills:
                return t5.value.reduce((t6, e3) => (t6.push(Kn(e3, s2)), t6), new G());
            case jt.Gradient:
                return Hn(t5.value);
            case jt.ImageRef:
            case jt.Lock:
                return t5.value;
            case jt.Shadows:
                return t5.value.reduce((t6, e3) => (t6.push(kn(e3)), t6), new G());
            case jt.Status:
                return t5.value;
            case jt.Style:
                return eo(t5.value, s2);
            case jt.SymbolRef:
                return t5.value;
            case jt.TableCell:
                return ao(t5.value, s2);
            case jt.Text:
                return t5.value instanceof Ia ? ro(t5.value) : t5.value;
            case jt.Visible:
                return t5.value;
            case jt.ExportOptions:
                return Dn(t5.value);
            default:
                throw new Error();
        }
    }(s.value, t4, e), s.type, e, n2);
    n2.shapeAddOverride(e, p2, l2, u.id);
}
function Ag(t4, e, i, s, r, n2) {
    return Cg(e, i, s, n2, t4, r);
}
function Fg(t4, e, i, s, r, n2) {
    const o2 = Cg(s, r, () => n2, i, e, t4);
    return o2 && o2.value !== n2 && t4.shapeModifyVariable(e, o2, n2), !!o2;
}
function Rg(t4, e, i) {
    return Ag(e, jt.Borders, Et.Borders, (t5) => {
        const e2 = (t5 == null ? void 0 : t5.value) ?? i.getBorders();
        return new G(...e2.map((t6) => Jn(t6)));
    }, t4, i) || i.data;
}
function Og(t4, e, i) {
    return Ag(e, jt.Fills, Et.Fills, (t5) => {
        const e2 = (t5 == null ? void 0 : t5.value) ?? i.getFills();
        return new G(...e2.map((t6) => {
            const e3 = Kn(t6), i2 = t6.getImageMgr();
            return i2 && e3.setImageMgr(i2), e3;
        }));
    }, t4, i) || i.data;
}
function Lg(t4, e, i) {
    return Ag(e, jt.Shadows, Et.Shadows, (t5) => {
        const e2 = (t5 == null ? void 0 : t5.value) ?? i.getShadows();
        return new G(...e2.map((t6) => kn(t6)));
    }, t4, i) || i.data;
}
function Pg(t4, e, i) {
    const s = Ag(e, jt.CornerRadius, Et.CornerRadius, (t5) => {
        const e2 = (t5 == null ? void 0 : t5.value) ?? i.cornerRadius;
        return e2 ? dn(e2) : new ie(0, 0, 0, 0);
    }, t4, i) || i.data;
    if (s instanceof Ar) throw new Error();
    return s;
}
function Bg(t4) {
    var _a2;
    let e = false;
    for (let i = 0, s = t4.length; i < s; i++) {
        const s2 = t4[i];
        if (Vt.Symbol === s2.type || Vt.Contact === s2.type) return true;
        if (((_a2 = s2.childs) == null ? void 0 : _a2.length) && (e = Bg(s2.childs)), e) return true;
    }
    return false;
}
function Ng(t4) {
    return t4.type === Vt.Symbol || t4.type === Vt.SymbolUnion;
}
function zg(t4, e) {
    if (!(t4.parent instanceof zi)) return t4.name;
    const i = t4.parent.variables;
    if (!i) return t4.name;
    let s = [];
    return i.forEach((i2, r) => {
        var _a2;
        if (i2.type !== jt.Status) return;
        let n2 = ((_a2 = t4.symtags) == null ? void 0 : _a2.get(r)) || i2.value;
        n2 === Ni.Default_State && (n2 = e), n2 && s.push(n2);
    }), s.toString();
}
function Vg(t4, e) {
    if (t4.isVirtualShape) return 1;
    if (t4.type === Vt.SymbolUnion) return 2;
    let i = t4;
    for (; i && i.type !== Vt.Symbol; ) i = i.parent;
    if (i) {
        if (Bg([e])) return 3;
        const t5 = e.naviChilds || e.childs;
        if (t5 == null ? void 0 : t5.length) {
            const t6 = e instanceof Ar ? e.symData : e;
            if (!t6) return 4;
            if (ug(t6, i.id)) return 5;
        }
    }
    return 0;
}
function Dg(t4, e, i, s) {
    var _a2;
    if (s instanceof zi && !((_a2 = s.childs) == null ? void 0 : _a2.length)) {
        const r = s.parent;
        if (!r) return;
        const n2 = r.indexOfChild(s);
        if (n2 < 0) return;
        i.shapeDelete(t4, e, r, n2);
    }
}
class $g extends cg {
    constructor(t4, e, i, s = false) {
        super(t4, e, i);
        __publicField(this, "shape");
        s && (this.__repo.rollback(), this.api = this.__repo.start("path-modify", (t5, e2, i2) => {
            var _a2;
            const s2 = {};
            s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : this.shape ? [this.shape.id] : [], t5.restore(s2);
        }));
    }
    start() {
        return this.__repo.start("path-modify");
    }
    modifyBorderSetting() {
        if (this.haveEdit || !this.shape) return;
        const t4 = this.shape.getBorders() || [];
        for (let e = 0; e < t4.length; e++) {
            const i = t4[e], { thicknessBottom: s, thicknessTop: r, thicknessLeft: n2, thicknessRight: o2, sideType: a2 } = i.sideSetting;
            if (a2 === Dt.Normal) continue;
            const h2 = Math.max(s, r, n2, o2);
            this.api.setBorderSide(this.page, this.shape, e, new Me(Dt.Normal, h2, h2, h2, h2));
        }
        this.api.shapeEditPoints(this.page, this.shape, true);
    }
    get haveEdit() {
        var _a2;
        return !!((_a2 = this.shape) == null ? void 0 : _a2.haveEdit);
    }
    createVec(e, i, s, r) {
        try {
            const n2 = r ? eo(rr(r)) : kd();
            if (r) n2.fills = new G(), n2.shadows = new G();
            else {
                const e2 = new Me(Dt.Normal, 1, 1, 1, 1), i2 = new ts([0], v4(), true, xt.SolidColor, new Ji(1, 0, 0, 0), ht.Center, 1, new Kt(0, 0), ut.Miter, e2);
                n2.borders.push(i2);
            }
            const o2 = new se([0], v4(), 0, 0, ft.Straight), a2 = new pe([0], v4(), new G(o2), false), h2 = new ye(i.width, i.height), c2 = new Ii();
            c2.m02 = i.x, c2.m12 = i.y;
            const l2 = new Vi(new G(), v4(), e, Vt.Path, c2, n2, h2, new G(a2));
            bd(l2);
            const d2 = $c(s);
            return this.api.shapeInsert(this.__document, this.page, d2, l2, d2.childs.length), this.shape = d2.childs[d2.childs.length - 1], this.updateView(), this.shape;
        } catch (t4) {
            return console.error("PathModifier.createVec", t4), this.exception = true, false;
        }
    }
    addPoint(e, i, s) {
        try {
            const r = $c(e);
            return this.shape = r, this.modifyBorderSetting(), this.api.addPointAt(this.page, r, s, new se(new G(), v4(), 0, 0, ft.Straight), i), ol(this.page, this.api, r, s, i), this.updateView(), true;
        } catch (t4) {
            return console.log("PathModifier.addPoint:", t4), false;
        }
    }
    addPointForPen(e, i, s, r) {
        try {
            if (i < 0 || s < 0) return false;
            const n2 = $c(e);
            return this.shape = n2, this.api.addPointAt(this.page, n2, s, new se(new G(), v4(), r.x, r.y, ft.Straight), i), this.updateView(), true;
        } catch (t4) {
            return console.log("PathModifier.addPointForPen:", t4), false;
        }
    }
    addSegmentForPen(e, i) {
        try {
            const s = $c(e);
            this.shape = s;
            const r = this.shape.pathsegs.length, n2 = new se([0], v4(), i.x, i.y, ft.Straight), o2 = new pe([r], v4(), new G(n2), false);
            return this.api.addSegmentAt(this.page, s, r, o2), this.api.shapeEditPoints(this.page, s, true), this.updateView(), true;
        } catch (t4) {
            return console.log("PathModifier.addSegmentForPen:", t4), false;
        }
    }
    execute(t4, e) {
        try {
            const i = this.api, s = this.page, r = $c(t4);
            if (this.shape = r, r.pathType !== Ve.Editable) return;
            this.modifyBorderSetting(), e.forEach((t5, e2) => {
                const n2 = r.pathsegs[e2].points;
                for (let o2 = 0; o2 < t5.length; o2++) {
                    const a2 = t5[o2], h2 = n2[a2.index];
                    h2 && (this.api.shapeModifyCurvPoint(s, r, a2.index, { x: a2.x, y: a2.y }, e2), h2.hasFrom && i.shapeModifyCurvFromPoint(s, r, a2.index, { x: a2.fromX, y: a2.fromY }, e2), h2.hasTo && i.shapeModifyCurvToPoint(s, r, a2.index, { x: a2.toX, y: a2.toY }, e2));
                }
            }), this.updateView();
        } catch (t5) {
            console.log("PathModifier.execute:", t5), this.exception = true;
        }
    }
    preCurve(t4, e, i, s) {
        this.modifyBorderSetting(), this.shape = $c(e), function(t5, e2, i2, s2, r, n2) {
            var _a2;
            let o2;
            o2 = (_a2 = s2 == null ? void 0 : s2.pathsegs[n2]) == null ? void 0 : _a2.points[r], o2 && (3 === t5 ? o2.mode !== ft.Mirrored && i2.modifyPointCurveMode(e2, s2, r, ft.Mirrored, n2) : o2.mode !== ft.Disconnected && i2.modifyPointCurveMode(e2, s2, r, ft.Disconnected, n2), Qc(t5, s2, e2, i2, o2, r, n2, 0.01));
        }(t4, this.page, this.api, this.shape, i, s);
    }
    preCurve2(t4, e, i, s) {
        var _a2, _b;
        try {
            if (this.shape = $c(e), s < 0) return;
            let r;
            if (r = (_b = (_a2 = this.shape) == null ? void 0 : _a2.pathsegs[s]) == null ? void 0 : _b.points[i], !r) return;
            const n2 = this.api, o2 = this.page, a2 = this.shape;
            2 === t4 ? (r.mode !== ft.Disconnected && n2.modifyPointCurveMode(o2, a2, i, ft.Disconnected, s), n2.shapeModifyCurvFromPoint(o2, a2, i, { x: r.x, y: r.y }, s), n2.modifyPointHasFrom(o2, a2, i, true, s)) : (r.mode !== ft.Mirrored && n2.modifyPointCurveMode(o2, a2, i, ft.Mirrored, s), n2.shapeModifyCurvFromPoint(o2, a2, i, { x: r.x, y: r.y }, s), n2.shapeModifyCurvToPoint(o2, a2, i, { x: r.x, y: r.y }, s), n2.modifyPointHasFrom(o2, a2, i, true, s), n2.modifyPointHasTo(o2, a2, i, true, s)), this.updateView();
        } catch (t5) {
            console.error("PathModifier.preCurve2", t5), this.exception = true;
        }
    }
    execute4handle(t4, e, i, s, r, n2) {
        var _a2, _b;
        try {
            const o2 = this.api, a2 = this.page;
            this.shape = $c(t4);
            const h2 = this.shape;
            let c2;
            this.modifyBorderSetting(), h2.pathType === Ve.Editable && (c2 = (_b = (_a2 = h2 == null ? void 0 : h2.pathsegs[n2]) == null ? void 0 : _a2.points[e]) == null ? void 0 : _b.mode), c2 === ft.Mirrored || c2 === ft.Asymmetric ? (o2.shapeModifyCurvFromPoint(a2, h2, e, s, n2), o2.shapeModifyCurvToPoint(a2, h2, e, r, n2)) : c2 === ft.Disconnected && ("from" === i ? o2.shapeModifyCurvFromPoint(a2, h2, e, s, n2) : o2.shapeModifyCurvToPoint(a2, h2, e, r, n2)), this.updateView();
        } catch (t5) {
            console.log("PathModifier.execute4handle:", t5), this.exception = true;
        }
    }
    closeSegmentAt(t4, e) {
        const i = $c(t4);
        this.shape = i;
        return !!i.pathsegs[e] && (this.api.setCloseStatus(this.page, i, true, e), true);
    }
    mergeSegment(e, i, s, r) {
        try {
            const n2 = $c(e);
            this.shape = n2;
            const o2 = n2.pathsegs[i], a2 = n2.pathsegs[s];
            if (!o2 || !a2 || o2.isClosed || a2.isClosed) return false;
            const h2 = new G();
            let c2 = [], l2 = 0;
            if ("start" === r) c2 = [...o2.points, ...a2.points], l2 = o2.points.length;
            else {
                c2 = [...a2.points];
                for (let t4 = o2.points.length - 1; t4 > -1; t4--) {
                    const e2 = o2.points[t4], i2 = new se(e2.crdtidx, e2.id, e2.x, e2.y, e2.mode);
                    i2.radius = e2.radius, i2.hasTo = e2.hasFrom, i2.hasFrom = e2.hasTo, i2.fromX = e2.toX, i2.fromY = e2.toY, i2.toX = e2.fromX, i2.toY = e2.fromY, c2.push(i2);
                }
                l2 = a2.points.length - 1;
            }
            for (let e2 = 0; e2 < c2.length; e2++) {
                const i2 = c2[e2], s2 = new se([e2], v4(), i2.x, i2.y, i2.mode);
                s2.radius = i2.radius, s2.hasFrom = i2.hasFrom, s2.hasTo = i2.hasTo, s2.fromX = i2.fromX, s2.fromY = i2.fromY, s2.toX = i2.toX, s2.toY = i2.toY, h2.push(s2);
            }
            const d2 = this.api, p2 = this.page;
            d2.deleteSegmentAt(p2, n2, i), d2.deleteSegmentAt(p2, n2, s);
            const u = new pe([n2.pathsegs.length], v4(), h2, false);
            return d2.addSegmentAt(p2, n2, n2.pathsegs.length, u), this.updateView(), { segment: n2.pathsegs.length - 1, activeIndex: l2 };
        } catch (t4) {
            return console.error("PathModifier.mergeSegmentFromStart:", t4), this.exception = true, false;
        }
    }
    breakOffHandle(t4, e, i) {
        try {
            const s = $c(t4);
            this.shape = s;
            return s.pathsegs[e].points[i].mode === ft.Disconnected || (this.api.modifyPointCurveMode(this.page, s, i, ft.Disconnected, e), this.updateView()), true;
        } catch (t5) {
            return console.error("PathModifier.breakOffHandle:", t5), this.exception = true, false;
        }
    }
    recoveryHandle(t4, e, i, s, r) {
        try {
            const n2 = $c(t4);
            this.shape = n2;
            const o2 = n2.pathsegs[e].points[i];
            if (o2.mode !== ft.Disconnected) return true;
            const a2 = this.api, h2 = this.page;
            if (a2.modifyPointCurveMode(h2, n2, i, s, e), "from" === r) {
                if (s === ft.Mirrored) {
                    const t5 = (o2.fromX || 0) - o2.x, s2 = (o2.fromY || 0) - o2.y, r2 = o2.x - t5, c2 = o2.y - s2;
                    o2.toX === r2 && o2.toY === c2 || a2.shapeModifyCurvToPoint(h2, n2, i, { x: r2, y: c2 }, e);
                } else if (s === ft.Asymmetric) {
                    const t5 = Math.hypot(o2.x - (o2.toX || 0), o2.y - (o2.toY || 0)), s2 = Math.atan2((o2.fromX || 0) - o2.x, (o2.fromY || 0) - o2.y), r2 = Math.abs(Math.sin(s2) * t5), c2 = Math.abs(Math.cos(s2) * t5), l2 = (o2.fromX || 0) - o2.x, d2 = (o2.fromY || 0) - o2.y, p2 = o2.x - l2 / Math.abs(l2) * r2, u = o2.y - d2 / Math.abs(d2) * c2;
                    o2.toX === p2 && o2.toY === p2 || a2.shapeModifyCurvToPoint(h2, n2, i, { x: p2, y: u }, e);
                }
            } else if (s === ft.Mirrored) {
                const t5 = (o2.toX || 0) - o2.x, s2 = (o2.toY || 0) - o2.y, r2 = o2.x - t5, c2 = o2.y - s2;
                o2.fromX === r2 && o2.fromY === c2 || a2.shapeModifyCurvFromPoint(h2, n2, i, { x: r2, y: c2 }, e);
            } else if (s === ft.Asymmetric) {
                const t5 = Math.hypot(o2.x - (o2.fromX || 0), o2.y - (o2.fromY || 0)), s2 = Math.atan2((o2.toX || 0) - o2.x, (o2.toY || 0) - o2.y), r2 = Math.abs(Math.sin(s2) * t5), c2 = Math.abs(Math.cos(s2) * t5), l2 = (o2.toX || 0) - o2.x, d2 = (o2.toY || 0) - o2.y, p2 = o2.x - l2 / Math.abs(l2) * r2, u = o2.y - d2 / Math.abs(d2) * c2;
                o2.fromX === p2 && o2.fromY === p2 || a2.shapeModifyCurvFromPoint(h2, n2, i, { x: p2, y: u }, e);
            }
            return this.updateView(), true;
        } catch (t5) {
            return console.error("PathModifier.recoveryHandle:", t5), this.exception = true, false;
        }
    }
    reversePointsAt(e, i) {
        try {
            const s = $c(e);
            this.shape = s;
            const r = s.pathsegs[i];
            if (!r) return false;
            const n2 = r.points, o2 = new G();
            for (let e2 = n2.length - 1; e2 > -1; e2--) {
                const i2 = n2[e2], s2 = new se([e2], v4(), i2.x, i2.y, i2.mode);
                s2.radius = i2.radius, s2.hasTo = i2.hasFrom, s2.hasFrom = i2.hasTo, s2.fromX = i2.toX, s2.fromY = i2.toY, s2.toX = i2.fromX, s2.toY = i2.fromY, o2.push(s2);
            }
            const a2 = this.api, h2 = this.page;
            a2.deleteSegmentAt(h2, s, i);
            const c2 = s.pathsegs.length, l2 = new pe([c2], v4(), o2, r.isClosed);
            return a2.addSegmentAt(h2, s, c2, l2), this.updateView(), { segment: c2, activeIndex: l2.points.length - 1 };
        } catch (t4) {
            return console.error("PathModifier.reversePointsAt:", t4), this.exception = true, false;
        }
    }
    clip(e, i, s) {
        try {
            const r = $c(e);
            this.shape = r;
            const n2 = r == null ? void 0 : r.pathsegs[i];
            if (!n2) throw new Error("wrong segment");
            const { points: o2, isClosed: a2 } = n2;
            if (!o2[s]) throw new Error("wrong index");
            const h2 = o2.length;
            if (h2 < 2) throw new Error("wrong length");
            const c2 = this.page, l2 = this.api;
            if (a2) {
                const e2 = new G();
                for (let t4 = s + 1; t4 < h2; t4++) e2.push(o2[t4]);
                for (let t4 = 0; t4 <= s; t4++) e2.push(o2[t4]);
                l2.deleteSegmentAt(c2, r, i);
                const n3 = new pe([r.pathsegs.length], v4(), e2, false);
                l2.addSegmentAt(c2, r, r.pathsegs.length, n3);
            } else if (2 === h2) l2.deleteSegmentAt(c2, r, i);
            else if (0 === s) l2.deletePoint(c2, r, 0, i);
            else if (s === h2 - 2) l2.deletePoint(c2, r, h2 - 1, i);
            else {
                const e2 = new G(), n3 = new G();
                for (let t4 = 0; t4 <= s; t4++) e2.push(o2[t4]);
                for (let t4 = s + 1; t4 < h2; t4++) n3.push(o2[t4]);
                l2.deleteSegmentAt(c2, r, i);
                const a3 = new pe([r.pathsegs.length], v4(), e2, false);
                l2.addSegmentAt(c2, r, r.pathsegs.length, a3);
                const d2 = new pe([r.pathsegs.length], v4(), n3, false);
                l2.addSegmentAt(c2, r, r.pathsegs.length, d2);
            }
            return this.api.shapeEditPoints(this.page, r, true), true;
        } catch (t4) {
            return console.error("PathModifier.clip:", t4), this.exception = true, false;
        }
    }
    sortSegment(t4) {
        try {
            const e = $c(t4);
            this.shape = e;
            const i = this.api, s = this.page, r = e.pathsegs;
            if (!r.length) {
                const t5 = e.parent, r2 = t5.indexOfChild(e);
                return void i.shapeDelete(this.__document, s, t5, r2);
            }
            for (let t5 = r.length - 1; t5 > -1; t5--) {
                r[t5].points.length < 2 && i.deleteSegmentAt(s, e, t5);
            }
        } catch (t5) {
            return console.error("PathModifier.sortSegment:", t5), this.exception = true, false;
        }
    }
    modifyClosedStatus(t4, e) {
        try {
            const i = $c(t4);
            this.shape = i;
            const s = i == null ? void 0 : i.pathsegs;
            if (!(s == null ? void 0 : s.length)) return false;
            const r = this.page, n2 = this.api;
            for (let t5 = 0; t5 < s.length; t5++) {
                const o2 = s[t5];
                o2.points.length < 3 || n2.setCloseStatus(r, i, e, t5);
            }
            return true;
        } catch (t5) {
            return console.error("PathModifier.modifyClosedStatus:", t5), this.exception = true, false;
        }
    }
    commit() {
        this.__repo.isNeedCommit() && !this.exception ? (Kc(this.api, this.page, this.shape), this.__repo.commit()) : this.__repo.rollback();
    }
}
function Jg(t4, e) {
    return Math.abs(t4 - e) < We;
}
function Kg(t4, e, i, s) {
    const r = i.pathsegs[0].points, n2 = r[0], o2 = r[1], a2 = i.matrix2Parent(), h2 = i.size;
    a2.preScale(h2.width, h2.height);
    const c2 = a2.computeCoord2(n2.x, n2.y), l2 = pm(c2, a2.computeCoord2(o2.x, o2.y)), d2 = Math.cos(l2) * s + c2.x, p2 = Math.sin(l2) * s + c2.y, u = a2.inverseCoord({ x: d2, y: p2 });
    t4.shapeModifyCurvPoint(e, i, 1, u, 0), Kc(t4, e, i);
}
class qg {
    constructor(t4, e, i, s) {
        __publicField(this, "__shape");
        __publicField(this, "__repo");
        __publicField(this, "__page");
        __publicField(this, "__document");
        if (!(t4 instanceof Vh)) throw new Error("shape wrong");
        if (!(e instanceof qi)) throw console.error("page wrong", e ? JSON.stringify(e, (t5, e2) => t5.startsWith("__")) : e), new Error("page wrong");
        if (!(i instanceof Nf)) throw new Error("repo wrong");
        if (!(s instanceof Oa)) throw new Error("document wrong");
        this.__shape = t4, this.__repo = i, this.__page = e, this.__document = s;
    }
    get view() {
        return this.__shape;
    }
    get shape() {
        return $c(this.__shape);
    }
    _repoWrap(t4, e) {
        const i = this.__repo.start(t4);
        try {
            e(i), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    overrideVariable(t4, e, i, s, r) {
        return r = r ?? this.__shape, Ag(this.__page, t4, e, i, s, r);
    }
    modifyVariable(t4, e, i, s) {
        return Fg(s, this.__page, this.__shape, t4, e, i);
    }
    modifyVariable2(t4, e, i) {
        Eg(this.__document, this.__page, this.__shape, t4, { value: e }, i);
    }
    modifyVariableName(t4, e) {
        try {
            const i = this.__repo.start("modifyVariableName");
            Eg(this.__document, this.__page, this.__shape, t4, { name: e }, i), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    modifySymbolRefVariable(t4, e) {
        const i = this.__repo.start("modifySymbolRefVariable");
        try {
            this.modifyVariable2(t4, e, i), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    resetSymbolRefVariable() {
        let t4 = this.view, e = t4;
        for (; e && e.isVirtualShape; ) e = e.parent;
        if (!(e instanceof nc)) throw new Error();
        const i = this.__repo.start("resetSymbolRefVariable");
        try {
            if (e === t4) {
                const e2 = t4.variables, s = t4.overrides;
                if (s && s.forEach((e3, s2) => {
                    i.shapeRemoveOverride(this.__page, t4.data, s2);
                }), e2.forEach((e3, s2) => {
                    i.shapeRemoveVariable(this.__page, t4.data, s2);
                }), t4.isCustomSize) {
                    i.shapeModifyIsCustomSize(this.__page, t4.data, false);
                    const e3 = t4.symData;
                    e3 && i.shapeModifyWH(this.__page, t4.data, e3.size.width, e3.size.height);
                }
            } else {
                const s = e.variables, r = e.overrides, n2 = e, o2 = t4.id.split("/").slice(1).join("/");
                r && r.forEach((t5, e2) => {
                    if (!e2.startsWith(o2)) return;
                    i.shapeRemoveOverride(this.__page, n2.data, e2);
                    s.get(t5) && i.shapeRemoveVariable(this.__page, n2.data, e2);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    makeVisibleVar(e, i, s, r) {
        let n2 = $c(e);
        if (!Ng(n2)) throw new Error("wrong role!");
        const o2 = this.__repo.start("makeVisibleVar");
        try {
            const e2 = new Ri(v4(), jt.Visible, i, s);
            o2.shapeAddVariable(this.__page, n2, e2);
            for (let t4 = 0, i2 = r.length; t4 < i2; t4++) {
                const i3 = r[t4];
                o2.shapeBindVar(this.__page, i3, Et.Visible, e2.id);
            }
            return this.__repo.commit(), n2;
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    makeSymbolRefVar(e, i, s) {
        let r = $c(e);
        if (!s.length) throw new Error("invalid data");
        if (!Ng(r)) throw new Error("wrong role!");
        const n2 = this.__repo.start("makeSymbolRefVar");
        try {
            const e2 = new Ri(v4(), jt.SymbolRef, i, s[0].refId);
            n2.shapeAddVariable(this.__page, r, e2);
            for (let t4 = 0, i2 = s.length; t4 < i2; t4++) n2.shapeBindVar(this.__page, s[t4], Et.SymbolID, e2.id);
            return this.__repo.commit(), r;
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    makeTextVar(e, i, s, r) {
        var _a2, _b, _c2, _d2;
        let n2 = $c(e);
        if (!Ng(n2)) throw new Error("wrong role!");
        const o2 = this.__repo.start("makeTextVar");
        try {
            const e2 = ((_a2 = r[0]) == null ? void 0 : _a2.text) instanceof Ia ? (_b = r[0]) == null ? void 0 : _b.text : void 0, a2 = ea(e2 == null ? void 0 : e2.attr, (_c2 = e2 == null ? void 0 : e2.paras[0]) == null ? void 0 : _c2.attr, (_d2 = e2 == null ? void 0 : e2.paras[0]) == null ? void 0 : _d2.spans[0]);
            a2.insertText(s, 0);
            const h2 = new Ri(v4(), jt.Text, i, a2);
            o2.shapeAddVariable(this.__page, n2, h2);
            for (let t4 = 0, e3 = r.length; t4 < e3; t4++) {
                const e4 = r[t4];
                o2.shapeBindVar(this.__page, e4, Et.Text, h2.id);
            }
            return this.__repo.commit(), n2;
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    modifyVar(t4, e, i, s, r, n2) {
        const o2 = {};
        if (o2[jt.Text] = Et.Text, o2[jt.Visible] = Et.Visible, o2[jt.SymbolRef] = Et.SymbolID, !Ng(t4)) throw new Error("wrong role!");
        const a2 = this.__repo.start("modifyVar");
        try {
            for (let t5 = 0, i2 = r.length; t5 < i2; t5++) {
                const i3 = r[t5];
                a2.shapeBindVar(this.__page, i3, o2[e.type], e.id);
            }
            for (let t5 = 0, i2 = n2.length; t5 < i2; t5++) {
                const i3 = n2[t5];
                a2.shapeUnbinVar(this.__page, i3, o2[e.type]);
            }
            return i !== e.name && Eg(this.__document, this.__page, this.__shape, e, { name: i }, a2), s !== e.value && Eg(this.__document, this.__page, this.__shape, e, { value: s }, a2), this.__repo.commit(), true;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    setName(t4) {
        this._repoWrap("setName", (e) => {
            this.modifyVariable(jt.Name, Et.Name, t4, e) || (e.shapeModifyName(this.__page, this.shape, t4), e.shapeModifyNameFixed(this.__page, this.shape, true));
        });
    }
    toggleVisible() {
        this._repoWrap("toggleVisible", (t4) => {
            const e = !this.view.isVisible;
            this.modifyVariable(jt.Visible, Et.Visible, e, t4) || t4.shapeModifyVisible(this.__page, this.shape, e);
        });
    }
    toggleLock() {
        this._repoWrap("toggleLock", (t4) => {
            const e = !this.view.isLocked;
            this.modifyVariable(jt.Lock, Et.Lock, e, t4) || t4.shapeModifyLock(this.__page, this.shape, e);
        });
    }
    translate(t4, e, i = true) {
        this._repoWrap("translate", (s) => {
            ng(s, this.__page, this.shape, t4, e, i);
        });
    }
    translateTo(t4, e) {
        this._repoWrap("translateTo", (i) => {
            rg(i, this.__page, this.shape, t4, e);
        });
    }
    expand(t4, e) {
        this._repoWrap("expand", (i) => {
            ag(i, this.__document, this.__page, this.shape, t4, e);
        });
    }
    expandTo(t4, e) {
        this._repoWrap("expandTo", (i) => {
            og(i, this.__document, this.__page, this.shape, t4, e);
        });
    }
    setConstrainerProportions(t4) {
        this._repoWrap("setConstrainerProportions", (e) => {
            e.shapeModifyConstrainerProportions(this.__page, this.shape, t4);
        });
    }
    flipH() {
        this._repoWrap("flipHorizontal", (t4) => {
            t4.shapeModifyHFlip(this.__page, this.shape);
        });
    }
    flipV() {
        this._repoWrap("flipVertical", (t4) => {
            t4.shapeModifyVFlip(this.__page, this.shape);
        });
    }
    contextSettingOpacity(t4) {
        const e = this.__repo.start("contextSettingOpacity");
        try {
            const i = Ig(e, this.__shape, this.__page);
            e.shapeModifyContextSettingsOpacity(this.__page, i, t4), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setResizingConstraint(t4) {
        this._repoWrap("setResizingConstraint", (e) => {
            e.shapeModifyResizingConstraint(this.__page, this.shape, t4);
        });
    }
    rotate(t4) {
        this._repoWrap("rotate", (t5) => {
        });
    }
    setRectRadius(t4, e, i, s) {
        const r = this.shape;
        this._repoWrap("setRectRadius", (n2) => {
            n2.shapeModifyRadius(this.__page, r, t4, e, i, s);
        });
    }
    setFixedRadius(t4) {
        if (this.shape instanceof Li) {
            if (!(this.shape instanceof Pi)) return;
        } else if (!(this.shape instanceof Vi || this.shape instanceof Di || this.shape instanceof Gi)) return;
        this._repoWrap("setFixedRadius", (e) => {
            e.shapeModifyFixedRadius(this.__page, this.shape, t4 || void 0);
        });
    }
    setBoolOp(t4, e) {
        this.shape instanceof Pi && this._repoWrap("setBoolOp", (i) => {
            const s = this.shape;
            e && i.shapeModifyName(this.__page, this.shape, e), s.childs.forEach((e2) => {
                i.shapeModifyBoolOp(this.__page, e2, t4);
            });
        });
    }
    shape4fill(t4, e) {
        return Og(t4, this.__page, e ?? this.__shape);
    }
    addFill(t4) {
        this._repoWrap("addFill", (e) => {
            const i = this.shape4fill(e), s = i instanceof Oi ? i.style.fills.length : i.value.length;
            e.addFillAt(this.__page, i, t4, s);
        });
    }
    setFillColor(t4, e) {
        this._repoWrap("setFillColor", (i) => {
            const s = this.shape4fill(i);
            i.setFillColor(this.__page, s, t4, e);
        });
    }
    setFillEnable(t4, e) {
        this._repoWrap("setFillEnable", (i) => {
            const s = this.shape4fill(i);
            i.setFillEnable(this.__page, s, t4, e);
        });
    }
    deleteFill(t4) {
        this._repoWrap("deleteFill", (e) => {
            const i = this.shape4fill(e);
            e.deleteFillAt(this.__page, i, t4);
        });
    }
    shape4border(t4, e) {
        return Rg(t4, this.__page, e ?? this.__shape);
    }
    setBorderEnable(t4, e) {
        this._repoWrap("setBorderEnable", (i) => {
            const s = this.shape4border(i);
            i.setBorderEnable(this.__page, s, t4, e);
        });
    }
    setBorderColor(t4, e) {
        this._repoWrap("setBorderColor", (i) => {
            const s = this.shape4border(i);
            i.setBorderColor(this.__page, s, t4, e);
        });
    }
    setBorderThickness(t4, e) {
        this._repoWrap("setBorderThickness", (i) => {
            const s = this.shape4border(i);
            i.setBorderThickness(this.__page, s, t4, e);
        });
    }
    setBorderPosition(t4, e) {
        this._repoWrap("setBorderPosition", (i) => {
            const s = this.shape4border(i);
            i.setBorderPosition(this.__page, s, t4, e);
        });
    }
    setBorderStyle(t4, e) {
        this._repoWrap("setBorderStyle", (i) => {
            const s = this.shape4border(i);
            i.setBorderStyle(this.__page, s, t4, e);
        });
    }
    setMarkerType(t4, e) {
        this._repoWrap("setMarkerType", (i) => {
            this.modifyVariable(jt.MarkerType, e ? Et.EndMarkerType : Et.StartMarkerType, t4, i) || (e ? i.shapeModifyEndMarkerType(this.__page, this.shape, t4) : i.shapeModifyStartMarkerType(this.__page, this.shape, t4));
        });
    }
    exchangeMarkerType() {
        const t4 = this.__shape.startMarkerType, e = this.__shape.endMarkerType;
        e !== t4 && this._repoWrap("exchangeMarkerType", (i) => {
            this.modifyVariable(jt.MarkerType, Et.EndMarkerType, t4 || Ct.Line, i) ? this.modifyVariable(jt.MarkerType, Et.StartMarkerType, e || Ct.Line, i) : (i.shapeModifyEndMarkerType(this.__page, this.shape, t4 || Ct.Line), i.shapeModifyStartMarkerType(this.__page, this.shape, e || Ct.Line));
        });
    }
    deleteBorder(t4) {
        this._repoWrap("deleteBorder", (e) => {
            const i = this.shape4border(e);
            e.deleteBorderAt(this.__page, i, t4);
        });
    }
    addBorder(t4) {
        this._repoWrap("addBorder", (e) => {
            const i = this.shape4border(e), s = i instanceof Oi ? i.style.borders.length : i.value.length;
            e.addBorderAt(this.__page, i, t4, s);
        });
    }
    setPathClosedStatus(t4, e) {
        this._repoWrap("setPathClosedStatus", (i) => {
            i.setCloseStatus(this.__page, this.shape, t4, e);
        });
    }
    addPointAt(t4, e, i) {
        this._repoWrap("addPointAt", (s) => {
            s.addPointAt(this.__page, this.shape, e, t4, i);
        });
    }
    removePoints(t4) {
        try {
            let e = -1;
            const i = this.__repo.start("removePoints"), s = this.__page, r = this.shape;
            t4.forEach((t5, e2) => {
                if (!(t5 = t5.sort((t6, e3) => t6 > e3 ? 1 : -1)).length) return void console.log("removePoints: !indexes.length");
                for (let n4 = t5.length - 1; n4 > -1; n4--) i.deletePoint(s, r, t5[n4], e2);
                const n3 = r.pathsegs[e2];
                2 === n3.points.length && i.setCloseStatus(s, r, false, e2), n3.points.length < 2 && i.deleteSegmentAt(s, r, e2);
            }), e = 1;
            let n2 = true;
            for (let t5 = 0; t5 < r.pathsegs.length; t5++) if (r.pathsegs[t5].points.length > 1) {
                n2 = false;
                break;
            }
            return n2 ? (this.__delete(r, i), e = 0) : (i.shapeEditPoints(s, r, true), Kc(i, s, r)), this.__repo.commit(), e;
        } catch (t5) {
            return this.__repo.rollback(), console.log("removePoints:", t5), -1;
        }
    }
    __delete(t4, e) {
        const i = t4.parent, s = i.indexOfChild(t4);
        s < 0 || (e.shapeDelete(this.__document, this.__page, i, s), i.childs.length || this.__delete(i, e));
    }
    modifyPointsCurveMode(t4, e) {
        try {
            const i = this.__repo.start("modifyPointsCurveMode");
            if (this.shape.pathType !== Ve.Editable) return;
            return t4.forEach((t5, s) => {
                for (let r = t5.length - 1; r > -1; r--) {
                    const n2 = t5[r];
                    il(this.shape, this.__page, i, n2, e, s), i.modifyPointCurveMode(this.__page, this.shape, n2, e, s);
                }
            }), Kc(i, this.__page, this.shape), this.__repo.commit(), true;
        } catch (t5) {
            return console.log("modifyPointsCurveMode:", t5), this.__repo.rollback(), false;
        }
    }
    modifyPointsCornerRadius(t4, e) {
        try {
            const i = this.__repo.start("modifyPointsCornerRadius");
            if (this.shape.pathType !== Ve.Editable) return;
            return t4.forEach((t5, s) => {
                for (let r = t5.length - 1; r > -1; r--) i.modifyPointCornerRadius(this.__page, this.shape, t5[r], e, s);
            }), this.__repo.commit(), true;
        } catch (t5) {
            return console.log("modifyPointsCornerRadius:", t5), this.__repo.rollback(), false;
        }
    }
    modifyPointsXY(t4) {
        try {
            if (!this.shape.pathType) return;
            return function(t5, e, i, s) {
                let r = new o(i.matrix2Parent());
                const n2 = i.size;
                if (r.preScale(n2.width, n2.height), r = new o(r.inverse), i.pathType === Ve.Editable) {
                    for (let n3 = 0, o2 = s.length; n3 < o2; n3++) {
                        const o3 = s[n3], a2 = r.computeCoord2(o3.x, o3.y);
                        t5.shapeModifyCurvPoint(e, i, o3.index, a2, o3.segment);
                    }
                    Kc(t5, e, i);
                }
            }(this.__repo.start("modifyPointsXY"), this.__page, this.shape, t4), this.__repo.commit(), true;
        } catch (t5) {
            return console.log("modifyPointsXY:", t5), this.__repo.rollback(), false;
        }
    }
    shape4shadow(t4, e) {
        return Lg(t4, this.__page, e ?? this.__shape);
    }
    addShadow(t4) {
        const e = this.__repo.start("addShadow");
        try {
            const i = this.shape4shadow(e), s = i instanceof Oi ? i.style.shadows.length : i.value.length;
            e.addShadow(this.__page, i, t4, s), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    deleteShadow(t4) {
        const e = this.__repo.start("deleteShadow");
        try {
            const i = this.shape4shadow(e);
            e.deleteShadowAt(this.__page, i, t4), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowPosition(t4, e) {
        const i = this.__repo.start("setShadowPosition");
        try {
            const s = this.shape4shadow(i);
            i.setShadowPosition(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowEnable(t4, e) {
        const i = this.__repo.start("setShadowEnable");
        try {
            const s = this.shape4shadow(i);
            i.setShadowEnable(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowColor(t4, e) {
        const i = this.__repo.start("setShadowColor");
        try {
            const s = this.shape4shadow(i);
            i.setShadowColor(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowOffsetX(t4, e) {
        const i = this.__repo.start("setShadowOffsetX");
        try {
            const s = this.shape4shadow(i);
            i.setShadowOffsetX(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowOffsetY(t4, e) {
        const i = this.__repo.start("setShadowOffsetY");
        try {
            const s = this.shape4shadow(i);
            i.setShadowOffsetY(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowBlur(t4, e) {
        const i = this.__repo.start("setShadowBlur");
        try {
            const s = this.shape4shadow(i);
            i.setShadowBlur(this.__page, s, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setShadowSpread(t4, e) {
        const i = this.__repo.start("setShadowSpread");
        try {
            this.shape4shadow(i);
            i.setShadowSpread(this.__page, this.shape, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    addExportFormat(t4) {
        const e = this.__repo.start("addExportFormat");
        try {
            const i = kg(e, this.__shape, this.__page), s = i instanceof Oi ? i.exportOptions : i.value, r = (s == null ? void 0 : s.exportFormats.length) || 0;
            for (let s2 = 0; s2 < t4.length; s2++) {
                const n2 = t4[s2], o2 = r + s2;
                e.addExportFormat(this.__page, i, n2, o2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    deleteExportFormat(t4) {
        var _a2;
        const e = (_a2 = this.__shape.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
        if (e) {
            const e2 = this.__repo.start("deleteExportFormat");
            try {
                const i = kg(e2, this.__shape, this.__page);
                e2.deleteExportFormatAt(this.__page, i, t4), this.__repo.commit();
            } catch (t5) {
                console.error(t5), this.__repo.rollback();
            }
        }
    }
    setExportFormatScale(t4, e) {
        var _a2;
        const i = (_a2 = this.__shape.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
        if (i) {
            const i2 = this.__repo.start("setExportFormatScale");
            try {
                const s = kg(i2, this.__shape, this.__page);
                i2.setExportFormatScale(this.__page, s, t4, e), this.__repo.commit();
            } catch (t5) {
                console.error(t5), this.__repo.rollback();
            }
        }
    }
    setExportFormatName(t4, e) {
        var _a2;
        const i = (_a2 = this.__shape.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
        if (i) {
            const i2 = this.__repo.start("setExportFormatName");
            try {
                const s = kg(i2, this.__shape, this.__page);
                i2.setExportFormatName(this.__page, s, t4, e), this.__repo.commit();
            } catch (t5) {
                console.error(t5), this.__repo.rollback();
            }
        }
    }
    setExportFormatFileFormat(t4, e) {
        var _a2;
        const i = (_a2 = this.__shape.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
        if (i) {
            const i2 = this.__repo.start("setExportFormatFileFormat");
            try {
                const s = kg(i2, this.__shape, this.__page);
                i2.setExportFormatFileFormat(this.__page, s, t4, e), this.__repo.commit();
            } catch (t5) {
                console.error(t5), this.__repo.rollback();
            }
        }
    }
    setExportFormatPerfix(t4, e) {
        var _a2;
        const i = (_a2 = this.__shape.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
        if (i) {
            const i2 = this.__repo.start("setExportFormatPerfix");
            try {
                const s = kg(i2, this.__shape, this.__page);
                i2.setExportFormatPerfix(this.__page, s, t4, e), this.__repo.commit();
            } catch (t5) {
                console.error(t5), this.__repo.rollback();
            }
        }
    }
    setExportTrimTransparent(t4) {
        const e = this.__repo.start("setExportTrimTransparent");
        try {
            const i = kg(e, this.__shape, this.__page);
            e.setExportTrimTransparent(this.__page, i, t4), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setExportCanvasBackground(t4) {
        const e = this.__repo.start("setExportTrimTransparent");
        try {
            const i = kg(e, this.__shape, this.__page);
            e.setExportCanvasBackground(this.__page, i, t4), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setExportPreviewUnfold(t4) {
        const e = this.__repo.start("setExportTrimTransparent");
        try {
            const i = kg(e, this.__shape, this.__page);
            e.setExportPreviewUnfold(this.__page, i, t4), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    adapt() {
        try {
            if (!(this.view instanceof Hh)) throw new Error("!(this.shape instanceof Artboard)");
            if (!function(t4, e, i) {
                const s = i.childs;
                if (!s.length) return console.log("adapt_for_artboard: !children.length");
                const r = i.matrix2Root(), n2 = i.size, o2 = function() {
                    const t5 = [];
                    s.forEach((e3) => {
                        const i3 = e3.frame, s2 = e3.matrix2Parent(), r3 = i3.x + i3.width, n4 = i3.y + i3.height;
                        t5.push(...[{ x: i3.x, y: i3.y }, { x: r3, y: i3.y }, { x: r3, y: n4 }, { x: i3.x, y: n4 }].map((t6) => s2.computeCoord3(t6)));
                    });
                    const e2 = t5.reduce((t6, e3) => Math.min(t6, e3.x), t5[0].x), i2 = t5.reduce((t6, e3) => Math.max(t6, e3.x), t5[0].x), r2 = t5.reduce((t6, e3) => Math.min(t6, e3.y), t5[0].y), n3 = t5.reduce((t6, e3) => Math.max(t6, e3.y), t5[0].y);
                    return new _e(e2, r2, i2 - e2, n3 - r2);
                }();
                if (Jg(0, o2.x) && Jg(0, o2.y) && Jg(n2.width, o2.width) && Jg(n2.height, o2.height)) return console.log("invalid action");
                s.forEach((i2) => {
                    const s2 = $c(i2);
                    t4.shapeModifyX(e, s2, i2.transform.translateX - o2.x), t4.shapeModifyY(e, s2, i2.transform.translateY - o2.y);
                });
                const a2 = $c(i);
                t4.shapeModifyWH(e, a2, Math.max(o2.width, 1), Math.max(o2.height, 1));
                const h2 = r.computeCoord3(o2);
                return rg(t4, e, a2, h2.x, h2.y), true;
            }(this.__repo.start("adapt"), this.__page, this.view)) throw new Error("wrong env");
            this.__repo.commit();
        } catch (t4) {
            console.error("adapt", t4), this.__repo.rollback();
        }
    }
    delete() {
        if (_g(this.shape)) return void this.toggleVisible();
        const t4 = this.shape.parent;
        if (t4) {
            const e = (t4.type === Vt.SymbolRef ? t4.naviChilds || [] : t4.childs).findIndex((t5) => t5.id === this.shape.id);
            if (e >= 0) try {
                const i = this.__repo.start("deleteShape", (t5, e2, i2) => {
                    var _a2;
                    const s2 = {};
                    s2.shapes = e2 ? [this.shape.id] : ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [], t5.restore(s2);
                });
                this.shape.type === Vt.Contact ? this.removeContactSides(i, this.__page, this.shape) : this.removeContact(i, this.__page, this.shape);
                const s = Uf(this.shape);
                if (s && qf(this.__page, this.shape, s, i), i.shapeDelete(this.__document, this.__page, t4, e), eg(t4)) {
                    const e2 = t4.parent, s2 = e2.childs.findIndex((e3) => e3.id === t4.id);
                    i.shapeDelete(this.__document, this.__page, e2, s2);
                }
                this.shape.type === Vt.Symbol && this.__document.__correspondent.notify("update-symbol-list"), this.__repo.commit();
            } catch (t5) {
                this.__repo.rollback(), console.log(t5);
            }
        }
    }
    removeContactSides(t4, e, i) {
        if (i.from) {
            const s = e.getShape(i.from.shapeId), r = s == null ? void 0 : s.style.contacts;
            if (s && r) {
                let n2 = -1;
                for (let t5 = 0, e2 = r.length; t5 < e2; t5++) {
                    if (r[t5].shapeId === i.id) {
                        n2 = t5;
                        break;
                    }
                }
                n2 > -1 && t4.removeContactRoleAt(e, s, n2);
            }
        }
        if (i.to) {
            const s = e.getShape(i.to.shapeId), r = s == null ? void 0 : s.style.contacts;
            if (s && r) {
                let n2 = -1;
                for (let t5 = 0, e2 = r.length; t5 < e2; t5++) {
                    if (r[t5].shapeId === i.id) {
                        n2 = t5;
                        break;
                    }
                }
                n2 > -1 && t4.removeContactRoleAt(e, s, n2);
            }
        }
    }
    removeContact(t4, e, i) {
        const s = i.style.contacts;
        if (s && s.length) for (let i2 = 0, r = s.length; i2 < r; i2++) {
            const r2 = e.getShape(s[i2].shapeId);
            if (!r2) continue;
            const n2 = r2.parent;
            if (!n2) continue;
            let o2 = -1;
            for (let t5 = 0, e2 = n2.childs.length; t5 < e2; t5++) if (n2.childs[t5].id === r2.id) {
                o2 = t5;
                break;
            }
            o2 > -1 && t4.shapeDelete(this.__document, e, n2, o2);
        }
    }
    isDeleted() {
        return !this.__page.getShape(this.shape.id);
    }
    modify_edit_state(t4) {
        if (this.shape.type !== Vt.Contact) return false;
        this._repoWrap("modify_edit_state", (e) => {
            e.contactModifyEditState(this.__page, this.shape, t4);
        });
    }
    reset_contact_path() {
        if (!(this.shape instanceof Cs)) return false;
        const e = this.shape;
        this._repoWrap("reset_contact_path", (i) => {
            i.contactModifyEditState(this.__page, e, false);
            const s = jc(this.__page, e, 1, e.getPoints()), r = e.points.length;
            i.deletePoints(this.__page, e, 0, r, 0);
            for (let e2 = 0, i2 = s.length; e2 < i2; e2++) {
                const i3 = un(s[e2]);
                i3.id = v4(), s[e2] = i3;
            }
            i.addPoints(this.__page, e, s, 0), Kc(i, this.__page, e);
        });
    }
    switchSymRef(t4) {
        if (!(this.view instanceof nc)) return;
        const e = this.__repo.start("switchSymRef");
        try {
            if (!this.modifyVariable(jt.SymbolRef, Et.SymbolID, t4, e)) {
                e.shapeModifySymRef(this.__page, this.view.data, t4);
                const i = this.view;
                if (!i.data.isCustomSize) {
                    const s = this.__document.symbolsMgr.get(t4);
                    s && e.shapeModifyWH(this.__page, i.data, s.size.width, s.size.height);
                }
            }
            this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    switchSymState(t4, e) {
        var _a2;
        if (!(this.shape instanceof Ar)) return;
        const i = this.shape.symData, s = i == null ? void 0 : i.parent;
        if (!(i && s && s instanceof zi)) return;
        const r = s.childs, n2 = /* @__PURE__ */ new Map();
        (_a2 = s.variables) == null ? void 0 : _a2.forEach((s2) => {
            var _a3;
            if (s2.type === jt.Status) {
                const r2 = s2.id === t4 ? e : (_a3 = i.symtags) == null ? void 0 : _a3.get(s2.id);
                n2.set(s2.id, r2 ?? s2.value);
            }
        });
        const o2 = [], a2 = [];
        r.forEach((e2) => {
            const i2 = e2.symtags;
            let s2 = true;
            n2.forEach((r2, n3) => {
                const a3 = (i2 == null ? void 0 : i2.get(n3)) ?? Ni.Default_State;
                s2 && (s2 = r2 === a3), n3 === t4 && r2 === a3 && o2.push(e2);
            }), s2 && a2.push(e2);
        });
        const h2 = a2[0] ?? o2[0];
        if (!h2) throw new Error();
        this.switchSymRef(h2.id);
    }
    modifySymTag(t4, e) {
        var _a2;
        const i = this.shape;
        if (!(i instanceof Ni)) return;
        if (i.isVirtualShape) return;
        const s = i.parent;
        if (!(s instanceof zi)) return;
        s.childs;
        const r = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map();
        throw (_a2 = s.variables) == null ? void 0 : _a2.forEach((t5) => {
            if (t5.type === jt.Status) {
                const e2 = bs(t5.id, Et.Variable, this.__shape.varsContainer || []), i2 = e2 ? e2[e2.length - 1] : t5;
                n2.set(t5.id, i2.value), r.set(t5.id, i2);
            }
        }), new Error();
    }
    modifyStateSymTagValue(t4, e) {
        if (!(this.shape.parent && this.shape.parent instanceof zi)) return;
        const i = this.__repo.start("modifyStateSymTagValue");
        try {
            if (function(t5) {
                var _a2;
                const e2 = t5.parent;
                if (!(e2 && e2 instanceof zi)) return false;
                const i2 = e2.childs;
                return ((_a2 = i2[0]) == null ? void 0 : _a2.id) === t5.id;
            }(this.shape)) {
                const s = this.shape.parent.variables, r = s == null ? void 0 : s.get(t4);
                if (!r) throw new Error("wrong variable");
                i.shapeModifyVariable(this.__page, r, e);
            }
            i.shapeModifyVartag(this.__page, this.shape, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    createVar(e, i, s) {
        if (!(this.shape instanceof Ni || this.shape instanceof Ar)) return;
        if (this.shape.isVirtualShape) return;
        const r = new Ri(v4(), e, i, s), n2 = this.__repo.start("createVar");
        try {
            n2.shapeAddVariable(this.__page, this.shape, r), this.__repo.commit();
        } catch (t4) {
            console.error(t4), this.__repo.rollback();
        }
    }
    removeVar(t4) {
        const e = this.shape;
        if (!(e instanceof Ni)) return;
        if (e.isVirtualShape) return;
        const i = e.getVar(t4);
        if (!i) return;
        const s = (t5, e2, i2, r2) => {
            t5.childs.forEach((t6) => {
                var _a2;
                const n2 = (_a2 = t6.varbinds) == null ? void 0 : _a2.get(i2);
                n2 === e2 && r2(t6), t6 instanceof Li && s(t6, e2, i2, r2);
            });
        }, r = this.__repo.start("removeVar");
        try {
            switch (i.type) {
                case jt.Visible:
                    s(e, i.id, Et.Visible, (t5) => {
                        !!t5.isVisible != !!i.value && r.shapeModifyVisible(this.__page, t5, !t5.isVisible);
                    });
                    break;
                case jt.Text:
                    s(e, i.id, Et.Text, (t5) => {
                        t5 instanceof Gi && (r.deleteText2(this.__page, t5, 0, t5.text.length - 1), "string" == typeof i.value ? r.insertSimpleText2(this.__page, t5, 0, i.value) : r.insertComplexText2(this.__page, t5, 0, i.value));
                    });
            }
            r.shapeRemoveVariable(this.__page, e, t4), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    removeBinds(t4) {
        var _a2;
        if (yg(this.shape)) try {
            const e = this.__repo.start("removeBinds"), i = (_a2 = this.shape.varbinds) == null ? void 0 : _a2.get(t4);
            if (!i) throw new Error("Invalid Override");
            e.shapeUnbinVar(this.__page, this.shape, t4);
            const s = Uf(this.shape);
            if (!s) return void this.__repo.commit();
            Yf(s, i, t4).length || e.shapeRemoveVariable(this.__page, s, i), this.__repo.commit();
        } catch (t5) {
            console.error("error from removeBinds:", t5), this.__repo.rollback();
        }
    }
    bindVar(t4, e) {
        const i = this.__shape;
        if (!i.varsContainer) throw new Error();
        if (i.isVirtualShape) throw new Error();
        const s = this.__repo.start("bindVar");
        try {
            s.shapeBindVar(this.__page, this.shape, t4, e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
}
var Qg, tm;
!function(t4) {
    t4.RectLeft = "rect-left", t4.RectRight = "rect-right", t4.RectBottom = "rect-bottom", t4.RectTop = "rect-top", t4.RectLT = "rect-left-top", t4.RectRT = "rect-right-top", t4.RectRB = "rect-right-bottom", t4.RectLB = "rect-left-bottom", t4.RectLTR = "rect-left-top-rotate", t4.RectRTR = "rect-right-top-rotate", t4.RectRBR = "rect-right-bottom-rotate", t4.RectLBR = "rect-left-bottom-rotate", t4.LineStart = "line-start", t4.LineEnd = "line-end", t4.LineStartR = "line-start-rotate", t4.LineEndR = "line-end-rotate", t4.Text = "text";
}(Qg || (Qg = {})), function(t4) {
    t4.Pending = "pending", t4.Fulfilled = "fulfilled", t4.Exception = "exception";
}(tm || (tm = {}));
class em {
    constructor(t4, e) {
        __publicField(this, "__repo");
        __publicField(this, "__document");
        this.__repo = t4, this.__document = e;
    }
    create(t4, e, i, s) {
        switch (t4) {
            case Vt.Artboard:
                return Ed(e, i);
            case Vt.Rectangle:
                return Fd(e, i);
            case Vt.Oval:
                return Rd(e, i);
            case Vt.Line:
                return Pd(e, i);
            case Vt.Polygon:
                return Od(e, i);
            case Vt.Star:
                return Ld(e, i);
            case Vt.Text:
                return s ? Nd(e, s, i) : zd(e, i);
            default:
                return Fd(e, i);
        }
    }
    asyncCreator(e, i) {
        const s = e;
        let r, n2, a2 = tm.Pending;
        const h2 = this.__repo.start("createshape", (t4, e2, i2) => {
            var _a2;
            const s2 = {};
            s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : r ? [r.id] : [], t4.restore(s2);
        });
        return { init: (e2, s2, o2, c2, l2, d2) => {
                try {
                    n2 = e2, a2 = tm.Pending;
                    const p2 = this.create(o2, c2, l2, d2);
                    return p2.type !== Vt.Line && (p2.constrainerProportions = !!i), Zd(p2, s2), h2.shapeInsert(this.__document, e2, s2, p2, s2.childs.length), r = s2.childs[s2.childs.length - 1], r.type === Vt.Artboard && s2 instanceof qi && h2.addFillAt(e2, r, new es(new G(), v4(), true, xt.SolidColor, new Ji(0, 0, 0, 0)), 0), rg(h2, n2, r, l2.x, l2.y), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, init_media: (e2, i2, s2, o2, c2, l2) => {
                if (a2 = tm.Pending, this.__document) try {
                    n2 = e2;
                    const d2 = f(c2.base64), p2 = `${v4()}.${d2}`;
                    this.__document.mediasMgr.add(p2, c2);
                    const u = Dd(s2, o2, this.__document.mediasMgr, l2, p2), g2 = i2.frame2Root();
                    return u.transform.translateX -= g2.x, u.transform.translateY -= g2.y, h2.shapeInsert(this.__document, e2, i2, u, i2.childs.length), r = i2.childs.at(-1), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, init_text: (t4, e2, s2, n3, o2) => {
                if (a2 = tm.Pending, this.__document) try {
                    let c2 = n3;
                    n3.length > 19 && (c2 = c2.slice(0, 19) + "...");
                    const l2 = o2 ? Nd(c2, o2) : zd(c2);
                    l2.constrainerProportions = !!i, Zd(l2, e2), l2.text.insertText(n3, 0);
                    const d2 = l2.getLayout();
                    return l2.size.width = d2.contentWidth, l2.size.height = d2.contentHeight, h2.shapeInsert(this.__document, t4, e2, l2, e2.childs.length), r = e2.childs[e2.childs.length - 1], rg(h2, t4, r, s2.x, s2.y), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, init_arrow: (t4, e2, i2, s2) => {
                try {
                    n2 = t4, a2 = tm.Pending;
                    const o2 = Bd(i2, s2);
                    return Zd(o2, e2), h2.shapeInsert(this.__document, t4, e2, o2, e2.childs.length), r = e2.childs[e2.childs.length - 1], rg(h2, n2, r, s2.x, s2.y), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, init_contact: (t4, e2, i2, s2, o2) => {
                try {
                    n2 = t4, a2 = tm.Pending;
                    const c2 = Wd(s2, i2, o2), l2 = e2.frame2Root();
                    return c2.transform.translateX -= l2.x, c2.transform.translateY -= l2.y, h2.shapeInsert(this.__document, t4, e2, c2, e2.childs.length), r = e2.childs.at(-1), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, setFrame: (t4) => {
                if (r && n2) {
                    a2 = tm.Pending;
                    try {
                        r.type === Vt.Line ? Zc(h2, n2, r, 1, t4) : function(t5, e2, i2, s2, r2, n3, a3) {
                            const h3 = s2.parent;
                            if (!h3) return;
                            const c2 = s2.frame, l2 = h3.matrix2Root(), d2 = s2.matrix2Parent(), p2 = l2.inverseCoord(r2, n3);
                            let u = 0, f2 = 0;
                            const g2 = d2.inverseCoord(p2.x, p2.y);
                            let m2 = g2.x, _2 = c2.height - g2.y;
                            const y2 = d2.computeCoord(0, 0), x2 = d2;
                            _2 = -(x2.m00 * (y2.y - p2.y) - x2.m10 * (y2.x - p2.x)) / (x2.m00 * x2.m11 - x2.m10 * x2.m01), m2 < 0 && (m2 = -m2), _2 < 0 && (_2 = -_2), m2 < ig && (m2 = ig), _2 < ig && (_2 = ig);
                            const w2 = m2 / 2, b2 = _2 / 2, M2 = new o();
                            M2.trans(-w2, -b2), s2.rotation && M2.rotate(s2.rotation / 180 * Math.PI), M2.trans(w2, b2), M2.trans(c2.x, c2.y);
                            const v2 = M2.computeCoord(m2, _2);
                            u = p2.x - v2.x, f2 = p2.y - v2.y, t5.shapeModifyX(i2, s2, s2.transform.translateX + u), t5.shapeModifyY(i2, s2, s2.transform.translateY + f2), sg(i2, s2, m2, _2, t5), hg(t5, e2, i2, s2);
                        }(h2, this.__document, n2, r, t4.x, t4.y), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                    } catch (t5) {
                        console.error(t5), a2 = tm.Exception;
                    }
                }
            }, setFrameByWheel: (t4) => {
                if (r && n2) try {
                    a2 = tm.Pending;
                    const { x: e2, y: i2 } = s, { x: o2, y: c2 } = t4, l2 = { x: Math.min(e2, o2), y: Math.min(i2, c2) }, d2 = { x: Math.max(e2, o2), y: Math.max(i2, c2) }, p2 = d2.y - l2.y, u = d2.x - l2.x;
                    og(h2, this.__document, n2, r, u, p2), rg(h2, n2, r, l2.x, l2.y), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, collect: (t4, e2, i2) => {
                t4 = t4 instanceof Ac ? t4.data : t4, a2 = tm.Pending;
                try {
                    if (e2.length) {
                        for (let s3 = 0; s3 < e2.length; s3++) {
                            const r3 = e2[s3], n4 = r3.parent, o2 = n4.indexOfChild(r3);
                            h2.shapeMove(t4, n4, o2, i2, 0), n4.childs.length <= 0 && im(this.__document, t4, r3, h2);
                        }
                        const s2 = e2.map((t5) => t5.frame2Root()), r2 = i2.frame, n3 = e2[0].parent, a3 = new o(n3.matrix2Root().inverse);
                        for (let i3 = 0; i3 < e2.length; i3++) {
                            const n4 = e2[i3], o2 = s2[i3], c2 = a3.computeCoord(o2.x, o2.y), l2 = n4.matrix2Parent().computeCoord(0, 0);
                            h2.shapeModifyX(t4, n4, n4.frame.x + c2.x - l2.x - r2.x), h2.shapeModifyY(t4, n4, n4.frame.y + c2.y - l2.y - r2.y);
                        }
                    }
                    this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, init_table: (t4, e2, i2, s2, o2, c2) => {
                try {
                    n2 = t4, a2 = tm.Pending;
                    const l2 = Hd(i2, s2, o2, c2, this.__document.mediasMgr), d2 = e2.frame2Root();
                    return l2.transform.translateX -= d2.x, l2.transform.translateY -= d2.y, h2.shapeInsert(this.__document, t4, e2, l2, e2.childs.length), r = e2.childs.at(-1), (r == null ? void 0 : r.type) === Vt.Artboard && h2.setFillColor(t4, r, 0, new Ji(0, 0, 0, 0)), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, contact_to: (t4, e2) => {
                if (r && n2) try {
                    a2 = tm.Pending, Zc(h2, n2, r, 1, t4), h2.shapeModifyContactTo(n2, r, e2), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, migrate: (t4) => {
                if (r && n2) try {
                    a2 = tm.Pending;
                    const e2 = r.parent, { x: i2, y: s2 } = r.frame2Root();
                    let o2 = t4.childs.length;
                    e2.id === t4.id && --o2, h2.shapeMove(n2, e2, e2.indexOfChild(r), t4, o2), rg(h2, n2, r, i2, s2), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, close: () => {
                var _a2, _b;
                if (a2 == tm.Fulfilled && r && this.__repo.isNeedCommit()) try {
                    if (r.type === Vt.Artboard && r.parent instanceof qi && h2.setFillColor(n2, r, 0, new Ji(1, 255, 255, 255)), r.type === Vt.Contact) {
                        if (r.from) {
                            const e2 = n2 == null ? void 0 : n2.getShape(r.from.shapeId);
                            e2 && h2.addContactAt(n2, e2, new Se(new G(), v4(), dt.From, r.id), ((_a2 = e2.style.contacts) == null ? void 0 : _a2.length) || 0);
                        }
                        if (r.to) {
                            const e2 = n2 == null ? void 0 : n2.getShape(r.to.shapeId);
                            e2 && h2.addContactAt(n2, e2, new Se(new G(), v4(), dt.To, r.id), ((_b = e2.style.contacts) == null ? void 0 : _b.length) || 0);
                        }
                    }
                    r.type === Vt.Line && n2 && Kc(h2, n2, r), this.__repo.commit();
                } catch (t4) {
                    console.error(t4), this.__repo.rollback();
                }
                else this.__repo.rollback();
            }, init_cutout: (t4, e2, s2, o2) => {
                try {
                    n2 = t4, a2 = tm.Pending;
                    const c2 = $d(s2, o2);
                    return c2.constrainerProportions = !!i, Zd(c2, e2), h2.shapeInsert(this.__document, t4, e2, c2, e2.childs.length), r = e2.childs[e2.childs.length - 1], rg(h2, t4, r, o2.x, o2.y), r && h2.setFillColor(t4, r, 0, new Ji(0, 0, 0, 0)), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled, r;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            } };
    }
    asyncTransfer(t4, e) {
        const i = e instanceof Ac ? $c(e) : e;
        let s = t4[0] instanceof Vh ? t4.map((t5) => $c(t5)) : t4, r = /* @__PURE__ */ new Map(), n2 = [], o2 = "";
        const a2 = this.__repo.start("transfer");
        let h2 = tm.Pending;
        const c2 = (t5) => {
            o2 = t5.id;
        };
        return { migrate: (t5, e2, s2) => {
                try {
                    if (t5.id === o2) return;
                    h2 = tm.Pending;
                    const r2 = rm(t5);
                    let n3 = t5.childs.length;
                    for (let o3 = 0, h3 = e2.length; o3 < h3; o3++) sm(this.__document, a2, i, t5, e2[o3], s2, n3, r2), n3++;
                    c2(t5), this.__repo.transactCtx.fireNotify(), h2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), h2 = tm.Exception;
                }
            }, trans: (t5, e2) => {
                h2 = tm.Pending;
                try {
                    for (let r2 = 0; r2 < s.length; r2++) ng(a2, i, s[r2], e2.x - t5.x, e2.y - t5.y);
                    this.__repo.transactCtx.fireNotify(), h2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), h2 = tm.Exception;
                }
            }, stick: (t5, e2) => {
                h2 = tm.Pending;
                try {
                    for (let r2 = 0; r2 < s.length; r2++) ng(a2, i, s[r2], t5, e2);
                    this.__repo.transactCtx.fireNotify(), h2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), h2 = tm.Exception;
                }
            }, transByWheel: (t5, e2) => {
                h2 = tm.Pending;
                try {
                    for (let r2 = 0; r2 < s.length; r2++) ng(a2, i, s[r2], t5, e2);
                    this.__repo.transactCtx.fireNotify(), h2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), h2 = tm.Exception;
                }
            }, shortPaste: (t5, e2) => {
                try {
                    h2 = tm.Pending;
                    const r2 = [];
                    for (let s2 = 0, n3 = e2.length; s2 < n3; s2++) {
                        const n4 = t5[s2], { parent: o3, index: h3 } = e2[s2];
                        a2.shapeInsert(this.__document, i, o3, n4, h3), r2.push(o3.childs[h3]);
                    }
                    return this.__repo.transactCtx.fireNotify(), h2 = tm.Fulfilled, s = r2, r2;
                } catch (t6) {
                    return console.log(t6), h2 = tm.Exception, false;
                }
            }, setEnvs: (t5) => {
                r = t5;
            }, getEnvs: () => r, setExceptEnvs: (t5) => {
                n2 = t5;
            }, getExceptEnvs: () => n2, backToStartEnv: (t5, e2) => {
                try {
                    if (t5.id === o2) return;
                    h2 = tm.Pending, r.forEach((t6, s2) => {
                        const r2 = i.getShape(s2);
                        if (!r2) return;
                        const n3 = rm(r2);
                        for (let s3 = 0, o3 = t6.length; s3 < o3; s3++) {
                            const o4 = t6[s3];
                            sm(this.__document, a2, i, r2, $c(o4.shape), e2, o4.index, n3);
                        }
                    }), this.__repo.transactCtx.fireNotify(), c2(t5), h2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), h2 = tm.Exception;
                }
            }, setCurrentEnv: c2, abort: () => {
                this.__repo.rollback();
            }, close: () => {
                h2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncPathEditor(e, i) {
        const s = e instanceof Vh ? $c(e) : e, r = i instanceof Ac ? $c(i) : i, n2 = this.__repo.start("asyncPathEditor");
        let a2 = tm.Pending;
        const h2 = s.size.width, c2 = s.size.height;
        let l2 = new o(s.matrix2Root());
        l2.preScale(h2, c2), l2 = new o(l2.inverse);
        return { addNode: (e2) => {
                tm.Pending;
                try {
                    const i2 = new se(new G(), v4(), 0, 0, ft.Straight);
                    n2.addPointAt(r, s, e2, i2, 0), ol(r, n2, s, e2, 0), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, execute: (t4, e2) => {
                tm.Pending;
                try {
                    Zc(n2, r, s, t4, e2, l2), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, execute2: (t4, e2, i2) => {
                tm.Pending;
                try {
                    const o2 = s.pathsegs;
                    t4.forEach((t5, a3) => {
                        const h3 = o2[a3].points;
                        (h3 == null ? void 0 : h3.length) && function(t6, e3, i3, s2, r2, n3, o3, a4 = -1) {
                            for (let h4 = 0, c3 = r2.length; h4 < c3; h4++) {
                                const c4 = r2[h4], l3 = s2[c4];
                                l3 && (t6.shapeModifyCurvPoint(e3, i3, c4, { x: l3.x + n3, y: l3.y + o3 }, a4), l3.hasFrom && t6.shapeModifyCurvFromPoint(e3, i3, c4, { x: (l3.fromX || 0) + n3, y: (l3.fromY || 0) + o3 }, a4), l3.hasTo && t6.shapeModifyCurvToPoint(e3, i3, c4, { x: (l3.toX || 0) + n3, y: (l3.toY || 0) + o3 }, a4));
                            }
                        }(n2, r, s, h3, t5, e2, i2, a3);
                    }), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, close: () => {
                a2 = tm.Pending;
                try {
                    Kc(n2, r, s), a2 = tm.Fulfilled;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
                a2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            }, abort: () => {
                this.__repo.rollback();
            } };
    }
    asyncContactEditor(e, i) {
        const s = e instanceof Vh ? $c(e) : e, r = i instanceof Ac ? $c(i) : i, n2 = this.__repo.start("action");
        let a2 = tm.Pending;
        return { pre: () => {
                try {
                    a2 = tm.Pending;
                    const e2 = s.getPoints();
                    if (0 === e2.length) throw new Error("none point");
                    const i2 = [e2[0], e2[e2.length - 1]];
                    for (let e3 = 0, s2 = i2.length; e3 < s2; e3++) {
                        const s3 = un(i2[e3]);
                        s3.id = v4(), i2[e3] = s3;
                    }
                    const o2 = s.points.length;
                    n2.deletePoints(r, s, 0, o2, 0), n2.contactModifyEditState(r, s, false), n2.addPoints(r, s, i2, 0), a2 = tm.Fulfilled;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, modify_contact_from: (e2, i2) => {
                var _a2, _b, _c2;
                a2 = tm.Pending;
                try {
                    if (i2) {
                        if (!s.from) {
                            n2.shapeModifyContactFrom(r, s, i2.apex);
                            const e3 = r.getShape(i2.apex.shapeId);
                            e3 && n2.addContactAt(r, e3, new Se(new G(), v4(), dt.From, s.id), ((_a2 = e3.style.contacts) == null ? void 0 : _a2.length) || 0);
                        }
                        Zc(n2, r, s, 0, i2.p);
                    } else {
                        if (s.from) {
                            const t4 = r.getShape(s.from.shapeId), e3 = (_c2 = (_b = t4 == null ? void 0 : t4.style) == null ? void 0 : _b.contacts) == null ? void 0 : _c2.findIndex((t5) => t5.shapeId === s.id);
                            t4 && void 0 !== e3 && e3 > -1 && n2.removeContactRoleAt(r, t4, e3), n2.shapeModifyContactFrom(r, s, void 0);
                        }
                        Zc(n2, r, s, 0, e2);
                    }
                    this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, modify_contact_to: (e2, i2) => {
                var _a2, _b, _c2, _d2;
                a2 = tm.Pending;
                try {
                    const o2 = (_a2 = s.points) == null ? void 0 : _a2.length;
                    if (!o2) return false;
                    if (i2) {
                        if (!s.to) {
                            n2.shapeModifyContactTo(r, s, i2.apex);
                            const e3 = r.getShape(i2.apex.shapeId);
                            e3 && n2.addContactAt(r, e3, new Se(new G(), v4(), dt.To, s.id), ((_b = e3.style.contacts) == null ? void 0 : _b.length) || 0);
                        }
                        Zc(n2, r, s, o2 - 1, i2.p);
                    } else {
                        if (s.to) {
                            const t4 = r.getShape(s.to.shapeId), e3 = (_d2 = (_c2 = t4 == null ? void 0 : t4.style) == null ? void 0 : _c2.contacts) == null ? void 0 : _d2.findIndex((t5) => t5.shapeId === s.id);
                            t4 && void 0 !== e3 && e3 > -1 && n2.removeContactRoleAt(r, t4, e3), n2.shapeModifyContactTo(r, s, void 0);
                        }
                        Zc(n2, r, s, o2 - 1, e2);
                    }
                    this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t4) {
                    console.error(t4), a2 = tm.Exception;
                }
            }, before: (t4) => {
                try {
                    tm.Pending, Jc(n2, r, s, t4), tm.Fulfilled;
                } catch (t5) {
                    console.log(t5);
                }
            }, modify_sides: (t4, e2, i2) => {
                try {
                    a2 = tm.Pending, function(t5, e3, i3, s2, r2, n3, a3) {
                        const h2 = new o(i3.matrix2Root()), c2 = i3.size.width, l2 = i3.size.height;
                        h2.preScale(c2, l2);
                        const d2 = new o(h2.inverse);
                        let p2 = i3.points[s2], u = i3.points[r2];
                        if (!p2 || !u) return false;
                        p2 = h2.computeCoord2(p2.x, p2.y), u = h2.computeCoord2(u.x, u.y), n3 && (p2.x = p2.x + n3, u.x = u.x + n3), a3 && (p2.y = p2.y + a3, u.y = u.y + a3), p2 = d2.computeCoord3(p2), u = d2.computeCoord3(u), t5.shapeModifyCurvPoint(e3, i3, s2, p2, 0), t5.shapeModifyCurvPoint(e3, i3, r2, u, 0);
                    }(n2, r, s, t4, t4 + 1, e2, i2), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, migrate: (t4) => {
                a2 = tm.Pending;
                try {
                    const e2 = s.parent, { x: i2, y: o2 } = s.frame2Root();
                    n2.shapeMove(r, e2, e2.indexOfChild(s), t4, t4.childs.length), rg(n2, r, s, i2, o2), this.__repo.transactCtx.fireNotify(), a2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), a2 = tm.Exception;
                }
            }, close: () => {
                a2 === tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncBorderThickness(t4, e) {
        const i = t4, s = e instanceof Ac ? $c(e) : e, r = this.__repo.start("asyncBorderThickness");
        let n2 = tm.Pending;
        return { execute: (t5, e2) => {
                n2 = tm.Pending;
                try {
                    for (let n3 = 0, o2 = i.length; n3 < o2; n3++) {
                        const o3 = Rg(r, s, i[n3]), a2 = i[n3].getBorders()[e2].sideSetting.sideType;
                        switch (a2) {
                            case Dt.Normal:
                                r.setBorderSide(s, o3, e2, new Me(a2, t5, t5, t5, t5));
                                break;
                            case Dt.Top:
                                r.setBorderThicknessTop(s, o3, e2, t5);
                                break;
                            case Dt.Right:
                                r.setBorderThicknessRight(s, o3, e2, t5);
                                break;
                            case Dt.Bottom:
                                r.setBorderThicknessBottom(s, o3, e2, t5);
                                break;
                            case Dt.Left:
                                r.setBorderThicknessLeft(s, o3, e2, t5);
                                break;
                            default:
                                r.setBorderSide(s, o3, e2, new Me(a2, t5, t5, t5, t5));
                        }
                    }
                    this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, close: () => {
                n2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncBorderSideThickness(t4, e, i) {
        const s = t4, r = e instanceof Ac ? $c(e) : e, n2 = this.__repo.start("asyncBorderSideThickness");
        let o2 = tm.Pending;
        return { execute: (t5, e2) => {
                o2 = tm.Pending;
                try {
                    for (let o3 = 0, a2 = s.length; o3 < a2; o3++) {
                        const a3 = Rg(n2, r, s[o3]);
                        switch (i) {
                            case Dt.Top:
                                n2.setBorderThicknessTop(r, a3, e2, t5);
                                break;
                            case Dt.Right:
                                n2.setBorderThicknessRight(r, a3, e2, t5);
                                break;
                            case Dt.Bottom:
                                n2.setBorderThicknessBottom(r, a3, e2, t5);
                                break;
                            case Dt.Left:
                                n2.setBorderThicknessLeft(r, a3, e2, t5);
                        }
                    }
                    this.__repo.transactCtx.fireNotify(), o2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), o2 = tm.Exception;
                }
            }, close: () => {
                o2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncOpacityEditor(t4, e) {
        const i = t4, s = e instanceof Ac ? $c(e) : e, r = this.__repo.start("asyncOpacityEditor");
        let n2 = tm.Pending;
        return { execute: (t5) => {
                n2 = tm.Pending;
                try {
                    for (let e2 = 0, n3 = i.length; e2 < n3; e2++) {
                        const n4 = Ig(r, i[e2], s);
                        r.shapeModifyContextSettingsOpacity(s, n4, t5);
                    }
                    this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, close: () => {
                n2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncGradientEditor(t4, e, i, s) {
        const r = e instanceof Ac ? $c(e) : e, n2 = this.__repo.start("asyncGradientEditor");
        let o2 = tm.Pending;
        return { execute_from: (e2) => {
                o2 = tm.Pending;
                try {
                    for (let o3 = 0, a2 = t4.length; o3 < a2; o3++) {
                        const a3 = t4[o3], h2 = "fills" === s ? a3.getFills() : a3.getBorders();
                        if (!(h2 == null ? void 0 : h2.length)) continue;
                        const c2 = h2[i].gradient;
                        if (!c2) return;
                        const l2 = Hn(qs(c2));
                        l2.from.x = e2.x, l2.from.y = e2.y;
                        const d2 = "fills" === s ? n2.setFillGradient.bind(n2) : n2.setBorderGradient.bind(n2), p2 = Og(n2, r, a3);
                        d2(r, p2, i, l2);
                    }
                    this.__repo.transactCtx.fireNotify(), o2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), o2 = tm.Exception;
                }
            }, execute_to: (e2) => {
                o2 = tm.Pending;
                try {
                    for (let o3 = 0, a2 = t4.length; o3 < a2; o3++) {
                        const a3 = t4[o3], h2 = "fills" === s ? a3.getFills() : a3.getBorders();
                        if (!(h2 == null ? void 0 : h2.length)) continue;
                        const c2 = h2[i].gradient;
                        if (!c2) return;
                        const l2 = Hn(qs(c2));
                        l2.to.x = e2.x, l2.to.y = e2.y;
                        const d2 = "fills" === s ? n2.setFillGradient.bind(n2) : n2.setBorderGradient.bind(n2), p2 = Og(n2, r, a3);
                        d2(r, p2, i, l2);
                    }
                    this.__repo.transactCtx.fireNotify(), o2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), o2 = tm.Exception;
                }
            }, execute_elipselength: (e2) => {
                o2 = tm.Pending;
                try {
                    for (let o3 = 0, a2 = t4.length; o3 < a2; o3++) {
                        const a3 = t4[o3], h2 = "fills" === s ? a3.getFills() : a3.getBorders();
                        if (!(h2 == null ? void 0 : h2.length)) continue;
                        const c2 = h2[i].gradient;
                        if (!c2) return;
                        const l2 = Hn(qs(c2));
                        l2.elipseLength = e2;
                        const d2 = "fills" === s ? n2.setFillGradient.bind(n2) : n2.setBorderGradient.bind(n2), p2 = Og(n2, r, a3);
                        d2(r, p2, i, l2);
                    }
                    this.__repo.transactCtx.fireNotify(), o2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), o2 = tm.Exception;
                }
            }, execute_stop_position: (e2, a2) => {
                var _a2;
                o2 = tm.Pending;
                try {
                    const h2 = "fills" === s ? t4[0].getFills() : t4[0].getBorders(), c2 = (_a2 = h2[i].gradient) == null ? void 0 : _a2.stops;
                    if (c2) {
                        const o3 = c2.findIndex((t5) => t5.id === a2);
                        for (let h3 = 0, c3 = t4.length; h3 < c3; h3++) {
                            const c4 = t4[h3], l2 = "fills" === s ? c4.getFills() : c4.getBorders();
                            if (!(l2 == null ? void 0 : l2.length)) continue;
                            const d2 = l2[i].gradient;
                            if (!d2) return;
                            const p2 = Hn(qs(d2));
                            if (-1 === o3) {
                                console.warn(`gradient stop not found: ${a2}`);
                                continue;
                            }
                            p2.stops[o3].position = e2;
                            p2.stops.sort((t5, e3) => t5.position > e3.position ? 1 : t5.position < e3.position ? -1 : 0);
                            const u = "fills" === s ? n2.setFillGradient.bind(n2) : n2.setBorderGradient.bind(n2), f2 = Og(n2, r, c4);
                            u(r, f2, i, p2);
                        }
                    }
                    this.__repo.transactCtx.fireNotify(), o2 = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), o2 = tm.Exception;
                }
            }, close: () => {
                o2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
}
function im(t4, e, i, s) {
    const r = i.parent;
    return !!r && (s.shapeDelete(t4, e, r, r.indexOfChild(i)), r.childs.length <= 0 && im(t4, e, r, s), true);
}
function sm(t4, e, i, s, r, n2, o2, a2) {
    const h2 = Vg(s, r);
    if (h2) return void console.log("migrate error:", h2);
    const c2 = r.parent;
    if (c2.id === s.id) return;
    if (Gf(r)) {
        const t5 = zg(r, n2);
        e.shapeModifyName(i, r, `${c2.name}/${t5}`);
    }
    r.parent;
    const l2 = r.matrix2Root(), { x: d2, y: p2 } = l2.computeCoord(0, 0);
    e.shapeMove(i, c2, c2.indexOfChild(r), s, o2++), false !== a2.ohflip && e.shapeModifyHFlip(i, r), false !== a2.ovflip && e.shapeModifyVFlip(i, r), l2.multiAtLeft(a2.pminverse);
    let u = l2.m10, f2 = l2.m00, g2 = Math.asin(u);
    f2 < 0 && (g2 = u > 0 ? Math.PI - g2 : u < 0 ? -Math.PI - g2 : Math.PI), Number.isNaN(g2) && console.log("rotate is NaN", g2), rg(e, i, r, d2, p2), Dg(t4, i, e, c2);
}
function rm(t4) {
    return { ohflip: false, ovflip: false, pminverse: t4.matrix2Root().inverse };
}
class nm extends qg {
    constructor(t4, e, i, s) {
        super(t4, e, i, s);
        __publicField(this, "_cacheAttr");
        __publicField(this, "__composingEnding");
        __publicField(this, "__composingStarted", false);
        __publicField(this, "__composingIndex", 0);
        __publicField(this, "__composingDel", 0);
        __publicField(this, "__composingAttr");
        __publicField(this, "__composdelSpan");
        __publicField(this, "__composdelpara");
        __publicField(this, "__composingApi");
        __publicField(this, "__preInputText");
    }
    get cacheAttr() {
        return void 0 === this._cacheAttr && (this._cacheAttr = new ba()), this._cacheAttr;
    }
    get shape() {
        return $c(this.__shape);
    }
    resetCachedSpanAttr() {
        this._cacheAttr = void 0;
    }
    getCachedSpanAttr() {
        return this._cacheAttr;
    }
    insertText(t4, e, i) {
        return this.insertText2(t4, e, 0, i);
    }
    fixFrameByLayout(t4) {
        this.shape.isVirtualShape || (this.view instanceof Ic ? Df(t4, this.__page, this.view) : this.view instanceof Cc && Hf(t4, this.__page, this.view, this.view.parent));
    }
    fixFrameByLayout2(t4, e) {
        e instanceof Ri || e.isVirtualShape || (e instanceof Ic ? Df(t4, this.__page, e) : e instanceof Cc && Hf(t4, this.__page, e, this.view.parent));
    }
    shape4edit(e, i) {
        const s = i ?? this.__shape;
        if (s instanceof Cc) {
            const t4 = function(t5, e2, i3, s2) {
                const r = e2.indexOfCell(i3);
                if (!r) throw new Error();
                const { rowIdx: n2, colIdx: o2 } = r, a2 = i3.data.id, h2 = e2.data.id + "/" + a2, c2 = Tg(t5, jt.TableCell, Et.TableCell, h2, (t6) => {
                    const s3 = (t6 == null ? void 0 : t6.value) ?? i3.data;
                    if (s3) return oo(s3);
                    new ye();
                    const r2 = new Ii();
                    return new ka(new G(), a2, "", Vt.TableCell, r2, new is(new G(), new G(), new G()), Wt.Text, ia(e2.data.textAttr));
                }, s2, e2);
                if (c2) return c2;
                s2.tableInitCell(t5, e2.data, n2, o2);
            }(this.__page, s.parent, s, e);
            let i2;
            if (t4) i2 = t4.value;
            else {
                if (i2 = s.parent.data.cells.get(s.data.id), !i2) throw new Error();
            }
            return this.__repo.updateTextSelectionPath(i2.text), (t4 || i2 !== s.data) && s.setData(i2), s;
        }
        {
            let r = this.overrideVariable(jt.Text, Et.Text, (t4) => {
                if (!t4) return ro(s.text);
                if (t4.value instanceof Ia) return ro(t4.value);
                if ("string" == typeof t4.value) return ro(s.text);
                throw new Error();
            }, e, i);
            if (r && "string" == typeof r.value) {
                const i2 = wg(r), n2 = new Ri(v4(), jt.Text, r.name, ro(s.text));
                if (i2 instanceof Ni) {
                    e.shapeRemoveVariable(this.__page, i2, r.id), e.shapeAddVariable(this.__page, i2, n2);
                    const t4 = r.id, s2 = (i3) => {
                        var _a2;
                        ((_a2 = i3.varbinds) == null ? void 0 : _a2.get(Et.Text)) === t4 && (e.shapeUnbinVar(this.__page, i3, Et.Text), e.shapeBindVar(this.__page, i3, Et.Text, n2.id)), i3 instanceof Li && i3.childs.forEach((t5) => s2(t5));
                    };
                    s2(i2);
                } else {
                    let t4;
                    for (let [e2, s2] of i2.overrides) if (s2 === r.id) {
                        t4 = e2;
                        break;
                    }
                    if (!t4) throw new Error();
                    e.shapeRemoveOverride(this.__page, i2, t4), e.shapeRemoveVariable(this.__page, i2, r.id), e.shapeAddVariable(this.__page, i2, n2), e.shapeAddOverride(this.__page, i2, t4, n2.id);
                }
                r = n2;
            }
            return r ? (this.__repo.updateTextSelectionPath(r.value), r) : s;
        }
    }
    deleteText(t4, e) {
        if (t4 < 0 && (e += t4, t4 = 0), e <= 0) return 0;
        const i = this.__repo.start("deleteText");
        try {
            const s = this.shape4edit(i);
            return i.deleteText(this.__page, s, t4, e), e <= 0 ? (this.__repo.rollback(), 0) : (this.fixFrameByLayout(i), this.updateName(i), this.__repo.commit(Np.TextDelete), e);
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return 0;
    }
    updateName(t4) {
        const e = this.shape;
        if (e.nameIsFixed || e.isVirtualShape) return;
        const i = e.text.getText(0, 1 / 0), s = i.indexOf("\n");
        t4.shapeModifyName(this.__page, e, i.slice(0, s));
    }
    insertText2(t4, e, i, s) {
        var _a2, _b;
        if (0 === t4.length && 0 === i) return 0;
        s = s ?? this._cacheAttr, this.resetCachedSpanAttr();
        let r = t4.length;
        const n2 = this.__repo.start("insertText");
        try {
            const r2 = this.shape4edit(n2);
            if (this.__repo.updateTextSelectionRange(e, i), i > 0 && 0 === t4.length) n2.deleteText(this.__page, r2, e, i);
            else if (i > 0) {
                const o2 = r2 instanceof Ri ? r2.value : r2.text, a2 = o2.spanAt(e + i - 1), h2 = o2.paraAt(e), c2 = new Ia(new G()), l2 = new Ta(t4, new G());
                (h2 == null ? void 0 : h2.para) && Ko(l2, h2.para), c2.paras.push(l2);
                const d2 = new Ca(l2.length);
                a2 && jo(d2, a2), s && jo(d2, s), l2.spans.push(d2), n2.deleteText(this.__page, r2, e, i), n2.insertComplexText(this.__page, r2, e, c2);
            } else n2.insertSimpleText(this.__page, r2, e, t4, s);
            this.fixFrameByLayout(n2), this.updateName(n2), this.__repo.commit(Np.TextInsert);
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), 0;
        }
        if (" " === t4) {
            const t5 = this.shape.text.paraAt(e);
            if (t5 && 1 === t5.index && "*" === t5.para.text.at(0)) {
                const i2 = t5.para.spans[0];
                if (!i2 || !i2.placeholder) {
                    const t6 = this.__repo.start("auto bullet");
                    try {
                        const i3 = this.shape4edit(t6);
                        t6.deleteText(this.__page, i3, e - 1, 2), t6.textModifyBulletNumbers(this.__page, i3, lt.Disorded, e - 1, 0), this.fixFrameByLayout(t6), this.__repo.commit(), r = 0;
                    } catch (t7) {
                        return console.log(t7), this.__repo.rollback(), r;
                    }
                }
            } else if (t5 && t5.index >= 1 && "." === t5.para.text.at(t5.index - 1)) {
                const i2 = t5.para.text.slice(0, t5.index - 1), s2 = parseInt(i2);
                if ("" + s2 === i2) {
                    const n3 = this.__repo.start("auto number");
                    try {
                        const o2 = this.shape4edit(n3);
                        if (e - t5.index !== e - i2.length - 1) throw new Error("wrong??");
                        n3.deleteText(this.__page, o2, e - i2.length - 1, i2.length + 2), n3.textModifyBulletNumbers(this.__page, o2, lt.Ordered1Ai, e - i2.length - 1, 0);
                        const a2 = this.shape.text.paras, h2 = t5.paraIndex, c2 = ((_a2 = t5.para.attr) == null ? void 0 : _a2.indent) || 0;
                        let l2 = 0;
                        for (let t6 = h2 - 1; t6 >= 0; t6--) {
                            const e2 = a2[t6];
                            if ("*" === e2.text.at(0) && e2.spans.length > 0 && e2.spans[0].placeholder && e2.spans[0].bulletNumbers && 1 === e2.spans[0].length) {
                                const t7 = ((_b = e2.attr) == null ? void 0 : _b.indent) || 0;
                                if (t7 < c2) break;
                                if (t7 > c2) continue;
                                const i3 = e2.spans[0].bulletNumbers;
                                if (i3.type === lt.None) continue;
                                if (i3.type !== lt.Ordered1Ai) break;
                                if (i3.behavior && i3.behavior !== ct.Inherit) {
                                    l2 += i3.offset || 0, l2++;
                                    break;
                                }
                                l2++;
                            }
                        }
                        if (s2 !== l2 + 1) {
                            const i3 = e - t5.index;
                            n3.textModifyBulletNumbersInherit(this.__page, o2, false, i3, 1), n3.textModifyBulletNumbersStart(this.__page, o2, s2 - 1, i3, 1);
                        }
                        this.fixFrameByLayout(n3), this.__repo.commit(), r = -i2.length;
                    } catch (t6) {
                        return console.log(t6), this.__repo.rollback(), r;
                    }
                }
            }
        }
        return r;
    }
    insertTextForNewLine(t4, e, i) {
        var _a2;
        i = i ?? this._cacheAttr, this.resetCachedSpanAttr();
        const s = this.__repo.start("insertTextForNewLine");
        try {
            const r = this.shape4edit(s);
            let n2 = 1;
            for (e > 0 && s.deleteText(this.__page, r, t4, e); ; ) {
                const e2 = this.shape.text.paraAt(t4);
                if (!e2) throw new Error("index wrong? not find para :" + t4);
                const o2 = e2.para.text, a2 = e2.para.spans[0];
                if ("\n" === o2 || "*\n" === o2 && 1 === e2.index) {
                    const i2 = ((_a2 = e2.para.attr) == null ? void 0 : _a2.indent) || 0;
                    if (i2 > 0) {
                        s.textModifyParaIndent(this.__page, r, i2 - 1, t4, o2.length), n2 = 0;
                        break;
                    }
                    if ("*\n" === o2 && a2.placeholder && 1 === a2.length && a2.bulletNumbers) {
                        s.textModifyBulletNumbers(this.__page, r, void 0, t4, 0), n2 = -1;
                        break;
                    }
                }
                s.insertSimpleText(this.__page, r, t4, "\n", i), i && i.bulletNumbers || !a2.placeholder || 1 !== a2.length || !a2.bulletNumbers || a2.bulletNumbers.type === lt.None || (s.textModifyBulletNumbers(this.__page, r, a2.bulletNumbers.type, t4, 2), n2++);
                break;
            }
            return this.fixFrameByLayout(s), this.__repo.commit(), n2;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return 0;
    }
    insertFormatText(t4, e, i) {
        if (0 === t4.length && 0 === i) return true;
        const s = this.__repo.start("insertText");
        try {
            const r = this.shape4edit(s);
            return i > 0 && s.deleteText(this.__page, r, e, i), s.insertComplexText(this.__page, r, e, t4), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    composingInputStart(t4, e, i) {
        this.__composingEnding && (clearTimeout(this.__composingEnding), this.__composingEnding = void 0), this.__preInputText = void 0, this.__composingStarted = true, this.__composingIndex = t4, this.__composingDel = e, this.__composingAttr = i;
        const s = this.__repo.start("composingInput");
        this.__composingApi = s;
        try {
            const i2 = this.shape4edit(s);
            if (e > 0) {
                const r = i2 instanceof Ri ? i2.value : i2.text, n2 = r.spanAt(t4 + e - 1), o2 = r.paraAt(t4);
                this.__composdelSpan = n2, this.__composdelpara = o2 == null ? void 0 : o2.para.attr, s.deleteText(this.__page, i2, t4, e), this.fixFrameByLayout(s);
            }
        } catch (t5) {
            console.error(t5);
        }
    }
    composingInputUpdate(t4) {
        const e = this.__composingApi;
        if (!e) throw new Error();
        try {
            const i = t4, s = this.shape4edit(e);
            let r = this.__composingIndex;
            if (this.__preInputText && this.__preInputText.length > 0) {
                const i2 = this.__preInputText.length, n2 = this.__preInputText, o2 = t4.length;
                let a2 = n2.length, h2 = r;
                o2 <= i2 ? n2.startsWith(t4) && (t4 = "", a2 = n2.length - o2, h2 += o2) : t4.startsWith(n2) && (t4 = t4.slice(i2), a2 = 0, r += i2), a2 > 0 && e.deleteText(this.__page, s, h2, a2), this.__preInputText = void 0;
            }
            if (this.__composingDel > 0 && t4.length > 0) {
                const i2 = this.__composingAttr, n2 = this.__composdelSpan, o2 = this.__composdelpara, a2 = new Ia(new G()), h2 = new Ta(t4, new G());
                o2 && Ko(h2, o2), a2.paras.push(h2);
                const c2 = new Ca(h2.length);
                n2 && jo(c2, n2), i2 && jo(c2, i2), h2.spans.push(c2), e.insertComplexText(this.__page, s, r, a2);
            } else t4.length > 0 && e.insertSimpleText(this.__page, s, r, t4, this.__composingAttr);
            return this.__preInputText = i, !this.view.isVirtualShape && this.view instanceof Ic && this.view.forceUpdateOriginFrame(), this.fixFrameByLayout(e), this.__repo.transactCtx.fireNotify(), true;
        } catch (t5) {
            return console.error(t5), false;
        }
    }
    composingInputEnd(t4) {
        return this.__repo.rollback("composingInput"), this.__composingEnding = setTimeout(() => {
            this.__composingStarted = false;
        }, 50), 0 === t4.length && 0 === this.__composingDel || (!this.view.isVirtualShape && this.view instanceof Ic && this.view.forceUpdateOriginFrame(), !!this.insertText2(t4, this.__composingIndex, this.__composingDel, this.__composingAttr));
    }
    isInComposingInput() {
        return this.__composingStarted;
    }
    setTextColor(t4, e, i) {
        if (0 === e) return void 0 === this._cacheAttr && (this._cacheAttr = new ba()), void (this._cacheAttr.color = i);
        const s = this.__repo.start("setTextColor");
        try {
            const r = this.shape4edit(s);
            return s.textModifyColor(this.__page, r, t4, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextColorMulti(t4, e) {
        const i = this.__repo.start("setTextColorMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyColor(this.__page, n2, 0, o2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHighlightColor(t4, e, i) {
        if (0 === e) return void (this.cacheAttr.highlight = i);
        const s = this.__repo.start("setTextHighlightColor");
        try {
            const r = this.shape4edit(s);
            return s.textModifyHighlightColor(this.__page, r, t4, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHighlightColorMulti(t4, e) {
        const i = this.__repo.start("setTextHighlightColorMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyHighlightColor(this.__page, n2, 0, o2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontName(t4, e, i) {
        if (0 === e) return void (this.cacheAttr.fontName = i);
        const s = this.__repo.start("setTextFontName");
        try {
            const r = this.shape4edit(s);
            return s.textModifyFontName(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontNameMulti(t4, e) {
        const i = this.__repo.start("setTextFontNameMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && (i.textModifyFontName(this.__page, n2, 0, o2, e), this.fixFrameByLayout2(i, n2));
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontSize(t4, e, i) {
        if ("number" != typeof i && (i = Number.parseFloat(i)), 0 === e) return void (this.cacheAttr.fontSize = i);
        const s = this.__repo.start("setTextFontSize");
        try {
            const r = this.shape4edit(s);
            return s.textModifyFontSize(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontSizeMulti(t4, e) {
        const i = this.__repo.start("setTextFontSizeMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyFontSize(this.__page, n2, 0, o2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBehaviour(t4) {
        const e = this.__repo.start("setTextBehaviour");
        try {
            const i = this.shape4edit(e), s = i instanceof Vh ? i.text : i.value;
            return e.shapeModifyTextBehaviour(this.__page, s, t4), this.fixFrameByLayout(e), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBehaviourMulti(t4, e) {
        const i = this.__repo.start("setTextBehaviourMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = n2 instanceof Vh ? n2.text : n2.value;
                0 !== o2.length && (i.shapeModifyTextBehaviour(this.__page, o2, e), this.fixFrameByLayout2(i, n2));
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextVerAlign(t4) {
        const e = this.__repo.start("setTextVerAlign");
        try {
            const i = this.shape4edit(e);
            return e.shapeModifyTextVerAlign(this.__page, i, t4), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextVerAlignMulti(t4, e) {
        const i = this.__repo.start("setTextVerAlignMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2);
                i.shapeModifyTextVerAlign(this.__page, n2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHorAlign(t4, e, i) {
        const s = this.__repo.start("setTextHorAlign");
        try {
            const r = this.shape4edit(s);
            return s.textModifyHorAlign(this.__page, r, t4, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHorAlignMulti(t4, e) {
        const i = this.__repo.start("setTextHorAlignMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                i.textModifyHorAlign(this.__page, n2, e, 0, o2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setMinLineHeight(t4, e, i) {
        const s = this.__repo.start("setMinLineHeight");
        try {
            const r = this.shape4edit(s);
            return s.textModifyMinLineHeight(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setMaxLineHeight(t4, e, i) {
        const s = this.__repo.start("setMaxLineHeight");
        try {
            const r = this.shape4edit(s);
            return s.textModifyMaxLineHeight(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setLineHeight(t4, e, i) {
        const s = this.__repo.start("setLineHeight");
        try {
            const r = this.shape4edit(s);
            return s.textModifyMinLineHeight(this.__page, r, t4, e, i), s.textModifyMaxLineHeight(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setLineHeightMulit(t4, e) {
        const i = this.__repo.start("setLineHeightMulit");
        try {
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                if (r.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                i.textModifyMinLineHeight(this.__page, n2, e, 0, o2), i.textModifyMaxLineHeight(this.__page, n2, e, 0, o2), this.fixFrameByLayout2(i, n2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setCharSpacing(t4, e, i) {
        if (0 === i) return void (this.cacheAttr.kerning = t4);
        const s = this.__repo.start("setCharSpace");
        try {
            const r = this.shape4edit(s);
            return s.textModifyKerning(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setCharSpacingMulit(t4, e) {
        const i = this.__repo.start("setCharSpacingMulit");
        try {
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                if (r.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                i.textModifyKerning(this.__page, n2, e, 0, o2), this.fixFrameByLayout2(i, n2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setParaSpacing(t4, e, i) {
        const s = this.__repo.start("setParaSpacing");
        try {
            const r = this.shape4edit(s);
            return s.textModifyParaSpacing(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setParaSpacingMulit(t4, e) {
        const i = this.__repo.start("setParaSpacingMulit");
        try {
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                if (r.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                i.textModifyParaSpacing(this.__page, n2, e, 0, o2), this.fixFrameByLayout2(i, n2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextUnderline(t4, e, i) {
        if (0 === i) return void (this.cacheAttr.underline = t4 ? Zt.Single : Zt.None);
        const s = this.__repo.start("setTextUnderline");
        try {
            const r = this.shape4edit(s);
            return s.textModifyUnderline(this.__page, r, t4 ? Zt.Single : Zt.None, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextUnderlineMulti(t4, e) {
        const i = this.__repo.start("setTextUnderlineMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyUnderline(this.__page, n2, e ? Zt.Single : Zt.None, 0, o2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextStrikethrough(t4, e, i) {
        if (0 === i) return void (this.cacheAttr.strikethrough = t4 ? Ht.Single : Ht.None);
        const s = this.__repo.start("setTextStrikethrough");
        try {
            const r = this.shape4edit(s);
            return s.textModifyStrikethrough(this.__page, r, t4 ? Ht.Single : Ht.None, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextStrikethroughMulti(t4, e) {
        const i = this.__repo.start("setTextStrikethroughMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyStrikethrough(this.__page, n2, e ? Ht.Single : Ht.None, 0, o2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFillType(t4, e, i) {
        if (0 === i) return void (this.cacheAttr.fillType = t4);
        const s = this.__repo.start("setTextFillType");
        try {
            const r = this.shape4edit(s);
            return s.textModifyFillType(this.__page, r, t4, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFillTypeMulti(t4, e) {
        const i = this.__repo.start("setTextFillTypeMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.textModifyFillType(this.__page, n2, e, 0, o2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextWeight(t4, e, i, s) {
        if (0 === s) return this.cacheAttr.weight = t4, void (this.cacheAttr.italic = e);
        const r = this.__repo.start("setTextWeight");
        try {
            const n2 = this.shape4edit(r);
            return r.textModifyWeight(this.__page, n2, t4, i, s), r.textModifyItalic(this.__page, n2, e, i, s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextWeightMulti(t4, e, i) {
        const s = this.__repo.start("setTextWeightMulti");
        try {
            for (let r = 0, n2 = t4.length; r < n2; r++) {
                const n3 = t4[r];
                if (n3.type !== Vt.Text) continue;
                const o2 = this.shape4edit(s, n3), a2 = (o2 instanceof Vh ? o2.text : o2.value).length;
                0 !== a2 && (s.textModifyWeight(this.__page, o2, e, 0, a2), s.textModifyItalic(this.__page, o2, i, 0, a2));
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBulletNumbers(t4, e, i) {
        const s = this.__repo.start("setTextBulletNumbers");
        try {
            const r = this.shape4edit(s);
            return s.textModifyBulletNumbers(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBulletNumbersMulti(t4, e) {
        const i = this.__repo.start("setTextBulletNumbersMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && (i.textModifyBulletNumbers(this.__page, n2, e, 0, o2), this.fixFrameByLayout2(i, n2));
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBulletNumbersStart(t4, e, i) {
        const s = this.__repo.start("setTextBulletNumbersStart");
        try {
            const r = this.shape4edit(s);
            return s.textModifyBulletNumbersStart(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextBulletNumbersInherit(t4, e, i) {
        const s = this.__repo.start("setTextBulletNumbersInherit");
        try {
            const r = this.shape4edit(s);
            return s.textModifyBulletNumbersInherit(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextTransform(t4, e, i) {
        if (0 === i && t4 !== Yt.UppercaseFirst) return void (this.cacheAttr.transform = t4);
        const s = this.__repo.start("setTextTransform");
        try {
            const r = this.shape4edit(s);
            return s.textModifyTransform(this.__page, r, t4, e, i), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextTransformMulti(t4, e) {
        const i = this.__repo.start("setTextTransformMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && (i.textModifyTransform(this.__page, n2, e, 0, o2), this.fixFrameByLayout2(i, n2));
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    offsetParaIndent(t4, e, i) {
        const s = this.__repo.start("offsetParaIndent");
        try {
            const r = this.shape4edit(s);
            return Yo((r instanceof Vh ? r.text : r.value).paras, e, i || 1, (i2, n2, o2, a2, h2) => {
                var _a2;
                e -= a2;
                const c2 = ((_a2 = o2.attr) == null ? void 0 : _a2.indent) || 0, l2 = Math.max(0, c2 + t4);
                c2 !== l2 && s.textModifyParaIndent(this.__page, r, l2 || void 0, e, o2.length), e += o2.length;
            }), this.fixFrameByLayout(s), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextGradient(t4, e, i) {
        if (0 === i) return void (this.cacheAttr.gradient = t4);
        const s = this.__repo.start("setTextGradient");
        try {
            const r = this.shape4edit(s);
            return s.setTextGradient(this.__page, r, t4, e, i), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextGradientMulti(t4, e) {
        const i = this.__repo.start("setTextGradientMulti");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Text) continue;
                const n2 = this.shape4edit(i, r2), o2 = (n2 instanceof Vh ? n2.text : n2.value).length;
                0 !== o2 && i.setTextGradient(this.__page, n2, e, 0, o2);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    asyncSetTextGradient(t4, e, i, s) {
        const r = this.__repo.start("asyncSetTextGradient");
        let n2 = tm.Pending;
        const o2 = (e2) => {
            if (1 === t4.length) {
                const t5 = Hn(e2);
                0 === s && (this.cacheAttr.gradient = t5);
                const n3 = this.shape4edit(r);
                r.setTextGradient(this.__page, n3, t5, i, s);
            } else if (t4.length > 1) for (let i2 = 0, s2 = t4.length; i2 < s2; i2++) {
                const s3 = Hn(e2), n3 = t4[i2];
                if (n3.type !== Vt.Text) continue;
                const o3 = this.shape4edit(r, n3), a2 = (o3 instanceof Vh ? o3.text : o3.value).length;
                0 !== a2 && r.setTextGradient(this.__page, o3, s3, 0, a2);
            }
        };
        return { execute_from: (t5) => {
                n2 = tm.Pending;
                try {
                    const i2 = Hn(e);
                    i2.from.x = t5.x, i2.from.y = t5.y, o2(i2), this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, execute_to: (t5) => {
                n2 = tm.Pending;
                try {
                    const i2 = Hn(e);
                    i2.to.x = t5.x, i2.to.y = t5.y, o2(i2), this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, execute_elipselength: (t5) => {
                n2 = tm.Pending;
                try {
                    const i2 = Hn(e);
                    i2.elipseLength = t5, o2(i2), this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, execute_stop_position: (t5, i2) => {
                n2 = tm.Pending;
                try {
                    const s2 = Hn(e), r2 = s2.stops.findIndex((t6) => t6.id === i2);
                    s2.stops[r2].position = t5;
                    s2.stops.sort((t6, e2) => t6.position > e2.position ? 1 : t6.position < e2.position ? -1 : 0), o2(s2), this.__repo.transactCtx.fireNotify(), n2 = tm.Fulfilled;
                } catch (t6) {
                    console.error(t6), n2 = tm.Exception;
                }
            }, close: () => {
                n2 == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    asyncSetTextAttr(t4, e, i) {
        const s = this.__repo.start("asyncSetTextAttr");
        let r = tm.Pending;
        return { execute_char_spacing: (n2) => {
                r = tm.Pending;
                try {
                    if (1 === t4.length) if (0 === i) this.cacheAttr.kerning = n2;
                    else {
                        const t5 = this.shape4edit(s);
                        s.textModifyKerning(this.__page, t5, n2, e, i), this.fixFrameByLayout(s);
                    }
                    else if (t4.length > 1) for (let e2 = 0, i2 = t4.length; e2 < i2; e2++) {
                        const i3 = t4[e2];
                        if (i3.type !== Vt.Text) continue;
                        const r2 = this.shape4edit(s, i3), o2 = (r2 instanceof Vh ? r2.text : r2.value).length;
                        0 !== o2 && (s.textModifyKerning(this.__page, r2, n2, 0, o2), this.fixFrameByLayout2(s, r2));
                    }
                    this.__repo.transactCtx.fireNotify(), r = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), r = tm.Exception;
                }
            }, execute_line_height: (n2) => {
                r = tm.Pending;
                try {
                    if (1 === t4.length) {
                        const t5 = this.shape4edit(s);
                        s.textModifyMinLineHeight(this.__page, t5, n2, e, i), s.textModifyMaxLineHeight(this.__page, t5, n2, e, i), this.fixFrameByLayout(s);
                    } else if (t4.length > 1) for (let e2 = 0, i2 = t4.length; e2 < i2; e2++) {
                        const i3 = t4[e2];
                        if (i3.type !== Vt.Text) continue;
                        const r2 = this.shape4edit(s, i3), o2 = (r2 instanceof Vh ? r2.text : r2.value).length;
                        0 !== o2 && (s.textModifyMinLineHeight(this.__page, r2, n2, 0, o2), s.textModifyMaxLineHeight(this.__page, r2, n2, 0, o2), this.fixFrameByLayout2(s, r2));
                    }
                    this.__repo.transactCtx.fireNotify(), r = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), r = tm.Exception;
                }
            }, close: () => {
                r == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
}
function om(t4, e, i) {
    e < t4.left ? t4.left = e : e > t4.right && (t4.right = e), i < t4.top ? t4.top = i : i > t4.bottom && (t4.bottom = i);
}
function am(t4, e, i, s) {
    const r = i.parent;
    return !!r && (s.shapeDelete(t4, e, r, r.indexOfChild(i)), r.childs.length <= 0 && am(t4, e, r, s), true);
}
function hm(t4, e, i, s, r, n2, o2) {
    const a2 = i.map((t5) => ki(t5.matrix2Root())), h2 = ki(s.transform), c2 = h2.getInverse(), l2 = a2.map((t5) => t5.clone().addTransform(c2));
    let d2 = 1 / 0, p2 = -1 / 0, u = 1 / 0, f2 = -1 / 0;
    l2.forEach((t5, e2) => {
        const s2 = i[e2].size, { col0: r2, col1: n3, col2: o3, col3: a3 } = t5.transform([E.FromXY(0, 0), E.FromXY(s2.width, 0), E.FromXY(s2.width, s2.height), E.FromXY(0, s2.height)]);
        r2.x < d2 ? d2 = r2.x : r2.x > p2 && (p2 = r2.x), r2.y < u ? u = r2.y : r2.y > f2 && (f2 = r2.y), n3.x < d2 ? d2 = n3.x : n3.x > p2 && (p2 = n3.x), n3.y < u ? u = n3.y : n3.y > f2 && (f2 = n3.y), o3.x < d2 ? d2 = o3.x : o3.x > p2 && (p2 = o3.x), o3.y < u ? u = o3.y : o3.y > f2 && (f2 = o3.y), a3.x < d2 ? d2 = a3.x : a3.x > p2 && (p2 = a3.x), a3.y < u ? u = a3.y : a3.y > f2 && (f2 = a3.y);
    });
    const g2 = { left: d2, top: u, right: p2, bottom: f2 };
    h2.translate(E.FromXY(g2.left, g2.top)).addTransform(ki(r.matrix2Root()).getInverse()), s.size.width = g2.right - g2.left, s.size.height = g2.bottom - g2.top, s.transform = Ei(h2), s = o2.shapeInsert(t4, e, r, s, n2);
    for (let r2 = 0, n3 = i.length; r2 < n3; r2++) {
        const n4 = i[r2], a3 = n4.parent, h3 = a3.indexOfChild(n4);
        o2.shapeMove(e, a3, h3, s, 0), a3.childs.length <= 0 && am(t4, e, a3, o2);
    }
    const m2 = ki(s.matrix2Root()).getInverse();
    for (let t5 = 0, s2 = i.length; t5 < s2; t5++) o2.shapeModifyTransform(e, i[t5], Ei(a2[t5].addTransform(m2)));
    return s;
}
function cm(t4, e, i, s) {
    const r = i.parent;
    let n2 = r.indexOfChild(i);
    const o2 = n2, a2 = [], h2 = /* @__PURE__ */ new Map();
    for (let t5 = 0, e2 = i.childs.length; t5 < e2; t5++) {
        const e3 = i.childs[t5];
        h2.set(e3.id, ki(e3.matrix2Root()));
    }
    const c2 = ki(r.matrix2Root()).getInverse();
    for (let t5 = i.childs.length; t5 > 0; t5--) {
        const t6 = i.childs[0], o3 = h2.get(t6.id);
        s.shapeMove(e, i, 0, r, n2), s.shapeModifyTransform(e, t6, Ei(o3.addTransform(c2))), n2++, a2.push(t6);
    }
    return s.shapeDelete(t4, e, r, o2 + a2.length), a2;
}
const lm = Ea.MinCellSize;
Ea.MinCellSize, Ea.MaxColCount, Ea.MaxRowCount;
class dm extends qg {
    constructor(t4, e, i, s) {
        super(t4, e, i, s);
    }
    get view() {
        return this.__shape;
    }
    get shape() {
        return this.__shape.data;
    }
    cell4edit(t4, e, i) {
        return function(t5, e2, i2, s, r) {
            const n2 = e2.getCellAt(i2, s);
            if (!n2) throw new Error("cell init fail?");
            const o2 = e2.rowHeights[i2].id + "," + e2.colWidths[s].id, a2 = e2.data.id + "/" + o2, h2 = Tg(t5, jt.TableCell, Et.TableCell, a2, (t6) => {
                const r2 = (t6 == null ? void 0 : t6.value) ?? e2._getCellAt(i2, s);
                if (r2) return oo(r2);
                new ye();
                const n3 = new Ii();
                return new ka(new G(), o2, "", Vt.TableCell, n3, new is(new G(), new G(), new G()), Wt.Text, ia(e2.data.textAttr));
            }, r, e2);
            if (h2) return n2.setData(h2.value), n2;
            if (r.tableInitCell(t5, e2.data, i2, s)) {
                const t6 = e2._getCellAt2(i2, s);
                if (!t6) throw new Error();
                n2.setData(t6);
            }
            return n2;
        }(this.__page, this.view, t4, e, i);
    }
    horSplitCell(t4, e) {
        const i = this.view.getLayout().grid.get(t4, e), s = this.view.getCellAt(i.index.row, i.index.col), r = this.__repo.start("horSplitCell");
        try {
            if (s && (s.rowSpan ?? 1) > 1) {
                const n2 = s.rowSpan ?? 1;
                if (n2 > 2) {
                    let o2 = 0;
                    const a2 = i.index.row;
                    for (let t5 = a2, e2 = a2 + n2; t5 < e2; ++t5) o2 += this.shape.rowHeights[t5].value;
                    o2 /= 2;
                    let h2 = 0, c2 = 0;
                    for (let t5 = a2, e2 = a2 + n2; t5 < e2; ++t5) if (c2 += this.shape.rowHeights[t5].value, c2 >= o2) {
                        h2 = t5 - a2 + 1;
                        break;
                    }
                    h2 = Math.min(h2, n2 - 1), r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e, r), h2, s.colSpan ?? 1);
                    const l2 = n2 - h2, d2 = s.colSpan || 1;
                    if (l2 > 1 || d2 > 1) {
                        const t5 = i.index.row + h2, e2 = i.index.col;
                        r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t5, e2, r), l2, d2);
                    }
                } else r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e, r), n2 - 1, s.colSpan ?? 1), (s.colSpan ?? 1) > 1 && r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4 + 1, e, r), 1, s.colSpan ?? 1);
            } else {
                const i2 = this.shape.rowHeights[t4].value / 2;
                r.tableInsertRow(this.__page, this.shape, t4 + 1, i2), r.tableModifyRowHeight(this.__page, this.shape, t4, i2);
                this.view._getVisibleCells(t4, t4, 0, this.shape.colWidths.length).forEach((i3) => {
                    var _a2, _b;
                    i3.rowIdx === t4 && i3.colIdx === e || r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(i3.rowIdx, i3.colIdx, r), (((_a2 = i3.cell) == null ? void 0 : _a2.rowSpan) ?? 1) + 1, ((_b = i3.cell) == null ? void 0 : _b.colSpan) ?? 1);
                });
                const s2 = this.view.getCellAt(t4, e);
                r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4 + 1, e, r), 1, (s2 == null ? void 0 : s2.colSpan) ?? 1);
            }
            this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    verSplitCell(t4, e) {
        const i = this.view.getLayout().grid.get(t4, e), s = this.view.getCellAt(i.index.row, i.index.col), r = this.__repo.start("verSplitCell");
        try {
            if (s && (s.colSpan ?? 1) > 1) {
                const n2 = s.colSpan ?? 1;
                if (n2 > 2) {
                    let o2 = 0;
                    const a2 = i.index.col;
                    for (let t5 = a2, e2 = a2 + n2; t5 < e2; ++t5) o2 += this.shape.colWidths[t5].value;
                    o2 /= 2;
                    let h2 = 0, c2 = 0;
                    for (let t5 = a2, e2 = a2 + n2; t5 < e2; ++t5) if (c2 += this.shape.rowHeights[t5].value, c2 >= o2) {
                        h2 = t5 - a2 + 1;
                        break;
                    }
                    h2 = Math.min(h2, n2 - 1), r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e, r), s.rowSpan ?? 1, h2);
                    const l2 = n2 - h2, d2 = s.rowSpan || 1;
                    if (l2 > 1 || d2 > 1) {
                        const t5 = i.index.row, e2 = i.index.col + h2;
                        r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t5, e2, r), d2, l2);
                    }
                } else r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e, r), s.rowSpan ?? 1, n2 - 1), (s.rowSpan ?? 1) > 1 && r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e + 1, r), s.rowSpan ?? 1, 1);
            } else {
                const i2 = this.shape.colWidths[e].value / 2;
                r.tableInsertCol(this.__page, this.shape, e + 1, i2), r.tableModifyColWidth(this.__page, this.shape, e, i2);
                this.view._getVisibleCells(0, this.shape.rowCount, e, e).forEach((i3) => {
                    var _a2, _b;
                    i3.rowIdx === t4 && i3.colIdx === e || r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(i3.rowIdx, i3.colIdx, r), ((_a2 = i3.cell) == null ? void 0 : _a2.rowSpan) ?? 1, (((_b = i3.cell) == null ? void 0 : _b.colSpan) ?? 1) + 1);
                });
                const s2 = this.view.getCellAt(t4, e);
                r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, e + 1, r), (s2 == null ? void 0 : s2.rowSpan) ?? 1, 1);
            }
            this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    mergeCells(t4, e, i, s) {
        const r = this.__repo.start("mergeCells");
        try {
            const n2 = this.view.getCells(t4, t4, i, i), o2 = this.view._getVisibleCells(t4, e, i, s);
            if (0 === n2.length) throw new Error("not find cell");
            if (0 === o2.length || o2[0].rowIdx !== n2[0].rowIdx && o2[0].colIdx !== n2[0].colIdx) throw new Error("cell not visible");
            const a2 = n2[0];
            r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t4, i, r), e - t4 + 1, s - i + 1), o2.forEach((t5) => {
                var _a2, _b, _c2;
                if (t5.cell && (t5.cell.cellType ?? Wt.None) !== Wt.None && (t5.rowIdx !== a2.rowIdx || t5.colIdx !== a2.colIdx)) {
                    if (t5.cell.cellType === Wt.Image) (((_a2 = a2.cell) == null ? void 0 : _a2.cellType) ?? Wt.None) === Wt.None && (r.tableSetCellContentType(this.__page, this.shape, this.cell4edit(a2.rowIdx, a2.colIdx, r), Wt.Image), r.tableSetCellContentImage(this.__page, this.shape, this.cell4edit(a2.rowIdx, a2.colIdx, r), t5.cell.imageRef));
                    else if (t5.cell.cellType === Wt.Text && ((((_b = a2.cell) == null ? void 0 : _b.cellType) ?? Wt.None) === Wt.None && r.tableSetCellContentType(this.__page, this.shape, this.cell4edit(a2.rowIdx, a2.colIdx, r), Wt.Text), ((_c2 = a2.cell) == null ? void 0 : _c2.cellType) === Wt.Text && t5.cell.text)) {
                        t5.cell.text.length > 1 && r.insertComplexText(this.__page, a2.cell, a2.cell.text.length - 1, t5.cell.text);
                    }
                    r.tableSetCellContentType(this.__page, this.shape, this.cell4edit(t5.rowIdx, t5.colIdx, r), void 0), r.tableSetCellContentImage(this.__page, this.shape, this.cell4edit(t5.rowIdx, t5.colIdx, r), void 0);
                }
            });
            for (let t5 = 1; t5 < n2.length; ++t5) {
                const t6 = n2[0];
                if (t6.cell) {
                    const e2 = t6.cell.colSpan ?? 1, i2 = t6.cell.rowSpan ?? 1;
                    (e2 > 1 || i2 > 1) && r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t6.rowIdx, t6.colIdx, r), 1, 1);
                }
            }
            this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setCellContentImage(t4, e, i) {
        const s = this.__repo.start("setCellContentImage");
        try {
            s.tableSetCellContentType(this.__page, this.shape, this.cell4edit(t4, e, s), Wt.Image), s.tableSetCellContentImage(this.__page, this.shape, this.cell4edit(t4, e, s), i), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    initCells(t4, e, i, s) {
        const r = this.__repo.start("initCells");
        try {
            this._initCells(t4, e, i, s, r), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    _initCells(t4, e, i, s, r) {
        for (let n2 = t4; n2 <= e; n2++) for (let t5 = i; t5 <= s; t5++) {
            const e2 = this.view._getCellAt2(n2, t5);
            if (e2 && e2.cellType && e2.cellType !== Wt.None) continue;
            const i2 = this.cell4edit(n2, t5, r);
            r.tableSetCellContentType(this.__page, this.shape, i2, Wt.Text);
        }
    }
    resetCells(t4, e, i, s) {
        const r = this.__repo.start("resetCells");
        try {
            this._resetCells(t4, e, i, s, r), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    resetTextCells(t4, e, i, s) {
        const r = this.__repo.start("resetCells");
        try {
            this._resetTextCells(t4, e, i, s, r), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    _resetCells(t4, e, i, s, r) {
        var _a2;
        for (let n2 = t4; n2 <= e; n2++) for (let t5 = i; t5 <= s; t5++) {
            const e2 = this.view.getCellAt(n2, t5);
            if (!e2) continue;
            const i2 = this.cell4edit(n2, t5, r);
            if (i2.cellType === Wt.Image) r.tableSetCellContentType(this.__page, this.shape, i2, Wt.Text);
            else if (i2.cellType === Wt.Text) {
                const i3 = ((_a2 = e2.text) == null ? void 0 : _a2.length) || 0;
                if (i3 <= 1) continue;
                const s2 = this.cell4edit(n2, t5, r);
                r.deleteText(this.__page, s2, 0, i3 - 1);
            }
        }
    }
    _resetTextCells(t4, e, i, s, r) {
        var _a2;
        for (let n2 = t4; n2 <= e; n2++) for (let t5 = i; t5 <= s; t5++) {
            const e2 = this.view.getCellAt(n2, t5);
            if (!e2 || e2.cellType !== Wt.Text) continue;
            const i2 = ((_a2 = e2.text) == null ? void 0 : _a2.length) || 0;
            if (i2 <= 1) continue;
            const s2 = this.cell4edit(n2, t5, r);
            r.deleteText(this.__page, s2, 0, i2 - 1);
        }
    }
    setColWidth(t4, e) {
        const i = this.shape.colWidths.reduce((t5, e2) => t5 + e2.value, 0), s = this.shape.colWidths[t4].value / i * this.shape.size.width;
        if (e === s) return;
        const r = this.shape.colWidths[t4].value * e / s, n2 = this.__repo.start("setColWidth");
        try {
            n2.tableModifyColWidth(this.__page, this.shape, t4, r), n2.shapeModifyWH(this.__page, this.shape, this.shape.size.width - s + e, this.shape.size.height), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    adjColWidth(t4, e, i) {
        const s = this.__repo.start("adjColWidth");
        try {
            !function(t5, e2, i2, s2, r, n2) {
                if (0 === r || i2 < 0 || s2 < 0 || i2 === s2) return;
                const o2 = e2.colWidths;
                if (i2 >= o2.length || s2 >= o2.length) return;
                const a2 = e2.widthTotalWeights, h2 = e2.frame;
                let c2 = o2[i2].value / a2 * h2.width, l2 = o2[s2].value / a2 * h2.width;
                const d2 = c2 + l2;
                c2 -= r, l2 += r, r < 0 ? l2 < lm && (l2 = Math.min(l2 - r, lm), c2 = d2 - l2) : c2 < lm && (c2 = Math.min(c2 + r, lm), l2 = d2 - c2);
                const p2 = c2 / h2.width * a2, u = l2 / h2.width * a2;
                n2.tableModifyColWidth(t5, e2.data, i2, p2), n2.tableModifyColWidth(t5, e2.data, s2, u);
            }(this.__page, this.view, t4, e, i, s), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setRowHeight(t4, e) {
        const i = this.view.heightTotalWeights, s = this.shape.rowHeights[t4].value / i * this.shape.size.height;
        if (e === s) return;
        const r = this.shape.rowHeights[t4].value * e / s, n2 = this.__repo.start("setRowHeight");
        try {
            n2.tableModifyRowHeight(this.__page, this.shape, t4, r), n2.shapeModifyWH(this.__page, this.shape, this.shape.size.width, this.shape.size.height - s + e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    adjRowHeight(t4, e, i) {
        const s = this.__repo.start("adjRowHeight");
        try {
            !function(t5, e2, i2, s2, r, n2) {
                if (0 === r || i2 < 0 || s2 < 0 || i2 === s2) return;
                const o2 = e2.rowHeights;
                if (i2 >= o2.length || s2 >= o2.length) return;
                const a2 = e2.heightTotalWeights, h2 = e2.frame;
                let c2 = o2[i2].value / a2 * h2.height, l2 = o2[s2].value / a2 * h2.height;
                const d2 = c2 + l2;
                c2 -= r, l2 += r, r < 0 ? l2 < lm && (l2 = Math.min(l2 - r, lm), c2 = d2 - l2) : c2 < lm && (c2 = Math.min(c2 + r, lm), l2 = d2 - c2);
                const p2 = c2 / h2.height * a2, u = l2 / h2.height * a2;
                n2.tableModifyRowHeight(t5, e2.data, i2, p2), n2.tableModifyRowHeight(t5, e2.data, s2, u);
            }(this.__page, this.view, t4, e, i, s), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    insertRow(t4, e) {
        const i = this.view.heightTotalWeights, s = e / this.shape.size.height * i, r = this.__repo.start("insertRow");
        try {
            r.tableInsertRow(this.__page, this.shape, t4, s), r.shapeModifyWH(this.__page, this.shape, this.shape.size.width, this.shape.size.height + e), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    insertMultiRow(t4, e, i) {
        const s = this.view.heightTotalWeights, r = e / this.shape.size.height * s, n2 = this.__repo.start("insertMultiRow");
        try {
            for (let e2 = 0; e2 < i; ++e2) n2.tableInsertRow(this.__page, this.shape, t4 + e2, r);
            n2.shapeModifyWH(this.__page, this.shape, this.shape.size.width, this.shape.size.height + e * i), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    removeRow(t4, e) {
        const i = (e = e ?? t4) - t4 + 1;
        if (i >= this.shape.rowHeights.length) return super.delete(), 1;
        const s = this.view.heightTotalWeights, r = this.__repo.start("removeRow");
        try {
            let e2 = 0;
            for (let s2 = 0; s2 < i; ++s2) e2 += this.shape.rowHeights[t4].value, r.tableRemoveRow(this.__page, this.shape, t4);
            if (t4 < this.shape.rowCount) {
                this.view._getVisibleCells(t4, t4, 0, this.shape.colCount).forEach((t5) => {
                    if (t5.cell) {
                        let e3 = t5.cell.rowSpan ?? 1;
                        e3 > 1 && (e3 = Math.max(1, e3 - i), r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t5.rowIdx, t5.colIdx, r), e3, t5.cell.colSpan ?? 1));
                    }
                });
            }
            const n2 = e2 / s * this.shape.size.height;
            r.shapeModifyWH(this.__page, this.shape, this.shape.size.width, this.shape.size.height - n2), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    insertCol(t4, e) {
        const i = this.view.widthTotalWeights, s = e / this.shape.size.width * i, r = this.__repo.start("insertCol");
        try {
            r.tableInsertCol(this.__page, this.shape, t4, s), r.shapeModifyWH(this.__page, this.shape, this.shape.size.width + e, this.shape.size.height), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    insertMultiCol(t4, e, i) {
        const s = this.view.widthTotalWeights, r = e / this.shape.size.width * s, n2 = this.__repo.start("insertMultiCol");
        try {
            for (let e2 = 0; e2 < i; ++e2) n2.tableInsertCol(this.__page, this.shape, t4 + e2, r);
            n2.shapeModifyWH(this.__page, this.shape, this.shape.size.width + e * i, this.shape.size.height), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    removeCol(t4, e) {
        const i = (e = e ?? t4) - t4 + 1;
        if (i >= this.shape.colWidths.length) return super.delete(), 1;
        const s = this.view.widthTotalWeights, r = this.__repo.start("removeCol");
        try {
            let e2 = 0;
            for (let s2 = 0; s2 < i; ++s2) e2 += this.shape.colWidths[t4].value, r.tableRemoveCol(this.__page, this.shape, t4);
            if (t4 < this.shape.colCount) {
                this.view._getVisibleCells(0, this.shape.rowCount, t4, t4).forEach((t5) => {
                    if (t5.cell) {
                        let e3 = t5.cell.colSpan ?? 1;
                        e3 > 1 && (e3 = Math.max(1, e3 - i), r.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t5.rowIdx, t5.colIdx, r), t5.cell.rowSpan ?? 1, e3));
                    }
                });
            }
            const n2 = e2 / s * this.shape.size.width;
            r.shapeModifyWH(this.__page, this.shape, this.shape.size.width - n2, this.shape.size.height), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    removeRowAndCol(t4, e, i, s) {
        const r = e - t4 + 1;
        if (r >= this.shape.rowHeights.length) return super.delete(), 1;
        const n2 = s - i + 1;
        if (n2 >= this.shape.colWidths.length) return super.delete(), 1;
        const o2 = this.view.widthTotalWeights, a2 = this.view.heightTotalWeights, h2 = this.__repo.start("removeRowAndCol");
        try {
            let e2 = 0;
            for (let t5 = 0; t5 < n2; ++t5) e2 += this.shape.colWidths[i].value, h2.tableRemoveCol(this.__page, this.shape, i);
            const s2 = e2 / o2 * this.shape.size.width;
            if (i < this.shape.colCount) {
                const t5 = i, e3 = n2;
                this.view._getVisibleCells(0, this.shape.rowCount, t5, t5).forEach((t6) => {
                    if (t6.cell) {
                        let i2 = t6.cell.colSpan ?? 1;
                        i2 > 1 && (i2 = Math.max(1, i2 - e3), h2.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t6.rowIdx, t6.colIdx, h2), t6.cell.rowSpan ?? 1, i2));
                    }
                });
            }
            let c2 = 0;
            for (let e3 = 0; e3 < r; ++e3) c2 += this.shape.rowHeights[t4].value, h2.tableRemoveRow(this.__page, this.shape, t4);
            const l2 = c2 / a2 * this.shape.size.height;
            if (t4 < this.shape.rowCount) {
                const e3 = t4, i2 = r;
                this.view._getVisibleCells(e3, e3, 0, this.shape.colCount).forEach((t5) => {
                    if (t5.cell) {
                        let e4 = t5.cell.rowSpan ?? 1;
                        e4 > 1 && (e4 = Math.max(1, e4 - i2), h2.tableModifyCellSpan(this.__page, this.shape, this.cell4edit(t5.rowIdx, t5.colIdx, h2), e4, t5.cell.colSpan ?? 1));
                    }
                });
            }
            h2.shapeModifyWH(this.__page, this.shape, this.shape.size.width - s2, this.shape.size.height - l2), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    fixFrameByLayout(t4, e, i) {
        Hf(i, this.__page, t4, e);
    }
    setTextColor(t4, e) {
        const i = this.__repo.start("setTableTextColor");
        try {
            let s;
            return e ? (this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i), s = this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).map((t5) => t5.cell)) : (i.tableModifyTextColor(this.__page, this.shape, t4), s = this.view.childs), s.forEach((e2) => {
                e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyColor(this.__page, e2, 0, e2.text.length, t4);
            }), this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHighlightColor(t4, e) {
        const i = this.__repo.start("setTableTextHighlightColor");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.textModifyHighlightColor(this.__page, s, 0, s.text.length, t4);
                });
            } else {
                i.tableModifyTextHighlightColor(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyHighlightColor(this.__page, e2, 0, e2.text.length, t4);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontName(t4, e) {
        const i = this.__repo.start("setTableTextFontName");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && (i.textModifyFontName(this.__page, s, 0, s.text.length, t4), this.fixFrameByLayout(s, this.view, i));
                });
            } else {
                i.tableModifyTextFontName(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && (i.textModifyFontName(this.__page, e2, 0, e2.text.length, t4), this.fixFrameByLayout(e2, this.view, i));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFontSize(t4, e) {
        const i = this.__repo.start("setTableTextFontSize");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && (i.textModifyFontSize(this.__page, s, 0, s.text.length, t4), this.fixFrameByLayout(s, this.view, i));
                });
            } else {
                i.tableModifyTextFontSize(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && (i.textModifyFontSize(this.__page, e2, 0, e2.text.length, t4), this.fixFrameByLayout(e2, this.view, i));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextVerAlign(t4, e) {
        const i = this.__repo.start("setTableTextVerAlign");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.shapeModifyTextVerAlign(this.__page, s, t4);
                });
            } else {
                i.tableModifyTextVerAlign(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.shapeModifyTextVerAlign(this.__page, e2, t4);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextHorAlign(t4, e) {
        const i = this.__repo.start("setTableTextHorAlign");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.textModifyHorAlign(this.__page, s, t4, 0, s.text.length);
                });
            } else {
                i.tableModifyTextHorAlign(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyHorAlign(this.__page, e2, t4, 0, e2.text.length);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setLineHeight(t4, e) {
        const i = this.__repo.start("setLineHeight");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    if (s && s.cellType === Wt.Text && s.data.parent) {
                        const e3 = s.text.length;
                        i.textModifyMinLineHeight(this.__page, s, t4, 0, e3), i.textModifyMaxLineHeight(this.__page, s, t4, 0, e3), this.fixFrameByLayout(s, this.view, i);
                    }
                });
            } else {
                i.tableModifyTextMinLineHeight(this.__page, this.shape, t4), i.tableModifyTextMaxLineHeight(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    if (e2 && e2.cellType === Wt.Text && e2.data.parent) {
                        const s = e2.text.length;
                        i.textModifyMinLineHeight(this.__page, e2, t4, 0, s), i.textModifyMaxLineHeight(this.__page, e2, t4, 0, s), this.fixFrameByLayout(e2, this.view, i);
                    }
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setCharSpacing(t4, e) {
        const i = this.__repo.start("setTableCharSpace");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && (i.textModifyKerning(this.__page, s, t4, 0, s.text.length), this.fixFrameByLayout(s, this.view, i));
                });
            } else {
                i.tableModifyTextKerning(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && (i.textModifyKerning(this.__page, e2, t4, 0, e2.text.length), this.fixFrameByLayout(e2, this.view, i));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setParaSpacing(t4, e) {
        const i = this.__repo.start("setTableParaSpacing");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && (i.textModifyParaSpacing(this.__page, s, t4, 0, s.text.length), this.fixFrameByLayout(s, this.view, i));
                });
            } else {
                i.tableModifyTextParaSpacing(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && (i.textModifyParaSpacing(this.__page, e2, t4, 0, e2.text.length), this.fixFrameByLayout(e2, this.view, i));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextUnderline(t4, e) {
        const i = this.__repo.start("setTableTextUnderline");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.textModifyUnderline(this.__page, s, t4 ? Zt.Single : Zt.None, 0, s.text.length);
                });
            } else {
                i.tableModifyTextUnderline(this.__page, this.shape, t4 ? Zt.Single : Zt.None);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyUnderline(this.__page, e2, t4 ? Zt.Single : Zt.None, 0, e2.text.length);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextStrikethrough(t4, e) {
        const i = this.__repo.start("setTableTextStrikethrough");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.textModifyStrikethrough(this.__page, s, t4 ? Ht.Single : Ht.None, 0, s.text.length);
                });
            } else {
                i.tableModifyTextStrikethrough(this.__page, this.shape, t4 ? Ht.Single : Ht.None);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyStrikethrough(this.__page, e2, t4 ? Ht.Single : Ht.None, 0, e2.text.length);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextWeight(t4, e, i) {
        const s = this.__repo.start("setTableTextWeight");
        try {
            if (i) {
                this._initCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd, s);
                this.view.getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                    const r = i2.cell;
                    r && r.cellType === Wt.Text && r.data.parent && (s.textModifyWeight(this.__page, r, t4, 0, r.text.length), s.textModifyItalic(this.__page, r, e, 0, r.text.length));
                });
            } else {
                s.tableModifyTextWeight(this.__page, this.shape, t4), s.tableModifyTextItalic(this.__page, this.shape, e);
                this.view.childs.forEach((i2) => {
                    i2 && i2.cellType === Wt.Text && i2.data.parent && (s.textModifyWeight(this.__page, i2, t4, 0, i2.text.length), s.textModifyItalic(this.__page, i2, e, 0, i2.text.length));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextTransform(t4, e) {
        const i = this.__repo.start("setTableTextTransform");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && (i.textModifyTransform(this.__page, s, t4, 0, s.text.length), this.fixFrameByLayout(s, this.view, i));
                });
            } else {
                i.tableModifyTextTransform(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && (i.textModifyTransform(this.__page, e2, t4, 0, e2.text.length), this.fixFrameByLayout(e2, this.view, i));
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextFillType(t4, e) {
        const i = this.__repo.start("setTableTextFillType");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.textModifyFillType(this.__page, s, t4, 0, s.text.length);
                });
            } else {
                i.tableModifyTextFillType(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.textModifyFillType(this.__page, e2, t4, 0, e2.text.length);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    setTextGradient(t4, e) {
        const i = this.__repo.start("setTableTextGradient");
        try {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s = e2.cell;
                    s && s.cellType === Wt.Text && s.data.parent && i.setTextGradient(this.__page, s, t4, 0, s.text.length);
                });
            } else {
                i.tableModifyTextGradient(this.__page, this.shape, t4);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.setTextGradient(this.__page, e2, t4, 0, e2.text.length);
                });
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    asyncSetTextGradient(t4, e) {
        const i = this.__repo.start("asyncSetTextGradient");
        let s = tm.Pending;
        const r = (t5) => {
            if (e) {
                this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, i);
                this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                    const s2 = e2.cell;
                    s2 && s2.cellType === Wt.Text && s2.data.parent && i.setTextGradient(this.__page, s2, t5, 0, s2.text.length);
                });
            } else {
                i.tableModifyTextGradient(this.__page, this.shape, t5);
                this.view.childs.forEach((e2) => {
                    e2 && e2.cellType === Wt.Text && e2.data.parent && i.setTextGradient(this.__page, e2, t5, 0, e2.text.length);
                });
            }
        };
        return { execute_from: (e2) => {
                s = tm.Pending;
                try {
                    const i2 = Hn(t4);
                    i2.from.x = e2.x, i2.from.y = e2.y, r(i2), this.__repo.transactCtx.fireNotify(), s = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), s = tm.Exception;
                }
            }, execute_to: (e2) => {
                s = tm.Pending;
                try {
                    const i2 = Hn(t4);
                    i2.to.x = e2.x, i2.to.y = e2.y, r(i2), this.__repo.transactCtx.fireNotify(), s = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), s = tm.Exception;
                }
            }, execute_elipselength: (e2) => {
                s = tm.Pending;
                try {
                    const i2 = Hn(t4);
                    i2.elipseLength = e2, r(i2), this.__repo.transactCtx.fireNotify(), s = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), s = tm.Exception;
                }
            }, execute_stop_position: (e2, i2) => {
                s = tm.Pending;
                try {
                    const n2 = Hn(t4), o2 = n2.stops.findIndex((t5) => t5.id === i2);
                    n2.stops[o2].position = e2;
                    n2.stops.sort((t5, e3) => t5.position > e3.position ? 1 : t5.position < e3.position ? -1 : 0), r(n2), this.__repo.transactCtx.fireNotify(), s = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), s = tm.Exception;
                }
            }, close: () => {
                s == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    addFill4Cell(t4, e, i) {
        const s = this.__repo.start("addFill");
        try {
            this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, s);
            const r = t4.getImageMgr();
            this.view._getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                const n2 = Kn(t4);
                if (r && n2.setImageMgr(r), !e2.cell) throw new Error("init cell fail?");
                const o2 = this.cell4edit(e2.rowIdx, e2.colIdx, s);
                i && s.deleteFills(this.__page, o2.data, 0, o2.style.fills.length), s.addFillAt(this.__page, o2.data, n2, e2.cell.style.fills.length);
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setFillColor4Cell(t4, e, i) {
        const s = this.__repo.start("setFillColor");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setFillColor(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setFillEnable4Cell(t4, e, i) {
        const s = this.__repo.start("setFillEnable");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setFillEnable(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setFillType4Cell(t4, e, i) {
        const s = this.__repo.start("setFillType");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setFillType(this.__page, r.data, t4, e), r.data.style.fills[t4].imageScaleMode || s.setFillScaleMode(this.__page, r.data, t4, Mt.Fill);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    deleteFill4Cell(t4, e) {
        const i = this.__repo.start("deleteFill");
        try {
            this.view._getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                if (e2.cell) {
                    const s = this.cell4edit(e2.rowIdx, e2.colIdx, i);
                    i.deleteFillAt(this.__page, s.data, t4);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setBorderEnable4Cell(t4, e, i) {
        const s = this.__repo.start("setBorderEnable");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setBorderEnable(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setBorderColor4Cell(t4, e, i) {
        const s = this.__repo.start("setBorderColor");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setBorderColor(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    setBorderThickness4Cell(t4, e, i) {
        const s = this.__repo.start("setBorderThickness");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setBorderThickness(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    asyncBorderThickness4Cell(t4) {
        const e = this.__repo.start("setBorderThickness");
        let i = tm.Pending;
        return { execute: (s, r) => {
                i = tm.Pending;
                try {
                    this.view._getVisibleCells(t4.rowStart, t4.rowEnd, t4.colStart, t4.colEnd).forEach((t5) => {
                        if (t5.cell) {
                            const i2 = this.cell4edit(t5.rowIdx, t5.colIdx, e);
                            e.setBorderThickness(this.__page, i2.data, r, s);
                        }
                    }), this.__repo.transactCtx.fireNotify(), i = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), i = tm.Exception;
                }
            }, close: () => {
                i == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
    setBorderStyle4Cell(t4, e, i) {
        const s = this.__repo.start("setBorderStyle");
        try {
            this.view._getVisibleCells(i.rowStart, i.rowEnd, i.colStart, i.colEnd).forEach((i2) => {
                if (i2.cell) {
                    const r = this.cell4edit(i2.rowIdx, i2.colIdx, s);
                    s.setBorderStyle(this.__page, r.data, t4, e);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    deleteBorder4Cell(t4, e) {
        const i = this.__repo.start("deleteBorder");
        try {
            this.view._getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                if (e2.cell) {
                    const s = this.cell4edit(e2.rowIdx, e2.colIdx, i);
                    i.deleteBorderAt(this.__page, s.data, t4);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    addBorder4Cell(t4, e, i) {
        t4.position = ht.Center;
        const s = this.__repo.start("addBorder");
        try {
            this._initCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd, s);
            this.view.getVisibleCells(e.rowStart, e.rowEnd, e.colStart, e.colEnd).forEach((e2) => {
                const r = Jn(t4);
                if (!e2.cell) throw new Error("init cell fail?");
                {
                    const t5 = this.cell4edit(e2.rowIdx, e2.colIdx, s);
                    i && s.deleteBorders(this.__page, t5.data, 0, t5.style.borders.length), s.addBorderAt(this.__page, t5.data, r, t5.style.borders.length);
                }
            }), this.__repo.commit();
        } catch (t5) {
            console.error(t5), this.__repo.rollback();
        }
    }
    asyncSetTableAttr(t4) {
        const e = this.__repo.start("asyncSetTableAttr");
        let i = tm.Pending;
        return { execute_char_spacing: (s) => {
                i = tm.Pending;
                try {
                    if (t4) {
                        this._initCells(t4.rowStart, t4.rowEnd, t4.colStart, t4.colEnd, e);
                        this.view.getVisibleCells(t4.rowStart, t4.rowEnd, t4.colStart, t4.colEnd).forEach((t5) => {
                            const i2 = t5.cell;
                            i2 && i2.cellType === Wt.Text && i2.data.parent && (e.textModifyKerning(this.__page, i2, s, 0, i2.text.length), this.fixFrameByLayout(i2, this.view, e));
                        });
                    } else {
                        e.tableModifyTextKerning(this.__page, this.shape, s);
                        this.view.childs.forEach((t5) => {
                            t5 && t5.cellType === Wt.Text && t5.data.parent && (e.textModifyKerning(this.__page, t5, s, 0, t5.text.length), this.fixFrameByLayout(t5, this.view, e));
                        });
                    }
                    this.__repo.transactCtx.fireNotify(), i = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), i = tm.Exception;
                }
            }, execute_line_height: (s) => {
                i = tm.Pending;
                try {
                    if (t4) {
                        this._initCells(t4.rowStart, t4.rowEnd, t4.colStart, t4.colEnd, e);
                        this.view.getVisibleCells(t4.rowStart, t4.rowEnd, t4.colStart, t4.colEnd).forEach((t5) => {
                            const i2 = t5.cell;
                            if (i2 && i2.cellType === Wt.Text && i2.data.parent) {
                                const t6 = i2.text.length;
                                e.textModifyMinLineHeight(this.__page, i2, s, 0, t6), e.textModifyMaxLineHeight(this.__page, i2, s, 0, t6), this.fixFrameByLayout(i2, this.view, e);
                            }
                        });
                    } else {
                        e.tableModifyTextMinLineHeight(this.__page, this.shape, s), e.tableModifyTextMaxLineHeight(this.__page, this.shape, s);
                        this.view.childs.forEach((t5) => {
                            if (t5 && t5.cellType === Wt.Text && t5.data.parent) {
                                const i2 = t5.text.length;
                                e.textModifyMinLineHeight(this.__page, t5, s, 0, i2), e.textModifyMaxLineHeight(this.__page, t5, s, 0, i2), this.fixFrameByLayout(t5, this.view, e);
                            }
                        });
                    }
                    this.__repo.transactCtx.fireNotify(), i = tm.Fulfilled;
                } catch (t5) {
                    console.error(t5), i = tm.Exception;
                }
            }, close: () => {
                i == tm.Fulfilled && this.__repo.isNeedCommit() ? this.__repo.commit() : this.__repo.rollback();
            } };
    }
}
function pm(t4, e) {
    return Math.atan2(e.y - t4.y, e.x - t4.x);
}
function fm(t4) {
    return t4.style.fills.length > 0 ? t4.style : t4 instanceof Pi && t4.childs.length > 0 ? fm(t4.childs[0]) : t4.style;
}
function gm(t4) {
    return t4.style.borders.length > 0 ? t4.style : t4 instanceof Pi && t4.childs.length > 0 ? gm(t4.childs[0]) : t4.style;
}
class mm {
    constructor(t4, e, i) {
        __publicField(this, "__repo");
        __publicField(this, "__page");
        __publicField(this, "__document");
        if (!(e instanceof qi)) throw console.error("page wrong", e ? JSON.stringify(e, (t5, e2) => t5.startsWith("__")) : e), new Error("page wrong");
        if (!(t4 instanceof Nf)) throw new Error("repo wrong");
        if (!(i instanceof Oa)) throw new Error("document wrong");
        this.__repo = t4, this.__page = e, this.__document = i;
    }
    group(t4, e) {
        if (0 === t4.length) return false;
        if (t4.find((t5) => !t5.parent)) return false;
        const i = t4[0].parent;
        let s = Sd(e);
        const r = this.__repo.start("group", (t5, e2, i2) => {
            var _a2;
            const r2 = {};
            r2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [s.id], t5.restore(r2);
        });
        try {
            const e2 = i.indexOfChild(t4[0]);
            return s = hm(this.__document, this.__page, t4, s, i, e2, r), this.__repo.commit(), s;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    ungroup(t4) {
        const e = [], i = this.__repo.start("ungroup", (t5, i2, s) => {
            var _a2;
            const r = {};
            r.shapes = i2 ? ((_a2 = s.saveselection) == null ? void 0 : _a2.shapes) || [] : e.map((t6) => t6.id), t5.restore(r);
        });
        try {
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                if (r.isVirtualShape) continue;
                if (!r.parent) continue;
                const n2 = cm(this.__document, this.__page, r, i);
                e.push(...n2);
            }
            return this.__repo.commit(), e.length > 0 && e;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    create_artboard(t4, e) {
        if (0 === t4.length) return false;
        if (t4.find((t5) => !t5.parent)) return false;
        const i = t4[0].parent;
        let s = Ed(e, new _e(0, 0, 100, 100));
        const r = this.__repo.start("create_artboard", (t5, e2, i2) => {
            var _a2;
            const r2 = {};
            r2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [s.id], t5.restore(r2);
        });
        try {
            const e2 = i.indexOfChild(t4[0]);
            return s = hm(this.__document, this.__page, t4, s, i, e2, r), this.__repo.commit(), s;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    dissolution_artboard(t4) {
        const e = [], i = this.__repo.start("dissolution_artboard", (t5, i2, s) => {
            var _a2;
            const r = {};
            r.shapes = i2 ? ((_a2 = s.saveselection) == null ? void 0 : _a2.shapes) || [] : e.map((t6) => t6.id), t5.restore(r);
        });
        try {
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                if (r.isVirtualShape) continue;
                if (!r.parent) continue;
                const n2 = cm(this.__document, this.__page, r, i);
                e.push(...n2);
            }
            return this.__repo.commit(), e.length > 0 && e;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    modifyShapesContextSettingOpacity(t4, e) {
        if (!t4.length) return console.log("invalid data");
        try {
            const i = this.__repo.start("modifyShapesContextSettingOpacity");
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                i.shapeModifyContextSettingsOpacity(this.__page, r2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    modifyShapesContextSettingBlendMode(t4, e) {
        if (!t4.length) return console.log("invalid data");
        try {
            const i = this.__repo.start("modifyShapesContextSettingBlendMode");
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                i.shapeModifyContextSettingsBlendMode(this.__page, r2, e);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    boolgroup(t4, e, i) {
        if (0 === t4.length) return false;
        if (t4.find((t5) => !t5.parent)) return false;
        const s = t4[0].parent, r = fm(t4[t4.length - 1]), n2 = this.cloneStyle(r);
        0 === n2.fills.length && n2.fills.push(Td());
        const o2 = gm(t4[t4.length - 1]);
        o2 !== r && (n2.borders = new G(...o2.borders.map((t5) => Jn(t5))));
        let a2 = Cd(e, n2);
        const h2 = this.__repo.start("boolgroup", (t5, e2, i2) => {
            var _a2;
            const s2 = {};
            s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [a2.id], t5.restore(s2);
        });
        try {
            const e2 = s.indexOfChild(t4[0]);
            return a2 = hm(this.__document, this.__page, t4, a2, s, e2, h2), t4.forEach((t5) => h2.shapeModifyBoolOp(this.__page, t5, i)), this.__repo.commit(), a2;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    boolgroup2(t4, e, i) {
        try {
            if (0 === t4.childs.length) return false;
            const s = t4.childs.slice(0).reverse(), r = t4.parent;
            if (!(r instanceof Li)) return false;
            const n2 = this.cloneStyle(t4.style);
            0 === n2.fills.length && n2.fills.push(Td());
            let o2 = Cd(e, n2);
            o2.transform = Ei(ki(t4.matrix2Root()));
            const a2 = this.__repo.start("boolgroup2", (t5, e2, i2) => {
                var _a2;
                const s2 = {};
                s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [o2.id], t5.restore(s2);
            });
            let h2 = r.indexOfChild(t4);
            return o2 = hm(this.__document, this.__page, s, o2, r, h2, a2), h2 = r.indexOfChild(t4), h2 >= 0 && a2.shapeDelete(this.__document, this.__page, r, h2), s.forEach((t5) => a2.shapeModifyBoolOp(this.__page, t5, i)), this.__repo.commit(), o2;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    makeSymbol(t4, e, i) {
        try {
            if (!e.length) return;
            const s = e[0], r = s.frame2Parent(), n2 = 1 === e.length && (s instanceof Li && !(s instanceof Pi) || s instanceof ji), o2 = n2 ? eo(s.style) : void 0, a2 = Xd(n2 ? s.name : i ?? s.name, r, o2);
            n2 && s instanceof ji && (s.cornerRadius && (a2.cornerRadius = dn(s.cornerRadius)), s.prototypeInteractions && (a2.prototypeInteractions = new G(), s.prototypeInteractions.forEach((t5) => {
                var _a2;
                (_a2 = a2.prototypeInteractions) == null ? void 0 : _a2.push(Gn(t5));
            })), s.prototypeStartingPoint && (a2.prototypeStartingPoint = Tn(s.prototypeStartingPoint)), s.overlayPosition && (a2.overlayPosition = xn(s.overlayPosition)), s.overlayBackgroundInteraction && (a2.overlayBackgroundInteraction = s.overlayBackgroundInteraction), s.overlayBackgroundAppearance && (a2.overlayBackgroundAppearance = Wn(s.overlayBackgroundAppearance)), s.scrollDirection && (a2.scrollDirection = s.scrollDirection));
            const h2 = this.__page, c2 = this.__repo.start("makeSymbol", (t5, e2, i2) => {
                var _a2;
                const s2 = {};
                s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [a2.id], t5.restore(s2);
            }), l2 = [];
            let d2;
            if (function(t5, e2, i2, s2, r2) {
                for (let n3 = 0, o3 = i2.length; n3 < o3; n3++) {
                    let o4 = i2[n3];
                    if (o4.type === Vt.Symbol) {
                        r2.push(o4);
                        const a4 = o4.parent;
                        if (!a4) throw new Error("wrong data: invaild parent");
                        const h3 = a4.indexOfChild(o4);
                        if (s2.shapeMove(e2, a4, h3, e2, e2.childs.length), o4 instanceof zi) continue;
                        const { x: c3, y: l3, width: d3, height: p2 } = o4.frame, u = new _e(c3, l3, d3, p2), f2 = Yd(o4.name, u, o4.id, t5.symbolsMgr);
                        i2[n3] = s2.shapeInsert(t5, e2, a4, f2, h3);
                        continue;
                    }
                    const a3 = o4.childs;
                    o4.type !== Vt.Table && (a3 == null ? void 0 : a3.length) && Qf(t5, e2, o4.childs, s2, r2);
                }
            }(t4, h2, e, c2, l2), n2) {
                const e2 = s.parent.indexOfChild(s);
                d2 = c2.shapeInsert(t4, h2, s.parent, a2, e2 + 1);
                const i2 = s.childs;
                for (let t5 = 0, e3 = i2.length; t5 < e3; ++t5) c2.shapeMove(h2, s, 0, a2, t5);
                c2.shapeDelete(t4, h2, s.parent, e2);
            } else {
                const i2 = s.parent.indexOfChild(s);
                d2 = hm(t4, h2, e, a2, s.parent, i2, c2);
                for (let t5 = 0; t5 < e.length; t5++) {
                    const i3 = e[t5], s2 = void 0 === i3.resizingConstraint ? Ne.Mask : i3.resizingConstraint, r2 = Ne.setToScaleByHeight(Ne.setToScaleByWidth(s2));
                    c2.shapeModifyResizingConstraint(h2, i3, r2);
                }
            }
            if (d2) {
                const e2 = d2;
                return t4.symbolsMgr.add(e2.id, e2), l2.length && function(t5, e3, i2, s2) {
                    const r2 = e3.parent;
                    if (!r2) return;
                    const n3 = r2.matrix2Root(), o3 = e3.boundingBox(), a3 = n3.computeCoord2(o3.x + o3.width, o3.y).x;
                    for (let e4 = 0, r3 = i2.length; e4 < r3; e4++) {
                        const r4 = i2[e4], n4 = r4.matrix2Root().computeCoord2(0, 0);
                        rg(s2, t5, r4, a3 + 36, n4.y);
                    }
                }(h2, e2, l2, c2), this.__repo.commit(), e2;
            }
            throw new Error("failed");
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    makeStatus(e, i, s, r) {
        let n2 = $c(e);
        const o2 = this.__repo.start("makeStatus");
        try {
            if (n2 instanceof zi) {
                const e2 = r ? Ni.Default_State : s, a2 = new Ri(v4(), jt.Status, i, e2);
                o2.shapeAddVariable(this.__page, n2, a2);
            } else {
                const e2 = function(e3, i2, s2, r2, n3) {
                    const o3 = r2.parent;
                    if (!o3 || o3 instanceof zi) return false;
                    const a2 = o3.indexOfChild(r2);
                    if (a2 < 0) return false;
                    const h2 = r2.boundingBox(), c2 = new _e(h2.x - 20, h2.y - 20, h2.width + 40, h2.height + 40);
                    let l2 = Gd(r2.name, c2);
                    r2.variables.forEach((t4, e4) => {
                        l2.variables.set(e4, t4);
                    }), l2.fixedRadius = 4;
                    const d2 = new Me(Dt.Normal, 2, 2, 2, 2), p2 = new Kt(5, 5), u = new ts([l2.style.borders.length], v4(), true, xt.SolidColor, new Ji(1, 127, 88, 249), ht.Inner, 2, p2, ut.Miter, d2);
                    l2.style.borders.push(u);
                    const f2 = new Ri(v4(), jt.Status, n3, Ni.Default_State);
                    l2.variables.set(f2.id, f2);
                    const g2 = e3.shapeInsert(i2, s2, o3, l2, a2);
                    return !!g2 && (r2.variables.forEach((t4, i3) => {
                        e3.shapeRemoveVariable(s2, r2, i3);
                    }), l2 = g2, e3.shapeMove(s2, o3, a2 + 1, l2, 0), e3.shapeModifyX(s2, r2, 20), e3.shapeModifyY(s2, r2, 20), l2);
                }(o2, this.__document, this.__page, n2, i);
                if (!e2) throw new Error("make union failed!");
                n2 = e2;
            }
            return this.__repo.commit(), n2;
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    makeVar(e, i, s, r) {
        const n2 = this.__repo.start("makeVar");
        try {
            if (i.type !== Vt.Symbol || i.parent && i.parent instanceof zi) throw new Error("wrong role!");
            const o2 = new Ri(v4(), e, s, r);
            return n2.shapeAddVariable(this.__page, i, o2), this.__repo.commit(), i;
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    makeStateAt(e, i, s, r) {
        if (!(e instanceof zi && e.childs.length)) return;
        let n2 = void 0 === s ? e.childs.length - 1 : s;
        void 0 !== s && (s > e.childs.length || s < 0) && (n2 = e.childs.length);
        const o2 = e.childs[n2];
        if (o2) try {
            const a2 = Ir(o2);
            if (a2.id = v4(), Sp(a2.childs), void 0 === s) {
                const t4 = Wf(e);
                if (!t4) throw new Error("failed");
                a2.transform.m12 = t4.y + 20;
            } else a2.transform.m02 = r || a2.transform.m02 + 20;
            const h2 = this, c2 = new class {
                constructor() {
                    __publicField(this, "document", h2.__document);
                    __publicField(this, "curPage", h2.__page.id);
                    __publicField(this, "fmtVer", rn);
                }
            }(), l2 = this.__repo.start("makeStateAt"), d2 = Do(a2, c2), p2 = l2.shapeInsert(this.__document, this.__page, e, d2, n2 + 1);
            if (function(t4, e2, i2) {
                const s2 = Wf(i2);
                if (!s2) return;
                const r2 = i2.size.width - s2.x, n3 = i2.size.height - s2.y;
                r2 <= 0 && e2.shapeModifyWidth(t4, i2, i2.size.width - r2 + 20), n3 <= 0 && e2.shapeModifyHeight(t4, i2, i2.size.height - n3 + 20);
            }(this.__page, l2, e), $f(l2, this.__page, p2, i), p2) return this.__repo.commit(), p2;
            throw new Error("failed");
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    insertStateAt(t4, e, i) {
    }
    extractSymbol(e) {
        const i = [], s = (e2) => {
            e2.id = v4(), e2.childs && e2.childs.forEach((t4) => s(t4));
        }, r = (t4) => {
            t4.varbinds && (t4.varbinds = void 0);
            const e2 = t4;
            Array.isArray(e2.childs) && e2.childs.forEach((t5) => r(t5));
        }, n2 = (e2, i2) => {
            const s2 = e2.overrides, r2 = e2.variables;
            if (s2) for (let o3 = 0, a3 = i2.childs; o3 < a3.length; ++o3) {
                const i3 = a3[o3];
                if (i3.childs) return void n2(e2, i3);
                if ("symbol-ref-shape" !== i3.typeId) continue;
                let h2 = i3.id;
                if (h2 = h2.substring(h2.indexOf("/") + 1), 0 === h2.length) throw new Error();
                s2.forEach((e3, s3) => {
                    if (!s3.startsWith(h2)) return;
                    const n3 = r2.get(e3);
                    if (!n3) return;
                    const o4 = dr(n3);
                    o4.id = v4();
                    const a4 = s3.substring(h2.length + 1);
                    if (0 === a4.length) throw new Error();
                    const c2 = i3;
                    if (c2.variables[a4]) {
                        const t4 = c2.variables[a4];
                        t4.name = o4.name, t4.value = o4.value;
                    } else if (c2.overrides && c2.overrides[a4]) {
                        const t4 = c2.overrides[a4], e4 = c2.variables[t4];
                        e4 ? (e4.name = o4.name, e4.value = o4.value) : (c2.variables[o4.id] = o4, c2.overrides[a4] = o4.id);
                    } else c2.variables[o4.id] = o4, c2.overrides || (c2.overrides = {}), c2.overrides[a4] = o4.id;
                });
            }
        }, o2 = [];
        for (let t4 = 0, a3 = e.length; t4 < a3; t4++) {
            const a4 = e[t4];
            if (a4.type !== Vt.SymbolRef) {
                o2.push(a4);
                continue;
            }
            if (a4.isVirtualShape) {
                o2.push(a4);
                continue;
            }
            const h2 = this, c2 = new class {
                constructor() {
                    __publicField(this, "document", h2.__document);
                    __publicField(this, "curPage", h2.__page.id);
                    __publicField(this, "fmtVer", rn);
                }
            }(), l2 = Ed(a4.name, a4.frame);
            l2.childs = a4.naviChilds, l2.varbinds = a4.varbinds, l2.style = a4.style, l2.transform.m00 = a4.transform.m00, l2.transform.m01 = a4.transform.m01, l2.transform.m10 = a4.transform.m10, l2.transform.m11 = a4.transform.m11, l2.transform.m02 = a4.transform.m02, l2.transform.m12 = a4.transform.m12, l2.cornerRadius = a4.cornerRadius;
            const d2 = vr(l2);
            n2(a4, d2), r(d2), s(d2);
            const p2 = a4.parent;
            if (!p2) {
                o2.push(a4);
                continue;
            }
            const u = p2.indexOfChild(a4);
            if (u < 0) {
                o2.push(a4);
                continue;
            }
            const f2 = Fo(d2, c2);
            i.push({ parent: p2, self: f2, insertIndex: u });
        }
        if (!i.length) return e;
        const a2 = this.__repo.start("extractSymbol", (t4, e2, s2) => {
            var _a2;
            const r2 = {};
            r2.shapes = e2 ? ((_a2 = s2.saveselection) == null ? void 0 : _a2.shapes) || [] : i.map((t5) => t5.self.id), t4.restore(r2);
        });
        try {
            const t4 = [];
            for (let e2 = 0, s2 = i.length; e2 < s2; e2++) {
                const { parent: s3, self: r2, insertIndex: n3 } = i[e2], o3 = a2.shapeInsert(this.__document, this.__page, s3, r2, n3);
                a2.shapeDelete(this.__document, this.__page, s3, n3 + 1), t4.push(o3);
            }
            return this.__repo.commit(), [...o2, ...t4];
        } catch (t4) {
            console.log(t4), this.__repo.rollback();
        }
    }
    refSymbol(t4, e, i, s) {
        const r = Yd(e, i, s, t4.symbolsMgr), n2 = t4.symbolsMgr.get(s);
        return n2 && (r.transform.m00 = n2.transform.m00, r.transform.m01 = n2.transform.m01, r.transform.m10 = n2.transform.m10, r.transform.m11 = n2.transform.m11), r;
    }
    cloneStyle(t4) {
        const e = this;
        return eo(t4, new class {
            constructor() {
                __publicField(this, "document", e.__document);
                __publicField(this, "curPage", e.__page.id);
                __publicField(this, "fmtVer", rn);
            }
        }());
    }
    flattenShapes(t4, e) {
        if (0 === t4.length) return false;
        if (t4.find((t5) => !t5.parent)) return false;
        const i = $c(t4[0]), s = i.parent, r = s.indexOfChild(i);
        e || (e = i.name);
        const n2 = fm(t4[t4.length - 1]), a2 = this.cloneStyle(n2), h2 = gm(t4[t4.length - 1]);
        h2 !== n2 && (a2.borders = new G(...h2.borders.map((t5) => Jn(t5))));
        const c2 = t4.map((t5) => {
            const e2 = t5.boundingBox(), i2 = t5.parent.matrix2Root(), s2 = i2.computeCoord(e2.x, e2.y), r2 = i2.computeCoord(e2.x + e2.width, e2.y + e2.height);
            return { x: s2.x, y: s2.y, width: r2.x - s2.x, height: r2.y - s2.y };
        }), l2 = c2[0], d2 = { left: l2.x, top: l2.y, right: l2.x, bottom: l2.y };
        c2.reduce((t5, e2) => (om(t5, e2.x, e2.y), om(t5, e2.x + e2.width, e2.y + e2.height), t5), d2);
        const u = new o(s.matrix2Root().inverse), f2 = u.computeCoord(d2.left, d2.top), g2 = new _e(f2.x, f2.y, d2.right - d2.left, d2.bottom - d2.top);
        let m2 = "";
        t4.forEach((t5) => {
            const e2 = t5.matrix2Root(), i2 = ul(t5);
            e2.multiAtLeft(u), i2.transform(e2), m2 = m2.length > 0 ? p.boolop.union(m2, i2.toString()) : i2.toString();
        });
        const _2 = new pi(m2);
        _2.translate(-g2.x, -g2.y);
        let y2 = Ad(e, g2, _2, a2);
        const x2 = this.__repo.start("flattenShapes", (t5, e2, i2) => {
            var _a2;
            const s2 = {};
            s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [y2.id], t5.restore(s2);
        });
        try {
            y2 = x2.shapeInsert(this.__document, this.__page, s, y2, r);
            for (let e2 = 0, i2 = t4.length; e2 < i2; e2++) {
                const i3 = $c(t4[e2]), s2 = i3.parent, r2 = s2.indexOfChild(i3);
                x2.shapeDelete(this.__document, this.__page, s2, r2), s2.childs.length <= 0 && am(this.__document, this.__page, s2, x2);
            }
            return this.__repo.commit(), y2;
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    flattenBoolShape(t4) {
        try {
            const e = $c(t4).parent;
            if (!e) return false;
            const i = ul(t4), s = fm(t4), r = this.cloneStyle(s), n2 = gm(t4);
            n2 !== s && (r.borders = new G(...n2.borders.map((t5) => Jn(t5))));
            const o2 = t4.frame, a2 = i.calcBounds(), h2 = a2.minX, c2 = a2.minY, l2 = a2.maxX - a2.minX, d2 = a2.maxY - a2.minY, p2 = new _e(o2.x, o2.y, l2, d2);
            i.translate(-a2.minX, -a2.minY);
            let u = Ad(t4.name, p2, i, r);
            u.fixedRadius = t4.fixedRadius, u.transform = Ei(new P().setTranslate(E.FromXY(h2, c2)).addTransform(ki(t4.transform)));
            const f2 = e.indexOfChild($c(t4)), g2 = this.__repo.start("flattenBoolShape", (t5, e2, i2) => {
                var _a2;
                const s2 = {};
                s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [u.id], t5.restore(s2);
            });
            return g2.shapeDelete(this.__document, this.__page, e, f2), u = g2.shapeInsert(this.__document, this.__page, e, u, f2), this.__repo.commit(), u;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    flattenGroup(t4, e) {
        if (0 === t4.childs.length) return false;
        const i = $c(t4), s = i.parent, r = (s == null ? void 0 : s.indexOfChild(i)) ?? -1;
        if (r < 0) return false;
        const n2 = this.cloneStyle(t4.style);
        0 === n2.fills.length && n2.fills.push(Td());
        const o2 = ul(t4, at.Union), a2 = fm(t4), h2 = this.cloneStyle(a2), c2 = gm(t4);
        c2 !== a2 && (n2.borders = new G(...c2.borders.map((t5) => Jn(t5))));
        let l2 = Ad(t4.name, t4.frame, o2, h2);
        l2.fixedRadius = t4.fixedRadius, l2.transform = On(t4.transform), l2.style = n2;
        try {
            const e2 = this.__repo.start("flattenGroup", (e3, i2, s2) => {
                var _a2;
                const r2 = {};
                r2.shapes = i2 ? ((_a2 = s2.saveselection) == null ? void 0 : _a2.shapes) || [] : [t4.id], e3.restore(r2);
            });
            return e2.shapeDelete(this.__document, this.__page, s, r), l2 = e2.shapeInsert(this.__document, this.__page, s, l2, r), this.__repo.commit(), l2;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    removeContactSides(t4, e, i) {
        if (i.from) {
            const s = e.getShape(i.from.shapeId), r = s == null ? void 0 : s.style.contacts;
            if (s && r) {
                let n2 = -1;
                for (let t5 = 0, e2 = r.length; t5 < e2; t5++) {
                    if (r[t5].shapeId === i.id) {
                        n2 = t5;
                        break;
                    }
                }
                n2 > -1 && t4.removeContactRoleAt(e, s, n2);
            }
        }
        if (i.to) {
            const s = e.getShape(i.to.shapeId), r = s == null ? void 0 : s.style.contacts;
            if (s && r) {
                let n2 = -1;
                for (let t5 = 0, e2 = r.length; t5 < e2; t5++) {
                    if (r[t5].shapeId === i.id) {
                        n2 = t5;
                        break;
                    }
                }
                n2 > -1 && t4.removeContactRoleAt(e, s, n2);
            }
        }
    }
    removeContact(t4, e, i) {
        const s = i.style.contacts;
        if (s && s.length) for (let i2 = 0, r = s.length; i2 < r; i2++) {
            const r2 = e.getShape(s[i2].shapeId);
            if (!r2) continue;
            const n2 = r2.parent;
            if (!n2) continue;
            let o2 = -1;
            for (let t5 = 0, e2 = n2.childs.length; t5 < e2; t5++) if (n2.childs[t5].id === r2.id) {
                o2 = t5;
                break;
            }
            o2 > -1 && t4.shapeDelete(this.__document, e, n2, o2);
        }
    }
    delete_inner(t4, e, i) {
        const s = e instanceof Oi ? e : e.data, r = s.parent;
        return !!r && (s.type === Vt.Contact ? this.removeContactSides(i, t4, s) : this.removeContact(i, t4, s), i.shapeDelete(this.__document, t4, r, r.indexOfChild(s)), r.childs.length <= 0 && r.type === Vt.Group && this.delete_inner(t4, r, i), true);
    }
    delete(t4) {
        const e = t4.getPage();
        if (!e) return false;
        const i = t4.parent;
        if (!i) return false;
        const s = this.__repo.start("delete", (e2, i2) => {
            const s2 = {};
            s2.shapes = i2 ? [t4.id] : [], e2.restore(s2);
        });
        try {
            if (_g(t4)) {
                const e2 = !t4.isVisible;
                return Fg(s, this.__page, t4, jt.Visible, Et.Visible, e2) || s.shapeModifyVisible(this.__page, t4.data, e2), true;
            }
            const r = Uf(t4);
            if (r && qf(e, t4, r, s), this.delete_inner(e.data, t4, s)) return eg(i) && this.delete_inner(e.data, i, s), t4.type === Vt.Symbol && this.__document.__correspondent.notify("update-symbol-list"), this.__repo.commit(), true;
            this.__repo.rollback();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
        return false;
    }
    delete_batch(t4) {
        const e = this.__repo.start("deleteBatch", (e2, i2) => {
            const s = {};
            s.shapes = i2 ? t4.map((t5) => t5.id) : [], e2.restore(s);
        });
        let i = false;
        for (let s = 0; s < t4.length; s++) try {
            const r = t4[s];
            if (_g(r)) {
                const t5 = !r.isVisible;
                if (Fg(e, this.__page, r, jt.Visible, Et.Visible, t5)) continue;
                e.shapeModifyVisible(this.__page, r.data, t5);
                continue;
            }
            const n2 = Uf(r);
            n2 && qf(this.__page, r, n2, e), r.type === Vt.Symbol && (i = true);
            const o2 = r.getPage();
            if (!o2) return false;
            const a2 = r.parent;
            if (!a2) return false;
            this.delete_inner(o2.data, r, e), eg(a2) && this.delete_inner(o2.data, a2, e);
        } catch (t5) {
            return this.__repo.rollback(), false;
        }
        return i && this.__document.__correspondent.notify("update-symbol-list"), this.__repo.commit(), true;
    }
    insert(e, i, s, r = false) {
        if (!r) {
            const t4 = e.frame2Root(), i2 = ki(s.transform);
            i2.translate(new E([-t4.x, -t4.y, 0])), Fi(s.transform, i2);
        }
        s.id = v4();
        const n2 = this.__repo.start("insertshape", (t4, e2, i2) => {
            var _a2;
            const r2 = {};
            r2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : [s.id], t4.restore(r2);
        });
        try {
            return n2.shapeInsert(this.__document, this.__page, e, s, i), s = e.childs[i], this.__repo.commit(), s;
        } catch (t4) {
            return console.log(t4), this.__repo.rollback(), false;
        }
    }
    pasteShapes1(t4, e) {
        const i = this.__repo.start("insertShapes1", (t5, i2, s) => {
            var _a2;
            const r = {};
            r.shapes = i2 ? ((_a2 = s.saveselection) == null ? void 0 : _a2.shapes) || [] : e.map((t6) => t6.id), t5.restore(r);
        });
        try {
            const s = [];
            let r = t4.childs.length;
            for (let n2 = 0, o2 = e.length; n2 < o2; n2++) {
                const o3 = e[n2];
                i.shapeInsert(this.__document, this.__page, t4, o3, r), s.push(t4.childs[r]), r++;
            }
            return this.__repo.commit(), { shapes: s };
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    pasteShapes2(t4, e) {
        const i = this.__repo.start("insertShapes2", (e2, i2, s) => {
            var _a2;
            const r = {};
            r.shapes = i2 ? ((_a2 = s.saveselection) == null ? void 0 : _a2.shapes) || [] : t4.map((t5) => t5.id), e2.restore(r);
        });
        try {
            const s = [];
            for (let r = 0, n2 = e.length; r < n2; r++) {
                const n3 = t4[r], { parent: o2, index: a2 } = e[r];
                i.shapeInsert(this.__document, this.__page, o2, n3, a2), s.push(o2.childs[a2]);
            }
            return this.__repo.commit(), s;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    pasteShapes3(t4) {
        try {
            const e = this.__repo.start("pasteShapes3", (e2, i2, s) => {
                var _a2;
                const r = {};
                r.shapes = i2 ? ((_a2 = s.saveselection) == null ? void 0 : _a2.shapes) || [] : t4.reduce((t5, e3) => [...t5, ...e3.shapes.map((t6) => t6.id)], []), e2.restore(r);
            }), i = [];
            for (let s = 0, r = t4.length; s < r; s++) {
                const { env: r2, shapes: n2 } = t4[s];
                for (let t5 = 0; t5 < n2.length; t5++) {
                    let s2 = r2.childs.length;
                    e.shapeInsert(this.__document, this.__page, r2, n2[t5], s2), i.push(r2.childs[s2]);
                }
            }
            return this.__repo.commit(), i;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    create(t4, e, i) {
        switch (t4) {
            case Vt.Artboard:
                return Ed(e, i);
            case Vt.Rectangle:
                return Fd(e, i);
            case Vt.Oval:
                return Rd(e, i);
            case Vt.Line:
                return Pd(e, i);
            default:
                return Fd(e, i);
        }
    }
    createArtboard(t4, e, i) {
        return Ed(t4, e, i);
    }
    shapesModifyRadius(t4, e) {
        try {
            const i = this.__repo.start("shapesModifyRadius"), s = this.__page;
            for (let r = 0; r < t4.length; r++) {
                const n2 = $c(t4[r]), o2 = n2.radiusType === De.Rect;
                let a2 = false;
                if (o2) {
                    4 !== e.length && (e = [e[0], e[0], e[0], e[0]]);
                    const [o3, h2, c2, l2] = e;
                    if (n2 instanceof Ar) {
                        const e2 = Pg(i, s, t4[r]);
                        i.shapeModifyRadius2(s, e2, o3, h2, c2, l2);
                    }
                    if (n2.isVirtualShape) continue;
                    if (n2 instanceof Vi) {
                        const t5 = n2.pathsegs[0].points;
                        for (let r2 = 0; r2 < 4; r2++) {
                            const o4 = e[r2];
                            t5[r2].radius === o4 || o4 < 0 || i.modifyPointCornerRadius(s, n2, r2, o4, 0);
                        }
                        a2 = true;
                    } else if (n2 instanceof Di) {
                        const t5 = n2.pathsegs[0].points;
                        for (let r2 = 0; r2 < 4; r2++) {
                            const o4 = e[r2];
                            t5[r2].radius === o4 || o4 < 0 || i.modifyPointCornerRadius(s, n2, r2, o4, 0);
                        }
                        a2 = true;
                    } else {
                        const t5 = n2;
                        i.shapeModifyRadius2(s, t5, o3, h2, c2, l2);
                    }
                } else {
                    if (n2.isVirtualShape || n2.radiusType === De.None) continue;
                    n2 instanceof Vi ? (n2.pathsegs.forEach((t5, r2) => {
                        for (let o3 = 0; o3 < t5.points.length; o3++) t5.points[o3].radius !== e[0] && i.modifyPointCornerRadius(s, n2, o3, e[0], r2);
                    }), a2 = true) : n2 instanceof Di ? (n2.pathsegs.forEach((t5, r2) => {
                        for (let o3 = 0; o3 < t5.points.length; o3++) t5.points[o3].radius !== e[0] && i.modifyPointCornerRadius(s, n2, o3, e[0], r2);
                    }), a2 = true) : i.shapeModifyFixedRadius(s, n2, e[0]);
                }
                a2 && Kc(i, this.__page, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("shapesModifyRadius", t5), this.__repo.rollback();
        }
    }
    create2(t4, e, i, s, r, n2) {
        const { is_arrow: o2, rotation: a2, target_xy: h2 } = n2;
        let c2;
        switch (i) {
            case Vt.Artboard:
                c2 = Ed(s, r);
                break;
            case Vt.Rectangle:
                c2 = Fd(s, r);
                break;
            case Vt.Oval:
                c2 = Rd(s, r);
                break;
            case Vt.Line:
                c2 = o2 ? Bd(s, r) : Pd(s, r);
                break;
            default:
                c2 = Fd(s, r);
        }
        if (!c2) return false;
        const l2 = e.matrix2Root(), d2 = this.__repo.start("create2");
        try {
            const i2 = e.childs.length, s2 = l2.computeCoord2(0, 0), r2 = ki(c2.transform);
            if (r2.translate(new E([-s2.x, -s2.y, 0])), Fi(c2.transform, r2), a2) {
                const t5 = ki(c2.transform);
                t5.setRotateZ(a2 % 360 / 180 * Math.PI), Fi(c2.transform, t5);
            }
            return c2 = d2.shapeInsert(this.__document, this.__page, e, c2, i2), h2 && rg(d2, t4, c2, h2.x, h2.y), this.__repo.commit(), c2;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    move(t4, e, i) {
        const s = t4.parent;
        if (!s) return false;
        const r = s.childs.length - s.indexOfChild(t4) - 1;
        if (r < 0) return false;
        if (e.id !== s.id || i !== r && i + 1 !== r) {
            const t5 = this.__repo.start("move");
            try {
                return e.id === s.id && (i = r >= i ? i : i + 1), t5.shapeMove(this.__page, s, r, e, i), this.__repo.commit(), true;
            } catch (t6) {
                console.log(t6), this.__repo.rollback();
            }
        }
        return false;
    }
    upperLayer(t4, e) {
        const i = (t5, e2, i2, s) => {
            const r = t5.childs.length - 1;
            i2 > r && (i2 = r);
            const n2 = t5.childs;
            let o2 = i2;
            for (let t6 = i2; t6 > s && e2.has(n2[t6].id); t6--) o2--;
            return o2;
        };
        try {
            const s = this.__repo.start("upperLayer"), r = /* @__PURE__ */ new Set();
            for (let e2 = 0; e2 < t4.length; e2++) {
                const i2 = t4[e2];
                r.add(i2.id);
            }
            let n2 = false;
            for (let o2 = 0; o2 < t4.length; o2++) {
                const a2 = $c(t4[o2]);
                if (a2.isVirtualShape) continue;
                const h2 = a2.parent, c2 = h2.indexOfChild(a2), l2 = i(h2, r, e ? c2 + e : h2.childs.length - 1, c2);
                l2 !== c2 && (n2 = true, s.shapeMove(this.__page, h2, c2, h2, l2));
            }
            return this.__repo.commit(), n2;
        } catch (t5) {
            return console.log("upperLayer:", t5), this.__repo.rollback(), false;
        }
    }
    lowerLayer(t4, e) {
        const i = (t5, e2, i2, s) => {
            i2 < 0 && (i2 = 0);
            const r = t5.childs;
            let n2 = i2;
            for (let t6 = i2; t6 < s && e2.has(r[t6].id); t6++) n2++;
            return n2;
        };
        try {
            const s = this.__repo.start("upperLayer"), r = /* @__PURE__ */ new Set();
            for (let e2 = 0; e2 < t4.length; e2++) {
                const i2 = t4[e2];
                r.add(i2.id);
            }
            let n2 = false;
            for (let o2 = 0; o2 < t4.length; o2++) {
                const a2 = $c(t4[o2]);
                if (a2.isVirtualShape) continue;
                const h2 = a2.parent, c2 = h2.indexOfChild(a2), l2 = i(h2, r, e ? c2 - e : 0, c2);
                l2 !== c2 && (n2 = true, s.shapeMove(this.__page, h2, c2, h2, l2));
            }
            return this.__repo.commit(), n2;
        } catch (t5) {
            return console.log("lowerLayer:", t5), this.__repo.rollback(), false;
        }
    }
    replace(e, i, s) {
        const r = [], n2 = this.__repo.start("replace", (t4, e2, i2) => {
            var _a2;
            const s2 = {};
            s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : r.map((t5) => t5.id), t4.restore(s2);
        });
        try {
            const o2 = i.length, a2 = i[0].frame, h2 = { x: a2.x, y: a2.y };
            for (let t4 = 1; t4 < o2; t4++) {
                const e2 = i[t4].frame;
                e2.x < h2.x && (h2.x = e2.x), e2.y < h2.y && (h2.y = e2.y);
            }
            const c2 = [];
            for (let t4 = 0; t4 < o2; t4++) {
                const e2 = i[t4].frame, s2 = { x: e2.x - h2.x, y: e2.y - h2.y };
                c2.push(s2);
            }
            for (let a3 = 0; a3 < s.length; a3++) {
                const h3 = s[a3];
                if (xg(h3)) continue;
                const l2 = h3.parent;
                if (!l2) throw new Error("invalid root");
                let d2 = l2.indexOfChild(h3);
                if (d2 < 0) throw new Error("invalid childs data");
                const p2 = h3.frame, u = { x: p2.x, y: p2.y };
                if (!this.delete_inner(this.__page, h3, n2)) throw new Error("delete failed");
                const f2 = a3 < 1 ? i : kp(e, this.__page, i);
                for (let e2 = 0; e2 < o2; e2++) {
                    let i2 = f2[e2];
                    i2.id = v4();
                    const s2 = ki(i2.transform);
                    s2.setTranslate(new E([u.x + c2[e2].x, u.y + c2[e2].y, 0])), Fi(i2.transform, s2), n2.shapeInsert(this.__document, this.__page, l2, i2, d2), r.push(l2.childs[d2]), d2++;
                }
            }
            return this.__repo.commit(), r;
        } catch (t4) {
            return console.log(t4), this.__repo.rollback(), false;
        }
    }
    arrange(t4) {
        const e = this.__repo.start("arrange");
        try {
            for (let i = 0; i < t4.length; i++) {
                const s = t4[i];
                ng(e, this.__page, s.target, s.transX, s.transY);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesX(t4) {
        try {
            const e = this.__repo.start("modifyShapesX"), i = this.__page;
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                e.shapeModifyX(i, r.target, r.x);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesY(t4) {
        try {
            const e = this.__repo.start("modifyShapesY"), i = this.__page;
            for (let s = 0; s < t4.length; s++) {
                const r = t4[s];
                e.shapeModifyY(i, r.target, r.y);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesAngleCount(t4) {
        const e = this.__repo.start("modifyShapesAngleCount");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, count: r } = t4[i];
                if (s.haveEdit) continue;
                const n2 = s.type === Vt.Star ? s.innerAngle : void 0, o2 = cl(hl(s.type === Vt.Star ? 2 * r : r, n2), s.radius[0]);
                e.deletePoints(this.__page, s, 0, s.type === Vt.Star ? 2 * s.counts : s.counts, 0), e.addPoints(this.__page, s, o2, 0), e.shapeModifyCounts(this.__page, s, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesInnerAngle(t4) {
        const e = this.__repo.start("modifyShapesInnerAngle");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, offset: r } = t4[i];
                if (s.haveEdit) continue;
                const n2 = s == null ? void 0 : s.pathsegs[0];
                if (!n2) continue;
                const o2 = n2 == null ? void 0 : n2.points;
                if (o2 == null ? void 0 : o2.length) {
                    for (let t5 = 0; t5 < o2.length; t5++) {
                        if (t5 % 2 == 0) continue;
                        const i2 = ll(r, 2 * Math.PI / o2.length * t5);
                        e.shapeModifyCurvPoint(this.__page, s, t5, i2, 0);
                    }
                    e.shapeModifyInnerAngle(this.__page, s, r);
                }
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesConstrainerProportions(t4) {
        const e = this.__repo.start("setShapesConstrainerProportions");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.shapeModifyConstrainerProportions(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFrame(t4) {
        const e = this.__repo.start("setShapesFrame");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, widthExtend: r, heightExtend: n2 } = t4[i];
                ag(e, this.__document, this.__page, s, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesWidth(t4, e) {
        try {
            !function(t5, e2, i, s, r) {
                for (let n2 = 0, o2 = s.length; n2 < o2; n2++) {
                    const o3 = s[n2], a2 = $c(o3);
                    if (al(a2)) {
                        Kg(t5, i, a2, r);
                        continue;
                    }
                    const h2 = a2.size.width;
                    let c2 = a2.size.height;
                    a2.constrainerProportions && (c2 /= h2 / r);
                    const l2 = a2.frame.height;
                    og(t5, e2, i, a2, r, c2), o3 instanceof Dh && lg(t5, i, o3, { x: r / h2, y: c2 / l2 });
                }
            }(this.__repo.start("modifyShapesWidth"), this.__document, this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    modifyShapesHeight(t4, e) {
        try {
            !function(t5, e2, i, s, r) {
                for (let n2 = 0, o2 = s.length; n2 < o2; n2++) {
                    const o3 = s[n2], a2 = $c(o3);
                    if (al(a2)) continue;
                    let h2 = a2.size.width;
                    const c2 = a2.size.height;
                    a2.constrainerProportions && (h2 /= c2 / r);
                    const l2 = a2.frame.width;
                    og(t5, e2, i, a2, h2, r), o3 instanceof Dh && lg(t5, i, o3, { x: h2 / l2, y: r / c2 });
                }
            }(this.__repo.start("modifyShapesHeight"), this.__document, this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesRotate(t4) {
        try {
            const e = this.__repo.start("setShapesRotate");
            for (const i of t4) {
                const { shape: t5, transform: s } = i, r = $c(t5);
                e.shapeModifyRotate(this.__page, r, s);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    shapesFlip(t4) {
        try {
            const e = this.__repo.start("shapesFlip"), i = this.__page;
            for (let s = 0; s < t4.length; s++) {
                const { shape: r, transform2: n2 } = t4[s];
                e.shapeModifyTransform(i, $c(r), Ei(n2));
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    makeMask(t4, e) {
        try {
            const i = this.__page, s = this.__document;
            let r = [];
            const n2 = this.__repo.start("modify-mask-status", (t5, e2, i2) => {
                var _a2;
                const s2 = {};
                s2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : r, t5.restore(s2);
            }), o2 = t4.length;
            if (!o2) throw new Error("no shapes");
            if (1 === o2) {
                const o3 = $c(t4[0]);
                if (o3.parent.id === i.id) if (o3.mask) n2.shapeModifyMask(i, o3, false), r = [o3.id];
                else {
                    const t5 = Sd(e), a2 = i.indexOfChild(o3);
                    r = [hm(s, i, [o3], t5, i, a2, n2).id], n2.shapeModifyMask(i, o3, true);
                }
                else {
                    const t5 = !o3.mask;
                    n2.shapeModifyMask(i, o3, t5), r = [o3.id];
                }
            } else {
                const o3 = $c(t4[0]), a2 = o3.parent, h2 = Sd(e), c2 = a2.indexOfChild(o3), l2 = hm(s, i, t4.map((t5) => $c(t5)), h2, a2, c2, n2);
                r = [l2.id], l2.childs[0].mask || n2.shapeModifyMask(i, l2.childs[0], true);
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            return console.log("makeMask", t5), this.__repo.rollback(), false;
        }
    }
    reverseShapesGradient(t4) {
        try {
            const e = this.__repo.start("reverseShapesGradient");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2 } = t4[i], o2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(o2 == null ? void 0 : o2.length)) continue;
                const a2 = o2[r];
                if (!a2 || !a2.gradient) continue;
                const h2 = a2.gradient, c2 = h2.stops;
                if (!(c2 == null ? void 0 : c2.length)) continue;
                const l2 = new G();
                for (let t5 = 0, e2 = c2.length; t5 < e2; t5++) {
                    const e3 = c2[t5], i2 = c2.length - 1 - t5;
                    l2.push(Fn(Gs(new xe(e3.crdtidx, e3.id, e3.position, c2[i2].color))));
                }
                const d2 = Og(e, this.__page, s2);
                "fills" === n2 ? e.setFillColor(this.__page, d2, r, l2[0].color) : e.setBorderColor(this.__page, d2, r, l2[0].color);
                const p2 = Hn(qs(h2));
                p2.stops = l2;
                ("fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e))(this.__page, d2, r, p2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("reverseShapesGradient:", t5), this.__repo.rollback();
        }
    }
    rotateShapesGradient(t4) {
        try {
            const e = this.__repo.start("rotateShapesGradient");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2 } = t4[i], a2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(a2 == null ? void 0 : a2.length)) continue;
                const h2 = a2[r];
                if (!h2 || !h2.gradient) continue;
                const c2 = Hn(qs(h2.gradient)), { from: l2, to: d2 } = c2, p2 = c2.gradientType;
                if (p2 === wt.Linear) {
                    const t5 = { x: (d2.x + l2.x) / 2, y: (d2.y + l2.y) / 2 }, e2 = new o();
                    e2.trans(-t5.x, -t5.y), e2.rotate(Math.PI / 2), e2.trans(t5.x, t5.y), c2.to = e2.computeCoord3(d2), c2.from = e2.computeCoord3(l2);
                } else if (p2 === wt.Radial || p2 === wt.Angular) {
                    const t5 = new o();
                    t5.trans(-l2.x, -l2.y), t5.rotate(Math.PI / 2), t5.trans(l2.x, l2.y), c2.to = t5.computeCoord3(d2);
                }
                const u = "fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e), f2 = Og(e, this.__page, s2);
                u(this.__page, f2, r, c2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("rotateShapesGradient:", t5), this.__repo.rollback();
        }
    }
    addShapesGradientStop(t4) {
        try {
            const e = this.__repo.start("addShapesGradientStop");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2, value: o2 } = t4[i], a2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(a2 == null ? void 0 : a2.length)) continue;
                const h2 = a2[r];
                if (!h2) continue;
                const c2 = h2.gradient;
                if (!c2) continue;
                const l2 = Hn(qs(c2));
                l2.stops.push(Fn(Gs(o2)));
                l2.stops.sort((t5, e2) => t5.position > e2.position ? 1 : t5.position < e2.position ? -1 : 0), l2.stops.forEach((t5, e2) => {
                    const i2 = new G();
                    i2.push(e2), t5.crdtidx = i2;
                });
                const d2 = "fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e), p2 = Og(e, this.__page, s2);
                d2(this.__page, p2, r, l2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("addShapesGradientStop:", t5), this.__repo.rollback();
        }
    }
    toggerShapeGradientType(e) {
        try {
            const i = this.__repo.start("toggerShapeGradientType");
            for (let s = 0, r = e.length; s < r; s++) {
                const { target: r2, index: n2, type: o2, value: a2 } = e[s], h2 = "fills" === o2 ? r2.getFills() : r2.getBorders();
                if (!(h2 == null ? void 0 : h2.length)) continue;
                const c2 = h2[n2];
                if (!c2) continue;
                const l2 = c2.gradient, d2 = Og(i, this.__page, r2);
                if (c2.fillType !== xt.Gradient && ("fills" === o2 ? i.setFillType(this.__page, d2, n2, xt.Gradient) : i.setBorderFillType(this.__page, d2, n2, xt.Gradient)), l2) {
                    const t4 = Hn(qs(l2));
                    t4.gradientType = a2, a2 === wt.Linear && l2.gradientType !== wt.Linear ? (t4.from.y = t4.from.y - (t4.to.y - t4.from.y), t4.from.x = t4.from.x - (t4.to.x - t4.from.x)) : l2.gradientType === wt.Linear && a2 !== wt.Linear && (t4.from.y = t4.from.y + (t4.to.y - t4.from.y) / 2, t4.from.x = t4.from.x + (t4.to.x - t4.from.x) / 2), a2 === wt.Radial && void 0 === t4.elipseLength && (t4.elipseLength = 1), t4.stops[0].color = c2.color;
                    ("fills" === o2 ? i.setFillGradient.bind(i) : i.setBorderGradient.bind(i))(this.__page, d2, n2, t4);
                } else {
                    const e2 = new G(), { alpha: s2, red: r3, green: h3, blue: l3 } = c2.color;
                    e2.push(new xe(new G(), v4(), 0, new Ji(s2, r3, h3, l3)), new xe(new G(), v4(), 1, new Ji(0, r3, h3, l3)));
                    const p2 = a2 === wt.Linear ? { x: 0.5, y: 0 } : { x: 0.5, y: 0.5 }, u = { x: 0.5, y: 1 };
                    let f2;
                    a2 === wt.Radial && (f2 = 1);
                    const g2 = new Qi(p2, u, a2, e2, f2);
                    g2.stops.forEach((t4, e3) => {
                        const i2 = new G();
                        i2.push(e3), t4.crdtidx = i2;
                    });
                    ("fills" === o2 ? i.setFillGradient.bind(i) : i.setBorderGradient.bind(i))(this.__page, d2, n2, g2);
                }
            }
            this.__repo.commit();
        } catch (t4) {
            console.log("toggerShapeGradientType:", t4), this.__repo.rollback();
        }
    }
    setShapesGradientStopColor(t4) {
        try {
            const e = this.__repo.start("setShapesGradientStopColor");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2, value: o2 } = t4[i], a2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(a2 == null ? void 0 : a2.length)) continue;
                const h2 = a2[r];
                if (!h2 || !h2.gradient || h2.fillType !== xt.Gradient) continue;
                const c2 = h2.gradient, l2 = c2.stops;
                if (!(l2 == null ? void 0 : l2.length)) continue;
                const { color: d2, stop_i: p2 } = o2, u = Hn(qs(c2));
                u.stops[p2].color = d2;
                const f2 = "fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e), g2 = Og(e, this.__page, s2);
                "fills" === n2 ? e.setFillColor(this.__page, g2, r, u.stops[0].color) : e.setBorderColor(this.__page, g2, r, u.stops[0].color), f2(this.__page, g2, r, u);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("setShapesGradientStopColor:", t5), this.__repo.rollback();
        }
    }
    deleteShapesGradientStop(t4) {
        try {
            const e = this.__repo.start("setShapesGradientStopColor");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2, value: o2 } = t4[i], a2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(a2 == null ? void 0 : a2.length)) continue;
                const h2 = a2[r];
                if (!h2 || !h2.gradient || h2.fillType !== xt.Gradient) continue;
                const c2 = h2.gradient, l2 = c2.stops;
                if (!(l2 == null ? void 0 : l2.length) || 1 === c2.stops.length) continue;
                const d2 = Hn(qs(c2));
                d2.stops.splice(o2, 1);
                const p2 = "fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e), u = Og(e, this.__page, s2);
                p2(this.__page, u, r, d2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("setShapesGradientStopColor:", t5), this.__repo.rollback();
        }
    }
    setGradientOpacity(t4) {
        try {
            const e = this.__repo.start("setGradientOpacity");
            for (let i = 0, s = t4.length; i < s; i++) {
                const { target: s2, index: r, type: n2, value: o2 } = t4[i], a2 = "fills" === n2 ? s2.getFills() : s2.getBorders();
                if (!(a2 == null ? void 0 : a2.length)) continue;
                const h2 = a2[r];
                if (!h2 || !h2.gradient || h2.fillType !== xt.Gradient) continue;
                const c2 = Hn(qs(h2.gradient));
                c2.gradientOpacity = o2;
                const l2 = "fills" === n2 ? e.setFillGradient.bind(e) : e.setBorderGradient.bind(e), d2 = Og(e, this.__page, s2);
                l2(this.__page, d2, r, c2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log("setGradientOpacity:", t5), this.__repo.rollback();
        }
    }
    setShapesFillColor(t4) {
        const e = this.__repo.start("setShapesFillColor");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillColor(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillEnabled(t4) {
        const e = this.__repo.start("setShapesFillEnabled");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillEnable(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillType(t4) {
        const e = this.__repo.start("setShapesFillType");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s), a2 = o2 instanceof Oi ? o2.style.fills : o2.value;
                e.setFillType(this.__page, o2, r, n2), a2[r].imageScaleMode || e.setFillScaleMode(this.__page, o2, r, Mt.Fill);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillImageScaleMode(t4) {
        const e = this.__repo.start("setShapesFillImageScaleMode");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                if (e.setFillScaleMode(this.__page, o2, r, n2), n2 === Mt.Tile) {
                    (o2 instanceof Oi ? o2.style.fills : o2.value)[r].scale || e.setFillImageScale(this.__page, o2, r, 0.5);
                }
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillImageRef(t4) {
        const e = this.__repo.start("setShapesFillImageRef");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillImageRef(this.__document, this.__page, o2, r, n2.urlRef, n2.imageMgr), e.setFillImageOriginWidth(this.__page, o2, r, n2.origin.width), e.setFillImageOriginHeight(this.__page, o2, r, n2.origin.height);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillImageRotate(t4) {
        const e = this.__repo.start("setShapesFillImageRotate");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillImageRotate(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillImageScale(t4) {
        const e = this.__repo.start("setShapesFillImageScale");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillImageScale(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillEdit(t4, e, i) {
        const s = this.__repo.start("setShapesFillEdit");
        try {
            const r = Og(s, this.__page, t4);
            s.setFillEdit(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesFillFilter(t4) {
        const e = this.__repo.start("setShapesFillFilter");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Og(e, this.__page, s);
                e.setFillImageFilter(this.__page, o2, r, n2.key, n2.value);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesAddFill(t4) {
        const e = this.__repo.start("shapesAddFill");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i], n2 = Og(e, this.__page, s), o2 = n2 instanceof Oi ? n2.style.fills.length : n2.value.length;
                e.addFillAt(this.__page, n2, r, o2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesDeleteFill(t4) {
        const e = this.__repo.start("shapesDeleteFill");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r } = t4[i], n2 = Og(e, this.__page, s);
                e.deleteFillAt(this.__page, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesFillsUnify(t4) {
        const e = this.__repo.start("shapesFillsUnify");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i], n2 = Og(e, this.__page, s);
                e.deleteFills(this.__page, n2, 0, s.style.fills.length), e.addFills(this.__page, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderColor(t4) {
        const e = this.__repo.start("setShapesBorderColor");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderColor(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderEnabled(t4) {
        const e = this.__repo.start("setShapesBorderEnabled");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderEnable(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderType(t4) {
        const e = this.__repo.start("setShapesBorderType");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderFillType(this.__page, o2, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesAddBorder(t4) {
        const e = this.__repo.start("shapesAddBorder");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i], n2 = Rg(e, this.__page, s), o2 = n2 instanceof Oi ? n2.style.borders.length : n2.value.length;
                e.addBorderAt(this.__page, n2, r, o2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    shapesDeleteBorder(t4) {
        const e = this.__repo.start("shapesDeleteBorder");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r } = t4[i], n2 = Rg(e, this.__page, s);
                e.deleteBorderAt(this.__page, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesBordersUnify(t4) {
        const e = this.__repo.start("shapesBordersUnify");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i], n2 = Rg(e, this.__page, s);
                e.deleteBorders(this.__page, n2, 0, s.style.borders.length), e.addBorders(this.__page, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderPosition(t4) {
        const e = this.__repo.start("setShapesBorderPosition");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                if (s.type === Vt.Table) continue;
                const o2 = Rg(e, this.__page, s);
                e.setBorderPosition(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderThickness(t4) {
        const e = this.__repo.start("setShapesBorderThickness");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s), a2 = s.getBorders()[n2].sideSetting.sideType;
                switch (a2) {
                    case Dt.Normal:
                        e.setBorderSide(this.__page, o2, n2, new Me(a2, r, r, r, r));
                        break;
                    case Dt.Top:
                        e.setBorderThicknessTop(this.__page, o2, n2, r);
                        break;
                    case Dt.Right:
                        e.setBorderThicknessRight(this.__page, o2, n2, r);
                        break;
                    case Dt.Bottom:
                        e.setBorderThicknessBottom(this.__page, o2, n2, r);
                        break;
                    case Dt.Left:
                        e.setBorderThicknessLeft(this.__page, o2, n2, r);
                        break;
                    default:
                        e.setBorderSide(this.__page, o2, n2, new Me(a2, r, r, r, r));
                }
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderStyle(t4) {
        const e = this.__repo.start("setShapesBorderStyle");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderStyle(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBorderFillExchange(e) {
        try {
            const i = this.__repo.start("setShapeBorderFillExchange");
            for (let s = 0; s < e.length; s++) {
                const r = e[s], n2 = r.getBorders(), o2 = r.getFills();
                let a2 = new G(), h2 = new G();
                for (let e2 = 0; e2 < n2.length; e2++) {
                    const { isEnabled: i2, color: r2, fillType: a3, gradient: c3, contextSettings: l3, imageRef: d2, transform: p2, paintFilter: u, imageScaleMode: f2, scale: g2, rotation: m2, originalImageHeight: _2, originalImageWidth: y2 } = n2[e2], x2 = new es([s], v4(), i2, a3, r2);
                    x2.gradient = c3, x2.contextSettings = l3, o2.length > e2 && (x2.fillRule = o2[e2].fillRule), x2.imageRef = d2, x2.transform = p2, x2.paintFilter = u, x2.imageScaleMode = f2, x2.scale = g2, x2.rotation = m2, x2.originalImageHeight = _2, x2.originalImageWidth = y2;
                    const w2 = n2[e2].getImageMgr();
                    w2 && x2.setImageMgr(w2), h2.unshift(x2);
                }
                for (let e2 = 0; e2 < o2.length; e2++) {
                    const { isEnabled: i2, color: r2, fillType: h3, gradient: c3, contextSettings: l3, imageRef: d2, transform: p2, paintFilter: u, imageScaleMode: f2, scale: g2, rotation: m2, originalImageHeight: _2, originalImageWidth: y2 } = o2[e2];
                    let x2, w2 = h3;
                    if (h3 === xt.Pattern && (w2 = xt.SolidColor), n2.length > e2) {
                        const { position: o3, borderStyle: a3, thickness: h4, cornerType: d3, sideSetting: p3 } = n2[e2];
                        x2 = new ts([s], v4(), i2, w2, r2, o3, h4, a3, d3, p3), x2.gradient = c3, x2.contextSettings = l3;
                    } else {
                        const e3 = new Me(Dt.Normal, 1, 1, 1, 1);
                        x2 = new ts([s], v4(), i2, w2, r2, ht.Inner, 1, new Kt(0, 0), ut.Miter, e3), x2.gradient = c3, x2.contextSettings = l3;
                    }
                    x2.imageRef = d2, x2.transform = p2, x2.paintFilter = u, x2.imageScaleMode = f2, x2.scale = g2, x2.rotation = m2, x2.originalImageHeight = _2, x2.originalImageWidth = y2;
                    const b2 = o2[e2].getImageMgr();
                    b2 && x2.setImageMgr(b2), a2.unshift(x2);
                }
                const c2 = Og(i, this.__page, r);
                i.deleteFills(this.__page, c2, 0, r.style.fills.length), i.addFills(this.__page, c2, h2);
                const l2 = Rg(i, this.__page, r);
                i.deleteBorders(this.__page, l2, 0, r.style.borders.length), i.addBorders(this.__page, l2, a2);
            }
            this.__repo.commit();
        } catch (t4) {
            console.log(t4, "error"), this.__repo.rollback();
        }
    }
    setShapesBorderCornerType(t4) {
        const e = this.__repo.start("setShapesBorderCornerType");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderCornerType(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesBorderSide(t4) {
        const e = this.__repo.start("setShapesBorderSide");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderSide(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBorderThicknessTop(t4) {
        const e = this.__repo.start("setShapeBorderThicknessTop");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderThicknessTop(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBorderThicknessRight(t4) {
        const e = this.__repo.start("setShapeBorderThicknessRight");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderThicknessRight(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBorderThicknessBottom(t4) {
        const e = this.__repo.start("setShapeBorderThicknessBottom");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderThicknessBottom(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBorderThicknessLeft(t4) {
        const e = this.__repo.start("setShapeBorderThicknessLeft");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i], o2 = Rg(e, this.__page, s);
                e.setBorderThicknessLeft(this.__page, o2, n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesMarkerType(t4) {
        const e = this.__repo.start("setShapesMarkerType");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                Fg(e, this.__page, s, jt.MarkerType, r.isEnd ? Et.EndMarkerType : Et.StartMarkerType, r.mt) || (r.isEnd ? e.shapeModifyEndMarkerType(this.__page, $c(s), r.mt) : e.shapeModifyStartMarkerType(this.__page, $c(s), r.mt));
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesEndpoint(t4) {
        const e = this.__repo.start("setShapesEndpoint");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                Fg(e, this.__page, s, jt.MarkerType, Et.StartMarkerType, r.mt) ? Fg(e, this.__page, s, jt.MarkerType, Et.EndMarkerType, r.mt) : (e.shapeModifyEndMarkerType(this.__page, $c(s), r), e.shapeModifyStartMarkerType(this.__page, $c(s), r));
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    exchangeShapesMarkerType(t4) {
        const e = this.__repo.start("exchangeShapesMarkerType");
        try {
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i], n2 = s.startMarkerType, o2 = s.endMarkerType;
                o2 !== n2 && (Fg(e, this.__page, s, jt.MarkerType, Et.EndMarkerType, n2 || Ct.Line) ? Fg(e, this.__page, s, jt.MarkerType, Et.StartMarkerType, o2 || Ct.Line) : (e.shapeModifyEndMarkerType(this.__page, $c(s), n2 || Ct.Line), e.shapeModifyStartMarkerType(this.__page, $c(s), o2 || Ct.Line)));
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowOffsetY(t4) {
        try {
            const e = this.__repo.start("setShapesShadowOffsetY");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                e.setShadowOffsetY(this.__page, $c(s), n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowOffsetX(t4) {
        try {
            const e = this.__repo.start("setShapesShadowOffsetX");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                e.setShadowOffsetX(this.__page, $c(s), n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowSpread(t4) {
        try {
            const e = this.__repo.start("setShapesShadowSpread");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                e.setShadowSpread(this.__page, $c(s), n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowBlurRadius(t4) {
        try {
            const e = this.__repo.start("setShapesShadowBlurRadius");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                e.setShadowBlur(this.__page, $c(s), n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowColor(t4) {
        try {
            const e = this.__repo.start("setShapesShadowColor");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setShadowColor(this.__page, $c(s), r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowPosition(t4) {
        try {
            const e = this.__repo.start("setShapesShadowPosition");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r, index: n2 } = t4[i];
                e.setShadowPosition(this.__page, $c(s), n2, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesShadowEnabled(t4) {
        try {
            const e = this.__repo.start("setShapesShadowEnabled");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setShadowEnable(this.__page, $c(s), r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesDeleteShasow(t4) {
        try {
            const e = this.__repo.start("shapesDeleteShasow");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r } = t4[i];
                e.deleteShadowAt(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesAddShadow(t4) {
        try {
            const e = this.__repo.start("shapesAddShadow");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.addShadow(this.__page, $c(s), r, s.style.shadows.length);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesShadowsUnify(t4) {
        try {
            const e = this.__repo.start("shapesShadowsUnify");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.deleteShadows(this.__page, $c(s), 0, s.style.shadows.length), e.addShadows(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesAddBlur(t4) {
        try {
            const e = this.__repo.start("shapesAddBlur");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.addBlur(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesBlurUnify(t4) {
        try {
            const e = this.__repo.start("shapesBlurUnify");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.deleteBlur(this.__page, $c(s)), e.addBlur(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapeDeleteBlur(t4) {
        try {
            const e = this.__repo.start("shapeDeleteBlur");
            for (let i = 0; i < t4.length; i++) {
                const s = t4[i];
                e.deleteBlur(this.__page, $c(s));
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBlurEnabled(t4) {
        try {
            const e = this.__repo.start("setShapeBlurEnabled");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.shapeModifyBlurEdabled(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBlurSaturation(t4) {
        try {
            const e = this.__repo.start("setShapeBlurSaturation");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.shapeModifyBlurSaturation(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapeBlurType(t4) {
        try {
            const e = this.__repo.start("setShapeBlurType");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                e.shapeModifyBlurType(this.__page, $c(s), r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesExportFormatUnify(t4) {
        try {
            const e = this.__repo.start("shapesExportFormatUnify");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                s.exportOptions && e.deleteExportFormats(this.__page, s, 0, s.exportOptions.exportFormats.length), e.addExportFormats(this.__page, s, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesAddExportFormat(t4) {
        try {
            const e = this.__repo.start("shapesAddExportFormat");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, value: r } = t4[i];
                for (let t5 = 0; t5 < r.length; t5++) {
                    const i2 = r[t5], n2 = s.exportOptions ? s.exportOptions.exportFormats.length : 0;
                    e.addExportFormat(this.__page, s, i2, n2);
                }
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    pageAddExportFormat(t4) {
        try {
            const e = this.__repo.start("pageAddExportFormat");
            for (let i = 0; i < t4.length; i++) {
                const s = t4[i], r = this.__page.exportOptions ? this.__page.exportOptions.exportFormats.length : 0;
                e.addPageExportFormat(this.__page, s, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPageExportPreviewUnfold(t4) {
        try {
            this.__repo.start("setPageExportPreviewUnfold").setPageExportPreviewUnfold(this.__document, this.__page.id, t4), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shapesDeleteExportFormat(t4) {
        try {
            const e = this.__repo.start("shapesDeleteExportFormat");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r } = t4[i];
                e.deleteExportFormatAt(this.__page, s, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    pageDeleteExportFormat(t4) {
        var _a2;
        try {
            const e = (_a2 = this.__page.exportOptions) == null ? void 0 : _a2.exportFormats[t4];
            if (e) {
                this.__repo.start("pageDeleteExportFormat").deletePageExportFormatAt(this.__page, t4), this.__repo.commit();
            }
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesExportFormatScale(t4) {
        try {
            const e = this.__repo.start("setShapesExportFormatScale");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setExportFormatScale(this.__page, s, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPageExportFormatScale(t4, e) {
        try {
            this.__repo.start("setPageExportFormatScale").setPageExportFormatScale(this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesExportFormatName(t4) {
        try {
            const e = this.__repo.start("setShapesExportFormatName");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setExportFormatName(this.__page, s, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPageExportFormatName(t4, e) {
        try {
            this.__repo.start("setPageExportFormatName").setPageExportFormatName(this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesExportFormatPerfix(t4) {
        try {
            const e = this.__repo.start("setShapesExportFormatPerfix");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setExportFormatPerfix(this.__page, s, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPageExportFormatPerfix(t4, e) {
        try {
            this.__repo.start("setPageExportFormatPerfix").setPageExportFormatPerfix(this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setShapesExportFormatFileFormat(t4) {
        try {
            const e = this.__repo.start("setShapesExportFormatFileFormat");
            for (let i = 0; i < t4.length; i++) {
                const { target: s, index: r, value: n2 } = t4[i];
                e.setExportFormatFileFormat(this.__page, s, r, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPageExportFormatFileFormat(t4, e) {
        try {
            this.__repo.start("setPageExportFormatFileFormat").setPageExportFormatFileFormat(this.__page, t4, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeStart(t4, e) {
        try {
            const i = this.__repo.start("setPrototypeStart"), s = $c(t4);
            i.setShapeProtoStart(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    delPrototypeStart(t4) {
        try {
            const e = this.__repo.start("delPrototypeStart"), i = $c(t4);
            e.setShapeProtoStart(this.__page, i, void 0), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    shape4protoActions(t4, e, i, s) {
        const r = Ag(e, jt.ProtoInteractions, Et.ProtoInteractions, (t5) => {
            const e2 = new G();
            if (s) {
                const t6 = (i.prototypeInterActions || []).find((t7) => t7.id === s);
                t6 && e2.push(Gn(t6));
            }
            return e2;
        }, t4, i);
        if (r && s && !r.value.find((t5) => t5.id === s)) {
            const e2 = i.prototypeInterActions, n2 = e2 && e2.find((t5) => t5.id === s);
            if (n2) {
                const e3 = new Fe(new G(), s, new Ae(n2.event.interactionType), new Ee(n2.actions.connectionType));
                t4.insertShapeprototypeInteractions(this.__page, r, e3);
            }
        }
        return r || i.data;
    }
    insertPrototypeAction(t4, e) {
        try {
            const i = this.__repo.start("insertPrototypeAction"), s = this.shape4protoActions(i, this.__page, t4, void 0);
            i.insertShapeprototypeInteractions(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    deletePrototypeAction(t4, e) {
        try {
            const i = this.__repo.start("deletePrototypeAction"), s = this.shape4protoActions(i, this.__page, t4, e);
            s instanceof Ri ? i.shapeModifyPrototypeActionDeleted(this.__page, s, e, true) : i.deleteShapePrototypeInteractions(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionEvent(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionEvent"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionEvent(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionEventTime(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionEventTime"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionEventTime(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionConnNav(t4, e, i, s) {
        var _a2, _b, _c2, _d2;
        try {
            const r = this.__repo.start("setPrototypeActionConnectionType"), n2 = this.shape4protoActions(r, this.__page, t4, e), o2 = (_b = (_a2 = t4.prototypeInterActions) == null ? void 0 : _a2.find((t5) => t5.id === e)) == null ? void 0 : _b.actions.transitionType, a2 = (_d2 = (_c2 = t4.prototypeInterActions) == null ? void 0 : _c2.find((t5) => t5.id === e)) == null ? void 0 : _d2.actions.navigationType;
            if (r.shapeModifyPrototypeActionConnNav(this.__page, n2, e, i, s), s === Lt.SCROLLTO && a2 !== Lt.SCROLLTO) {
                const t5 = [Pt.INSTANTTRANSITION, Pt.SCROLLANIMATE];
                if (!o2) return;
                t5.includes(o2) || r.shapeModifyPrototypeActionTransitionType(this.__page, n2, e, Pt.INSTANTTRANSITION), r.shapeModifyPrototypeActionTargetNodeID(this.__page, n2, e, void 0);
            }
            if (s === Lt.SWAPSTATE && a2 !== Lt.SWAPSTATE) {
                const t5 = [Pt.INSTANTTRANSITION, Pt.DISSOLVE];
                if (!o2) return;
                t5.includes(o2) || r.shapeModifyPrototypeActionTransitionType(this.__page, n2, e, Pt.INSTANTTRANSITION), r.shapeModifyPrototypeActionTargetNodeID(this.__page, n2, e, void 0);
            }
            if (s === Lt.OVERLAY || s === Lt.SWAP || s === Lt.NAVIGATE) {
                const t5 = [Pt.INSTANTTRANSITION, Pt.DISSOLVE, Pt.MOVEFROMLEFT, Pt.MOVEFROMRIGHT, Pt.MOVEFROMTOP, Pt.MOVEFROMBOTTOM];
                if (!o2) return;
                t5.includes(o2) || r.shapeModifyPrototypeActionTransitionType(this.__page, n2, e, Pt.INSTANTTRANSITION);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionTargetNodeID(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionTargetNodeID"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionTargetNodeID(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionTransitionType(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionTransitionType"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionTransitionType(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionTransitionDuration(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionTransitionDuration"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionTransitionDuration(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionEasingType(t4, e, i, s) {
        try {
            const r = this.__repo.start("setPrototypeActionEasingType"), n2 = this.shape4protoActions(r, this.__page, t4, e);
            r.shapeModifyPrototypeActionEasingType(this.__page, n2, e, i, s), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionConnectionURL(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionConnectionURL"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionConnectionURL(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionOpenUrlInNewTab(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionOpenUrlInNewTab"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionOpenUrlInNewTab(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeActionEasingFunction(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeActionOpenUrlInNewTab"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeActionEasingFunction(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeExtraScrollOffsetX(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeExtraScrollOffsetX"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeExtraScrollOffsetX(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setPrototypeExtraScrollOffsetY(t4, e, i) {
        try {
            const s = this.__repo.start("setPrototypeExtraScrollOffsetY"), r = this.shape4protoActions(s, this.__page, t4, e);
            s.shapeModifyPrototypeExtraScrollOffsetY(this.__page, r, e, i), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayPositionType(t4, e) {
        try {
            const i = this.__repo.start("setOverlayPositionType"), s = $c(t4);
            i.shapeModifyOverlayPositionType(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayPositionTypeMarginTop(t4, e) {
        try {
            const i = this.__repo.start("setOverlayPositionTypeMarginTop"), s = $c(t4);
            i.shapeModifyOverlayPositionTypeMarginTop(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayPositionTypeMarginBottom(t4, e) {
        try {
            const i = this.__repo.start("setOverlayPositionTypeMarginBottom"), s = $c(t4);
            i.shapeModifyOverlayPositionTypeMarginBottom(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayPositionTypeMarginLeft(t4, e) {
        try {
            const i = this.__repo.start("setOverlayPositionTypeMarginLeft"), s = $c(t4);
            i.shapeModifyOverlayPositionTypeMarginLeft(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayPositionTypeMarginRight(t4, e) {
        try {
            const i = this.__repo.start("setOverlayPositionTypeMarginRight"), s = $c(t4);
            i.shapeModifyOverlayPositionTypeMarginRight(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayBackgroundInteraction(t4, e) {
        try {
            const i = this.__repo.start("setOverlayBackgroundInteraction"), s = $c(t4);
            i.shapeModifyOverlayBackgroundInteraction(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setOverlayBackgroundAppearance(t4, e) {
        try {
            const i = this.__repo.start("setOverlayBackgroundAppearance"), s = $c(t4);
            i.shapeModifyOverlayBackgroundAppearance(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setscrollDirection(t4, e) {
        try {
            const i = this.__repo.start("setscrollDirection"), s = $c(t4);
            i.shapeModifyscrollDirection(this.__page, s, e), this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    toggleShapesVisible(t4) {
        const e = this.__repo.start("setShapesVisible");
        try {
            for (let i = 0; i < t4.length; i++) {
                let s = t4[i];
                if (!s) continue;
                const r = !s.isVisible;
                Fg(e, this.__page, s, jt.Visible, Et.Visible, r) || e.shapeModifyVisible(this.__page, s.data, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    toggleShapesLock(t4) {
        const e = this.__repo.start("setShapesLocked");
        try {
            for (let i = 0; i < t4.length; i++) {
                let s = t4[i];
                const r = !s.isLocked;
                Fg(e, this.__page, s, jt.Lock, Et.Lock, r) || e.shapeModifyLock(this.__page, s.data, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    setBackground(t4) {
        const e = this.__repo.start("setBackground");
        try {
            e.pageModifyBackground(this.__document, this.__page.id, t4), this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    setShapesRadius(t4, e, i, s, r) {
        const n2 = this.__repo.start("setShapesRadius");
        try {
            for (let o2 = 0; o2 < t4.length; o2++) {
                const a2 = t4[o2];
                n2.shapeModifyRadius(this.__page, a2, e, i, s, r);
            }
            this.__repo.commit();
        } catch (t5) {
            this.__repo.rollback();
        }
    }
    afterShapeListDrag(t4, e, i) {
        if ((e.type === Vt.SymbolRef || e.type === Vt.SymbolUnion || e.isVirtualShape) && "inner" === i) return false;
        const s = e.parent;
        if (!s || s.isVirtualShape) return false;
        let r = [];
        for (let i2 = 0, s2 = t4.length; i2 < s2; i2++) {
            const s3 = t4[i2];
            if (s3.isVirtualShape) continue;
            let n2 = false, o2 = e;
            for (; o2; ) {
                if (o2.id === s3.id) {
                    n2 = true;
                    break;
                }
                o2 = o2.parent;
            }
            n2 || r.push(s3);
        }
        if (!r.length) return false;
        try {
            const t5 = this.__repo.start("afterShapeListDrag");
            if ("inner" === i) for (let i2 = 0, s2 = r.length; i2 < s2; i2++) {
                const s3 = r[i2], n2 = s3.parent;
                if (!n2) continue;
                if (Vg(e, s3)) continue;
                const o2 = s3.frame2Root();
                let a2 = e.childs.length;
                n2.id === e.id && a2--, t5.shapeMove(this.__page, n2, n2.indexOfChild(s3), e, a2), rg(t5, this.__page, s3, o2.x, o2.y), eg(n2) && this.delete_inner(this.__page, n2, t5);
            }
            else {
                "lower" === i && (r = r.reverse());
                let n2 = -1;
                for (let o2 = 0, a2 = r.length; o2 < a2; o2++) {
                    const a3 = r[o2], h2 = a3.parent;
                    if (!h2 || s.type === Vt.SymbolRef || s.type === Vt.SymbolUnion) continue;
                    if (yg(s) && Bg([a3])) continue;
                    const c2 = a3.naviChilds || a3.childs;
                    if (c2 == null ? void 0 : c2.length) {
                        const t6 = a3 instanceof Ar ? a3.symData : a3;
                        if (!t6 || ug(t6, s.id)) continue;
                    }
                    const l2 = a3.frame2Root();
                    let d2 = 0;
                    d2 = n2 >= 0 ? n2 : s.indexOfChild(e), h2.id === s.id && (d2 = tg(h2, a3, e, d2)), "upper" === i && d2++, t5.shapeMove(this.__page, h2, h2.indexOfChild(a3), s, d2);
                    const p2 = s.indexOfChild(a3);
                    p2 >= 0 && (n2 = p2), rg(t5, this.__page, a3, l2.x, l2.y), eg(h2) && this.delete_inner(this.__page, h2, t5);
                }
            }
            return this.__repo.commit(), true;
        } catch (t5) {
            return console.log(t5), this.__repo.rollback(), false;
        }
    }
    setLinesLength(t4, e) {
        const i = this.__repo.start("setLinesLength");
        try {
            for (let s = 0, r = t4.length; s < r; s++) {
                const r2 = t4[s];
                if (r2.type !== Vt.Line) continue;
                const n2 = r2.matrix2Root().computeCoord2(0, 0), o2 = r2.size, a2 = pm({ x: 0, y: 0 }, { x: o2.width, y: o2.height });
                i.shapeModifyWH(this.__page, r2, e * Math.cos(a2), e * Math.sin(a2));
                const h2 = r2.matrix2Root().computeCoord2(0, 0);
                ng(i, this.__page, r2, n2.x - h2.x, n2.y - h2.y);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    modifyStyleByEyeDropper(e, i) {
        try {
            const s = this.__repo.start("setLinesLength"), r = this.__page;
            for (let n2 = 0; n2 < e.length; n2++) {
                const o2 = $c(e[n2]);
                if (o2.isVirtualShape) continue;
                const a2 = new Ji(i.alpha, i.red, i.green, i.blue);
                if (o2.type === Vt.Text) {
                    const t4 = e[n2];
                    s.textModifyColor(r, t4, 0, t4.text.length, a2);
                    continue;
                }
                const h2 = o2.style;
                if (h2.fills.length) {
                    const t4 = Og(s, r, e[n2]);
                    s.setFillColor(r, t4, h2.fills.length - 1, a2);
                    continue;
                }
                if (h2.borders.length) {
                    const t4 = Rg(s, r, e[n2]);
                    s.setBorderColor(r, t4, h2.borders.length - 1, a2);
                    continue;
                }
                const c2 = Og(s, r, e[n2]), l2 = new es(new G(), v4(), true, xt.SolidColor, a2);
                s.addFillAt(r, c2, l2, 0);
            }
            this.__repo.commit();
        } catch (t4) {
            console.error("modifyStyleByEyeDropper:", t4), this.__repo.rollback();
        }
    }
    pasteProperties(t4, e) {
        var _a2, _b;
        try {
            const i = this.__repo.start("pasteProperties"), s = this.__page, r = e.fills, n2 = e.borders, o2 = e.shadows, a2 = e.blur, h2 = e.radius, c2 = e.contextSetting, l2 = e.mark, d2 = e.text;
            if (r.length || n2.length) {
                const e2 = this.__document, o3 = new class {
                    constructor() {
                        __publicField(this, "document", e2);
                        __publicField(this, "curPage", s.id);
                        __publicField(this, "fmtVer", rn);
                    }
                }(), a3 = function t5(e3) {
                    return e3.reduce((e4, i2) => {
                        if (i2.type !== Vt.Group) return e4.concat(i2);
                        {
                            const s2 = i2.childs;
                            if (Array.isArray(s2)) return e4.concat(t5(s2));
                        }
                    }, []);
                }(t4);
                for (const t5 of a3) {
                    $c(t5);
                    {
                        const e3 = Og(i, s, t5);
                        if (i.deleteFills(s, e3, 0, t5.style.fills.length), r == null ? void 0 : r.length) {
                            const t6 = r.map((t7) => Kn(t7, o3));
                            i.addFills(s, e3, t6);
                        }
                    }
                    {
                        const e3 = Rg(i, s, t5);
                        if (i.deleteBorders(s, e3, 0, t5.style.borders.length), n2 == null ? void 0 : n2.length) {
                            const t6 = n2.map((t7) => Jn(t7));
                            i.addBorders(s, e3, t6);
                        }
                    }
                }
            }
            for (let e2 = 0; e2 < t4.length; e2++) {
                const r2 = t4[e2], n3 = $c(r2);
                if (!n3.isVirtualShape) {
                    {
                        const t5 = Lg(i, s, r2);
                        if (i.deleteShadows(s, t5, 0, r2.style.shadows.length), o2 == null ? void 0 : o2.length) {
                            const e3 = o2.map((t6) => kn(t6));
                            i.addShadows(s, t5, e3);
                        }
                    }
                    if (i.deleteBlur(this.__page, n3), a2 && i.addBlur(this.__page, n3, Ln(a2)), h2) {
                        let r3 = false;
                        if (n3 instanceof Ar) {
                            const r4 = Pg(i, s, t4[e2]);
                            i.shapeModifyRadius2(s, r4, h2[0], h2[1], h2[2], h2[3]);
                        } else if (n3 instanceof ji || n3 instanceof Ni) i.shapeModifyRadius2(s, n3, h2[0], h2[1], h2[2], h2[3]);
                        else if (n3 instanceof Vi || n3 instanceof Di) {
                            if (n3.radiusType === De.Rect) {
                                const t5 = n3.pathsegs[0].points;
                                for (let e3 = 0; e3 < 4; e3++) {
                                    const r4 = h2[e3];
                                    t5[e3].radius === r4 || r4 < 0 || i.modifyPointCornerRadius(s, n3, e3, r4, 0);
                                }
                            } else n3.pathsegs.forEach((t5, e3) => {
                                for (let r4 = 0; r4 < t5.points.length; r4++) t5.points[r4].radius !== h2[0] && i.modifyPointCornerRadius(s, n3, r4, h2[0], e3);
                            });
                            r3 = true;
                        } else i.shapeModifyFixedRadius(s, n3, h2[0]);
                        r3 && Kc(i, this.__page, n3);
                    }
                    if (c2) {
                        const t5 = ln(c2);
                        i.shapeModifyContextSettingsOpacity(s, n3, t5.opacity ?? 1), i.shapeModifyContextSettingsBlendMode(s, n3, t5.blenMode);
                    }
                    if (l2 == null ? void 0 : l2.start) {
                        const t5 = yn(l2.start);
                        i.shapeModifyStartMarkerType(s, n3, t5);
                    }
                    if (l2 == null ? void 0 : l2.end) {
                        const t5 = yn(l2.end);
                        i.shapeModifyEndMarkerType(s, n3, t5);
                    }
                    if (d2 && n3 instanceof Gi) {
                        const t5 = ro(d2), e3 = (_a2 = t5.paras[0]) == null ? void 0 : _a2.spans[0], o3 = n3.text.length, a3 = r2;
                        let h3 = false;
                        const c3 = t5.attr;
                        c3 && (i.shapeModifyTextVerAlign(s, a3, c3.verAlign), i.shapeModifyTextBehaviour(s, a3.text, c3.textBehaviour)), e3 && (i.textModifyColor(s, a3, 0, o3, e3.color), i.textModifyFontName(s, a3, 0, o3, e3.fontName), i.textModifyFontSize(s, a3, 0, o3, e3.fontSize), i.textModifyItalic(s, a3, !!e3.italic, 0, o3), i.textModifyKerning(s, a3, e3.kerning || 0, 0, o3), i.textModifyUnderline(s, a3, e3.underline, 0, o3), i.textModifyStrikethrough(s, a3, e3.strikethrough, 0, o3), i.textModifyWeight(s, a3, e3.weight, 0, o3), i.textModifyHighlightColor(s, a3, 0, o3, e3.highlight), h3 = true);
                        const l3 = (_b = t5.paras[0]) == null ? void 0 : _b.attr;
                        l3 && (i.textModifyParaSpacing(s, a3, l3.paraSpacing || 0, 0, o3), i.textModifyMinLineHeight(s, a3, l3.minimumLineHeight, 0, o3), i.textModifyMaxLineHeight(s, a3, l3.maximumLineHeight, 0, o3), i.textModifyHorAlign(s, a3, l3.alignment, 0, o3), h3 = true), h3 && Df(i, s, a3);
                    }
                }
            }
            this.__repo.commit();
        } catch (t5) {
            console.error("pasteProperties:", t5), this.__repo.rollback();
        }
    }
    outlineShapes(e, i) {
        var _a2, _b;
        try {
            const s = this.__document, r = this.__page, n2 = [], o2 = this.__repo.start("outlineShapes", (t4, e2, i2) => {
                var _a3;
                const s2 = {};
                s2.shapes = e2 ? ((_a3 = i2.saveselection) == null ? void 0 : _a3.shapes) || [] : n2, t4.restore(s2);
            }), a2 = (t4) => {
                const e2 = [];
                for (const i2 of t4) i2 instanceof Tc || i2 instanceof kc || (i2.type === Vt.Group || i2 instanceof Hh || i2 instanceof sc ? e2.push(...a2(i2.childs)) : e2.push(i2));
                return e2;
            }, h2 = a2(e);
            for (const e2 of h2) if (e2 instanceof Ic) {
                const i2 = $c(e2), a3 = e2.getTextPath(), h3 = fm(e2), c2 = this.cloneStyle(h3), l2 = (_b = (_a2 = i2.text.paras[0]) == null ? void 0 : _a2.spans[0]) == null ? void 0 : _b.color;
                if (l2) {
                    const e3 = c2.fills.length;
                    c2.fills.push(new es([e3], v4(), true, xt.SolidColor, l2));
                }
                let d2 = Ad(e2.name, e2.frame, a3, c2);
                d2.transform = i2.transform.clone(), d2.mask = i2.mask, d2.resizingConstraint = i2.resizingConstraint;
                const p2 = i2.parent, u = p2.indexOfChild(i2);
                o2.shapeDelete(s, r, p2, u), d2 = o2.shapeInsert(s, r, p2, d2, u), Kc(o2, r, d2), n2.push(d2.id);
            } else {
                const a3 = e2.getBorders();
                if (!a3.length) continue;
                const h3 = $c(e2), c2 = h3.parent, l2 = (a4) => {
                    const l3 = fm(e2), d2 = this.cloneStyle(l3), p2 = new es([0], v4(), true, a4.fillType, a4.color);
                    p2.gradient = a4.gradient, p2.fillType === xt.Pattern && (p2.fillType = xt.SolidColor), d2.fills = new G(p2), d2.borders.length = 0;
                    const u = dl(e2, a4);
                    let f2 = Ad(e2.name + i, e2.frame, u, d2);
                    f2.transform = h3.transform.clone(), f2.mask = h3.mask, f2.resizingConstraint = h3.resizingConstraint;
                    const g2 = c2.indexOfChild(h3);
                    f2 = o2.shapeInsert(s, r, c2, f2, g2 + 1), Kc(o2, r, f2), n2.push(f2.id);
                };
                for (let t4 = a3.length - 1; t4 > -1; t4--) l2(a3[t4]);
                h3.style.fills.length ? (o2.deleteBorders(r, h3, 0, a3.length), n2.push(e2.data.id)) : o2.shapeDelete(s, r, c2, c2.indexOfChild(h3));
            }
            this.__repo.commit();
        } catch (t4) {
            console.error("outlineShapes:", t4), this.__repo.rollback();
        }
    }
    insertImages(e, i) {
        try {
            const s = [], r = [], n2 = this.__repo.start("insertImagesToPage", (t4, e2, i2) => {
                var _a2;
                const r2 = {};
                r2.shapes = e2 ? ((_a2 = i2.saveselection) == null ? void 0 : _a2.shapes) || [] : s, t4.restore(r2);
            }), o2 = this.__document, a2 = this.__page, h2 = i ? $c(i) : this.__page;
            for (const i2 of e) if (i2.pack.size) {
                const { size: e2, name: c2, buff: l2, base64: d2 } = i2.pack, p2 = f(d2), u = `${v4()}.${p2}`;
                o2.mediasMgr.add(u, { buff: l2, base64: d2 });
                const g2 = new RegExp(`.${p2}|.jpg$`, "img"), m2 = Dd(c2.replace(g2, "") || "image", new _e(0, 0, e2.width, e2.height), o2.mediasMgr, e2, u);
                m2.transform = i2.transform;
                const _2 = h2.childs.length, y2 = n2.shapeInsert(o2, a2, h2, m2, _2);
                y2 && (s.push(y2.id), r.push({ shape: y2, upload: [{ ref: u, buff: l2 }] }));
            } else {
                const t4 = i2.pack.shape;
                t4.transform = i2.transform;
                const e2 = h2.childs.length, c2 = n2.shapeInsert(o2, a2, h2, t4, e2);
                if (c2) {
                    s.push(c2.id);
                    const t5 = [];
                    i2.pack.mediaResourceMgr.forEach((e3, i3) => {
                        t5.push({ ref: i3, buff: e3.buff });
                    }), r.push({ shape: c2, upload: t5 });
                }
            }
            return this.__repo.commit(), r;
        } catch (t4) {
            return this.__repo.rollback(), console.error("insertImagesToPage:", t4), false;
        }
    }
    flattenSelection(t4, e) {
        try {
            if (!t4.length) return;
            let e2 = false;
            const i = function t5(i2) {
                const s = [];
                for (const r of i2) {
                    if (r.isVirtualShape) {
                        e2 = true;
                        break;
                    }
                    r instanceof Hh || r instanceof sc || r.type === Vt.Group ? s.push(...t5(r.childs)) : s.push(r);
                }
                return s;
            }(t4);
            if (e2 || !i.length) return;
            for (const t5 of i) ;
        } catch (t5) {
            this.__repo.rollback(), console.error(t5);
        }
    }
    editor4Shape(t4) {
        return new qg(t4, this.__page, this.__repo, this.__document);
    }
    editor4TextShape(t4) {
        return new nm(t4, this.__page, this.__repo, this.__document);
    }
    editor4Table(t4) {
        return new dm(t4, this.__page, this.__repo, this.__document);
    }
}
class _m {
    constructor(t4, e, i) {
        __publicField(this, "__repo");
        __publicField(this, "__page");
        __publicField(this, "__document");
        this.__repo = e, this.__page = t4, this.__document = i;
    }
    resizingConstraint(t4) {
        return void 0 === t4.resizingConstraint ? Ne.Mask : t4.resizingConstraint;
    }
    disabled(t4) {
        var _a2, _b;
        return t4.isVirtualShape || ((_a2 = t4.parent) == null ? void 0 : _a2.type) !== Vt.Artboard && ((_b = t4.parent) == null ? void 0 : _b.type) !== Vt.Symbol;
    }
    fixedToLeft(t4) {
        try {
            const e = this.__repo.start("fixedToLeft");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedLeft(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToRight(t4) {
        try {
            const e = this.__repo.start("fixedToRight");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedRight(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToLR(t4) {
        try {
            const e = this.__repo.start("fixedToLR");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedLeftAndRight(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    HorizontaljustifyCenter(t4) {
        try {
            const e = this.__repo.start("HorizontaljustifyCenter");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToHorizontalJustifyCenter(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    scaleByWidth(t4) {
        try {
            const e = this.__repo.start("scaleByWidth");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToScaleByWidth(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToWidth(t4) {
        try {
            const e = this.__repo.start("fixedToWidth");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToWidthFixed(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    flexWidth(t4) {
        try {
            const e = this.__repo.start("flexWidth");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToWidthFlex(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToTop(t4) {
        try {
            const e = this.__repo.start("fixedToTop");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedTop(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToBottom(t4) {
        try {
            const e = this.__repo.start("fixedToBottom");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedBottom(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToTB(t4) {
        try {
            const e = this.__repo.start("fixedToTB");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToFixedTopAndBottom(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    VerticaljustifyCenter(t4) {
        try {
            const e = this.__repo.start("VerticaljustifyCenter");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToVerticalJustifyCenter(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    scaleByHeight(t4) {
        try {
            const e = this.__repo.start("VerticaljustifyCenter");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToScaleByHeight(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    fixedToHeight(t4) {
        try {
            const e = this.__repo.start("fixedToHeight");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToHeightFixed(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
    flexHeight(t4) {
        try {
            const e = this.__repo.start("flexHeight");
            for (let i = 0, s = t4.length; i < s; i++) {
                const s2 = t4[i];
                if (this.disabled(s2)) continue;
                const r = this.resizingConstraint(s2), n2 = Ne.setToHeightFlex(r);
                e.shapeModifyResizingConstraint(this.__page, s2, n2);
            }
            this.__repo.commit();
        } catch (t5) {
            console.log(t5), this.__repo.rollback();
        }
    }
}
class ym {
    constructor(t4, e, i) {
        __publicField(this, "m_data");
        __publicField(this, "m_repo");
        __publicField(this, "m_docEditor");
        this.m_data = t4, this.m_repo = e;
    }
    editor4Doc() {
        return void 0 === this.m_docEditor && (this.m_docEditor = new Vf(this.m_data, this.m_repo)), this.m_docEditor;
    }
    editor4Page(t4) {
        if (!(t4.data && t4.data instanceof qi)) throw Error("page.data is not Page!");
        return new mm(this.m_repo, t4.data, this.m_data);
    }
    editor4Shape(t4, e) {
        return new qg(e, t4.data, this.m_repo, this.m_data);
    }
    editor4TextShape(t4, e) {
        return new nm(e, t4.data, this.m_repo, this.m_data);
    }
    editor4Table(t4, e) {
        return new dm(e, t4.data, this.m_repo, this.m_data);
    }
    controller() {
        return new em(this.m_repo, this.data);
    }
    editor4ResizingConstraint(t4) {
        return new _m(t4, this.m_repo, this.data);
    }
    get data() {
        return this.m_data;
    }
    get repo() {
        return this.m_repo;
    }
}
var Em;
!function(t4) {
    t4[t4.normal = 0] = "normal", t4[t4.requestdata = 1] = "requestdata";
}(Em || (Em = {}));
class Am {
    constructor() {
        __publicField(this, "__tasks", []);
        __publicField(this, "__started", false);
        __publicField(this, "__timer");
        this.__intervalRun = this.__intervalRun.bind(this);
    }
    __sort() {
        this.__tasks.sort((t4, e) => e.priority - t4.priority);
    }
    __popTask(t4) {
        this.__tasks.length > 0 && this.__tasks[0].task === t4 && this.__tasks.splice(0, 1);
    }
    __next() {
        this.__timer = setTimeout(this.__intervalRun, 0);
    }
    async __intervalRun() {
        if (0 === this.__tasks.length) return void (this.__timer = void 0);
        this.__sort();
        const t4 = this.__tasks[0].task;
        if (!t4.isValid()) return this.__popTask(t4), void this.__next();
        await t4.run(), t4.isDone() && this.__popTask(t4), this.__next();
    }
    add(t4, e) {
        const i = { task: t4, priority: e };
        this.__tasks.push(i), this.__started && !this.__timer && this.__next();
        const s = this;
        return { remove() {
                const t5 = s.__tasks.indexOf(i);
                t5 >= 0 && s.__tasks.splice(t5, 0);
            } };
    }
    startLoop() {
        this.__started || (this.__started = true, this.__tasks.length > 0 && this.__next());
    }
}
class LCStorage {
    get(uri) {
        const __slices = uri.split("/");
        if (__slices.includes("medias")) {
            uri = "/static/images/" + (__slices.pop() || "");
        } else if (__slices.includes("pages")) {
            uri = "/static/" + (__slices.pop() || "");
        } else {
            uri = "/static/" + (__slices.pop() || "");
        }
        return new Promise((resolve, reject) => {
            fetch(uri).then(async (res) => {
                const stream = res.body;
                if (!stream) throw new Error("null");
                const reader = stream.getReader();
                const values = [];
                let count = 0;
                while (reader) {
                    const { value, done } = await reader.read();
                    if (value) {
                        values.push(value);
                        count += value.length;
                    }
                    if (done) break;
                }
                if (values.length) {
                    const units = new Uint8Array(count);
                    let index2 = 0;
                    for (const u of values) {
                        units.set(u, index2);
                        index2 += u.length;
                    }
                    resolve(units);
                } else reject("wrong value");
            }).catch(reject);
        });
    }
    put(uri, data, contentType) {
        throw new Error("not implements yet");
    }
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
    (function() {
        var undefined$1;
        var VERSION2 = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
            ["ary", WRAP_ARY_FLAG],
            ["bind", WRAP_BIND_FLAG],
            ["bindKey", WRAP_BIND_KEY_FLAG],
            ["curry", WRAP_CURRY_FLAG],
            ["curryRight", WRAP_CURRY_RIGHT_FLAG],
            ["flip", WRAP_FLIP_FLAG],
            ["partial", WRAP_PARTIAL_FLAG],
            ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
            ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
            rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
            rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
            rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
            rsUpper + "+" + rsOptContrUpper,
            rsOrdUpper,
            rsOrdLower,
            rsDigits,
            rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
            "Array",
            "Buffer",
            "DataView",
            "Date",
            "Error",
            "Float32Array",
            "Float64Array",
            "Function",
            "Int8Array",
            "Int16Array",
            "Int32Array",
            "Map",
            "Math",
            "Object",
            "Promise",
            "RegExp",
            "Set",
            "String",
            "Symbol",
            "TypeError",
            "Uint8Array",
            "Uint8ClampedArray",
            "Uint16Array",
            "Uint32Array",
            "WeakMap",
            "_",
            "clearTimeout",
            "isFinite",
            "parseInt",
            "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
            // Latin-1 Supplement block.
            "À": "A",
            "Á": "A",
            "Â": "A",
            "Ã": "A",
            "Ä": "A",
            "Å": "A",
            "à": "a",
            "á": "a",
            "â": "a",
            "ã": "a",
            "ä": "a",
            "å": "a",
            "Ç": "C",
            "ç": "c",
            "Ð": "D",
            "ð": "d",
            "È": "E",
            "É": "E",
            "Ê": "E",
            "Ë": "E",
            "è": "e",
            "é": "e",
            "ê": "e",
            "ë": "e",
            "Ì": "I",
            "Í": "I",
            "Î": "I",
            "Ï": "I",
            "ì": "i",
            "í": "i",
            "î": "i",
            "ï": "i",
            "Ñ": "N",
            "ñ": "n",
            "Ò": "O",
            "Ó": "O",
            "Ô": "O",
            "Õ": "O",
            "Ö": "O",
            "Ø": "O",
            "ò": "o",
            "ó": "o",
            "ô": "o",
            "õ": "o",
            "ö": "o",
            "ø": "o",
            "Ù": "U",
            "Ú": "U",
            "Û": "U",
            "Ü": "U",
            "ù": "u",
            "ú": "u",
            "û": "u",
            "ü": "u",
            "Ý": "Y",
            "ý": "y",
            "ÿ": "y",
            "Æ": "Ae",
            "æ": "ae",
            "Þ": "Th",
            "þ": "th",
            "ß": "ss",
            // Latin Extended-A block.
            "Ā": "A",
            "Ă": "A",
            "Ą": "A",
            "ā": "a",
            "ă": "a",
            "ą": "a",
            "Ć": "C",
            "Ĉ": "C",
            "Ċ": "C",
            "Č": "C",
            "ć": "c",
            "ĉ": "c",
            "ċ": "c",
            "č": "c",
            "Ď": "D",
            "Đ": "D",
            "ď": "d",
            "đ": "d",
            "Ē": "E",
            "Ĕ": "E",
            "Ė": "E",
            "Ę": "E",
            "Ě": "E",
            "ē": "e",
            "ĕ": "e",
            "ė": "e",
            "ę": "e",
            "ě": "e",
            "Ĝ": "G",
            "Ğ": "G",
            "Ġ": "G",
            "Ģ": "G",
            "ĝ": "g",
            "ğ": "g",
            "ġ": "g",
            "ģ": "g",
            "Ĥ": "H",
            "Ħ": "H",
            "ĥ": "h",
            "ħ": "h",
            "Ĩ": "I",
            "Ī": "I",
            "Ĭ": "I",
            "Į": "I",
            "İ": "I",
            "ĩ": "i",
            "ī": "i",
            "ĭ": "i",
            "į": "i",
            "ı": "i",
            "Ĵ": "J",
            "ĵ": "j",
            "Ķ": "K",
            "ķ": "k",
            "ĸ": "k",
            "Ĺ": "L",
            "Ļ": "L",
            "Ľ": "L",
            "Ŀ": "L",
            "Ł": "L",
            "ĺ": "l",
            "ļ": "l",
            "ľ": "l",
            "ŀ": "l",
            "ł": "l",
            "Ń": "N",
            "Ņ": "N",
            "Ň": "N",
            "Ŋ": "N",
            "ń": "n",
            "ņ": "n",
            "ň": "n",
            "ŋ": "n",
            "Ō": "O",
            "Ŏ": "O",
            "Ő": "O",
            "ō": "o",
            "ŏ": "o",
            "ő": "o",
            "Ŕ": "R",
            "Ŗ": "R",
            "Ř": "R",
            "ŕ": "r",
            "ŗ": "r",
            "ř": "r",
            "Ś": "S",
            "Ŝ": "S",
            "Ş": "S",
            "Š": "S",
            "ś": "s",
            "ŝ": "s",
            "ş": "s",
            "š": "s",
            "Ţ": "T",
            "Ť": "T",
            "Ŧ": "T",
            "ţ": "t",
            "ť": "t",
            "ŧ": "t",
            "Ũ": "U",
            "Ū": "U",
            "Ŭ": "U",
            "Ů": "U",
            "Ű": "U",
            "Ų": "U",
            "ũ": "u",
            "ū": "u",
            "ŭ": "u",
            "ů": "u",
            "ű": "u",
            "ų": "u",
            "Ŵ": "W",
            "ŵ": "w",
            "Ŷ": "Y",
            "ŷ": "y",
            "Ÿ": "Y",
            "Ź": "Z",
            "Ż": "Z",
            "Ž": "Z",
            "ź": "z",
            "ż": "z",
            "ž": "z",
            "Ĳ": "IJ",
            "ĳ": "ij",
            "Œ": "Oe",
            "œ": "oe",
            "ŉ": "'n",
            "ſ": "s"
        };
        var htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        var htmlUnescapes = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        };
        var stringEscapes = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = exports && !exports.nodeType && exports;
        var freeModule = freeExports && true && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
            try {
                var types = freeModule && freeModule.require && freeModule.require("util").types;
                if (types) {
                    return types;
                }
                return freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e) {
            }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply2(func, thisArg, args) {
            switch (args.length) {
                case 0:
                    return func.call(thisArg);
                case 1:
                    return func.call(thisArg, args[0]);
                case 2:
                    return func.call(thisArg, args[0], args[1]);
                case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
                var value = array[index2];
                setter(accumulator, value, iteratee(value), array);
            }
            return accumulator;
        }
        function arrayEach(array, iteratee) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
                if (iteratee(array[index2], index2, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEachRight(array, iteratee) {
            var length = array == null ? 0 : array.length;
            while (length--) {
                if (iteratee(array[length], length, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEvery(array, predicate) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
                if (!predicate(array[index2], index2, array)) {
                    return false;
                }
            }
            return true;
        }
        function arrayFilter(array, predicate) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index2 < length) {
                var value = array[index2];
                if (predicate(value, index2, array)) {
                    result[resIndex++] = value;
                }
            }
            return result;
        }
        function arrayIncludes(array, value) {
            var length = array == null ? 0 : array.length;
            return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator2) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
                if (comparator2(value, array[index2])) {
                    return true;
                }
            }
            return false;
        }
        function arrayMap(array, iteratee) {
            var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
            while (++index2 < length) {
                result[index2] = iteratee(array[index2], index2, array);
            }
            return result;
        }
        function arrayPush(array, values) {
            var index2 = -1, length = values.length, offset = array.length;
            while (++index2 < length) {
                array[offset + index2] = values[index2];
            }
            return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index2 = -1, length = array == null ? 0 : array.length;
            if (initAccum && length) {
                accumulator = array[++index2];
            }
            while (++index2 < length) {
                accumulator = iteratee(accumulator, array[index2], index2, array);
            }
            return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
            var length = array == null ? 0 : array.length;
            if (initAccum && length) {
                accumulator = array[--length];
            }
            while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
        }
        function arraySome(array, predicate) {
            var index2 = -1, length = array == null ? 0 : array.length;
            while (++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                    return true;
                }
            }
            return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
            return string.split("");
        }
        function asciiWords(string) {
            return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
            var result;
            eachFunc(collection, function(value, key, collection2) {
                if (predicate(value, key, collection2)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
            var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
            while (fromRight ? index2-- : ++index2 < length) {
                if (predicate(array[index2], index2, array)) {
                    return index2;
                }
            }
            return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
            return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator2) {
            var index2 = fromIndex - 1, length = array.length;
            while (++index2 < length) {
                if (comparator2(array[index2], value)) {
                    return index2;
                }
            }
            return -1;
        }
        function baseIsNaN(value) {
            return value !== value;
        }
        function baseMean(array, iteratee) {
            var length = array == null ? 0 : array.length;
            return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
            return function(object) {
                return object == null ? undefined$1 : object[key];
            };
        }
        function basePropertyOf(object) {
            return function(key) {
                return object == null ? undefined$1 : object[key];
            };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
            eachFunc(collection, function(value, index2, collection2) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
            });
            return accumulator;
        }
        function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);
            while (length--) {
                array[length] = array[length].value;
            }
            return array;
        }
        function baseSum(array, iteratee) {
            var result, index2 = -1, length = array.length;
            while (++index2 < length) {
                var current = iteratee(array[index2]);
                if (current !== undefined$1) {
                    result = result === undefined$1 ? current : result + current;
                }
            }
            return result;
        }
        function baseTimes(n2, iteratee) {
            var index2 = -1, result = Array(n2);
            while (++index2 < n2) {
                result[index2] = iteratee(index2);
            }
            return result;
        }
        function baseToPairs(object, props) {
            return arrayMap(props, function(key) {
                return [key, object[key]];
            });
        }
        function baseTrim(string) {
            return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
            return function(value) {
                return func(value);
            };
        }
        function baseValues(object, props) {
            return arrayMap(props, function(key) {
                return object[key];
            });
        }
        function cacheHas(cache2, key) {
            return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
            var index2 = -1, length = strSymbols.length;
            while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
            }
            return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
            var index2 = strSymbols.length;
            while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
            }
            return index2;
        }
        function countHolders(array, placeholder) {
            var length = array.length, result = 0;
            while (length--) {
                if (array[length] === placeholder) {
                    ++result;
                }
            }
            return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
            return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
            return object == null ? undefined$1 : object[key];
        }
        function hasUnicode(string) {
            return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
            return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
            var data, result = [];
            while (!(data = iterator.next()).done) {
                result.push(data.value);
            }
            return result;
        }
        function mapToArray(map) {
            var index2 = -1, result = Array(map.size);
            map.forEach(function(value, key) {
                result[++index2] = [key, value];
            });
            return result;
        }
        function overArg(func, transform2) {
            return function(arg) {
                return func(transform2(arg));
            };
        }
        function replaceHolders(array, placeholder) {
            var index2 = -1, length = array.length, resIndex = 0, result = [];
            while (++index2 < length) {
                var value = array[index2];
                if (value === placeholder || value === PLACEHOLDER) {
                    array[index2] = PLACEHOLDER;
                    result[resIndex++] = index2;
                }
            }
            return result;
        }
        function setToArray(set2) {
            var index2 = -1, result = Array(set2.size);
            set2.forEach(function(value) {
                result[++index2] = value;
            });
            return result;
        }
        function setToPairs(set2) {
            var index2 = -1, result = Array(set2.size);
            set2.forEach(function(value) {
                result[++index2] = [value, value];
            });
            return result;
        }
        function strictIndexOf(array, value, fromIndex) {
            var index2 = fromIndex - 1, length = array.length;
            while (++index2 < length) {
                if (array[index2] === value) {
                    return index2;
                }
            }
            return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
            var index2 = fromIndex + 1;
            while (index2--) {
                if (array[index2] === value) {
                    return index2;
                }
            }
            return index2;
        }
        function stringSize(string) {
            return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
            return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
            var index2 = string.length;
            while (index2-- && reWhitespace.test(string.charAt(index2))) {
            }
            return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
            var result = reUnicode.lastIndex = 0;
            while (reUnicode.test(string)) {
                ++result;
            }
            return result;
        }
        function unicodeToArray(string) {
            return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
            return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
            context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
            var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
            var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
            var coreJsData = context["__core-js_shared__"];
            var funcToString = funcProto.toString;
            var hasOwnProperty2 = objectProto.hasOwnProperty;
            var idCounter = 0;
            var maskSrcKey = function() {
                var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid2 ? "Symbol(src)_1." + uid2 : "";
            }();
            var nativeObjectToString = objectProto.toString;
            var objectCtorString = funcToString.call(Object2);
            var oldDash = root._;
            var reIsNative = RegExp2(
                "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
            );
            var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
            var defineProperty = function() {
                try {
                    var func = getNative(Object2, "defineProperty");
                    func({}, "", {});
                    return func;
                } catch (e) {
                }
            }();
            var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
            var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
            var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
            var metaMap = WeakMap2 && new WeakMap2();
            var realNames = {};
            var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
            var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
            function lodash2(value) {
                if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
                    if (value instanceof LodashWrapper) {
                        return value;
                    }
                    if (hasOwnProperty2.call(value, "__wrapped__")) {
                        return wrapperClone(value);
                    }
                }
                return new LodashWrapper(value);
            }
            var baseCreate = /* @__PURE__ */ function() {
                function object() {
                }
                return function(proto) {
                    if (!isObject2(proto)) {
                        return {};
                    }
                    if (objectCreate) {
                        return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result2 = new object();
                    object.prototype = undefined$1;
                    return result2;
                };
            }();
            function baseLodash() {
            }
            function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined$1;
            }
            lodash2.templateSettings = {
                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "escape": reEscape,
                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "evaluate": reEvaluate,
                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type {RegExp}
                 */
                "interpolate": reInterpolate,
                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type {string}
                 */
                "variable": "",
                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type {Object}
                 */
                "imports": {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type {Function}
                     */
                    "_": lodash2
                }
            };
            lodash2.prototype = baseLodash.prototype;
            lodash2.prototype.constructor = lodash2;
            LodashWrapper.prototype = baseCreate(baseLodash.prototype);
            LodashWrapper.prototype.constructor = LodashWrapper;
            function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
            }
            function lazyClone() {
                var result2 = new LazyWrapper(this.__wrapped__);
                result2.__actions__ = copyArray(this.__actions__);
                result2.__dir__ = this.__dir__;
                result2.__filtered__ = this.__filtered__;
                result2.__iteratees__ = copyArray(this.__iteratees__);
                result2.__takeCount__ = this.__takeCount__;
                result2.__views__ = copyArray(this.__views__);
                return result2;
            }
            function lazyReverse() {
                if (this.__filtered__) {
                    var result2 = new LazyWrapper(this);
                    result2.__dir__ = -1;
                    result2.__filtered__ = true;
                } else {
                    result2 = this.clone();
                    result2.__dir__ *= -1;
                }
                return result2;
            }
            function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index2 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                    return baseWrapperValue(array, this.__actions__);
                }
                var result2 = [];
                outer:
                    while (length-- && resIndex < takeCount) {
                        index2 += dir;
                        var iterIndex = -1, value = array[index2];
                        while (++iterIndex < iterLength) {
                            var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
                            if (type == LAZY_MAP_FLAG) {
                                value = computed2;
                            } else if (!computed2) {
                                if (type == LAZY_FILTER_FLAG) {
                                    continue outer;
                                } else {
                                    break outer;
                                }
                            }
                        }
                        result2[resIndex++] = value;
                    }
                return result2;
            }
            LazyWrapper.prototype = baseCreate(baseLodash.prototype);
            LazyWrapper.prototype.constructor = LazyWrapper;
            function Hash(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                    var entry = entries[index2];
                    this.set(entry[0], entry[1]);
                }
            }
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
            }
            function hashDelete(key) {
                var result2 = this.has(key) && delete this.__data__[key];
                this.size -= result2 ? 1 : 0;
                return result2;
            }
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result2 = data[key];
                    return result2 === HASH_UNDEFINED ? undefined$1 : result2;
                }
                return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
            }
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
            }
            function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
                return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype["delete"] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                    var entry = entries[index2];
                    this.set(entry[0], entry[1]);
                }
            }
            function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
            }
            function listCacheDelete(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                    return false;
                }
                var lastIndex = data.length - 1;
                if (index2 == lastIndex) {
                    data.pop();
                } else {
                    splice.call(data, index2, 1);
                }
                --this.size;
                return true;
            }
            function listCacheGet(key) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                return index2 < 0 ? undefined$1 : data[index2][1];
            }
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
                var data = this.__data__, index2 = assocIndexOf(data, key);
                if (index2 < 0) {
                    ++this.size;
                    data.push([key, value]);
                } else {
                    data[index2][1] = value;
                }
                return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype["delete"] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
                var index2 = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index2 < length) {
                    var entry = entries[index2];
                    this.set(entry[0], entry[1]);
                }
            }
            function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                    "hash": new Hash(),
                    "map": new (Map2 || ListCache)(),
                    "string": new Hash()
                };
            }
            function mapCacheDelete(key) {
                var result2 = getMapData(this, key)["delete"](key);
                this.size -= result2 ? 1 : 0;
                return result2;
            }
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
                var data = getMapData(this, key), size22 = data.size;
                data.set(key, value);
                this.size += data.size == size22 ? 0 : 1;
                return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype["delete"] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values2) {
                var index2 = -1, length = values2 == null ? 0 : values2.length;
                this.__data__ = new MapCache();
                while (++index2 < length) {
                    this.add(values2[index2]);
                }
            }
            function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
            }
            function setCacheHas(value) {
                return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
            }
            function stackDelete(key) {
                var data = this.__data__, result2 = data["delete"](key);
                this.size = data.size;
                return result2;
            }
            function stackGet(key) {
                return this.__data__.get(key);
            }
            function stackHas(key) {
                return this.__data__.has(key);
            }
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([key, value]);
                        this.size = ++data.size;
                        return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype["delete"] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                for (var key in value) {
                    if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                            isIndex(key, length)))) {
                        result2.push(key);
                    }
                }
                return result2;
            }
            function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined$1;
            }
            function arraySampleSize(array, n2) {
                return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
            }
            function arrayShuffle(array) {
                return shuffleSelf(copyArray(array));
            }
            function assignMergeValue(object, key, value) {
                if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
                    baseAssignValue(object, key, value);
                }
            }
            function assignValue(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
                    baseAssignValue(object, key, value);
                }
            }
            function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                    if (eq(array[length][0], key)) {
                        return length;
                    }
                }
                return -1;
            }
            function baseAggregator(collection, setter, iteratee2, accumulator) {
                baseEach(collection, function(value, key, collection2) {
                    setter(accumulator, value, iteratee2(value), collection2);
                });
                return accumulator;
            }
            function baseAssign(object, source) {
                return object && copyObject(source, keys(source), object);
            }
            function baseAssignIn(object, source) {
                return object && copyObject(source, keysIn(source), object);
            }
            function baseAssignValue(object, key, value) {
                if (key == "__proto__" && defineProperty) {
                    defineProperty(object, key, {
                        "configurable": true,
                        "enumerable": true,
                        "value": value,
                        "writable": true
                    });
                } else {
                    object[key] = value;
                }
            }
            function baseAt(object, paths) {
                var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                while (++index2 < length) {
                    result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
                }
                return result2;
            }
            function baseClamp(number2, lower, upper) {
                if (number2 === number2) {
                    if (upper !== undefined$1) {
                        number2 = number2 <= upper ? number2 : upper;
                    }
                    if (lower !== undefined$1) {
                        number2 = number2 >= lower ? number2 : lower;
                    }
                }
                return number2;
            }
            function baseClone(value, bitmask, customizer, key, object, stack2) {
                var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                    result2 = object ? customizer(value, key, object, stack2) : customizer(value);
                }
                if (result2 !== undefined$1) {
                    return result2;
                }
                if (!isObject2(value)) {
                    return value;
                }
                var isArr = isArray2(value);
                if (isArr) {
                    result2 = initCloneArray(value);
                    if (!isDeep) {
                        return copyArray(value, result2);
                    }
                } else {
                    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) {
                        return cloneBuffer(value, isDeep);
                    }
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                        result2 = isFlat || isFunc ? {} : initCloneObject(value);
                        if (!isDeep) {
                            return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                        }
                    } else {
                        if (!cloneableTags[tag]) {
                            return object ? value : {};
                        }
                        result2 = initCloneByTag(value, tag, isDeep);
                    }
                }
                stack2 || (stack2 = new Stack());
                var stacked = stack2.get(value);
                if (stacked) {
                    return stacked;
                }
                stack2.set(value, result2);
                if (isSet2(value)) {
                    value.forEach(function(subValue) {
                        result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
                    });
                } else if (isMap2(value)) {
                    value.forEach(function(subValue, key2) {
                        result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                    });
                }
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                var props = isArr ? undefined$1 : keysFunc(value);
                arrayEach(props || value, function(subValue, key2) {
                    if (props) {
                        key2 = subValue;
                        subValue = value[key2];
                    }
                    assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                });
                return result2;
            }
            function baseConforms(source) {
                var props = keys(source);
                return function(object) {
                    return baseConformsTo(object, source, props);
                };
            }
            function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                    return !length;
                }
                object = Object2(object);
                while (length--) {
                    var key = props[length], predicate = source[key], value = object[key];
                    if (value === undefined$1 && !(key in object) || !predicate(value)) {
                        return false;
                    }
                }
                return true;
            }
            function baseDelay(func, wait, args) {
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return setTimeout2(function() {
                    func.apply(undefined$1, args);
                }, wait);
            }
            function baseDifference(array, values2, iteratee2, comparator2) {
                var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                if (!length) {
                    return result2;
                }
                if (iteratee2) {
                    values2 = arrayMap(values2, baseUnary(iteratee2));
                }
                if (comparator2) {
                    includes2 = arrayIncludesWith;
                    isCommon = false;
                } else if (values2.length >= LARGE_ARRAY_SIZE) {
                    includes2 = cacheHas;
                    isCommon = false;
                    values2 = new SetCache(values2);
                }
                outer:
                    while (++index2 < length) {
                        var value = array[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
                        value = comparator2 || value !== 0 ? value : 0;
                        if (isCommon && computed2 === computed2) {
                            var valuesIndex = valuesLength;
                            while (valuesIndex--) {
                                if (values2[valuesIndex] === computed2) {
                                    continue outer;
                                }
                            }
                            result2.push(value);
                        } else if (!includes2(values2, computed2, comparator2)) {
                            result2.push(value);
                        }
                    }
                return result2;
            }
            var baseEach = createBaseEach(baseForOwn);
            var baseEachRight = createBaseEach(baseForOwnRight, true);
            function baseEvery(collection, predicate) {
                var result2 = true;
                baseEach(collection, function(value, index2, collection2) {
                    result2 = !!predicate(value, index2, collection2);
                    return result2;
                });
                return result2;
            }
            function baseExtremum(array, iteratee2, comparator2) {
                var index2 = -1, length = array.length;
                while (++index2 < length) {
                    var value = array[index2], current = iteratee2(value);
                    if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
                        var computed2 = current, result2 = value;
                    }
                }
                return result2;
            }
            function baseFill(array, value, start2, end2) {
                var length = array.length;
                start2 = toInteger(start2);
                if (start2 < 0) {
                    start2 = -start2 > length ? 0 : length + start2;
                }
                end2 = end2 === undefined$1 || end2 > length ? length : toInteger(end2);
                if (end2 < 0) {
                    end2 += length;
                }
                end2 = start2 > end2 ? 0 : toLength(end2);
                while (start2 < end2) {
                    array[start2++] = value;
                }
                return array;
            }
            function baseFilter(collection, predicate) {
                var result2 = [];
                baseEach(collection, function(value, index2, collection2) {
                    if (predicate(value, index2, collection2)) {
                        result2.push(value);
                    }
                });
                return result2;
            }
            function baseFlatten(array, depth, predicate, isStrict, result2) {
                var index2 = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result2 || (result2 = []);
                while (++index2 < length) {
                    var value = array[index2];
                    if (depth > 0 && predicate(value)) {
                        if (depth > 1) {
                            baseFlatten(value, depth - 1, predicate, isStrict, result2);
                        } else {
                            arrayPush(result2, value);
                        }
                    } else if (!isStrict) {
                        result2[result2.length] = value;
                    }
                }
                return result2;
            }
            var baseFor = createBaseFor();
            var baseForRight = createBaseFor(true);
            function baseForOwn(object, iteratee2) {
                return object && baseFor(object, iteratee2, keys);
            }
            function baseForOwnRight(object, iteratee2) {
                return object && baseForRight(object, iteratee2, keys);
            }
            function baseFunctions(object, props) {
                return arrayFilter(props, function(key) {
                    return isFunction2(object[key]);
                });
            }
            function baseGet(object, path) {
                path = castPath(path, object);
                var index2 = 0, length = path.length;
                while (object != null && index2 < length) {
                    object = object[toKey(path[index2++])];
                }
                return index2 && index2 == length ? object : undefined$1;
            }
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result2 = keysFunc(object);
                return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
            }
            function baseGetTag(value) {
                if (value == null) {
                    return value === undefined$1 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
            }
            function baseGt(value, other) {
                return value > other;
            }
            function baseHas(object, key) {
                return object != null && hasOwnProperty2.call(object, key);
            }
            function baseHasIn(object, key) {
                return object != null && key in Object2(object);
            }
            function baseInRange(number2, start2, end2) {
                return number2 >= nativeMin(start2, end2) && number2 < nativeMax(start2, end2);
            }
            function baseIntersection(arrays, iteratee2, comparator2) {
                var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                while (othIndex--) {
                    var array = arrays[othIndex];
                    if (othIndex && iteratee2) {
                        array = arrayMap(array, baseUnary(iteratee2));
                    }
                    maxLength = nativeMin(array.length, maxLength);
                    caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
                }
                array = arrays[0];
                var index2 = -1, seen = caches[0];
                outer:
                    while (++index2 < length && result2.length < maxLength) {
                        var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                        value = comparator2 || value !== 0 ? value : 0;
                        if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator2))) {
                            othIndex = othLength;
                            while (--othIndex) {
                                var cache2 = caches[othIndex];
                                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
                                    continue outer;
                                }
                            }
                            if (seen) {
                                seen.push(computed2);
                            }
                            result2.push(value);
                        }
                    }
                return result2;
            }
            function baseInverter(object, setter, iteratee2, accumulator) {
                baseForOwn(object, function(value, key, object2) {
                    setter(accumulator, iteratee2(value), key, object2);
                });
                return accumulator;
            }
            function baseInvoke(object, path, args) {
                path = castPath(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey(last(path))];
                return func == null ? undefined$1 : apply2(func, object, args);
            }
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            function baseIsArrayBuffer(value) {
                return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
            }
            function baseIsDate(value) {
                return isObjectLike(value) && baseGetTag(value) == dateTag;
            }
            function baseIsEqual(value, other, bitmask, customizer, stack2) {
                if (value === other) {
                    return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                    return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
            }
            function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
                var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                        return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                    stack2 || (stack2 = new Stack());
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        stack2 || (stack2 = new Stack());
                        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
                    }
                }
                if (!isSameTag) {
                    return false;
                }
                stack2 || (stack2 = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
            }
            function baseIsMap(value) {
                return isObjectLike(value) && getTag(value) == mapTag;
            }
            function baseIsMatch(object, source, matchData, customizer) {
                var index2 = matchData.length, length = index2, noCustomizer = !customizer;
                if (object == null) {
                    return !length;
                }
                object = Object2(object);
                while (index2--) {
                    var data = matchData[index2];
                    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                        return false;
                    }
                }
                while (++index2 < length) {
                    data = matchData[index2];
                    var key = data[0], objValue = object[key], srcValue = data[1];
                    if (noCustomizer && data[2]) {
                        if (objValue === undefined$1 && !(key in object)) {
                            return false;
                        }
                    } else {
                        var stack2 = new Stack();
                        if (customizer) {
                            var result2 = customizer(objValue, srcValue, key, object, source, stack2);
                        }
                        if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result2)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            function baseIsNative(value) {
                if (!isObject2(value) || isMasked(value)) {
                    return false;
                }
                var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
                return pattern2.test(toSource(value));
            }
            function baseIsRegExp(value) {
                return isObjectLike(value) && baseGetTag(value) == regexpTag;
            }
            function baseIsSet(value) {
                return isObjectLike(value) && getTag(value) == setTag;
            }
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            function baseIteratee(value) {
                if (typeof value == "function") {
                    return value;
                }
                if (value == null) {
                    return identity2;
                }
                if (typeof value == "object") {
                    return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
            }
            function baseKeys(object) {
                if (!isPrototype(object)) {
                    return nativeKeys(object);
                }
                var result2 = [];
                for (var key in Object2(object)) {
                    if (hasOwnProperty2.call(object, key) && key != "constructor") {
                        result2.push(key);
                    }
                }
                return result2;
            }
            function baseKeysIn(object) {
                if (!isObject2(object)) {
                    return nativeKeysIn(object);
                }
                var isProto = isPrototype(object), result2 = [];
                for (var key in object) {
                    if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                        result2.push(key);
                    }
                }
                return result2;
            }
            function baseLt(value, other) {
                return value < other;
            }
            function baseMap(collection, iteratee2) {
                var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value, key, collection2) {
                    result2[++index2] = iteratee2(value, key, collection2);
                });
                return result2;
            }
            function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function(object) {
                    return object === source || baseIsMatch(object, source, matchData);
                };
            }
            function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                }
                return function(object) {
                    var objValue = get2(object, path);
                    return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
            }
            function baseMerge(object, source, srcIndex, customizer, stack2) {
                if (object === source) {
                    return;
                }
                baseFor(source, function(srcValue, key) {
                    stack2 || (stack2 = new Stack());
                    if (isObject2(srcValue)) {
                        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
                    } else {
                        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
                        if (newValue === undefined$1) {
                            newValue = srcValue;
                        }
                        assignMergeValue(object, key, newValue);
                    }
                }, keysIn);
            }
            function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
                var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
                if (stacked) {
                    assignMergeValue(object, key, stacked);
                    return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
                var isCommon = newValue === undefined$1;
                if (isCommon) {
                    var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                    newValue = srcValue;
                    if (isArr || isBuff || isTyped) {
                        if (isArray2(objValue)) {
                            newValue = objValue;
                        } else if (isArrayLikeObject(objValue)) {
                            newValue = copyArray(objValue);
                        } else if (isBuff) {
                            isCommon = false;
                            newValue = cloneBuffer(srcValue, true);
                        } else if (isTyped) {
                            isCommon = false;
                            newValue = cloneTypedArray(srcValue, true);
                        } else {
                            newValue = [];
                        }
                    } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                        newValue = objValue;
                        if (isArguments(objValue)) {
                            newValue = toPlainObject(objValue);
                        } else if (!isObject2(objValue) || isFunction2(objValue)) {
                            newValue = initCloneObject(srcValue);
                        }
                    } else {
                        isCommon = false;
                    }
                }
                if (isCommon) {
                    stack2.set(srcValue, newValue);
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
                    stack2["delete"](srcValue);
                }
                assignMergeValue(object, key, newValue);
            }
            function baseNth(array, n2) {
                var length = array.length;
                if (!length) {
                    return;
                }
                n2 += n2 < 0 ? length : 0;
                return isIndex(n2, length) ? array[n2] : undefined$1;
            }
            function baseOrderBy(collection, iteratees, orders) {
                if (iteratees.length) {
                    iteratees = arrayMap(iteratees, function(iteratee2) {
                        if (isArray2(iteratee2)) {
                            return function(value) {
                                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                            };
                        }
                        return iteratee2;
                    });
                } else {
                    iteratees = [identity2];
                }
                var index2 = -1;
                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                var result2 = baseMap(collection, function(value, key, collection2) {
                    var criteria = arrayMap(iteratees, function(iteratee2) {
                        return iteratee2(value);
                    });
                    return { "criteria": criteria, "index": ++index2, "value": value };
                });
                return baseSortBy(result2, function(object, other) {
                    return compareMultiple(object, other, orders);
                });
            }
            function basePick(object, paths) {
                return basePickBy(object, paths, function(value, path) {
                    return hasIn(object, path);
                });
            }
            function basePickBy(object, paths, predicate) {
                var index2 = -1, length = paths.length, result2 = {};
                while (++index2 < length) {
                    var path = paths[index2], value = baseGet(object, path);
                    if (predicate(value, path)) {
                        baseSet(result2, castPath(path, object), value);
                    }
                }
                return result2;
            }
            function basePropertyDeep(path) {
                return function(object) {
                    return baseGet(object, path);
                };
            }
            function basePullAll(array, values2, iteratee2, comparator2) {
                var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
                if (array === values2) {
                    values2 = copyArray(values2);
                }
                if (iteratee2) {
                    seen = arrayMap(array, baseUnary(iteratee2));
                }
                while (++index2 < length) {
                    var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                    while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator2)) > -1) {
                        if (seen !== array) {
                            splice.call(seen, fromIndex, 1);
                        }
                        splice.call(array, fromIndex, 1);
                    }
                }
                return array;
            }
            function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                    var index2 = indexes[length];
                    if (length == lastIndex || index2 !== previous) {
                        var previous = index2;
                        if (isIndex(index2)) {
                            splice.call(array, index2, 1);
                        } else {
                            baseUnset(array, index2);
                        }
                    }
                }
                return array;
            }
            function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
            }
            function baseRange(start2, end2, step, fromRight) {
                var index2 = -1, length = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
                while (length--) {
                    result2[fromRight ? length : ++index2] = start2;
                    start2 += step;
                }
                return result2;
            }
            function baseRepeat(string, n2) {
                var result2 = "";
                if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
                    return result2;
                }
                do {
                    if (n2 % 2) {
                        result2 += string;
                    }
                    n2 = nativeFloor(n2 / 2);
                    if (n2) {
                        string += string;
                    }
                } while (n2);
                return result2;
            }
            function baseRest(func, start2) {
                return setToString(overRest(func, start2, identity2), func + "");
            }
            function baseSample(collection) {
                return arraySample(values(collection));
            }
            function baseSampleSize(collection, n2) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n2, 0, array.length));
            }
            function baseSet(object, path, value, customizer) {
                if (!isObject2(object)) {
                    return object;
                }
                path = castPath(path, object);
                var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index2 < length) {
                    var key = toKey(path[index2]), newValue = value;
                    if (key === "__proto__" || key === "constructor" || key === "prototype") {
                        return object;
                    }
                    if (index2 != lastIndex) {
                        var objValue = nested[key];
                        newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                        if (newValue === undefined$1) {
                            newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                        }
                    }
                    assignValue(nested, key, newValue);
                    nested = nested[key];
                }
                return object;
            }
            var baseSetData = !metaMap ? identity2 : function(func, data) {
                metaMap.set(func, data);
                return func;
            };
            var baseSetToString = !defineProperty ? identity2 : function(func, string) {
                return defineProperty(func, "toString", {
                    "configurable": true,
                    "enumerable": false,
                    "value": constant(string),
                    "writable": true
                });
            };
            function baseShuffle(collection) {
                return shuffleSelf(values(collection));
            }
            function baseSlice(array, start2, end2) {
                var index2 = -1, length = array.length;
                if (start2 < 0) {
                    start2 = -start2 > length ? 0 : length + start2;
                }
                end2 = end2 > length ? length : end2;
                if (end2 < 0) {
                    end2 += length;
                }
                length = start2 > end2 ? 0 : end2 - start2 >>> 0;
                start2 >>>= 0;
                var result2 = Array2(length);
                while (++index2 < length) {
                    result2[index2] = array[index2 + start2];
                }
                return result2;
            }
            function baseSome(collection, predicate) {
                var result2;
                baseEach(collection, function(value, index2, collection2) {
                    result2 = predicate(value, index2, collection2);
                    return !result2;
                });
                return !!result2;
            }
            function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array == null ? low : array.length;
                if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                    while (low < high) {
                        var mid = low + high >>> 1, computed2 = array[mid];
                        if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
                            low = mid + 1;
                        } else {
                            high = mid;
                        }
                    }
                    return high;
                }
                return baseSortedIndexBy(array, value, identity2, retHighest);
            }
            function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                var low = 0, high = array == null ? 0 : array.length;
                if (high === 0) {
                    return 0;
                }
                value = iteratee2(value);
                var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
                while (low < high) {
                    var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
                    if (valIsNaN) {
                        var setLow = retHighest || othIsReflexive;
                    } else if (valIsUndefined) {
                        setLow = othIsReflexive && (retHighest || othIsDefined);
                    } else if (valIsNull) {
                        setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                    } else if (valIsSymbol) {
                        setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                    } else if (othIsNull || othIsSymbol) {
                        setLow = false;
                    } else {
                        setLow = retHighest ? computed2 <= value : computed2 < value;
                    }
                    if (setLow) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return nativeMin(high, MAX_ARRAY_INDEX);
            }
            function baseSortedUniq(array, iteratee2) {
                var index2 = -1, length = array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                    var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                    if (!index2 || !eq(computed2, seen)) {
                        var seen = computed2;
                        result2[resIndex++] = value === 0 ? 0 : value;
                    }
                }
                return result2;
            }
            function baseToNumber(value) {
                if (typeof value == "number") {
                    return value;
                }
                if (isSymbol2(value)) {
                    return NAN;
                }
                return +value;
            }
            function baseToString(value) {
                if (typeof value == "string") {
                    return value;
                }
                if (isArray2(value)) {
                    return arrayMap(value, baseToString) + "";
                }
                if (isSymbol2(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
            }
            function baseUniq(array, iteratee2, comparator2) {
                var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
                if (comparator2) {
                    isCommon = false;
                    includes2 = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE) {
                    var set22 = iteratee2 ? null : createSet(array);
                    if (set22) {
                        return setToArray(set22);
                    }
                    isCommon = false;
                    includes2 = cacheHas;
                    seen = new SetCache();
                } else {
                    seen = iteratee2 ? [] : result2;
                }
                outer:
                    while (++index2 < length) {
                        var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
                        value = comparator2 || value !== 0 ? value : 0;
                        if (isCommon && computed2 === computed2) {
                            var seenIndex = seen.length;
                            while (seenIndex--) {
                                if (seen[seenIndex] === computed2) {
                                    continue outer;
                                }
                            }
                            if (iteratee2) {
                                seen.push(computed2);
                            }
                            result2.push(value);
                        } else if (!includes2(seen, computed2, comparator2)) {
                            if (seen !== result2) {
                                seen.push(computed2);
                            }
                            result2.push(value);
                        }
                    }
                return result2;
            }
            function baseUnset(object, path) {
                path = castPath(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey(last(path))];
            }
            function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet(object, path)), customizer);
            }
            function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index2 = fromRight ? length : -1;
                while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
                }
                return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
            }
            function baseWrapperValue(value, actions) {
                var result2 = value;
                if (result2 instanceof LazyWrapper) {
                    result2 = result2.value();
                }
                return arrayReduce(actions, function(result3, action) {
                    return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                }, result2);
            }
            function baseXor(arrays, iteratee2, comparator2) {
                var length = arrays.length;
                if (length < 2) {
                    return length ? baseUniq(arrays[0]) : [];
                }
                var index2 = -1, result2 = Array2(length);
                while (++index2 < length) {
                    var array = arrays[index2], othIndex = -1;
                    while (++othIndex < length) {
                        if (othIndex != index2) {
                            result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
                        }
                    }
                }
                return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
            }
            function baseZipObject(props, values2, assignFunc) {
                var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
                while (++index2 < length) {
                    var value = index2 < valsLength ? values2[index2] : undefined$1;
                    assignFunc(result2, props[index2], value);
                }
                return result2;
            }
            function castArrayLikeObject(value) {
                return isArrayLikeObject(value) ? value : [];
            }
            function castFunction(value) {
                return typeof value == "function" ? value : identity2;
            }
            function castPath(value, object) {
                if (isArray2(value)) {
                    return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
            }
            var castRest = baseRest;
            function castSlice(array, start2, end2) {
                var length = array.length;
                end2 = end2 === undefined$1 ? length : end2;
                return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
            }
            var clearTimeout2 = ctxClearTimeout || function(id) {
                return root.clearTimeout(id);
            };
            function cloneBuffer(buffer, isDeep) {
                if (isDeep) {
                    return buffer.slice();
                }
                var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                buffer.copy(result2);
                return result2;
            }
            function cloneArrayBuffer(arrayBuffer) {
                var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                return result2;
            }
            function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
            }
            function cloneRegExp(regexp) {
                var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result2.lastIndex = regexp.lastIndex;
                return result2;
            }
            function cloneSymbol(symbol) {
                return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
            }
            function cloneTypedArray(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
            }
            function compareAscending(value, other) {
                if (value !== other) {
                    var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
                    var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
                    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                        return 1;
                    }
                    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                        return -1;
                    }
                }
                return 0;
            }
            function compareMultiple(object, other, orders) {
                var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index2 < length) {
                    var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
                    if (result2) {
                        if (index2 >= ordersLength) {
                            return result2;
                        }
                        var order = orders[index2];
                        return result2 * (order == "desc" ? -1 : 1);
                    }
                }
                return object.index - other.index;
            }
            function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                    result2[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                        result2[holders[argsIndex]] = args[argsIndex];
                    }
                }
                while (rangeLength--) {
                    result2[leftIndex++] = args[argsIndex++];
                }
                return result2;
            }
            function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                    result2[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                    result2[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                        result2[offset + holders[holdersIndex]] = args[argsIndex++];
                    }
                }
                return result2;
            }
            function copyArray(source, array) {
                var index2 = -1, length = source.length;
                array || (array = Array2(length));
                while (++index2 < length) {
                    array[index2] = source[index2];
                }
                return array;
            }
            function copyObject(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index2 = -1, length = props.length;
                while (++index2 < length) {
                    var key = props[index2];
                    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                    if (newValue === undefined$1) {
                        newValue = source[key];
                    }
                    if (isNew) {
                        baseAssignValue(object, key, newValue);
                    } else {
                        assignValue(object, key, newValue);
                    }
                }
                return object;
            }
            function copySymbols(source, object) {
                return copyObject(source, getSymbols(source), object);
            }
            function copySymbolsIn(source, object) {
                return copyObject(source, getSymbolsIn(source), object);
            }
            function createAggregator(setter, initializer) {
                return function(collection, iteratee2) {
                    var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                    return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                };
            }
            function createAssigner(assigner) {
                return baseRest(function(object, sources) {
                    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
                    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                        customizer = length < 3 ? undefined$1 : customizer;
                        length = 1;
                    }
                    object = Object2(object);
                    while (++index2 < length) {
                        var source = sources[index2];
                        if (source) {
                            assigner(object, source, index2, customizer);
                        }
                    }
                    return object;
                });
            }
            function createBaseEach(eachFunc, fromRight) {
                return function(collection, iteratee2) {
                    if (collection == null) {
                        return collection;
                    }
                    if (!isArrayLike(collection)) {
                        return eachFunc(collection, iteratee2);
                    }
                    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
                    while (fromRight ? index2-- : ++index2 < length) {
                        if (iteratee2(iterable[index2], index2, iterable) === false) {
                            break;
                        }
                    }
                    return collection;
                };
            }
            function createBaseFor(fromRight) {
                return function(object, iteratee2, keysFunc) {
                    var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                    while (length--) {
                        var key = props[fromRight ? length : ++index2];
                        if (iteratee2(iterable[key], key, iterable) === false) {
                            break;
                        }
                    }
                    return object;
                };
            }
            function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                    var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return fn2.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
            }
            function createCaseFirst(methodName) {
                return function(string) {
                    string = toString(string);
                    var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
                    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                    return chr[methodName]() + trailing;
                };
            }
            function createCompounder(callback) {
                return function(string) {
                    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                };
            }
            function createCtor(Ctor) {
                return function() {
                    var args = arguments;
                    switch (args.length) {
                        case 0:
                            return new Ctor();
                        case 1:
                            return new Ctor(args[0]);
                        case 2:
                            return new Ctor(args[0], args[1]);
                        case 3:
                            return new Ctor(args[0], args[1], args[2]);
                        case 4:
                            return new Ctor(args[0], args[1], args[2], args[3]);
                        case 5:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                        case 6:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                        case 7:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    }
                    var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                    return isObject2(result2) ? result2 : thisBinding;
                };
            }
            function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                    var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
                    while (index2--) {
                        args[index2] = arguments[index2];
                    }
                    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                    length -= holders.length;
                    if (length < arity) {
                        return createRecurry(
                            func,
                            bitmask,
                            createHybrid,
                            wrapper.placeholder,
                            undefined$1,
                            args,
                            holders,
                            undefined$1,
                            undefined$1,
                            arity - length
                        );
                    }
                    var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return apply2(fn2, this, args);
                }
                return wrapper;
            }
            function createFind(findIndexFunc) {
                return function(collection, predicate, fromIndex) {
                    var iterable = Object2(collection);
                    if (!isArrayLike(collection)) {
                        var iteratee2 = getIteratee(predicate, 3);
                        collection = keys(collection);
                        predicate = function(key) {
                            return iteratee2(iterable[key], key, iterable);
                        };
                    }
                    var index2 = findIndexFunc(collection, predicate, fromIndex);
                    return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
                };
            }
            function createFlow(fromRight) {
                return flatRest(function(funcs) {
                    var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
                    if (fromRight) {
                        funcs.reverse();
                    }
                    while (index2--) {
                        var func = funcs[index2];
                        if (typeof func != "function") {
                            throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                            var wrapper = new LodashWrapper([], true);
                        }
                    }
                    index2 = wrapper ? index2 : length;
                    while (++index2 < length) {
                        func = funcs[index2];
                        var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
                        if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                        } else {
                            wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                        }
                    }
                    return function() {
                        var args = arguments, value = args[0];
                        if (wrapper && args.length == 1 && isArray2(value)) {
                            return wrapper.plant(value).value();
                        }
                        var index22 = 0, result2 = length ? funcs[index22].apply(this, args) : value;
                        while (++index22 < length) {
                            result2 = funcs[index22].call(this, result2);
                        }
                        return result2;
                    };
                });
            }
            function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
                function wrapper() {
                    var length = arguments.length, args = Array2(length), index2 = length;
                    while (index2--) {
                        args[index2] = arguments[index2];
                    }
                    if (isCurried) {
                        var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                    }
                    if (partials) {
                        args = composeArgs(args, partials, holders, isCurried);
                    }
                    if (partialsRight) {
                        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                    }
                    length -= holdersCount;
                    if (isCurried && length < arity) {
                        var newHolders = replaceHolders(args, placeholder);
                        return createRecurry(
                            func,
                            bitmask,
                            createHybrid,
                            wrapper.placeholder,
                            thisArg,
                            args,
                            newHolders,
                            argPos,
                            ary2,
                            arity - length
                        );
                    }
                    var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
                    length = args.length;
                    if (argPos) {
                        args = reorder(args, argPos);
                    } else if (isFlip && length > 1) {
                        args.reverse();
                    }
                    if (isAry && ary2 < length) {
                        args.length = ary2;
                    }
                    if (this && this !== root && this instanceof wrapper) {
                        fn2 = Ctor || createCtor(fn2);
                    }
                    return fn2.apply(thisBinding, args);
                }
                return wrapper;
            }
            function createInverter(setter, toIteratee) {
                return function(object, iteratee2) {
                    return baseInverter(object, setter, toIteratee(iteratee2), {});
                };
            }
            function createMathOperation(operator, defaultValue) {
                return function(value, other) {
                    var result2;
                    if (value === undefined$1 && other === undefined$1) {
                        return defaultValue;
                    }
                    if (value !== undefined$1) {
                        result2 = value;
                    }
                    if (other !== undefined$1) {
                        if (result2 === undefined$1) {
                            return other;
                        }
                        if (typeof value == "string" || typeof other == "string") {
                            value = baseToString(value);
                            other = baseToString(other);
                        } else {
                            value = baseToNumber(value);
                            other = baseToNumber(other);
                        }
                        result2 = operator(value, other);
                    }
                    return result2;
                };
            }
            function createOver(arrayFunc) {
                return flatRest(function(iteratees) {
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    return baseRest(function(args) {
                        var thisArg = this;
                        return arrayFunc(iteratees, function(iteratee2) {
                            return apply2(iteratee2, thisArg, args);
                        });
                    });
                });
            }
            function createPadding(length, chars) {
                chars = chars === undefined$1 ? " " : baseToString(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                    return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
            }
            function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
                    while (++leftIndex < leftLength) {
                        args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                        args[leftIndex++] = arguments[++argsIndex];
                    }
                    return apply2(fn2, isBind ? thisArg : this, args);
                }
                return wrapper;
            }
            function createRange(fromRight) {
                return function(start2, end2, step) {
                    if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
                        end2 = step = undefined$1;
                    }
                    start2 = toFinite(start2);
                    if (end2 === undefined$1) {
                        end2 = start2;
                        start2 = 0;
                    } else {
                        end2 = toFinite(end2);
                    }
                    step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
                    return baseRange(start2, end2, step, fromRight);
                };
            }
            function createRelationalOperation(operator) {
                return function(value, other) {
                    if (!(typeof value == "string" && typeof other == "string")) {
                        value = toNumber(value);
                        other = toNumber(other);
                    }
                    return operator(value, other);
                };
            }
            function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                }
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary2,
                    arity
                ];
                var result2 = wrapFunc.apply(undefined$1, newData);
                if (isLaziable(func)) {
                    setData(result2, newData);
                }
                result2.placeholder = placeholder;
                return setWrapToString(result2, func, bitmask);
            }
            function createRound(methodName) {
                var func = Math2[methodName];
                return function(number2, precision) {
                    number2 = toNumber(number2);
                    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                    if (precision && nativeIsFinite(number2)) {
                        var pair = (toString(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                        pair = (toString(value) + "e").split("e");
                        return +(pair[0] + "e" + (+pair[1] - precision));
                    }
                    return func(number2);
                };
            }
            var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                return new Set2(values2);
            };
            function createToPairs(keysFunc) {
                return function(object) {
                    var tag = getTag(object);
                    if (tag == mapTag) {
                        return mapToArray(object);
                    }
                    if (tag == setTag) {
                        return setToPairs(object);
                    }
                    return baseToPairs(object, keysFunc(object));
                };
            }
            function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                    partials = holders = undefined$1;
                }
                ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
                arity = arity === undefined$1 ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                    var partialsRight = partials, holdersRight = holders;
                    partials = holders = undefined$1;
                }
                var data = isBindKey ? undefined$1 : getData(func);
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary2,
                    arity
                ];
                if (data) {
                    mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                    var result2 = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                    result2 = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                    result2 = createPartial(func, bitmask, thisArg, partials);
                } else {
                    result2 = createHybrid.apply(undefined$1, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result2, newData), func, bitmask);
            }
            function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                    return srcValue;
                }
                return objValue;
            }
            function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
                if (isObject2(objValue) && isObject2(srcValue)) {
                    stack2.set(srcValue, objValue);
                    baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
                    stack2["delete"](srcValue);
                }
                return objValue;
            }
            function customOmitClone(value) {
                return isPlainObject2(value) ? undefined$1 : value;
            }
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                }
                var arrStacked = stack2.get(array);
                var othStacked = stack2.get(other);
                if (arrStacked && othStacked) {
                    return arrStacked == other && othStacked == array;
                }
                var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
                stack2.set(array, other);
                stack2.set(other, array);
                while (++index2 < arrLength) {
                    var arrValue = array[index2], othValue = other[index2];
                    if (customizer) {
                        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
                    }
                    if (compared !== undefined$1) {
                        if (compared) {
                            continue;
                        }
                        result2 = false;
                        break;
                    }
                    if (seen) {
                        if (!arraySome(other, function(othValue2, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                                return seen.push(othIndex);
                            }
                        })) {
                            result2 = false;
                            break;
                        }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                        result2 = false;
                        break;
                    }
                }
                stack2["delete"](array);
                stack2["delete"](other);
                return result2;
            }
            function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
                switch (tag) {
                    case dataViewTag:
                        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                            return false;
                        }
                        object = object.buffer;
                        other = other.buffer;
                    case arrayBufferTag:
                        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                            return false;
                        }
                        return true;
                    case boolTag:
                    case dateTag:
                    case numberTag:
                        return eq(+object, +other);
                    case errorTag:
                        return object.name == other.name && object.message == other.message;
                    case regexpTag:
                    case stringTag:
                        return object == other + "";
                    case mapTag:
                        var convert = mapToArray;
                    case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                        convert || (convert = setToArray);
                        if (object.size != other.size && !isPartial) {
                            return false;
                        }
                        var stacked = stack2.get(object);
                        if (stacked) {
                            return stacked == other;
                        }
                        bitmask |= COMPARE_UNORDERED_FLAG;
                        stack2.set(object, other);
                        var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                        stack2["delete"](object);
                        return result2;
                    case symbolTag:
                        if (symbolValueOf) {
                            return symbolValueOf.call(object) == symbolValueOf.call(other);
                        }
                }
                return false;
            }
            function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                    return false;
                }
                var index2 = objLength;
                while (index2--) {
                    var key = objProps[index2];
                    if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                        return false;
                    }
                }
                var objStacked = stack2.get(object);
                var othStacked = stack2.get(other);
                if (objStacked && othStacked) {
                    return objStacked == other && othStacked == object;
                }
                var result2 = true;
                stack2.set(object, other);
                stack2.set(other, object);
                var skipCtor = isPartial;
                while (++index2 < objLength) {
                    key = objProps[index2];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) {
                        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
                    }
                    if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                        result2 = false;
                        break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                }
                if (result2 && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                        result2 = false;
                    }
                }
                stack2["delete"](object);
                stack2["delete"](other);
                return result2;
            }
            function flatRest(func) {
                return setToString(overRest(func, undefined$1, flatten), func + "");
            }
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            function getAllKeysIn(object) {
                return baseGetAllKeys(object, keysIn, getSymbolsIn);
            }
            var getData = !metaMap ? noop : function(func) {
                return metaMap.get(func);
            };
            function getFuncName(func) {
                var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
                while (length--) {
                    var data = array[length], otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                        return data.name;
                    }
                }
                return result2;
            }
            function getHolder(func) {
                var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
                return object.placeholder;
            }
            function getIteratee() {
                var result2 = lodash2.iteratee || iteratee;
                result2 = result2 === iteratee ? baseIteratee : result2;
                return arguments.length ? result2(arguments[0], arguments[1]) : result2;
            }
            function getMapData(map2, key) {
                var data = map2.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
            }
            function getMatchData(object) {
                var result2 = keys(object), length = result2.length;
                while (length--) {
                    var key = result2[length], value = object[key];
                    result2[length] = [key, value, isStrictComparable(value)];
                }
                return result2;
            }
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : undefined$1;
            }
            function getRawTag(value) {
                var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = undefined$1;
                    var unmasked = true;
                } catch (e) {
                }
                var result2 = nativeObjectToString.call(value);
                if (unmasked) {
                    if (isOwn) {
                        value[symToStringTag] = tag;
                    } else {
                        delete value[symToStringTag];
                    }
                }
                return result2;
            }
            var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) {
                    return [];
                }
                object = Object2(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                });
            };
            var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                var result2 = [];
                while (object) {
                    arrayPush(result2, getSymbols(object));
                    object = getPrototype(object);
                }
                return result2;
            };
            var getTag = baseGetTag;
            if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                getTag = function(value) {
                    var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) {
                        switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag;
                            case mapCtorString:
                                return mapTag;
                            case promiseCtorString:
                                return promiseTag;
                            case setCtorString:
                                return setTag;
                            case weakMapCtorString:
                                return weakMapTag;
                        }
                    }
                    return result2;
                };
            }
            function getView(start2, end2, transforms) {
                var index2 = -1, length = transforms.length;
                while (++index2 < length) {
                    var data = transforms[index2], size22 = data.size;
                    switch (data.type) {
                        case "drop":
                            start2 += size22;
                            break;
                        case "dropRight":
                            end2 -= size22;
                            break;
                        case "take":
                            end2 = nativeMin(end2, start2 + size22);
                            break;
                        case "takeRight":
                            start2 = nativeMax(start2, end2 - size22);
                            break;
                    }
                }
                return { "start": start2, "end": end2 };
            }
            function getWrapDetails(source) {
                var match = source.match(reWrapDetails);
                return match ? match[1].split(reSplitDetails) : [];
            }
            function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index2 = -1, length = path.length, result2 = false;
                while (++index2 < length) {
                    var key = toKey(path[index2]);
                    if (!(result2 = object != null && hasFunc(object, key))) {
                        break;
                    }
                    object = object[key];
                }
                if (result2 || ++index2 != length) {
                    return result2;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
            }
            function initCloneArray(array) {
                var length = array.length, result2 = new array.constructor(length);
                if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
                    result2.index = array.index;
                    result2.input = array.input;
                }
                return result2;
            }
            function initCloneObject(object) {
                return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
            }
            function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                    case arrayBufferTag:
                        return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                        return new Ctor(+object);
                    case dataViewTag:
                        return cloneDataView(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                        return cloneTypedArray(object, isDeep);
                    case mapTag:
                        return new Ctor();
                    case numberTag:
                    case stringTag:
                        return new Ctor(object);
                    case regexpTag:
                        return cloneRegExp(object);
                    case setTag:
                        return new Ctor();
                    case symbolTag:
                        return cloneSymbol(object);
                }
            }
            function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                    return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                details = details.join(length > 2 ? ", " : " ");
                return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
            }
            function isFlattenable(value) {
                return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
            }
            function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
            }
            function isIterateeCall(value, index2, object) {
                if (!isObject2(object)) {
                    return false;
                }
                var type = typeof index2;
                if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
                    return eq(object[index2], value);
                }
                return false;
            }
            function isKey(value, object) {
                if (isArray2(value)) {
                    return false;
                }
                var type = typeof value;
                if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
                    return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
            }
            function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
            }
            function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash2[funcName];
                if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                    return false;
                }
                if (func === other) {
                    return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
            }
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            var isMaskable = coreJsData ? isFunction2 : stubFalse;
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
            }
            function isStrictComparable(value) {
                return value === value && !isObject2(value);
            }
            function matchesStrictComparable(key, srcValue) {
                return function(object) {
                    if (object == null) {
                        return false;
                    }
                    return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
                };
            }
            function memoizeCapped(func) {
                var result2 = memoize(func, function(key) {
                    if (cache2.size === MAX_MEMOIZE_SIZE) {
                        cache2.clear();
                    }
                    return key;
                });
                var cache2 = result2.cache;
                return result2;
            }
            function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                if (!(isCommon || isCombo)) {
                    return data;
                }
                if (srcBitmask & WRAP_BIND_FLAG) {
                    data[2] = source[2];
                    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                var value = source[3];
                if (value) {
                    var partials = data[3];
                    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                value = source[5];
                if (value) {
                    partials = data[5];
                    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                value = source[7];
                if (value) {
                    data[7] = value;
                }
                if (srcBitmask & WRAP_ARY_FLAG) {
                    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                }
                if (data[9] == null) {
                    data[9] = source[9];
                }
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
            }
            function nativeKeysIn(object) {
                var result2 = [];
                if (object != null) {
                    for (var key in Object2(object)) {
                        result2.push(key);
                    }
                }
                return result2;
            }
            function objectToString2(value) {
                return nativeObjectToString.call(value);
            }
            function overRest(func, start2, transform22) {
                start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
                return function() {
                    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
                    while (++index2 < length) {
                        array[index2] = args[start2 + index2];
                    }
                    index2 = -1;
                    var otherArgs = Array2(start2 + 1);
                    while (++index2 < start2) {
                        otherArgs[index2] = args[index2];
                    }
                    otherArgs[start2] = transform22(array);
                    return apply2(func, this, otherArgs);
                };
            }
            function parent(object, path) {
                return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
            }
            function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                while (length--) {
                    var index2 = indexes[length];
                    array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
                }
                return array;
            }
            function safeGet(object, key) {
                if (key === "constructor" && typeof object[key] === "function") {
                    return;
                }
                if (key == "__proto__") {
                    return;
                }
                return object[key];
            }
            var setData = shortOut(baseSetData);
            var setTimeout2 = ctxSetTimeout || function(func, wait) {
                return root.setTimeout(func, wait);
            };
            var setToString = shortOut(baseSetToString);
            function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + "";
                return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
            }
            function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function() {
                    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                    lastCalled = stamp;
                    if (remaining > 0) {
                        if (++count >= HOT_COUNT) {
                            return arguments[0];
                        }
                    } else {
                        count = 0;
                    }
                    return func.apply(undefined$1, arguments);
                };
            }
            function shuffleSelf(array, size22) {
                var index2 = -1, length = array.length, lastIndex = length - 1;
                size22 = size22 === undefined$1 ? length : size22;
                while (++index2 < size22) {
                    var rand = baseRandom(index2, lastIndex), value = array[rand];
                    array[rand] = array[index2];
                    array[index2] = value;
                }
                array.length = size22;
                return array;
            }
            var stringToPath = memoizeCapped(function(string) {
                var result2 = [];
                if (string.charCodeAt(0) === 46) {
                    result2.push("");
                }
                string.replace(rePropName, function(match, number2, quote, subString) {
                    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
                });
                return result2;
            });
            function toKey(value) {
                if (typeof value == "string" || isSymbol2(value)) {
                    return value;
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
            }
            function toSource(func) {
                if (func != null) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {
                    }
                    try {
                        return func + "";
                    } catch (e) {
                    }
                }
                return "";
            }
            function updateWrapDetails(details, bitmask) {
                arrayEach(wrapFlags, function(pair) {
                    var value = "_." + pair[0];
                    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                        details.push(value);
                    }
                });
                return details.sort();
            }
            function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                    return wrapper.clone();
                }
                var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result2.__actions__ = copyArray(wrapper.__actions__);
                result2.__index__ = wrapper.__index__;
                result2.__values__ = wrapper.__values__;
                return result2;
            }
            function chunk(array, size22, guard) {
                if (guard ? isIterateeCall(array, size22, guard) : size22 === undefined$1) {
                    size22 = 1;
                } else {
                    size22 = nativeMax(toInteger(size22), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size22 < 1) {
                    return [];
                }
                var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size22));
                while (index2 < length) {
                    result2[resIndex++] = baseSlice(array, index2, index2 += size22);
                }
                return result2;
            }
            function compact(array) {
                var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                while (++index2 < length) {
                    var value = array[index2];
                    if (value) {
                        result2[resIndex++] = value;
                    }
                }
                return result2;
            }
            function concat() {
                var length = arguments.length;
                if (!length) {
                    return [];
                }
                var args = Array2(length - 1), array = arguments[0], index2 = length;
                while (index2--) {
                    args[index2 - 1] = arguments[index2];
                }
                return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
            }
            var difference2 = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
            });
            var differenceBy = baseRest(function(array, values2) {
                var iteratee2 = last(values2);
                if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
            });
            var differenceWith = baseRest(function(array, values2) {
                var comparator2 = last(values2);
                if (isArrayLikeObject(comparator2)) {
                    comparator2 = undefined$1;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
            });
            function drop(array, n2, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
                return baseSlice(array, n2 < 0 ? 0 : n2, length);
            }
            function dropRight(array, n2, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
                n2 = length - n2;
                return baseSlice(array, 0, n2 < 0 ? 0 : n2);
            }
            function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
            }
            function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
            }
            function fill(array, value, start2, end2) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
                    start2 = 0;
                    end2 = length;
                }
                return baseFill(array, value, start2, end2);
            }
            function findIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                    index2 = nativeMax(length + index2, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2);
            }
            function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return -1;
                }
                var index2 = length - 1;
                if (fromIndex !== undefined$1) {
                    index2 = toInteger(fromIndex);
                    index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
            }
            function flatten(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
            }
            function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
            }
            function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
            }
            function fromPairs(pairs) {
                var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                while (++index2 < length) {
                    var pair = pairs[index2];
                    result2[pair[0]] = pair[1];
                }
                return result2;
            }
            function head(array) {
                return array && array.length ? array[0] : undefined$1;
            }
            function indexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return -1;
                }
                var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index2 < 0) {
                    index2 = nativeMax(length + index2, 0);
                }
                return baseIndexOf(array, value, index2);
            }
            function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 0, -1) : [];
            }
            var intersection2 = baseRest(function(arrays) {
                var mapped = arrayMap(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
            });
            var intersectionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                if (iteratee2 === last(mapped)) {
                    iteratee2 = undefined$1;
                } else {
                    mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
            });
            var intersectionWith = baseRest(function(arrays) {
                var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
                if (comparator2) {
                    mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
            });
            function join2(array, separator) {
                return array == null ? "" : nativeJoin.call(array, separator);
            }
            function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined$1;
            }
            function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return -1;
                }
                var index2 = length;
                if (fromIndex !== undefined$1) {
                    index2 = toInteger(fromIndex);
                    index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
            }
            function nth(array, n2) {
                return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
            }
            var pull = baseRest(pullAll);
            function pullAll(array, values2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
            }
            function pullAllBy(array, values2, iteratee2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
            }
            function pullAllWith(array, values2, comparator2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator2) : array;
            }
            var pullAt = flatRest(function(array, indexes) {
                var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                basePullAt(array, arrayMap(indexes, function(index2) {
                    return isIndex(index2, length) ? +index2 : index2;
                }).sort(compareAscending));
                return result2;
            });
            function remove2(array, predicate) {
                var result2 = [];
                if (!(array && array.length)) {
                    return result2;
                }
                var index2 = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index2 < length) {
                    var value = array[index2];
                    if (predicate(value, index2, array)) {
                        result2.push(value);
                        indexes.push(index2);
                    }
                }
                basePullAt(array, indexes);
                return result2;
            }
            function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
            }
            function slice(array, start2, end2) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
                    start2 = 0;
                    end2 = length;
                } else {
                    start2 = start2 == null ? 0 : toInteger(start2);
                    end2 = end2 === undefined$1 ? length : toInteger(end2);
                }
                return baseSlice(array, start2, end2);
            }
            function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
            }
            function sortedIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
            }
            function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                    var index2 = baseSortedIndex(array, value);
                    if (index2 < length && eq(array[index2], value)) {
                        return index2;
                    }
                }
                return -1;
            }
            function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
            }
            function sortedLastIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
            }
            function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                    var index2 = baseSortedIndex(array, value, true) - 1;
                    if (eq(array[index2], value)) {
                        return index2;
                    }
                }
                return -1;
            }
            function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
            }
            function sortedUniqBy(array, iteratee2) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
            }
            function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice(array, 1, length) : [];
            }
            function take(array, n2, guard) {
                if (!(array && array.length)) {
                    return [];
                }
                n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
                return baseSlice(array, 0, n2 < 0 ? 0 : n2);
            }
            function takeRight(array, n2, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                    return [];
                }
                n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
                n2 = length - n2;
                return baseSlice(array, n2 < 0 ? 0 : n2, length);
            }
            function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
            }
            function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
            }
            var union2 = baseRest(function(arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
            });
            var unionBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                }
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
            });
            var unionWith = baseRest(function(arrays) {
                var comparator2 = last(arrays);
                comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
            });
            function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
            }
            function uniqBy(array, iteratee2) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
            }
            function uniqWith(array, comparator2) {
                comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
                return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
            }
            function unzip(array) {
                if (!(array && array.length)) {
                    return [];
                }
                var length = 0;
                array = arrayFilter(array, function(group) {
                    if (isArrayLikeObject(group)) {
                        length = nativeMax(group.length, length);
                        return true;
                    }
                });
                return baseTimes(length, function(index2) {
                    return arrayMap(array, baseProperty(index2));
                });
            }
            function unzipWith(array, iteratee2) {
                if (!(array && array.length)) {
                    return [];
                }
                var result2 = unzip(array);
                if (iteratee2 == null) {
                    return result2;
                }
                return arrayMap(result2, function(group) {
                    return apply2(iteratee2, undefined$1, group);
                });
            }
            var without = baseRest(function(array, values2) {
                return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
            });
            var xor = baseRest(function(arrays) {
                return baseXor(arrayFilter(arrays, isArrayLikeObject));
            });
            var xorBy = baseRest(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined$1;
                }
                return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
            });
            var xorWith = baseRest(function(arrays) {
                var comparator2 = last(arrays);
                comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
                return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
            });
            var zip = baseRest(unzip);
            function zipObject(props, values2) {
                return baseZipObject(props || [], values2 || [], assignValue);
            }
            function zipObjectDeep(props, values2) {
                return baseZipObject(props || [], values2 || [], baseSet);
            }
            var zipWith = baseRest(function(arrays) {
                var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
                iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
                return unzipWith(arrays, iteratee2);
            });
            function chain(value) {
                var result2 = lodash2(value);
                result2.__chain__ = true;
                return result2;
            }
            function tap(value, interceptor) {
                interceptor(value);
                return value;
            }
            function thru(value, interceptor) {
                return interceptor(value);
            }
            var wrapperAt = flatRest(function(paths) {
                var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                    return baseAt(object, paths);
                };
                if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
                    return this.thru(interceptor);
                }
                value = value.slice(start2, +start2 + (length ? 1 : 0));
                value.__actions__.push({
                    "func": thru,
                    "args": [interceptor],
                    "thisArg": undefined$1
                });
                return new LodashWrapper(value, this.__chain__).thru(function(array) {
                    if (length && !array.length) {
                        array.push(undefined$1);
                    }
                    return array;
                });
            });
            function wrapperChain() {
                return chain(this);
            }
            function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
            }
            function wrapperNext() {
                if (this.__values__ === undefined$1) {
                    this.__values__ = toArray(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
                return { "done": done, "value": value };
            }
            function wrapperToIterator() {
                return this;
            }
            function wrapperPlant(value) {
                var result2, parent2 = this;
                while (parent2 instanceof baseLodash) {
                    var clone2 = wrapperClone(parent2);
                    clone2.__index__ = 0;
                    clone2.__values__ = undefined$1;
                    if (result2) {
                        previous.__wrapped__ = clone2;
                    } else {
                        result2 = clone2;
                    }
                    var previous = clone2;
                    parent2 = parent2.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result2;
            }
            function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                    var wrapped = value;
                    if (this.__actions__.length) {
                        wrapped = new LazyWrapper(this);
                    }
                    wrapped = wrapped.reverse();
                    wrapped.__actions__.push({
                        "func": thru,
                        "args": [reverse],
                        "thisArg": undefined$1
                    });
                    return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
            }
            function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
            }
            var countBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty2.call(result2, key)) {
                    ++result2[key];
                } else {
                    baseAssignValue(result2, key, 1);
                }
            });
            function every(collection, predicate, guard) {
                var func = isArray2(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
            }
            function filter(collection, predicate) {
                var func = isArray2(collection) ? arrayFilter : baseFilter;
                return func(collection, getIteratee(predicate, 3));
            }
            var find = createFind(findIndex);
            var findLast = createFind(findLastIndex);
            function flatMap(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), 1);
            }
            function flatMapDeep(collection, iteratee2) {
                return baseFlatten(map(collection, iteratee2), INFINITY);
            }
            function flatMapDepth(collection, iteratee2, depth) {
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(map(collection, iteratee2), depth);
            }
            function forEach(collection, iteratee2) {
                var func = isArray2(collection) ? arrayEach : baseEach;
                return func(collection, getIteratee(iteratee2, 3));
            }
            function forEachRight(collection, iteratee2) {
                var func = isArray2(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee2, 3));
            }
            var groupBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty2.call(result2, key)) {
                    result2[key].push(value);
                } else {
                    baseAssignValue(result2, key, [value]);
                }
            });
            function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                    fromIndex = nativeMax(length + fromIndex, 0);
                }
                return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
            }
            var invokeMap = baseRest(function(collection, path, args) {
                var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                baseEach(collection, function(value) {
                    result2[++index2] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
                });
                return result2;
            });
            var keyBy = createAggregator(function(result2, value, key) {
                baseAssignValue(result2, key, value);
            });
            function map(collection, iteratee2) {
                var func = isArray2(collection) ? arrayMap : baseMap;
                return func(collection, getIteratee(iteratee2, 3));
            }
            function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                    return [];
                }
                if (!isArray2(iteratees)) {
                    iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined$1 : orders;
                if (!isArray2(orders)) {
                    orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
            }
            var partition = createAggregator(function(result2, value, key) {
                result2[key ? 0 : 1].push(value);
            }, function() {
                return [[], []];
            });
            function reduce(collection, iteratee2, accumulator) {
                var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
            }
            function reduceRight(collection, iteratee2, accumulator) {
                var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
            }
            function reject(collection, predicate) {
                var func = isArray2(collection) ? arrayFilter : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
            }
            function sample(collection) {
                var func = isArray2(collection) ? arraySample : baseSample;
                return func(collection);
            }
            function sampleSize(collection, n2, guard) {
                if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
                    n2 = 1;
                } else {
                    n2 = toInteger(n2);
                }
                var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n2);
            }
            function shuffle(collection) {
                var func = isArray2(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
            }
            function size2(collection) {
                if (collection == null) {
                    return 0;
                }
                if (isArrayLike(collection)) {
                    return isString2(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag(collection);
                if (tag == mapTag || tag == setTag) {
                    return collection.size;
                }
                return baseKeys(collection).length;
            }
            function some(collection, predicate, guard) {
                var func = isArray2(collection) ? arraySome : baseSome;
                if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
            }
            var sortBy = baseRest(function(collection, iteratees) {
                if (collection == null) {
                    return [];
                }
                var length = iteratees.length;
                if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
            });
            var now = ctxNow || function() {
                return root.Date.now();
            };
            function after(n2, func) {
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n2 = toInteger(n2);
                return function() {
                    if (--n2 < 1) {
                        return func.apply(this, arguments);
                    }
                };
            }
            function ary(func, n2, guard) {
                n2 = guard ? undefined$1 : n2;
                n2 = func && n2 == null ? func.length : n2;
                return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
            }
            function before(n2, func) {
                var result2;
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                n2 = toInteger(n2);
                return function() {
                    if (--n2 > 0) {
                        result2 = func.apply(this, arguments);
                    }
                    if (n2 <= 1) {
                        func = undefined$1;
                    }
                    return result2;
                };
            }
            var bind = baseRest(function(func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
            });
            var bindKey = baseRest(function(object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
            });
            function curry(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curry.placeholder;
                return result2;
            }
            function curryRight(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curryRight.placeholder;
                return result2;
            }
            function debounce(func, wait, options) {
                var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                wait = toNumber(wait) || 0;
                if (isObject2(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    lastArgs = lastThis = undefined$1;
                    lastInvokeTime = time;
                    result2 = func.apply(thisArg, args);
                    return result2;
                }
                function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout2(timerExpired, wait);
                    return leading ? invokeFunc(time) : result2;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) {
                        return trailingEdge(time);
                    }
                    timerId = setTimeout2(timerExpired, remainingWait(time));
                }
                function trailingEdge(time) {
                    timerId = undefined$1;
                    if (trailing && lastArgs) {
                        return invokeFunc(time);
                    }
                    lastArgs = lastThis = undefined$1;
                    return result2;
                }
                function cancel() {
                    if (timerId !== undefined$1) {
                        clearTimeout2(timerId);
                    }
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                }
                function flush() {
                    return timerId === undefined$1 ? result2 : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                        if (timerId === undefined$1) {
                            return leadingEdge(lastCallTime);
                        }
                        if (maxing) {
                            clearTimeout2(timerId);
                            timerId = setTimeout2(timerExpired, wait);
                            return invokeFunc(lastCallTime);
                        }
                    }
                    if (timerId === undefined$1) {
                        timerId = setTimeout2(timerExpired, wait);
                    }
                    return result2;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
            }
            var defer = baseRest(function(func, args) {
                return baseDelay(func, 1, args);
            });
            var delay = baseRest(function(func, wait, args) {
                return baseDelay(func, toNumber(wait) || 0, args);
            });
            function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
            }
            function memoize(func, resolver) {
                if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                var memoized = function() {
                    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
                    if (cache2.has(key)) {
                        return cache2.get(key);
                    }
                    var result2 = func.apply(this, args);
                    memoized.cache = cache2.set(key, result2) || cache2;
                    return result2;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
            }
            memoize.Cache = MapCache;
            function negate(predicate) {
                if (typeof predicate != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                return function() {
                    var args = arguments;
                    switch (args.length) {
                        case 0:
                            return !predicate.call(this);
                        case 1:
                            return !predicate.call(this, args[0]);
                        case 2:
                            return !predicate.call(this, args[0], args[1]);
                        case 3:
                            return !predicate.call(this, args[0], args[1], args[2]);
                    }
                    return !predicate.apply(this, args);
                };
            }
            function once(func) {
                return before(2, func);
            }
            var overArgs = castRest(function(func, transforms) {
                transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                var funcsLength = transforms.length;
                return baseRest(function(args) {
                    var index2 = -1, length = nativeMin(args.length, funcsLength);
                    while (++index2 < length) {
                        args[index2] = transforms[index2].call(this, args[index2]);
                    }
                    return apply2(func, this, args);
                });
            });
            var partial = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
            });
            var partialRight = baseRest(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
            });
            var rearg = flatRest(function(func, indexes) {
                return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
            });
            function rest(func, start2) {
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start2 = start2 === undefined$1 ? start2 : toInteger(start2);
                return baseRest(func, start2);
            }
            function spread(func, start2) {
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
                return baseRest(function(args) {
                    var array = args[start2], otherArgs = castSlice(args, 0, start2);
                    if (array) {
                        arrayPush(otherArgs, array);
                    }
                    return apply2(func, this, otherArgs);
                });
            }
            function throttle(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (isObject2(options)) {
                    leading = "leading" in options ? !!options.leading : leading;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce(func, wait, {
                    "leading": leading,
                    "maxWait": wait,
                    "trailing": trailing
                });
            }
            function unary(func) {
                return ary(func, 1);
            }
            function wrap(value, wrapper) {
                return partial(castFunction(wrapper), value);
            }
            function castArray() {
                if (!arguments.length) {
                    return [];
                }
                var value = arguments[0];
                return isArray2(value) ? value : [value];
            }
            function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
            }
            function cloneWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
            }
            function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
            }
            function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
            }
            function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys(source));
            }
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }
            var gt2 = createRelationalOperation(baseGt);
            var gte = createRelationalOperation(function(value, other) {
                return value >= other;
            });
            var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            };
            var isArray2 = Array2.isArray;
            var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
            function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction2(value);
            }
            function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
            }
            function isBoolean2(value) {
                return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
            }
            var isBuffer = nativeIsBuffer || stubFalse;
            var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
            function isElement(value) {
                return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
            }
            function isEmpty(value) {
                if (value == null) {
                    return true;
                }
                if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                    return !value.length;
                }
                var tag = getTag(value);
                if (tag == mapTag || tag == setTag) {
                    return !value.size;
                }
                if (isPrototype(value)) {
                    return !baseKeys(value).length;
                }
                for (var key in value) {
                    if (hasOwnProperty2.call(value, key)) {
                        return false;
                    }
                }
                return true;
            }
            function isEqual(value, other) {
                return baseIsEqual(value, other);
            }
            function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                var result2 = customizer ? customizer(value, other) : undefined$1;
                return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
            }
            function isError(value) {
                if (!isObjectLike(value)) {
                    return false;
                }
                var tag = baseGetTag(value);
                return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
            }
            function isFinite2(value) {
                return typeof value == "number" && nativeIsFinite(value);
            }
            function isFunction2(value) {
                if (!isObject2(value)) {
                    return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            function isInteger(value) {
                return typeof value == "number" && value == toInteger(value);
            }
            function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            function isObject2(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
            }
            function isObjectLike(value) {
                return value != null && typeof value == "object";
            }
            var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
            function isMatch(object, source) {
                return object === source || baseIsMatch(object, source, getMatchData(source));
            }
            function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseIsMatch(object, source, getMatchData(source), customizer);
            }
            function isNaN2(value) {
                return isNumber2(value) && value != +value;
            }
            function isNative(value) {
                if (isMaskable(value)) {
                    throw new Error2(CORE_ERROR_TEXT);
                }
                return baseIsNative(value);
            }
            function isNull(value) {
                return value === null;
            }
            function isNil(value) {
                return value == null;
            }
            function isNumber2(value) {
                return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
            }
            function isPlainObject2(value) {
                if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false;
                }
                var proto = getPrototype(value);
                if (proto === null) {
                    return true;
                }
                var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
                return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
            }
            var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
            function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
            }
            var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
            function isString2(value) {
                return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
            }
            function isSymbol2(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
            }
            var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            function isUndefined(value) {
                return value === undefined$1;
            }
            function isWeakMap(value) {
                return isObjectLike(value) && getTag(value) == weakMapTag;
            }
            function isWeakSet(value) {
                return isObjectLike(value) && baseGetTag(value) == weakSetTag;
            }
            var lt2 = createRelationalOperation(baseLt);
            var lte = createRelationalOperation(function(value, other) {
                return value <= other;
            });
            function toArray(value) {
                if (!value) {
                    return [];
                }
                if (isArrayLike(value)) {
                    return isString2(value) ? stringToArray(value) : copyArray(value);
                }
                if (symIterator && value[symIterator]) {
                    return iteratorToArray(value[symIterator]());
                }
                var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                return func(value);
            }
            function toFinite(value) {
                if (!value) {
                    return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                    var sign2 = value < 0 ? -1 : 1;
                    return sign2 * MAX_INTEGER;
                }
                return value === value ? value : 0;
            }
            function toInteger(value) {
                var result2 = toFinite(value), remainder = result2 % 1;
                return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
            }
            function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
            }
            function toNumber(value) {
                if (typeof value == "number") {
                    return value;
                }
                if (isSymbol2(value)) {
                    return NAN;
                }
                if (isObject2(value)) {
                    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                    value = isObject2(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                    return value === 0 ? value : +value;
                }
                value = baseTrim(value);
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            function toPlainObject(value) {
                return copyObject(value, keysIn(value));
            }
            function toSafeInteger(value) {
                return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
            }
            function toString(value) {
                return value == null ? "" : baseToString(value);
            }
            var assign2 = createAssigner(function(object, source) {
                if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                }
                for (var key in source) {
                    if (hasOwnProperty2.call(source, key)) {
                        assignValue(object, key, source[key]);
                    }
                }
            });
            var assignIn = createAssigner(function(object, source) {
                copyObject(source, keysIn(source), object);
            });
            var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keysIn(source), object, customizer);
            });
            var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                copyObject(source, keys(source), object, customizer);
            });
            var at2 = flatRest(baseAt);
            function create(prototype, properties2) {
                var result2 = baseCreate(prototype);
                return properties2 == null ? result2 : baseAssign(result2, properties2);
            }
            var defaults = baseRest(function(object, sources) {
                object = Object2(object);
                var index2 = -1;
                var length = sources.length;
                var guard = length > 2 ? sources[2] : undefined$1;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1;
                }
                while (++index2 < length) {
                    var source = sources[index2];
                    var props = keysIn(source);
                    var propsIndex = -1;
                    var propsLength = props.length;
                    while (++propsIndex < propsLength) {
                        var key = props[propsIndex];
                        var value = object[key];
                        if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                            object[key] = source[key];
                        }
                    }
                }
                return object;
            });
            var defaultsDeep = baseRest(function(args) {
                args.push(undefined$1, customDefaultsMerge);
                return apply2(mergeWith, undefined$1, args);
            });
            function findKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
            }
            function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
            }
            function forIn(object, iteratee2) {
                return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
            }
            function forInRight(object, iteratee2) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
            }
            function forOwn(object, iteratee2) {
                return object && baseForOwn(object, getIteratee(iteratee2, 3));
            }
            function forOwnRight(object, iteratee2) {
                return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
            }
            function functions(object) {
                return object == null ? [] : baseFunctions(object, keys(object));
            }
            function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn(object));
            }
            function get2(object, path, defaultValue) {
                var result2 = object == null ? undefined$1 : baseGet(object, path);
                return result2 === undefined$1 ? defaultValue : result2;
            }
            function has2(object, path) {
                return object != null && hasPath(object, path, baseHas);
            }
            function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
            }
            var invert = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                }
                result2[value] = key;
            }, constant(identity2));
            var invertBy = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                }
                if (hasOwnProperty2.call(result2, value)) {
                    result2[value].push(key);
                } else {
                    result2[value] = [key];
                }
            }, getIteratee);
            var invoke = baseRest(baseInvoke);
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            function keysIn(object) {
                return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
            }
            function mapKeys(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, iteratee2(value, key, object2), value);
                });
                return result2;
            }
            function mapValues(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, key, iteratee2(value, key, object2));
                });
                return result2;
            }
            var merge = createAssigner(function(object, source, srcIndex) {
                baseMerge(object, source, srcIndex);
            });
            var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                baseMerge(object, source, srcIndex, customizer);
            });
            var omit = flatRest(function(object, paths) {
                var result2 = {};
                if (object == null) {
                    return result2;
                }
                var isDeep = false;
                paths = arrayMap(paths, function(path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                });
                copyObject(object, getAllKeysIn(object), result2);
                if (isDeep) {
                    result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                }
                var length = paths.length;
                while (length--) {
                    baseUnset(result2, paths[length]);
                }
                return result2;
            });
            function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
            }
            var pick = flatRest(function(object, paths) {
                return object == null ? {} : basePick(object, paths);
            });
            function pickBy(object, predicate) {
                if (object == null) {
                    return {};
                }
                var props = arrayMap(getAllKeysIn(object), function(prop) {
                    return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function(value, path) {
                    return predicate(value, path[0]);
                });
            }
            function result(object, path, defaultValue) {
                path = castPath(path, object);
                var index2 = -1, length = path.length;
                if (!length) {
                    length = 1;
                    object = undefined$1;
                }
                while (++index2 < length) {
                    var value = object == null ? undefined$1 : object[toKey(path[index2])];
                    if (value === undefined$1) {
                        index2 = length;
                        value = defaultValue;
                    }
                    object = isFunction2(value) ? value.call(object) : value;
                }
                return object;
            }
            function set2(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
            }
            function setWith(object, path, value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseSet(object, path, value, customizer);
            }
            var toPairs = createToPairs(keys);
            var toPairsIn = createToPairs(keysIn);
            function transform2(object, iteratee2, accumulator) {
                var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                iteratee2 = getIteratee(iteratee2, 4);
                if (accumulator == null) {
                    var Ctor = object && object.constructor;
                    if (isArrLike) {
                        accumulator = isArr ? new Ctor() : [];
                    } else if (isObject2(object)) {
                        accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
                    } else {
                        accumulator = {};
                    }
                }
                (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
                    return iteratee2(accumulator, value, index2, object2);
                });
                return accumulator;
            }
            function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
            }
            function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction(updater));
            }
            function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
            }
            function values(object) {
                return object == null ? [] : baseValues(object, keys(object));
            }
            function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn(object));
            }
            function clamp2(number2, lower, upper) {
                if (upper === undefined$1) {
                    upper = lower;
                    lower = undefined$1;
                }
                if (upper !== undefined$1) {
                    upper = toNumber(upper);
                    upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined$1) {
                    lower = toNumber(lower);
                    lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber(number2), lower, upper);
            }
            function inRange(number2, start2, end2) {
                start2 = toFinite(start2);
                if (end2 === undefined$1) {
                    end2 = start2;
                    start2 = 0;
                } else {
                    end2 = toFinite(end2);
                }
                number2 = toNumber(number2);
                return baseInRange(number2, start2, end2);
            }
            function random(lower, upper, floating) {
                if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                    upper = floating = undefined$1;
                }
                if (floating === undefined$1) {
                    if (typeof upper == "boolean") {
                        floating = upper;
                        upper = undefined$1;
                    } else if (typeof lower == "boolean") {
                        floating = lower;
                        lower = undefined$1;
                    }
                }
                if (lower === undefined$1 && upper === undefined$1) {
                    lower = 0;
                    upper = 1;
                } else {
                    lower = toFinite(lower);
                    if (upper === undefined$1) {
                        upper = lower;
                        lower = 0;
                    } else {
                        upper = toFinite(upper);
                    }
                }
                if (lower > upper) {
                    var temp = lower;
                    lower = upper;
                    upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                    var rand = nativeRandom();
                    return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                }
                return baseRandom(lower, upper);
            }
            var camelCase = createCompounder(function(result2, word, index2) {
                word = word.toLowerCase();
                return result2 + (index2 ? capitalize2(word) : word);
            });
            function capitalize2(string) {
                return upperFirst(toString(string).toLowerCase());
            }
            function deburr(string) {
                string = toString(string);
                return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
            }
            function endsWith(string, target, position) {
                string = toString(string);
                target = baseToString(target);
                var length = string.length;
                position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                var end2 = position;
                position -= target.length;
                return position >= 0 && string.slice(position, end2) == target;
            }
            function escape(string) {
                string = toString(string);
                return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
            }
            function escapeRegExp(string) {
                string = toString(string);
                return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
            }
            var kebabCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "-" : "") + word.toLowerCase();
            });
            var lowerCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toLowerCase();
            });
            var lowerFirst = createCaseFirst("toLowerCase");
            function pad(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                if (!length || strLength >= length) {
                    return string;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
            }
            function padEnd(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
            }
            function padStart(string, length, chars) {
                string = toString(string);
                length = toInteger(length);
                var strLength = length ? stringSize(string) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
            }
            function parseInt2(string, radix, guard) {
                if (guard || radix == null) {
                    radix = 0;
                } else if (radix) {
                    radix = +radix;
                }
                return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
            }
            function repeat(string, n2, guard) {
                if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
                    n2 = 1;
                } else {
                    n2 = toInteger(n2);
                }
                return baseRepeat(toString(string), n2);
            }
            function replace() {
                var args = arguments, string = toString(args[0]);
                return args.length < 3 ? string : string.replace(args[1], args[2]);
            }
            var snakeCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? "_" : "") + word.toLowerCase();
            });
            function split(string, separator, limit) {
                if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                    separator = limit = undefined$1;
                }
                limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                    return [];
                }
                string = toString(string);
                if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
                    separator = baseToString(separator);
                    if (!separator && hasUnicode(string)) {
                        return castSlice(stringToArray(string), 0, limit);
                    }
                }
                return string.split(separator, limit);
            }
            var startCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + upperFirst(word);
            });
            function startsWith(string, target, position) {
                string = toString(string);
                position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                target = baseToString(target);
                return string.slice(position, position + target.length) == target;
            }
            function template(string, options, guard) {
                var settings = lodash2.templateSettings;
                if (guard && isIterateeCall(string, options, guard)) {
                    options = undefined$1;
                }
                string = toString(string);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                var reDelimiters = RegExp2(
                    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                    "g"
                );
                var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
                    if (escapeValue) {
                        isEscaping = true;
                        source += "' +\n__e(" + escapeValue + ") +\n'";
                    }
                    if (evaluateValue) {
                        isEvaluating = true;
                        source += "';\n" + evaluateValue + ";\n__p += '";
                    }
                    if (interpolateValue) {
                        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                    }
                    index2 = offset + match.length;
                    return match;
                });
                source += "';\n";
                var variable = hasOwnProperty2.call(options, "variable") && options.variable;
                if (!variable) {
                    source = "with (obj) {\n" + source + "\n}\n";
                } else if (reForbiddenIdentifierChars.test(variable)) {
                    throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                var result2 = attempt(function() {
                    return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
                });
                result2.source = source;
                if (isError(result2)) {
                    throw result2;
                }
                return result2;
            }
            function toLower(value) {
                return toString(value).toLowerCase();
            }
            function toUpper(value) {
                return toString(value).toUpperCase();
            }
            function trim(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                    return baseTrim(string);
                }
                if (!string || !(chars = baseToString(chars))) {
                    return string;
                }
                var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice(strSymbols, start2, end2).join("");
            }
            function trimEnd(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                    return string.slice(0, trimmedEndIndex(string) + 1);
                }
                if (!string || !(chars = baseToString(chars))) {
                    return string;
                }
                var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                return castSlice(strSymbols, 0, end2).join("");
            }
            function trimStart(string, chars, guard) {
                string = toString(string);
                if (string && (guard || chars === undefined$1)) {
                    return string.replace(reTrimStart, "");
                }
                if (!string || !(chars = baseToString(chars))) {
                    return string;
                }
                var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
                return castSlice(strSymbols, start2).join("");
            }
            function truncate(string, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject2(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? toInteger(options.length) : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                }
                string = toString(string);
                var strLength = string.length;
                if (hasUnicode(string)) {
                    var strSymbols = stringToArray(string);
                    strLength = strSymbols.length;
                }
                if (length >= strLength) {
                    return string;
                }
                var end2 = length - stringSize(omission);
                if (end2 < 1) {
                    return omission;
                }
                var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
                if (separator === undefined$1) {
                    return result2 + omission;
                }
                if (strSymbols) {
                    end2 += result2.length - end2;
                }
                if (isRegExp2(separator)) {
                    if (string.slice(end2).search(separator)) {
                        var match, substring = result2;
                        if (!separator.global) {
                            separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                        }
                        separator.lastIndex = 0;
                        while (match = separator.exec(substring)) {
                            var newEnd = match.index;
                        }
                        result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
                    }
                } else if (string.indexOf(baseToString(separator), end2) != end2) {
                    var index2 = result2.lastIndexOf(separator);
                    if (index2 > -1) {
                        result2 = result2.slice(0, index2);
                    }
                }
                return result2 + omission;
            }
            function unescape(string) {
                string = toString(string);
                return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
            }
            var upperCase = createCompounder(function(result2, word, index2) {
                return result2 + (index2 ? " " : "") + word.toUpperCase();
            });
            var upperFirst = createCaseFirst("toUpperCase");
            function words(string, pattern2, guard) {
                string = toString(string);
                pattern2 = guard ? undefined$1 : pattern2;
                if (pattern2 === undefined$1) {
                    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                }
                return string.match(pattern2) || [];
            }
            var attempt = baseRest(function(func, args) {
                try {
                    return apply2(func, undefined$1, args);
                } catch (e) {
                    return isError(e) ? e : new Error2(e);
                }
            });
            var bindAll = flatRest(function(object, methodNames) {
                arrayEach(methodNames, function(key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                });
                return object;
            });
            function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap(pairs, function(pair) {
                    if (typeof pair[1] != "function") {
                        throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    return [toIteratee(pair[0]), pair[1]];
                });
                return baseRest(function(args) {
                    var index2 = -1;
                    while (++index2 < length) {
                        var pair = pairs[index2];
                        if (apply2(pair[0], this, args)) {
                            return apply2(pair[1], this, args);
                        }
                    }
                });
            }
            function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
            }
            function constant(value) {
                return function() {
                    return value;
                };
            }
            function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
            }
            var flow = createFlow();
            var flowRight = createFlow(true);
            function identity2(value) {
                return value;
            }
            function iteratee(func) {
                return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
            }
            function matches(source) {
                return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
            }
            function matchesProperty(path, srcValue) {
                return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
            }
            var method = baseRest(function(path, args) {
                return function(object) {
                    return baseInvoke(object, path, args);
                };
            });
            var methodOf = baseRest(function(object, args) {
                return function(path) {
                    return baseInvoke(object, path, args);
                };
            });
            function mixin(object, source, options) {
                var props = keys(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
                    options = source;
                    source = object;
                    object = this;
                    methodNames = baseFunctions(source, keys(source));
                }
                var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
                arrayEach(methodNames, function(methodName) {
                    var func = source[methodName];
                    object[methodName] = func;
                    if (isFunc) {
                        object.prototype[methodName] = function() {
                            var chainAll = this.__chain__;
                            if (chain2 || chainAll) {
                                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                                actions.push({ "func": func, "args": arguments, "thisArg": object });
                                result2.__chain__ = chainAll;
                                return result2;
                            }
                            return func.apply(object, arrayPush([this.value()], arguments));
                        };
                    }
                });
                return object;
            }
            function noConflict() {
                if (root._ === this) {
                    root._ = oldDash;
                }
                return this;
            }
            function noop() {
            }
            function nthArg(n2) {
                n2 = toInteger(n2);
                return baseRest(function(args) {
                    return baseNth(args, n2);
                });
            }
            var over = createOver(arrayMap);
            var overEvery = createOver(arrayEvery);
            var overSome = createOver(arraySome);
            function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
            }
            function propertyOf(object) {
                return function(path) {
                    return object == null ? undefined$1 : baseGet(object, path);
                };
            }
            var range = createRange();
            var rangeRight = createRange(true);
            function stubArray() {
                return [];
            }
            function stubFalse() {
                return false;
            }
            function stubObject() {
                return {};
            }
            function stubString() {
                return "";
            }
            function stubTrue() {
                return true;
            }
            function times(n2, iteratee2) {
                n2 = toInteger(n2);
                if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
                    return [];
                }
                var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
                iteratee2 = getIteratee(iteratee2);
                n2 -= MAX_ARRAY_LENGTH;
                var result2 = baseTimes(length, iteratee2);
                while (++index2 < n2) {
                    iteratee2(index2);
                }
                return result2;
            }
            function toPath(value) {
                if (isArray2(value)) {
                    return arrayMap(value, toKey);
                }
                return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
            }
            function uniqueId(prefix) {
                var id = ++idCounter;
                return toString(prefix) + id;
            }
            var add2 = createMathOperation(function(augend, addend) {
                return augend + addend;
            }, 0);
            var ceil = createRound("ceil");
            var divide = createMathOperation(function(dividend, divisor) {
                return dividend / divisor;
            }, 1);
            var floor = createRound("floor");
            function max(array) {
                return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
            }
            function maxBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
            }
            function mean(array) {
                return baseMean(array, identity2);
            }
            function meanBy(array, iteratee2) {
                return baseMean(array, getIteratee(iteratee2, 2));
            }
            function min(array) {
                return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
            }
            function minBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
            }
            var multiply = createMathOperation(function(multiplier, multiplicand) {
                return multiplier * multiplicand;
            }, 1);
            var round = createRound("round");
            var subtract2 = createMathOperation(function(minuend, subtrahend) {
                return minuend - subtrahend;
            }, 0);
            function sum(array) {
                return array && array.length ? baseSum(array, identity2) : 0;
            }
            function sumBy(array, iteratee2) {
                return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
            }
            lodash2.after = after;
            lodash2.ary = ary;
            lodash2.assign = assign2;
            lodash2.assignIn = assignIn;
            lodash2.assignInWith = assignInWith;
            lodash2.assignWith = assignWith;
            lodash2.at = at2;
            lodash2.before = before;
            lodash2.bind = bind;
            lodash2.bindAll = bindAll;
            lodash2.bindKey = bindKey;
            lodash2.castArray = castArray;
            lodash2.chain = chain;
            lodash2.chunk = chunk;
            lodash2.compact = compact;
            lodash2.concat = concat;
            lodash2.cond = cond;
            lodash2.conforms = conforms;
            lodash2.constant = constant;
            lodash2.countBy = countBy;
            lodash2.create = create;
            lodash2.curry = curry;
            lodash2.curryRight = curryRight;
            lodash2.debounce = debounce;
            lodash2.defaults = defaults;
            lodash2.defaultsDeep = defaultsDeep;
            lodash2.defer = defer;
            lodash2.delay = delay;
            lodash2.difference = difference2;
            lodash2.differenceBy = differenceBy;
            lodash2.differenceWith = differenceWith;
            lodash2.drop = drop;
            lodash2.dropRight = dropRight;
            lodash2.dropRightWhile = dropRightWhile;
            lodash2.dropWhile = dropWhile;
            lodash2.fill = fill;
            lodash2.filter = filter;
            lodash2.flatMap = flatMap;
            lodash2.flatMapDeep = flatMapDeep;
            lodash2.flatMapDepth = flatMapDepth;
            lodash2.flatten = flatten;
            lodash2.flattenDeep = flattenDeep;
            lodash2.flattenDepth = flattenDepth;
            lodash2.flip = flip;
            lodash2.flow = flow;
            lodash2.flowRight = flowRight;
            lodash2.fromPairs = fromPairs;
            lodash2.functions = functions;
            lodash2.functionsIn = functionsIn;
            lodash2.groupBy = groupBy;
            lodash2.initial = initial;
            lodash2.intersection = intersection2;
            lodash2.intersectionBy = intersectionBy;
            lodash2.intersectionWith = intersectionWith;
            lodash2.invert = invert;
            lodash2.invertBy = invertBy;
            lodash2.invokeMap = invokeMap;
            lodash2.iteratee = iteratee;
            lodash2.keyBy = keyBy;
            lodash2.keys = keys;
            lodash2.keysIn = keysIn;
            lodash2.map = map;
            lodash2.mapKeys = mapKeys;
            lodash2.mapValues = mapValues;
            lodash2.matches = matches;
            lodash2.matchesProperty = matchesProperty;
            lodash2.memoize = memoize;
            lodash2.merge = merge;
            lodash2.mergeWith = mergeWith;
            lodash2.method = method;
            lodash2.methodOf = methodOf;
            lodash2.mixin = mixin;
            lodash2.negate = negate;
            lodash2.nthArg = nthArg;
            lodash2.omit = omit;
            lodash2.omitBy = omitBy;
            lodash2.once = once;
            lodash2.orderBy = orderBy;
            lodash2.over = over;
            lodash2.overArgs = overArgs;
            lodash2.overEvery = overEvery;
            lodash2.overSome = overSome;
            lodash2.partial = partial;
            lodash2.partialRight = partialRight;
            lodash2.partition = partition;
            lodash2.pick = pick;
            lodash2.pickBy = pickBy;
            lodash2.property = property;
            lodash2.propertyOf = propertyOf;
            lodash2.pull = pull;
            lodash2.pullAll = pullAll;
            lodash2.pullAllBy = pullAllBy;
            lodash2.pullAllWith = pullAllWith;
            lodash2.pullAt = pullAt;
            lodash2.range = range;
            lodash2.rangeRight = rangeRight;
            lodash2.rearg = rearg;
            lodash2.reject = reject;
            lodash2.remove = remove2;
            lodash2.rest = rest;
            lodash2.reverse = reverse;
            lodash2.sampleSize = sampleSize;
            lodash2.set = set2;
            lodash2.setWith = setWith;
            lodash2.shuffle = shuffle;
            lodash2.slice = slice;
            lodash2.sortBy = sortBy;
            lodash2.sortedUniq = sortedUniq;
            lodash2.sortedUniqBy = sortedUniqBy;
            lodash2.split = split;
            lodash2.spread = spread;
            lodash2.tail = tail;
            lodash2.take = take;
            lodash2.takeRight = takeRight;
            lodash2.takeRightWhile = takeRightWhile;
            lodash2.takeWhile = takeWhile;
            lodash2.tap = tap;
            lodash2.throttle = throttle;
            lodash2.thru = thru;
            lodash2.toArray = toArray;
            lodash2.toPairs = toPairs;
            lodash2.toPairsIn = toPairsIn;
            lodash2.toPath = toPath;
            lodash2.toPlainObject = toPlainObject;
            lodash2.transform = transform2;
            lodash2.unary = unary;
            lodash2.union = union2;
            lodash2.unionBy = unionBy;
            lodash2.unionWith = unionWith;
            lodash2.uniq = uniq;
            lodash2.uniqBy = uniqBy;
            lodash2.uniqWith = uniqWith;
            lodash2.unset = unset;
            lodash2.unzip = unzip;
            lodash2.unzipWith = unzipWith;
            lodash2.update = update;
            lodash2.updateWith = updateWith;
            lodash2.values = values;
            lodash2.valuesIn = valuesIn;
            lodash2.without = without;
            lodash2.words = words;
            lodash2.wrap = wrap;
            lodash2.xor = xor;
            lodash2.xorBy = xorBy;
            lodash2.xorWith = xorWith;
            lodash2.zip = zip;
            lodash2.zipObject = zipObject;
            lodash2.zipObjectDeep = zipObjectDeep;
            lodash2.zipWith = zipWith;
            lodash2.entries = toPairs;
            lodash2.entriesIn = toPairsIn;
            lodash2.extend = assignIn;
            lodash2.extendWith = assignInWith;
            mixin(lodash2, lodash2);
            lodash2.add = add2;
            lodash2.attempt = attempt;
            lodash2.camelCase = camelCase;
            lodash2.capitalize = capitalize2;
            lodash2.ceil = ceil;
            lodash2.clamp = clamp2;
            lodash2.clone = clone;
            lodash2.cloneDeep = cloneDeep;
            lodash2.cloneDeepWith = cloneDeepWith;
            lodash2.cloneWith = cloneWith;
            lodash2.conformsTo = conformsTo;
            lodash2.deburr = deburr;
            lodash2.defaultTo = defaultTo;
            lodash2.divide = divide;
            lodash2.endsWith = endsWith;
            lodash2.eq = eq;
            lodash2.escape = escape;
            lodash2.escapeRegExp = escapeRegExp;
            lodash2.every = every;
            lodash2.find = find;
            lodash2.findIndex = findIndex;
            lodash2.findKey = findKey;
            lodash2.findLast = findLast;
            lodash2.findLastIndex = findLastIndex;
            lodash2.findLastKey = findLastKey;
            lodash2.floor = floor;
            lodash2.forEach = forEach;
            lodash2.forEachRight = forEachRight;
            lodash2.forIn = forIn;
            lodash2.forInRight = forInRight;
            lodash2.forOwn = forOwn;
            lodash2.forOwnRight = forOwnRight;
            lodash2.get = get2;
            lodash2.gt = gt2;
            lodash2.gte = gte;
            lodash2.has = has2;
            lodash2.hasIn = hasIn;
            lodash2.head = head;
            lodash2.identity = identity2;
            lodash2.includes = includes;
            lodash2.indexOf = indexOf;
            lodash2.inRange = inRange;
            lodash2.invoke = invoke;
            lodash2.isArguments = isArguments;
            lodash2.isArray = isArray2;
            lodash2.isArrayBuffer = isArrayBuffer;
            lodash2.isArrayLike = isArrayLike;
            lodash2.isArrayLikeObject = isArrayLikeObject;
            lodash2.isBoolean = isBoolean2;
            lodash2.isBuffer = isBuffer;
            lodash2.isDate = isDate2;
            lodash2.isElement = isElement;
            lodash2.isEmpty = isEmpty;
            lodash2.isEqual = isEqual;
            lodash2.isEqualWith = isEqualWith;
            lodash2.isError = isError;
            lodash2.isFinite = isFinite2;
            lodash2.isFunction = isFunction2;
            lodash2.isInteger = isInteger;
            lodash2.isLength = isLength;
            lodash2.isMap = isMap2;
            lodash2.isMatch = isMatch;
            lodash2.isMatchWith = isMatchWith;
            lodash2.isNaN = isNaN2;
            lodash2.isNative = isNative;
            lodash2.isNil = isNil;
            lodash2.isNull = isNull;
            lodash2.isNumber = isNumber2;
            lodash2.isObject = isObject2;
            lodash2.isObjectLike = isObjectLike;
            lodash2.isPlainObject = isPlainObject2;
            lodash2.isRegExp = isRegExp2;
            lodash2.isSafeInteger = isSafeInteger;
            lodash2.isSet = isSet2;
            lodash2.isString = isString2;
            lodash2.isSymbol = isSymbol2;
            lodash2.isTypedArray = isTypedArray;
            lodash2.isUndefined = isUndefined;
            lodash2.isWeakMap = isWeakMap;
            lodash2.isWeakSet = isWeakSet;
            lodash2.join = join2;
            lodash2.kebabCase = kebabCase;
            lodash2.last = last;
            lodash2.lastIndexOf = lastIndexOf;
            lodash2.lowerCase = lowerCase;
            lodash2.lowerFirst = lowerFirst;
            lodash2.lt = lt2;
            lodash2.lte = lte;
            lodash2.max = max;
            lodash2.maxBy = maxBy;
            lodash2.mean = mean;
            lodash2.meanBy = meanBy;
            lodash2.min = min;
            lodash2.minBy = minBy;
            lodash2.stubArray = stubArray;
            lodash2.stubFalse = stubFalse;
            lodash2.stubObject = stubObject;
            lodash2.stubString = stubString;
            lodash2.stubTrue = stubTrue;
            lodash2.multiply = multiply;
            lodash2.nth = nth;
            lodash2.noConflict = noConflict;
            lodash2.noop = noop;
            lodash2.now = now;
            lodash2.pad = pad;
            lodash2.padEnd = padEnd;
            lodash2.padStart = padStart;
            lodash2.parseInt = parseInt2;
            lodash2.random = random;
            lodash2.reduce = reduce;
            lodash2.reduceRight = reduceRight;
            lodash2.repeat = repeat;
            lodash2.replace = replace;
            lodash2.result = result;
            lodash2.round = round;
            lodash2.runInContext = runInContext2;
            lodash2.sample = sample;
            lodash2.size = size2;
            lodash2.snakeCase = snakeCase;
            lodash2.some = some;
            lodash2.sortedIndex = sortedIndex;
            lodash2.sortedIndexBy = sortedIndexBy;
            lodash2.sortedIndexOf = sortedIndexOf;
            lodash2.sortedLastIndex = sortedLastIndex;
            lodash2.sortedLastIndexBy = sortedLastIndexBy;
            lodash2.sortedLastIndexOf = sortedLastIndexOf;
            lodash2.startCase = startCase;
            lodash2.startsWith = startsWith;
            lodash2.subtract = subtract2;
            lodash2.sum = sum;
            lodash2.sumBy = sumBy;
            lodash2.template = template;
            lodash2.times = times;
            lodash2.toFinite = toFinite;
            lodash2.toInteger = toInteger;
            lodash2.toLength = toLength;
            lodash2.toLower = toLower;
            lodash2.toNumber = toNumber;
            lodash2.toSafeInteger = toSafeInteger;
            lodash2.toString = toString;
            lodash2.toUpper = toUpper;
            lodash2.trim = trim;
            lodash2.trimEnd = trimEnd;
            lodash2.trimStart = trimStart;
            lodash2.truncate = truncate;
            lodash2.unescape = unescape;
            lodash2.uniqueId = uniqueId;
            lodash2.upperCase = upperCase;
            lodash2.upperFirst = upperFirst;
            lodash2.each = forEach;
            lodash2.eachRight = forEachRight;
            lodash2.first = head;
            mixin(lodash2, function() {
                var source = {};
                baseForOwn(lodash2, function(func, methodName) {
                    if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
                        source[methodName] = func;
                    }
                });
                return source;
            }(), { "chain": false });
            lodash2.VERSION = VERSION2;
            arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                lodash2[methodName].placeholder = lodash2;
            });
            arrayEach(["drop", "take"], function(methodName, index2) {
                LazyWrapper.prototype[methodName] = function(n2) {
                    n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
                    var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
                    if (result2.__filtered__) {
                        result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
                    } else {
                        result2.__views__.push({
                            "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                            "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                        });
                    }
                    return result2;
                };
                LazyWrapper.prototype[methodName + "Right"] = function(n2) {
                    return this.reverse()[methodName](n2).reverse();
                };
            });
            arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
                var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function(iteratee2) {
                    var result2 = this.clone();
                    result2.__iteratees__.push({
                        "iteratee": getIteratee(iteratee2, 3),
                        "type": type
                    });
                    result2.__filtered__ = result2.__filtered__ || isFilter;
                    return result2;
                };
            });
            arrayEach(["head", "last"], function(methodName, index2) {
                var takeName = "take" + (index2 ? "Right" : "");
                LazyWrapper.prototype[methodName] = function() {
                    return this[takeName](1).value()[0];
                };
            });
            arrayEach(["initial", "tail"], function(methodName, index2) {
                var dropName = "drop" + (index2 ? "" : "Right");
                LazyWrapper.prototype[methodName] = function() {
                    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
            });
            LazyWrapper.prototype.compact = function() {
                return this.filter(identity2);
            };
            LazyWrapper.prototype.find = function(predicate) {
                return this.filter(predicate).head();
            };
            LazyWrapper.prototype.findLast = function(predicate) {
                return this.reverse().find(predicate);
            };
            LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                if (typeof path == "function") {
                    return new LazyWrapper(this);
                }
                return this.map(function(value) {
                    return baseInvoke(value, path, args);
                });
            });
            LazyWrapper.prototype.reject = function(predicate) {
                return this.filter(negate(getIteratee(predicate)));
            };
            LazyWrapper.prototype.slice = function(start2, end2) {
                start2 = toInteger(start2);
                var result2 = this;
                if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
                    return new LazyWrapper(result2);
                }
                if (start2 < 0) {
                    result2 = result2.takeRight(-start2);
                } else if (start2) {
                    result2 = result2.drop(start2);
                }
                if (end2 !== undefined$1) {
                    end2 = toInteger(end2);
                    result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
                }
                return result2;
            };
            LazyWrapper.prototype.takeRightWhile = function(predicate) {
                return this.reverse().takeWhile(predicate).reverse();
            };
            LazyWrapper.prototype.toArray = function() {
                return this.take(MAX_ARRAY_LENGTH);
            };
            baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                    return;
                }
                lodash2.prototype[methodName] = function() {
                    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
                    var interceptor = function(value2) {
                        var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
                        return isTaker && chainAll ? result3[0] : result3;
                    };
                    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                        isLazy = useLazy = false;
                    }
                    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                    if (!retUnwrapped && useLazy) {
                        value = onlyLazy ? value : new LazyWrapper(this);
                        var result2 = func.apply(value, args);
                        result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                        return new LodashWrapper(result2, chainAll);
                    }
                    if (isUnwrapped && onlyLazy) {
                        return func.apply(this, args);
                    }
                    result2 = this.thru(interceptor);
                    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                };
            });
            arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash2.prototype[methodName] = function() {
                    var args = arguments;
                    if (retUnwrapped && !this.__chain__) {
                        var value = this.value();
                        return func.apply(isArray2(value) ? value : [], args);
                    }
                    return this[chainName](function(value2) {
                        return func.apply(isArray2(value2) ? value2 : [], args);
                    });
                };
            });
            baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                var lodashFunc = lodash2[methodName];
                if (lodashFunc) {
                    var key = lodashFunc.name + "";
                    if (!hasOwnProperty2.call(realNames, key)) {
                        realNames[key] = [];
                    }
                    realNames[key].push({ "name": methodName, "func": lodashFunc });
                }
            });
            realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
                "name": "wrapper",
                "func": undefined$1
            }];
            LazyWrapper.prototype.clone = lazyClone;
            LazyWrapper.prototype.reverse = lazyReverse;
            LazyWrapper.prototype.value = lazyValue;
            lodash2.prototype.at = wrapperAt;
            lodash2.prototype.chain = wrapperChain;
            lodash2.prototype.commit = wrapperCommit;
            lodash2.prototype.next = wrapperNext;
            lodash2.prototype.plant = wrapperPlant;
            lodash2.prototype.reverse = wrapperReverse;
            lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
            lodash2.prototype.first = lodash2.prototype.head;
            if (symIterator) {
                lodash2.prototype[symIterator] = wrapperToIterator;
            }
            return lodash2;
        };
        var _2 = runInContext();
        if (freeModule) {
            (freeModule.exports = _2)._ = _2;
            freeExports._ = _2;
        } else {
            root._ = _2;
        }
    }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
function collect_point_group(host, align) {
    const m2 = host.matrix2Root();
    const f2 = host.frame;
    const x2 = f2.x;
    const y2 = f2.y;
    const r = x2 + f2.width;
    const b2 = y2 + f2.height;
    const cx = x2 + f2.width / 2;
    const cy = y2 + f2.height / 2;
    const lt2 = m2.computeCoord2(x2, y2);
    const rb = m2.computeCoord2(r, b2);
    const pivot = m2.computeCoord2(cx, cy);
    if (host.type === Vt.Line) {
        const apexX2 = [lt2.x, rb.x, pivot.x];
        const apexY2 = [lt2.y, rb.y, pivot.y];
        return { lt: lt2, rb, pivot, apexX: apexX2, apexY: apexY2 };
    }
    const rt2 = m2.computeCoord2(r, y2);
    const lb = m2.computeCoord2(x2, b2);
    if (align) {
        lt2.x = Math.round(lt2.x);
        lt2.y = Math.round(lt2.y);
        rb.x = Math.round(rb.x);
        rb.y = Math.round(rb.y);
        pivot.x = Math.round(pivot.x);
        pivot.y = Math.round(pivot.y);
        rt2.x = Math.round(rt2.x);
        rt2.y = Math.round(rt2.y);
        lb.x = Math.round(lb.x);
        lb.y = Math.round(lb.y);
    }
    const apexX = Array.from((/* @__PURE__ */ new Set([lt2.x, rt2.x, rb.x, lb.x, pivot.x])).values());
    const apexY = Array.from((/* @__PURE__ */ new Set([lt2.y, rt2.y, rb.y, lb.y, pivot.y])).values());
    const pg = { lt: lt2, rt: rt2, rb, lb, pivot, apexX, apexY };
    if (host.type === Vt.Artboard || host.type === Vt.Symbol) {
        const th2 = m2.computeCoord2(cx, y2);
        const rh2 = m2.computeCoord2(r, cy);
        const bh2 = m2.computeCoord2(cx, b2);
        const lh2 = m2.computeCoord2(x2, cy);
        apexX.push(th2.x, rh2.x, bh2.x, lh2.x);
        apexY.push(th2.y, rh2.y, bh2.y, lh2.y);
        pg.th = th2;
        pg.rh = rh2;
        pg.bh = bh2;
        pg.lh = lh2;
    }
    return pg;
}
function isShapeOut(context, shape2) {
    const m2 = shape2.matrix2Root();
    m2.multiAtLeft(context.workspace.matrix);
    const f2 = shape2.frame;
    const x2 = f2.x;
    const y2 = f2.y;
    const r = x2 + f2.width;
    const b2 = y2 + f2.height;
    const point = [
        m2.computeCoord2(x2, y2),
        m2.computeCoord2(r, y2),
        m2.computeCoord2(r, b2),
        m2.computeCoord2(x2, b2)
    ];
    const { width, height } = context.workspace.root;
    return Math.min(point[0].x, point[1].x, point[2].x, point[3].x) > width || Math.max(point[0].x, point[1].x, point[2].x, point[3].x) < 0 || Math.max(point[0].y, point[1].y, point[2].y, point[3].y) < 0 || Math.min(point[0].y, point[1].y, point[2].y, point[3].y) > height;
}
function finder(context, scope, all_pg, x_axis, y_axis) {
    let result = [];
    const align = context.user.isPixelAlignMent;
    if (scope.type === Vt.Artboard || scope.type === Vt.Symbol) {
        result.push(scope);
        const pg = collect_point_group(scope, align);
        all_pg.set(scope.id, pg);
        const pvs = Object.values(pg);
        for (let i = 0, len = pvs.length; i < len; i++) {
            const p2 = { id: scope.id, p: pvs[i] };
            const x2 = x_axis.get(p2.p.x);
            const y2 = y_axis.get(p2.p.y);
            if (x2) x2.push(p2);
            else x_axis.set(p2.p.x, [p2]);
            if (y2) y2.push(p2);
            else y_axis.set(p2.p.y, [p2]);
        }
    }
    const cs2 = scope.childs;
    for (let i = 0; i < cs2.length; i++) {
        const c2 = cs2[i];
        if (isShapeOut(context, c2) || c2.type === Vt.Contact) continue;
        result.push(c2);
        const pg = collect_point_group(c2, align);
        all_pg.set(c2.id, pg);
        const pvs = Object.values(pg);
        for (let i2 = 0, len = pvs.length; i2 < len; i2++) {
            const p2 = { id: c2.id, p: pvs[i2] };
            const x2 = x_axis.get(p2.p.x);
            const y2 = y_axis.get(p2.p.y);
            if (x2) x2.push(p2);
            else x_axis.set(p2.p.x, [p2]);
            if (y2) y2.push(p2);
            else y_axis.set(p2.p.y, [p2]);
        }
        if (c2.type === Vt.Group) {
            result = result.concat(finder(context, c2, all_pg, x_axis, y_axis));
        }
    }
    return result;
}
function _collect(context, new_matrix) {
    context.assist.set_stickness(5 / new_matrix.m00);
}
lodashExports.debounce(_collect, 100);
function alignXFromPointGroup(dx, xs2, livingXs) {
    let livingD = dx;
    let livingAD = Math.abs(dx);
    let targetX = 0;
    let spark = false;
    for (let i = 0; i < livingXs.length; i++) {
        const x2 = livingXs[i];
        for (let j2 = 0; j2 < xs2.length; j2++) {
            const fixedX = xs2[j2];
            const d2 = fixedX - x2;
            const ad = Math.abs(d2);
            if (ad < livingAD) {
                livingD = d2;
                livingAD = ad;
                targetX = fixedX;
                spark = true;
            }
        }
    }
    return { dx: livingD, targetX, spark };
}
function alignYFromPointGroup(dy, ys2, livingYs) {
    let livingD = dy;
    let livingAD = Math.abs(dy);
    let targetY = 0;
    let spark = false;
    for (let i = 0; i < livingYs.length; i++) {
        const y2 = livingYs[i];
        for (let j2 = 0; j2 < ys2.length; j2++) {
            const fixedY = ys2[j2];
            const d2 = fixedY - y2;
            const ad = Math.abs(d2);
            if (ad < livingAD) {
                livingD = d2;
                livingAD = ad;
                targetY = fixedY;
                spark = true;
            }
        }
    }
    return { dy: livingD, targetY, spark };
}
function alignXFromSpacePoint(dx, xs2, livingXs) {
    let livingD = dx;
    let livingAD = Math.abs(dx);
    let targetX = 0;
    let spark = false;
    const x2 = livingXs[1];
    for (let j2 = 0; j2 < xs2.length; j2++) {
        const fixedX = xs2[j2];
        const d2 = fixedX - x2;
        const ad = Math.abs(d2);
        if (ad < livingAD) {
            livingD = d2;
            livingAD = ad;
            targetX = fixedX;
            spark = true;
        }
    }
    return { dx: livingD, targetX, spark };
}
function alignYFromSpacePoint(dy, ys2, livingYs) {
    let livingD = dy;
    let livingAD = Math.abs(dy);
    let targetY = 0;
    let spark = false;
    const y2 = livingYs[1];
    for (let j2 = 0; j2 < ys2.length; j2++) {
        const fixedY = ys2[j2];
        const d2 = fixedY - y2;
        const ad = Math.abs(d2);
        if (ad < livingAD) {
            livingD = d2;
            livingAD = ad;
            targetY = fixedY;
            spark = true;
        }
    }
    return { dy: livingD, targetY, spark };
}
function modify_pt_x4p(pre_target1, p2, apexX, stickness) {
    let working = false;
    for (let i = 0, len = apexX.length; i < len; i++) {
        const x2 = apexX[i];
        const delta = Math.abs(x2 - p2.x);
        if (delta < stickness && (pre_target1.delta === void 0 || delta < pre_target1.delta)) {
            pre_target1.delta = delta;
            pre_target1.x = x2;
            pre_target1.sy = p2.y;
            working = true;
        }
    }
    return working;
}
function modify_pt_y4p(pre_target2, p2, apexY, stickness) {
    let working = false;
    for (let i = 0, len = apexY.length; i < len; i++) {
        const y2 = apexY[i];
        const delta = Math.abs(y2 - p2.y);
        if (delta < stickness && (pre_target2.delta === void 0 || delta < pre_target2.delta)) {
            pre_target2.delta = delta;
            pre_target2.y = y2;
            pre_target2.sx = p2.x;
            working = true;
        }
    }
    return working;
}
function get_tree(shape2, init2) {
    init2.set(shape2.id, shape2);
    if (shape2.type === Vt.Table) return;
    const cs2 = shape2.childs;
    if (!(cs2 == null ? void 0 : cs2.length)) return;
    for (let i = 0, len = cs2.length; i < len; i++) get_tree(cs2[i], init2);
}
function scout(context) {
    let temp = v4().split("-");
    const scoutId = temp[temp.length - 1] || "scout";
    temp = v4().split("-");
    temp[temp.length - 1] || "path";
    const ele = createSVGGeometryElement(scoutId);
    const path = createPath("M 0 0 l 2 0 l 2 2 l -2 0 z");
    ele.appendChild(path);
    document.body.appendChild(ele);
    const SVGPoint = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGPoint();
    function isPointInShape(shape2, point) {
        var _a2;
        const d2 = getPathOnPageString(shape2);
        SVGPoint.x = point.x;
        SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        const scale = context.workspace.curScale;
        let stroke2 = 14 / scale;
        let isClosed = true;
        if ((_a2 = shape2 == null ? void 0 : shape2.segments) == null ? void 0 : _a2.length) {
            const segments = shape2.segments;
            for (let i = 0; i < segments.length; i++) {
                if (!segments[i].isClosed) {
                    isClosed = false;
                    break;
                }
            }
        }
        path.setAttributeNS(null, "stroke-width", `${stroke2}`);
        if (isClosed) {
            return path.isPointInFill(SVGPoint);
        } else {
            return path.isPointInFill(SVGPoint) || path.isPointInStroke(SVGPoint);
        }
    }
    function isPointInShape2(shape2, point) {
        const d2 = getPathOnPageStringCustomOffset(shape2, 1 / context.workspace.matrix.m00);
        SVGPoint.x = point.x;
        SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        return path.isPointInFill(SVGPoint);
    }
    function isPointInPath(d2, point) {
        SVGPoint.x = point.x, SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        return path.isPointInFill(SVGPoint);
    }
    function isPointInStroke(d2, point) {
        SVGPoint.x = point.x, SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        path.setAttributeNS(null, "stroke-width", "14");
        return path.isPointInStroke(SVGPoint);
    }
    function isPointInStrokeByWidth(d2, point, width) {
        SVGPoint.x = point.x, SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        path.setAttributeNS(null, "stroke-width", `${width}`);
        return path.isPointInStroke(SVGPoint);
    }
    function remove2() {
        const s = document.querySelector(`[id="${scoutId}"]`);
        if (s) document.body.removeChild(s);
    }
    function isPointInShapeForPreview(shape2, point, d2, matrix) {
        var _a2;
        SVGPoint.x = point.x;
        SVGPoint.y = point.y;
        path.setAttributeNS(null, "d", d2);
        const scale = matrix.m00;
        let stroke2 = 14 / scale;
        let isClosed = true;
        if ((_a2 = shape2 == null ? void 0 : shape2.segments) == null ? void 0 : _a2.length) {
            const segments = shape2.segments;
            for (let i = 0; i < segments.length; i++) {
                if (!segments[i].isClosed) {
                    isClosed = false;
                    break;
                }
            }
        }
        path.setAttributeNS(null, "stroke-width", `${stroke2}`);
        if (isClosed) {
            return path.isPointInFill(SVGPoint);
        } else {
            return path.isPointInFill(SVGPoint) || path.isPointInStroke(SVGPoint);
        }
    }
    return { path, isPointInShape, isPointInShape2, remove: remove2, isPointInPath, isPointInStroke, isPointInStrokeByWidth, isPointInShapeForPreview };
}
function createSVGGeometryElement(id) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "10");
    svg.setAttribute("height", "10");
    svg.setAttribute("id", id);
    return svg;
}
function createPath(path, id) {
    const p2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p2.setAttributeNS(null, "d", path);
    return p2;
}
function getPathOnPageString(shape2) {
    const path = shape2.getPath().clone();
    const m2page = shape2.matrix2Root();
    path.transform(m2page);
    return path.toString();
}
function getPathOnPageStringCustomOffset(shape2, s) {
    const f2 = shape2.frame;
    const offset = 20 * s;
    const scalex = (f2.width + offset) / f2.width, scaley = (f2.height + offset) / f2.height;
    const m2 = new o();
    m2.preScale(scalex * f2.width, scaley * f2.height);
    m2.trans(-offset / 2, -offset / 2);
    m2.multiAtLeft(shape2.matrix2Root());
    return getBoxPath(m2);
}
function getBoxPath(transformMatrix) {
    const p1 = transformMatrix.computeCoord2(0, 0);
    const p2 = transformMatrix.computeCoord2(1, 0);
    const p3 = transformMatrix.computeCoord2(1, 1);
    const p4 = transformMatrix.computeCoord2(0, 1);
    return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y} L ${p4.x} ${p4.y} z`;
}
function isTarget(scout2, shape2, p2) {
    const masked = shape2.masked;
    if (masked) {
        const view = shape2.getPage().getView(masked.id);
        if (!view || !scout2.isPointInShape(view, p2)) return false;
    }
    return scout2.isPointInShape(shape2, p2);
}
function isTarget2(scout2, shape2, p2) {
    return scout2.isPointInShape2(shape2, p2);
}
function canNotBeApex(shape2) {
    return shape2.isVirtualShape || !shape2.isVisible || shape2.isLocked || shape2.type === Vt.Contact;
}
function finder_contact(scout2, g2, position, selected, init2) {
    const result = init2 || [];
    for (let i = g2.length - 1; i > -1; i--) {
        const item = g2[i];
        if (canNotBeApex(item)) {
            continue;
        }
        if ([Vt.Group, Vt.Artboard, Vt.Symbol, Vt.SymbolUnion, Vt.SymbolRef].includes(item.type)) {
            const isItemIsTarget = isTarget2(scout2, item, position);
            if (!isItemIsTarget) {
                continue;
            }
            const c2 = item instanceof nc ? item.naviChilds || [] : item.childs;
            if (c2.length) {
                result.push(...finder_contact(scout2, c2, position, selected, result));
                if (result.length) {
                    return result;
                } else {
                    result.push(item);
                    return result;
                }
            } else {
                result.push(item);
                return result;
            }
        } else {
            if (isTarget2(scout2, item, position)) {
                result.push(item);
                return result;
            }
        }
    }
    return result;
}
function finder_layers(scout2, g2, position) {
    const result = [];
    for (let i = g2.length - 1; i > -1; i--) {
        const item = g2[i];
        if (!canBeTarget(g2[i])) {
            continue;
        }
        if (!isTarget(scout2, item, position)) {
            continue;
        }
        if ([Vt.Group, Vt.Artboard, Vt.SymbolUnion, Vt.Symbol, Vt.SymbolRef].includes(item.type)) {
            const c2 = item.type === Vt.SymbolRef ? item.naviChilds : item.childs;
            if (c2 == null ? void 0 : c2.length) {
                result.push(...finder_layers(scout2, c2, position));
            }
        }
        result.push(item);
    }
    return result;
}
function finder_container(scout2, g2, position, except) {
    const layers = finder_layers(scout2, g2, position);
    for (let i = 0, len = layers.length; i < len; i++) {
        const item = layers[i];
        if (item.isVirtualShape) {
            continue;
        }
        if ([Vt.Artboard, Vt.Symbol].includes(item.type) && !(except == null ? void 0 : except.get(item.id))) {
            return item;
        }
    }
}
function finder_env_for_migrate(scout2, g2, position, shape4migrate) {
    const layers = finder_layers(scout2, g2, position);
    for (let i = 0, len = layers.length; i < len; i++) {
        const item = layers[i];
        if (item.isVirtualShape) {
            continue;
        }
        let p2 = item;
        let c2 = false;
        while (p2) {
            if (shape4migrate.has(p2.id)) {
                c2 = true;
                break;
            }
            p2 = p2.parent;
        }
        if (c2) {
            continue;
        }
        if (item.isContainer) {
            return item;
        }
    }
}
function canBeTarget(shape2) {
    return shape2.isVisible && !shape2.isLocked;
}
function finder2(context, scout2, scope, hot, selected, pen, m2) {
    if (pen) {
        return for_pen(context, scout2, scope, hot);
    }
    set_env(context, selected, m2);
    let result = void 0;
    result = for_env(context, scout2, hot);
    if (result) {
        return result;
    }
    return for_standard(context, scout2, scope, hot);
}
function for_pen(context, scout2, scope, hot) {
    let result = void 0;
    for (let i = scope.length - 1; i > -1; i--) {
        const item = scope[i];
        if (!canBeTarget(item)) continue;
        if (item.type !== Vt.Contact && isShapeOut(context, item)) continue;
        if (!isTarget(scout2, item, hot)) continue;
        if (item.type === Vt.Table) return item;
        const children = item.type === Vt.SymbolRef ? item.naviChilds || [] : item.childs || [];
        if (!children.length) return item;
        else {
            result = for_pen(context, scout2, children, hot);
            const background = item.type === Vt.Artboard || item.type == Vt.Symbol || item.type === Vt.SymbolUnion || item.type === Vt.SymbolRef;
            if (!result && background) return item;
        }
        if (result) return result;
    }
}
function for_env(context, scout2, hot) {
    const env = context.selection.envShapes;
    for (let i = 0, l2 = env.length; i < l2; i++) {
        const shape2 = env[i];
        if (!canBeTarget(shape2)) {
            continue;
        }
        if (is_hollow(shape2)) {
            if (for_hollow(context, scout2, shape2, hot)) {
                return shape2;
            }
        } else if (isTarget(scout2, shape2, hot)) {
            return shape2;
        }
    }
}
function for_standard(context, scout2, scope, hot) {
    let result = void 0;
    for (let i = scope.length - 1; i > -1; i--) {
        const item = scope[i];
        if (!canBeTarget(item)) {
            continue;
        }
        if (item.type !== Vt.Contact && isShapeOut(context, item)) {
            continue;
        }
        if (!isTarget(scout2, item, hot)) {
            continue;
        }
        if (is_fixed(item)) {
            result = for_fixed(context, scout2, item, hot);
            if (result) {
                return result;
            }
            if (!item.childs.length) {
                return item;
            }
            break;
        } else if (is_hollow(item)) {
            result = for_hollow(context, scout2, item, hot);
        } else {
            result = item;
        }
        if (result) {
            return result;
        }
    }
    return result;
}
function for_fixed(context, scout2, fixed2, hot) {
    const sub = fixed2.childs || [];
    for (let i = sub.length - 1; i > -1; i--) {
        const item = sub[i];
        if (!canBeTarget(item)) {
            continue;
        }
        if (item.type !== Vt.Contact && isShapeOut(context, item)) {
            continue;
        }
        if (is_hollow(item)) {
            if (for_hollow(context, scout2, item, hot)) {
                return item;
            }
        } else if (isTarget(scout2, item, hot)) {
            return item;
        }
    }
}
function for_hollow(context, scout2, hollow, hot) {
    const children = hollow.type === Vt.SymbolRef ? hollow.naviChilds || [] : hollow.childs || [];
    for (let i = children.length - 1; i > -1; i--) {
        const item = children[i];
        if (!canBeTarget(item)) {
            continue;
        }
        if (item.type !== Vt.Contact && isShapeOut(context, item)) {
            continue;
        }
        if (!isTarget(scout2, item, hot)) {
            continue;
        }
        if (is_hollow(item)) {
            if (for_hollow(context, scout2, item, hot)) {
                return hollow;
            }
        } else {
            return hollow;
        }
    }
}
function is_hollow(shape2) {
    return shape2.type === Vt.Group;
}
function is_fixed(shape2) {
    var _a2;
    return (shape2.type === Vt.Artboard || shape2.type === Vt.SymbolUnion) && ((_a2 = shape2.parent) == null ? void 0 : _a2.type) === Vt.Page;
}
function _set_env(context, shapes, m2) {
    const parents = /* @__PURE__ */ new Set();
    const bros = /* @__PURE__ */ new Set();
    for (let i = 0, l2 = shapes.length; i < l2; i++) {
        const shape2 = shapes[i];
        const parent = shape2.parent;
        if (!parent || parents.has(parent)) {
            continue;
        }
        parents.add(parent);
        sort_env(parent, bros, parents, m2);
    }
    context.selection.setEnvShapes(Array.from(bros));
    function sort_env(g2, bros2, parents2, m22) {
        let p2 = g2;
        while (p2 && p2.type !== Vt.Page) {
            const children = p2 instanceof nc ? p2.naviChilds || [] : p2.childs || [];
            for (let i = children.length - 1; i > -1; i--) {
                const child = children[i];
                if (parents2.has(child)) {
                    continue;
                }
                bros2.add(child);
            }
            if (is_fixed(p2)) {
                if (m22) {
                    bros2.add(p2);
                    parents2.add(p2);
                }
                break;
            }
            if (p2.type === Vt.Artboard || p2.type === Vt.Symbol || p2.type === Vt.SymbolRef || p2.type === Vt.SymbolUnion) {
                bros2.add(p2);
            }
            parents2.add(p2);
            p2 = p2.parent;
        }
    }
}
const set_env = lodashExports.throttle(_set_env, 200, { leading: true });
class TextSelectionLite extends U {
    constructor(selection) {
        super();
        __publicField(this, "m_cursorStart", -1);
        __publicField(this, "m_cursorAtBefore", false);
        __publicField(this, "m_cursorEnd", -1);
        __publicField(this, "m_selection");
        __publicField(this, "m_textAttr");
        this.m_selection = selection;
    }
    notify(...args) {
        this.m_selection.notify(...args);
    }
    reset(shape2) {
        this.m_cursorStart = -1;
        this.m_cursorEnd = -1;
        this.m_cursorAtBefore = false;
        this.notify(Selection.CHANGE_TEXT);
    }
    get shape() {
        return this.m_selection.focusTextShape;
    }
    get cursorStart() {
        return this.m_cursorStart;
    }
    get cursorAtBefore() {
        return this.m_cursorAtBefore;
    }
    get cursorEnd() {
        return this.m_cursorEnd;
    }
    /**
     * @param x page坐标系
     * @param y
     */
    locateText(x2, y2) {
        const shape2 = this.shape;
        if (shape2) {
            const matrix = shape2.matrix2Root();
            const xy = matrix.inverseCoord(x2, y2);
            x2 = xy.x;
            y2 = xy.y;
            return shape2.locateText(x2, y2);
        }
        return { index: -1, before: false, placeholder: false, attr: void 0 };
    }
    setCursor(index2, before) {
        const shape2 = this.shape;
        if (!shape2) return;
        if (index2 < 0) index2 = 0;
        const text = shape2.getText();
        const span = text.spanAt(index2);
        if ((span == null ? void 0 : span.placeholder) && span.length === 1) index2++;
        const length = text.length;
        if (index2 >= length) {
            index2 = length - 1;
            before = false;
        }
        if (index2 !== this.m_cursorStart || index2 !== this.m_cursorEnd || before !== this.m_cursorAtBefore) {
            this.m_cursorStart = index2;
            this.m_cursorEnd = index2;
            this.m_cursorAtBefore = before;
            this.notify(Selection.CHANGE_TEXT);
        }
    }
    selectText(start2, end2) {
        const shape2 = this.shape;
        if (!shape2) return;
        const text = shape2.getText();
        if (Math.abs(start2 - end2) === 1 && text.charAt(Math.min(start2, end2)) === "\n") {
            if (end2 > start2) {
                start2++;
                end2++;
            } else {
                start2--;
                end2--;
            }
        }
        const length = text.length;
        if (start2 < 0) start2 = 0;
        else if (start2 >= length) {
            start2 = length - 1;
        }
        if (end2 < 0) end2 = 0;
        else if (end2 >= length) {
            end2 = length - 1;
        }
        if (start2 !== this.m_cursorStart || end2 !== this.m_cursorEnd) {
            this.m_cursorStart = start2;
            this.m_cursorEnd = end2;
            this.m_cursorAtBefore = false;
            this.notify(Selection.CHANGE_TEXT);
        }
    }
    setTextAttr(attr2) {
        this.m_textAttr = attr2;
    }
    get getTextAttr() {
        return this.m_textAttr || new va();
    }
}
function compare_layer_3(selectedShapes, reverse = 1) {
    const path_map = /* @__PURE__ */ new Map();
    for (let i = 0; i < selectedShapes.length; i++) {
        const shape2 = selectedShapes[i];
        path_map.set(shape2.id, get_node_path(shape2));
    }
    return selectedShapes.sort((a2, b2) => {
        if (compare_layer_a_b_2(a2, b2, path_map)) {
            return reverse * -1;
        } else {
            return reverse * 1;
        }
    });
}
function compare_layer_a_b_2(shape2, another, paths) {
    const path1 = paths.get(shape2.id);
    const path2 = paths.get(another.id);
    if (!path1 || !path2) return false;
    const len = Math.min(path1.length, path2.length);
    for (let i = 0; i < len; i++) {
        if (path1[i] === path2[i]) {
            if (path1[i + 1] === path2[i + 1]) {
                continue;
            } else if (path1[i + 1] > path2[i + 1]) {
                return true;
            } else {
                return false;
            }
        }
    }
    return false;
}
function get_node_path(shape2) {
    const path = [];
    let self2 = shape2;
    let p2 = self2.parent;
    while (p2) {
        const childs = p2.childs;
        for (let i = childs.length - 1; i > -1; i--) {
            if (childs[i].id === self2.id) {
                path.unshift(i);
                break;
            }
        }
        self2 = p2;
        p2 = self2.parent;
    }
    path.unshift(0);
    return path;
}
const _Navi = class _Navi extends U {
    constructor() {
        super();
        __publicField(this, "m_page_need_extend", false);
        __publicField(this, "m_focus_text");
        __publicField(this, "m_keywords", "");
        __publicField(this, "m_shapelist_freeze", false);
        __publicField(this, "m_accurate", false);
        __publicField(this, "m_phase1", "");
        __publicField(this, "m_cur_module", "Shape");
        __publicField(this, "m_item_dragging", false);
    }
    get is_item_dragging() {
        return this.m_item_dragging;
    }
    set_dragging_status(v2) {
        this.m_item_dragging = v2;
    }
    get needExtend() {
        return this.m_page_need_extend;
    }
    set_phase(id) {
        this.m_phase1 = id;
    }
    isPhase2(shape2) {
        return Boolean(shape2.id === this.m_phase1);
    }
    set_page_need_extend(v2) {
        this.m_page_need_extend = v2;
    }
    get focusText() {
        return this.m_focus_text;
    }
    set_focus_text(v2) {
        this.m_focus_text = v2;
        this.notify(_Navi.TEXT_SELECTION_CHANGE);
    }
    get is_shapelist_freeze() {
        return this.m_shapelist_freeze;
    }
    set_sl_freeze(v2) {
        this.m_shapelist_freeze = v2 || false;
    }
    get keywords() {
        return this.m_keywords;
    }
    set_keywords(v2) {
        this.m_keywords = v2 || "";
    }
    get accurate() {
        return this.m_accurate;
    }
    setMode(isAcc) {
        this.m_accurate = isAcc;
    }
    get current_navi_module() {
        return this.m_cur_module;
    }
    set_current_navi_module(v2) {
        if (v2 == this.m_cur_module) return;
        this.m_cur_module = v2;
        this.notify(_Navi.MODULE_CHANGE);
    }
};
__publicField(_Navi, "SEARCH", 1);
__publicField(_Navi, "SEARCH_FINISHED", 2);
__publicField(_Navi, "SEARCH_PRE", 3);
__publicField(_Navi, "SEARCHING", 4);
__publicField(_Navi, "CHANGE_TYPE", 6);
__publicField(_Navi, "TEXT_SELECTION_CHANGE", 7);
__publicField(_Navi, "SHAPELIST_UPDATE", 8);
__publicField(_Navi, "ADD_PAGE", 9);
__publicField(_Navi, "MODULE_CHANGE", 10);
__publicField(_Navi, "ITEM_DRAG", 11);
__publicField(_Navi, "TO_SEARCH", 12);
__publicField(_Navi, "COMP_LIST_CHANGED", 13);
__publicField(_Navi, "LIST_FOLD", 14);
__publicField(_Navi, "RENAME", 15);
let Navi = _Navi;
function getRadiusForCopy(shapes) {
    let first;
    for (const shape2 of shapes) {
        const corner = __get(shape2);
        if (corner) {
            first = corner;
            break;
        }
    }
    if (!first) return;
    for (const shape2 of shapes) {
        const corner = __get(shape2);
        if (!corner) continue;
        if (!__compare(corner, first)) return;
    }
    return first;
    function __get(shape2) {
        if (shape2 instanceof Hh || shape2 instanceof sc || shape2 instanceof nc) {
            const corner = shape2.cornerRadius;
            if (!corner) return;
            return [corner.lt, corner.rt, corner.rb, corner.lb];
        } else if (shape2 instanceof Kh) {
            const points = shape2.segments[0].points;
            if (!points) return;
            let rs2 = [0, 0, 0, 0];
            for (let i = 0; i < 4; i++) {
                const p2 = points[i];
                if (!p2) break;
                rs2[i] = p2.radius ?? 0;
            }
            return rs2;
        } else {
            const fixed2 = shape2.fixedRadius;
            if (!fixed2) return;
            return [fixed2, fixed2, fixed2, fixed2];
        }
    }
    function __compare(a2, b2) {
        for (let i = 0; i < 4; i++) {
            if (a2[i] !== b2[i]) return false;
        }
        return true;
    }
}
function getContextSetting(shapes) {
    let first;
    for (const shape2 of shapes) {
        const cs2 = shape2.style.contextSettings;
        if (cs2) {
            first = new ee(cs2.blenMode, cs2.opacity);
            break;
        }
    }
    if (!first) return;
    for (const shape2 of shapes) {
        const cs2 = shape2.style.contextSettings;
        if (!cs2) continue;
        if (cs2.blenMode !== first.blenMode || cs2.opacity !== first.opacity) return;
    }
    return first;
}
function getMarkType(shapes) {
    let first;
    for (const shape2 of shapes) {
        const startMark = shape2.startMarkerType;
        const endMark = shape2.endMarkerType;
        if (!startMark && !endMark) continue;
        first = { start: startMark, end: endMark };
        break;
    }
    if (!first) return;
    for (const shape2 of shapes) {
        const startMark = shape2.startMarkerType;
        const endMark = shape2.endMarkerType;
        if (!startMark && !endMark) continue;
        if (startMark !== first.start || endMark !== first.end) return;
    }
    return first;
}
function getText(shapes) {
    let first;
    for (const shape2 of shapes) {
        if (shape2 instanceof Ic) {
            first = Ep(shape2.text);
            break;
        }
    }
    return first;
}
var ContextEvents;
((ContextEvents2) => {
    ContextEvents2.action_change = "action_change";
})(ContextEvents || (ContextEvents = {}));
var SelectionEvents;
((SelectionEvents2) => {
    SelectionEvents2.text_change = "text_change";
    SelectionEvents2.page_change = "page_change";
    SelectionEvents2.shape_change = "shape_change";
    SelectionEvents2.shape_hover_change = "shape_hover_change";
})(SelectionEvents || (SelectionEvents = {}));
var WorkspaceEvents;
((WorkspaceEvents2) => {
    WorkspaceEvents2.transform_change = "transform_change";
})(WorkspaceEvents || (WorkspaceEvents = {}));
const _uuid = "-E9BB37D8-8853-D650-4EF1-ACCF4E2D4BE5";
const Action = {
    Auto: "auto" + _uuid,
    AutoV: "drag" + _uuid,
    AutoK: "scale" + _uuid,
    AddRect: "add-rect" + _uuid,
    AddLine: "add-line" + _uuid,
    AddEllipse: "add-ellipse" + _uuid,
    AddArrow: "add-arrow" + _uuid,
    AddFrame: "add-frame" + _uuid,
    AddText: "add-text" + _uuid,
    AddImage: "add-image" + _uuid,
    AddTable: "table" + _uuid,
    AddContact: "add-contact" + _uuid,
    AddCutout: "add-cutout" + _uuid,
    Curve: "curve" + _uuid,
    PathClip: "path-clip" + _uuid,
    Pen: "add-vector" + _uuid,
    Pencil: "add-free-path" + _uuid,
    Polygon: "add-polygon" + _uuid,
    Star: "add-star" + _uuid,
    Export: "export" + _uuid
};
/* @__PURE__ */ new Map([
    [Action.Auto, void 0],
    [Action.AddRect, Vt.Rectangle],
    [Action.AddEllipse, Vt.Oval],
    [Action.AddLine, Vt.Line],
    [Action.AddFrame, Vt.Artboard],
    [Action.AddText, Vt.Text],
    [Action.AddImage, Vt.Image],
    [Action.AddArrow, Vt.Line],
    [Action.AddTable, Vt.Table],
    [Action.AddContact, Vt.Contact],
    [Action.AddCutout, Vt.Cutout],
    [Action.Polygon, Vt.Polygon],
    [Action.Star, Vt.Star]
]);
const _Tool = class _Tool extends U {
    constructor(context) {
        super();
        __publicField(this, "m_current_action", Action.AutoV);
        __publicField(this, "m_context");
        __publicField(this, "m_show_title", true);
        __publicField(this, "m_frame_size", { width: 100, height: 100 });
        // 容器模版frame
        __publicField(this, "m_frame_name", "");
        // 容器模版名称
        __publicField(this, "m_table_size", { row: 3, col: 3 });
        __publicField(this, "m_contact_apex");
        __publicField(this, "m_contact_from", false);
        __publicField(this, "m_lable_status", false);
        __publicField(this, "m_cutout_visible", true);
        __publicField(this, "m_refer_selection");
        __publicField(this, "m_refer_finer");
        this.m_context = context;
    }
    get action() {
        return this.m_current_action;
    }
    setAction(uuid) {
        this.m_current_action = uuid;
        this.notify(_Tool.CHANGE_ACTION);
        this.m_context.notify(ContextEvents.action_change);
    }
    reset() {
        let exe_result = false;
        if (this.m_current_action.startsWith("add")) {
            exe_result = true;
        }
        this.m_current_action = Action.AutoV;
        this.m_context.cursor.reset();
        this.notify(_Tool.CHANGE_ACTION);
        this.m_context.notify(ContextEvents.action_change);
        return exe_result;
    }
    get isShowTitle() {
        return this.m_show_title;
    }
    setTitleVisible(val) {
        this.m_show_title = val;
        this.notify(_Tool.TITLE_VISIBLE);
    }
    get isCutoutVisible() {
        return this.m_cutout_visible;
    }
    setCutoutVisible(v2) {
        this.m_cutout_visible = v2;
        this.notify(_Tool.CUTOUT_VISIBLE);
    }
    get frameSize() {
        return { size: this.m_frame_size, name: this.m_frame_name };
    }
    setArtboardTemp(width, height, name) {
        this.m_frame_size = { width, height };
        this.m_frame_name = name;
        this.notify(_Tool.INSERT_FRAME);
    }
    get tableSize() {
        return this.m_table_size;
    }
    insertTable(size2) {
        this.m_table_size = size2;
        this.notify(_Tool.INSERT_TABLE);
    }
    get contactApex() {
        return this.m_contact_apex;
    }
    setContactApex(shape2) {
        var _a2;
        if (shape2.id !== ((_a2 = this.m_contact_apex) == null ? void 0 : _a2.id)) {
            this.m_contact_apex = shape2;
            this.notify(_Tool.CHANGE_CONTACT_APEX);
        }
    }
    resetContactApex() {
        const needNotify = !!this.m_contact_apex;
        this.m_contact_apex = void 0;
        if (needNotify) {
            this.notify(_Tool.CHANGE_CONTACT_APEX);
        }
    }
    get contactFrom() {
        return this.m_contact_from;
    }
    setContactFrom(v2) {
        this.m_contact_from = v2;
    }
    get isLable() {
        return this.m_lable_status;
    }
    setLableSwitch(v2) {
        this.m_lable_status = v2;
        this.notify(_Tool.LABLE_CHANGE);
    }
    setReferSelection(rs2) {
        this.m_refer_selection = rs2;
    }
    get referSelection() {
        return this.m_refer_selection;
    }
    setReferFiner(func) {
        this.m_refer_finer = func;
    }
    get referFinder() {
        return this.m_refer_finer;
    }
};
__publicField(_Tool, "CHANGE_ACTION", 1);
__publicField(_Tool, "GROUP", 2);
__publicField(_Tool, "UNGROUP", 3);
__publicField(_Tool, "COMPS", 4);
__publicField(_Tool, "TITLE_VISIBLE", 5);
__publicField(_Tool, "INSERT_FRAME", 6);
__publicField(_Tool, "INSERT_TABLE", 7);
__publicField(_Tool, "CHANGE_CONTACT_APEX", 8);
__publicField(_Tool, "LABLE_CHANGE", 12);
__publicField(_Tool, "NEW_FILE", 9);
__publicField(_Tool, "COMPONENT", 10);
__publicField(_Tool, "SELECT_IMAGE", 11);
__publicField(_Tool, "BLOCKS_CHANGE", 12);
__publicField(_Tool, "CUTOUT_VISIBLE", 13);
__publicField(_Tool, "RULE_RENDER", 14);
__publicField(_Tool, "RULE_RENDER_SIM", 15);
__publicField(_Tool, "HOVER_REFER_CHANGE", 16);
__publicField(_Tool, "REFER_FOCUS_CHANGE", 17);
__publicField(_Tool, "RULE_CLEAR", 18);
let Tool = _Tool;
const toStyle = (obj) => {
    const keys = Object.keys(obj);
    return keys.reduce((pre, cur) => {
        return pre += `${cur}:${obj[cur]};`;
    }, "");
};
const C2 = {
    success: {
        backgroundColor: "#F0F9EB",
        color: "#67953A",
        border: "#E7F5DF"
    },
    info: {
        backgroundColor: "#F4F4F5",
        color: "#909399",
        border: "#AAAAAA"
    },
    danger: {
        backgroundColor: "#FEF0F0",
        color: "#F56C6C",
        border: "#FDE3E3"
    },
    feature: {
        backgroundColor: "#000",
        color: "#fff",
        border: "none"
    }
};
const message$2 = (type, context) => {
    const offset = 120;
    const duration = 2.5;
    const fadeDur = 0.8;
    const speed = 0;
    const position = "top";
    const style = toStyle({
        position: "absolute",
        bottom: "0",
        left: "50%",
        transform: "translateX(-50%)",
        "min-width": "72px",
        height: "32px",
        "border-radius": "4px",
        "background-color": C2[type].backgroundColor,
        "line-height": "32px",
        "z-index": "2008",
        color: C2[type].color,
        "font-size": "14px",
        padding: "0 8px",
        border: `1px solid ${C2[type].border}`,
        opacity: "0",
        "text-align": "center"
    });
    const el2 = document.createElement("div");
    el2.setAttribute("id", "message");
    el2.setAttribute("style", style);
    el2.innerText = context;
    const body = document.body;
    const exist = document.querySelector("body > #message");
    if (exist) {
        body.removeChild(exist);
    }
    body.appendChild(el2);
    dropIn(el2, speed);
    const preToOut = setTimeout(() => {
        fadeOut(el2);
        clearTimeout(preToOut);
    }, duration * 1e3);
    function dropIn(el22, dur) {
        const drop = setTimeout(() => {
            el22.style.transition = dur + "s";
            el22.style[position] = offset + "px";
            el22.style.opacity = "1";
            clearTimeout(drop);
        }, 1);
    }
    function fadeOut(el22) {
        el22.style.opacity = "0";
        const remove2 = setTimeout(() => {
            var _a2;
            (_a2 = el22 == null ? void 0 : el22.parentNode) == null ? void 0 : _a2.removeChild(el22);
            clearTimeout(remove2);
        }, fadeDur * 1e3 + 10);
    }
};
function getRectBox(x2, y2, w2, h2, transform2) {
    if (!transform2.hasRotation()) return {
        lt: { x: x2, y: y2 },
        rb: { x: x2 + w2, y: y2 + h2 },
        w: w2,
        h: h2
    };
    transform2 = transform2.makeFromRotateMatrix();
    const points = [
        new E([-w2 / 2, -h2 / 2, 0]),
        // 左上
        new E([w2 / 2, -h2 / 2, 0]),
        // 右上
        new E([w2 / 2, h2 / 2, 0]),
        // 右下
        new E([-w2 / 2, h2 / 2, 0])
        // 左下
    ];
    const newPoints = transform2.transform(points);
    const maxX = Math.max(...newPoints.data.row(0));
    const maxY = Math.max(...newPoints.data.row(1));
    return {
        lt: { x: -maxX + w2 / 2 + x2, y: -maxY + h2 / 2 + y2 },
        rb: { x: maxX + w2 / 2 + x2, y: maxY + h2 / 2 + y2 },
        w: maxX * 2,
        h: maxY * 2
    };
}
function mergeRectBox(...rectBoxes) {
    const ltX = Math.min(...rectBoxes.map((item) => item.lt.x));
    const ltY = Math.min(...rectBoxes.map((item) => item.lt.y));
    const rbX = Math.max(...rectBoxes.map((item) => item.rb.x));
    const rbY = Math.max(...rectBoxes.map((item) => item.rb.y));
    return {
        lt: { x: ltX, y: ltY },
        rb: { x: rbX, y: rbY },
        w: rbX - ltX,
        h: rbY - ltY
    };
}
function getAllFunctionCallFromString(content) {
    const regexp = /(\w+)\(([^)]+)\)/g;
    const result = [];
    for (; ; ) {
        const match = regexp.exec(content);
        if (!match) break;
        result.push([match[1], match[2]]);
    }
    return result.reverse();
}
function getAllStyleFromString(content) {
    const result = {};
    const items = content.split(";");
    for (const item of items) {
        const [key, value] = item.split(":").map((item2) => item2.trim());
        if (key && value) result[key] = value;
    }
    return result;
}
function parseTransform(transformContent) {
    const functionCalls = getAllFunctionCallFromString(transformContent);
    const transform2 = new P();
    for (const [name, args] of functionCalls) {
        const argList = args.split(/,|\s+/).filter((arg) => arg && arg.trim());
        const numArgList = argList.map((value, i) => {
            if (value.includes("deg")) return parseFloat(value.replace("deg", "")) * Math.PI / 180;
            else if (value.includes("rad")) return parseFloat(value.replace("rad", ""));
            else if (value.includes("grad")) return parseFloat(value.replace("grad", "")) * Math.PI / 200;
            else if (value.includes("turn")) return parseFloat(value.replace("turn", "")) * Math.PI * 2;
            else {
                if (name.startsWith("rotate") && !(name === "rotate" && i > 0) && !(name === "rotate3d" && i < 3)) {
                    return parseFloat(value.replace("deg", "")) * Math.PI / 180;
                } else {
                    return parseFloat(value);
                }
            }
        });
        if (name === "matrix") {
            const matrix = new C$1(new S([4, 4], [
                numArgList[0],
                numArgList[2],
                0,
                numArgList[4],
                numArgList[1],
                numArgList[3],
                0,
                numArgList[5],
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ], true));
            transform2.addTransform(new P({ matrix }));
        } else if (name.startsWith("rotate")) {
            if (name === "rotate") {
                if (numArgList.length === 1) {
                    transform2.rotateZ({ angle: numArgList[0] });
                } else if (numArgList.length === 3) {
                    transform2.rotateAt({
                        axis: new B(E.FromXYZ(0, 0, 1), E.FromXYZ(numArgList[0], numArgList[1], 0)),
                        angle: numArgList[0]
                    });
                }
            } else if (name === "rotateX") {
                transform2.rotateX({ angle: numArgList[0] });
            } else if (name === "rotateY") {
                transform2.rotateY({ angle: numArgList[0] });
            } else if (name === "rotateZ") {
                transform2.rotateZ({ angle: numArgList[0] });
            } else if (name === "rotate3d") {
                transform2.rotate({
                    axis: new N(E.FromXYZ(numArgList[0], numArgList[1], numArgList[2])),
                    angle: numArgList[3]
                });
            }
        } else if (name === "scale") {
            transform2.scale({ vector: new E([numArgList[0], numArgList[1], numArgList[2] || 1]) });
        } else if (name === "translate") {
            transform2.translate(new E([numArgList[0], numArgList[1] || numArgList[0], numArgList[2] || 0]));
        } else {
            console.log("不支持的变换函数", name, args);
        }
    }
    return transform2;
}
function myColorToColor(color2) {
    if (!color2) return new Ji(1, 0, 0, 0);
    return new Ji(color2.a, color2.r, color2.g, color2.b);
}
const namedColorMap = {
    "black": "#000000",
    "silver": "#c0c0c0",
    "gray": "#808080",
    "white": "#ffffff",
    "maroon": "#800000",
    "red": "#ff0000",
    "purple": "#800080",
    "fuchsia": "#ff00ff",
    "green": "#008000",
    "lime": "#00ff00",
    "olive": "#808000",
    "yellow": "#ffff00",
    "navy": "#000080",
    "blue": "#0000ff",
    "teal": "#008080",
    "aqua": "#00ffff",
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "blanchedalmond": "#ffebcd",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkgrey": "#a9a9a9",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkslategrey": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "greenyellow": "#adff2f",
    "grey": "#808080",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgray": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightgrey": "#d3d3d3",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370db",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "oldlace": "#fdf5e6",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#db7093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "rebeccapurple": "#663399",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "slategrey": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "transparent": "#00000000",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "whitesmoke": "#f5f5f5",
    "yellowgreen": "#9acd32"
};
function parseColor(content) {
    if (content in namedColorMap) content = namedColorMap[content];
    let color2;
    if (content.startsWith("rgba")) {
        const rgba = content.slice(5, -1).split(/,|\s+/).filter((arg) => arg && arg.trim()).map((item) => parseFloat(item));
        color2 = {
            r: rgba[0],
            g: rgba[1],
            b: rgba[2],
            a: rgba[3]
        };
    } else if (content.startsWith("rgb")) {
        const rgb = content.slice(4, -1).split(/,|\s+/).filter((arg) => arg && arg.trim()).map((item) => parseFloat(item));
        color2 = {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            a: 1
        };
    } else if (content.startsWith("#")) {
        let hex = content.slice(1);
        let r, g2, b2, a2;
        if (hex.length === 3) {
            r = parseInt(hex[0] + hex[0], 16);
            g2 = parseInt(hex[1] + hex[1], 16);
            b2 = parseInt(hex[2] + hex[2], 16);
            a2 = 1;
        } else if (hex.length === 4) {
            r = parseInt(hex[0] + hex[0], 16);
            g2 = parseInt(hex[1] + hex[1], 16);
            b2 = parseInt(hex[2] + hex[2], 16);
            a2 = parseInt(hex[3] + hex[3], 16) / 255;
        } else if (hex.length === 6) {
            r = parseInt(hex.substring(0, 2), 16);
            g2 = parseInt(hex.substring(2, 4), 16);
            b2 = parseInt(hex.substring(4, 6), 16);
            a2 = 1;
        } else if (hex.length === 8) {
            r = parseInt(hex.substring(0, 2), 16);
            g2 = parseInt(hex.substring(2, 4), 16);
            b2 = parseInt(hex.substring(4, 6), 16);
            a2 = parseInt(hex.substring(6, 8), 16) / 255;
        } else {
            console.log("无效的颜色格式", content);
            return;
        }
        color2 = {
            r,
            g: g2,
            b: b2,
            a: a2
        };
    } else if (content === "none") ;
    else {
        console.log("不支持的颜色格式", content);
    }
    return color2;
}
const hiddenSvgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
hiddenSvgElement.setAttribute("width", "100%");
hiddenSvgElement.setAttribute("height", "100%");
hiddenSvgElement.setAttribute("style", "position:absolute;top:-100%;left:-100%;visibility:hidden");
function getHiddenSvgElement() {
    if (!document.contains(hiddenSvgElement)) document.body.appendChild(hiddenSvgElement);
    if (hiddenSvgElement.childElementCount > 100) hiddenSvgElement.innerHTML = "";
    return hiddenSvgElement;
}
function getPathBoxFromD(d2) {
    const svg = getHiddenSvgElement();
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d2);
    svg.appendChild(path);
    return path.getBBox();
}
class BaseTreeNode {
    constructor() {
        __publicField(this, "root");
        __publicField(this, "parent");
        __publicField(this, "children", []);
    }
    index() {
        if (!this.parent) return -1;
        return this.parent.children.indexOf(this);
    }
    prevSibling() {
        const index2 = this.index();
        if (index2 <= 0) return;
        return this.parent.children[index2 - 1];
    }
    nextSibling() {
        const index2 = this.index();
        if (index2 === -1 || index2 === this.parent.children.length - 1) return;
        return this.parent.children[index2 + 1];
    }
    siblings() {
        const index2 = this.index();
        if (index2 === -1) return [];
        return this.parent.children.filter((_2, i) => i !== index2);
    }
    isAncestorOf(node) {
        let parent = node.parent;
        while (parent) {
            if (parent === this) return true;
            parent = parent.parent;
        }
        return false;
    }
    isDescendantOf(node) {
        return node.isAncestorOf(this);
    }
    isOnTree() {
        if (!this.root) return false;
        return this.root.isAncestorOf(this);
    }
    isSiblingOf(node) {
        return this.parent === node.parent;
    }
    getPath() {
        const path = [];
        let node = this;
        while (node) {
            path.push(node);
            node = node.parent;
        }
        return path.reverse();
    }
    remove() {
        const index2 = this.index();
        if (index2 === -1) return;
        this.parent.children.splice(index2, 1);
    }
    replaceWithChildren() {
        if (!this.parent) return;
        this.parent.insertChildesAfter(this, ...this.children);
        this.remove();
    }
    removeChildes(...childes) {
        for (const child of childes) child.remove();
    }
    appendChildes(...childes) {
        for (const child of childes) {
            child.remove();
            child.parent = this;
            child.root = this.root;
            this.children.push(child);
        }
    }
    insertChildes(index2, ...childes) {
        if (index2 < 0 || index2 > this.children.length) return;
        for (const child of childes) {
            child.remove();
            child.parent = this;
            child.root = this.root;
        }
        this.children.splice(index2, 0, ...childes);
    }
    insertChildesBefore(reference, ...childes) {
        const index2 = reference.index();
        if (index2 === -1) return;
        this.insertChildes(index2, ...childes);
    }
    insertChildesAfter(reference, ...childes) {
        const index2 = reference.index();
        if (index2 === -1) return;
        this.insertChildes(index2 + 1, ...childes);
    }
    // 遍历以本节点为根的树
    // 遍历顺序：do(根)-do(左)-afterChildrenDo(左)-do(右)-afterChildrenDo(右)-afterSiblingDo(左-右)-afterChildrenDo(根)-afterAllDo(根-左-右)
    traverse(handler) {
        var _a2, _b, _c2, _d2, _e2;
        const stack0 = [this];
        const stack1 = [];
        while (stack0.length) {
            const creator = stack0.pop();
            (_a2 = handler.do) == null ? void 0 : _a2.call(handler, creator);
            const children = creator.children;
            if (children.length) {
                stack0.push(...children.slice(0).reverse());
                stack1.push([creator, children.length]);
            } else {
                (_b = handler.afterChildrenDo) == null ? void 0 : _b.call(handler, creator);
                if (stack1.length === 0 && creator !== this) throw new Error("rootTreeNode元素不匹配");
                let currentCreator = creator;
                while (stack1.length > 0) {
                    const parentStack = stack1[stack1.length - 1];
                    const parentCreator = parentStack[0];
                    if (parentCreator !== currentCreator.parent) throw new Error("treeNode父级元素不匹配");
                    if (--parentStack[1] > 0) break;
                    stack1.pop();
                    for (const child of parentCreator.children) (_c2 = handler.afterSiblingDo) == null ? void 0 : _c2.call(handler, child);
                    (_d2 = handler.afterChildrenDo) == null ? void 0 : _d2.call(handler, parentCreator);
                    currentCreator = parentCreator;
                }
            }
        }
        const stack2 = [this];
        if (handler.afterAllDo) while (stack2.length) {
            const creator = stack2.pop();
            (_e2 = handler.afterAllDo) == null ? void 0 : _e2.call(handler, creator);
            stack2.push(...creator.children.slice(0).reverse());
        }
    }
}
class BaseCreator extends BaseTreeNode {
    constructor(context, root, parent, htmlElement) {
        super();
        __publicField(this, "context");
        __publicField(this, "root");
        __publicField(this, "parent");
        __publicField(this, "children", []);
        __publicField(this, "htmlElement");
        __publicField(this, "localAttributes", {});
        __publicField(this, "isLocalAttributesParsed", false);
        __publicField(this, "attributes", {});
        __publicField(this, "transform", new P());
        __publicField(this, "shape");
        __publicField(this, "style");
        this.context = context;
        this.root = root;
        this.parent = parent;
        if (htmlElement) {
            this.htmlElement = {
                ...htmlElement,
                tagName: htmlElement.node.tagName
            };
        }
    }
    static method(handlerName) {
        return function(creator) {
            creator[handlerName]();
        };
    }
    getShapeNumberName(name) {
        let shapeNameCountMap = this.context.shapeNameCountMap;
        if (Object.prototype.toString.call(shapeNameCountMap) !== "[object Object]") {
            shapeNameCountMap = this.context.shapeNameCountMap = {};
        }
        if (!(name in shapeNameCountMap)) shapeNameCountMap[name] = 0;
        const number2 = ++shapeNameCountMap[name];
        return `${name} ${number2 > 1 ? number2 : ""}`;
    }
    /**
     * 调整节点
     * adjust() // 调整节点
     * afterChildrenAdjust() // 所有子节点adjust之后
     * afterSiblingAdjust() // 所有兄弟节点adjust之后
     * afterAllAdjust() // 所有节点adjust之后
     *
     * 创建shape
     * createShape() // 创建shape
     * afterChildrenCreateShape() // 所有子节点创建shape之后
     * afterSiblingCreateShape() // 所有兄弟节点创建shape之后
     * afterAllCreateShape() // 所有节点创建shape之后
     */
    adjust() {
    }
    afterChildrenAdjust() {
    }
    afterSiblingAdjust() {
    }
    afterAllAdjust() {
    }
    createShape() {
    }
    _createShape() {
        this.createShape();
        this.updateShapeAttr();
    }
    afterChildrenCreateShape() {
    }
    afterSiblingCreateShape() {
    }
    afterAllCreateShape() {
        if (!this.shape) return;
        this.shape.name = this.getShapeNumberName(this.localAttributes.id || this.shape.name);
    }
    parseAttributes() {
        var _a2, _b, _c2, _d2, _e2, _f2, _g2;
        if (!this.htmlElement) return;
        const svgRoot = (_a2 = this.htmlElement) == null ? void 0 : _a2.root;
        if (!svgRoot) return;
        if (this.isLocalAttributesParsed) return;
        this.isLocalAttributesParsed = true;
        const attributes = this.htmlElement.node.attributes;
        for (const attribute of attributes) this.localAttributes[attribute.name] = attribute.value;
        const style = this.localAttributes["style"];
        if (style) {
            this.attributes.style = style;
            this.attributes.styleAttributes = getAllStyleFromString(style);
        }
        const styleMap = this.context["styleMap"];
        let classSelector = this.localAttributes["class"];
        if (classSelector) classSelector = "." + classSelector;
        let idSelector = this.localAttributes["id"];
        if (idSelector) idSelector = "#" + idSelector;
        for (const styleSelector of [classSelector, idSelector]) {
            if (!styleSelector) continue;
            const styleContent = styleMap[styleSelector];
            if (!styleContent) continue;
            if (style) {
                if (!this.attributes.style.endsWith(";")) this.attributes.style += ";";
                this.attributes.style += styleContent;
                this.attributes.styleAttributes = {
                    ...this.attributes.styleAttributes,
                    ...getAllStyleFromString(styleContent)
                };
            } else {
                this.attributes.style = styleContent;
                this.attributes.styleAttributes = getAllStyleFromString(styleContent);
            }
        }
        if (this.attributes.styleAttributes && "transform" in this.attributes.styleAttributes) {
            this.attributes.styleTransform = this.attributes.styleAttributes.transform;
        }
        const x2 = this.localAttributes["x"];
        if (x2) this.attributes.x = parseFloat(x2);
        const y2 = this.localAttributes["y"];
        if (y2) this.attributes.y = parseFloat(y2);
        const width = this.localAttributes["width"];
        if (width) this.attributes.width = parseFloat(width);
        const height = this.localAttributes["height"];
        if (height) this.attributes.height = parseFloat(height);
        if (this.htmlElement.tagName === "svg") {
            const viewBox2 = this.localAttributes["viewBox"];
            if (viewBox2) {
                const viewBoxSplitRes = viewBox2.split(/,|\s+/).filter((arg) => arg && arg.trim()).map((item) => parseFloat(item));
                this.attributes.width = viewBoxSplitRes[2];
                this.attributes.height = viewBoxSplitRes[3];
            }
        }
        const d2 = this.localAttributes["d"];
        const isPath = this.htmlElement.tagName === "path";
        if (d2) {
            this.attributes.d = d2;
            const { x: x3, y: y3, width: width2, height: height2 } = getPathBoxFromD(d2);
            this.attributes.pathX = x3;
            this.attributes.pathY = y3;
            if (isPath) {
                this.attributes.width = width2;
                this.attributes.height = height2;
            }
        }
        const points = this.localAttributes["points"];
        const isPolyline = this.htmlElement.tagName === "polyline" || this.htmlElement.tagName === "polygon";
        const pointsToPathD = jd.polylinePointsToPathD(points, this.htmlElement.tagName === "polyline");
        if (pointsToPathD) {
            this.attributes.pointsToPathD = pointsToPathD;
            const { x: x3, y: y3, width: width2, height: height2 } = getPathBoxFromD(pointsToPathD);
            this.attributes.polylineX = x3;
            this.attributes.polylineY = y3;
            if (isPolyline) {
                this.attributes.width = width2;
                this.attributes.height = height2;
            }
        }
        let transform2;
        if (this.attributes.styleTransform) transform2 = this.attributes.styleTransform;
        if (!transform2) {
            this.attributes.transform = this.localAttributes["transform"] ?? void 0;
            transform2 = this.attributes.transform;
        }
        if (transform2) this.transform.addTransform(parseTransform(transform2));
        const opacity2 = this.localAttributes["opacity"];
        if (opacity2) this.attributes.opacity = parseFloat(opacity2);
        const parseFillColor = (content, fillOpacity2 = 1) => {
            var _a3, _b2, _c3;
            if (!content) return;
            let colorType;
            let color2;
            let linearGradient;
            let radialGradient;
            if (content.startsWith("url(#")) {
                const urlId = content.slice(5, -1);
                const el2 = svgRoot.querySelector(`#${urlId}`);
                if (el2) {
                    const creator = el2.creator;
                    creator.parseAttributes();
                    const stops = creator.children.filter((child) => {
                        var _a4;
                        return ((_a4 = child.htmlElement) == null ? void 0 : _a4.tagName) === "stop";
                    }).map((child) => {
                        child.parseAttributes();
                        const attrs = child.localAttributes;
                        let offset = 0;
                        if (attrs["offset"]) {
                            if (attrs["offset"].includes("%")) offset = parseFloat(attrs["offset"].replace("%", "")) / 100;
                            else offset = parseFloat(attrs["offset"]);
                        }
                        const stopColor = parseColor(attrs["stop-color"] || "black");
                        const stopOpacity = parseFloat(attrs["stop-opacity"] || "1");
                        return {
                            offset,
                            color: stopColor,
                            opacity: stopOpacity
                        };
                    });
                    if (((_a3 = creator.htmlElement) == null ? void 0 : _a3.tagName) === "linearGradient") {
                        let x12 = creator.localAttributes["x1"] || "0";
                        x12 = x12.includes("%") ? parseFloat(x12.replace("%", "")) / 100 : parseFloat(x12);
                        let y12 = creator.localAttributes["y1"] || "0";
                        y12 = y12.includes("%") ? parseFloat(y12.replace("%", "")) / 100 : parseFloat(y12);
                        let x222 = creator.localAttributes["x2"] || "1";
                        x222 = x222.includes("%") ? parseFloat(x222.replace("%", "")) / 100 : parseFloat(x222);
                        let y222 = creator.localAttributes["y2"] || "0";
                        y222 = y222.includes("%") ? parseFloat(y222.replace("%", "")) / 100 : parseFloat(y222);
                        const parentX = parseFloat(this.localAttributes["x"] || "0");
                        const parentY = parseFloat(this.localAttributes["y"] || "0");
                        linearGradient = {
                            x1: x12 - parentX,
                            y1: y12 - parentY,
                            x2: x222 - parentX,
                            y2: y222 - parentY,
                            opacity: this.attributes.opacity || 1,
                            stops
                        };
                        colorType = "linearGradient";
                    } else if (((_b2 = creator.htmlElement) == null ? void 0 : _b2.tagName) === "radialGradient") {
                        const cx2 = parseFloat(creator.localAttributes["cx"] || "0");
                        const cy2 = parseFloat(creator.localAttributes["cy"] || "0");
                        const r2 = parseFloat(creator.localAttributes["r"] || "1");
                        const transform22 = new P();
                        if (creator.localAttributes["gradientTransform"]) transform22.addTransform(parseTransform(creator.localAttributes["gradientTransform"]));
                        const scaleArgs = (_c3 = getAllFunctionCallFromString(creator.localAttributes["gradientTransform"]).find((item) => item[0] === "scale")) == null ? void 0 : _c3[1].split(/,|\s+/).filter((arg) => arg && arg.trim());
                        radialGradient = {
                            cx: cx2,
                            cy: cy2,
                            r: r2,
                            opacity: this.attributes.opacity || 1,
                            transform: transform22,
                            stops,
                            scales: scaleArgs ? scaleArgs.map((arg) => parseFloat(arg)) : [1, 1]
                        };
                        colorType = "radialGradient";
                    }
                }
            } else if (content === "none") {
                return null;
            } else {
                color2 = parseColor(content);
                if (color2) {
                    color2.a *= fillOpacity2;
                    colorType = "color";
                }
            }
            return colorType && {
                colorType,
                color: color2,
                linearGradient,
                radialGradient
            };
        };
        let fill;
        if (this.attributes.styleAttributes && "fill" in this.attributes.styleAttributes) {
            fill = this.attributes.styleAttributes.fill;
        }
        if (!fill) fill = this.localAttributes["fill"];
        const fillAttrName = ((_b = this.htmlElement) == null ? void 0 : _b.tagName) === "text" ? "textFill" : "fill";
        if (!fill && this.attributes[fillAttrName] === void 0 && ((_c2 = this.htmlElement) == null ? void 0 : _c2.tagName) !== "svg" && ((_d2 = this.htmlElement) == null ? void 0 : _d2.tagName) !== "g") {
            let node = this.htmlElement.node.parentElement;
            while (node) {
                fill = node.creator.localAttributes[fillAttrName];
                if (fill) break;
                node = node.parentElement;
            }
            if (!fill) fill = "black";
        }
        const fillOpacity = parseFloat(this.localAttributes["fill-opacity"]) || 1;
        let fillColor = parseFillColor(fill, fillOpacity);
        let fillAttrValue;
        if (fillColor) {
            fillAttrValue = {
                colorType: fillColor.colorType,
                linearGradient: fillColor.linearGradient,
                radialGradient: fillColor.radialGradient,
                color: fillColor.color
            };
        } else {
            fillAttrValue = fillColor;
        }
        if (((_e2 = this.htmlElement) == null ? void 0 : _e2.tagName) === "svg" || ((_f2 = this.htmlElement) == null ? void 0 : _f2.tagName) === "g") {
            for (const child of this.children) {
                child.attributes[fillAttrName] = fillAttrValue;
            }
        } else if (fillColor !== void 0) {
            this.attributes[fillAttrName] = fillAttrValue;
        }
        let stroke2;
        if (this.attributes.styleAttributes && "stroke" in this.attributes.styleAttributes) {
            stroke2 = this.attributes.styleAttributes.stroke;
        }
        if (!stroke2) stroke2 = this.localAttributes["stroke"];
        const dashArray = ((_g2 = this.localAttributes["stroke-dasharray"]) == null ? void 0 : _g2.split(/,|\s+/).filter((arg) => arg && arg.trim()).map((item) => parseFloat(item))) || [0, 0];
        if (stroke2) {
            const strokeColor = parseFillColor(stroke2, 1);
            const strokeOpacity = parseFloat(this.localAttributes["stroke-opacity"] || "1");
            if (strokeColor) {
                if (strokeColor.color) strokeColor.color.a *= strokeOpacity;
                this.attributes.stroke = {
                    colorType: strokeColor.colorType,
                    linearGradient: strokeColor.linearGradient,
                    radialGradient: strokeColor.radialGradient,
                    color: strokeColor.color,
                    dashArray,
                    position: "center"
                };
            }
        }
        let strokeWidth;
        if (this.attributes.styleAttributes && "stroke-width" in this.attributes.styleAttributes) {
            strokeWidth = this.attributes.styleAttributes["stroke-width"];
        }
        if (!strokeWidth) strokeWidth = this.localAttributes["stroke-width"];
        if (strokeWidth) {
            this.attributes.strokeWidth = parseFloat(strokeWidth);
            if (this.attributes.stroke) this.attributes.stroke.width = this.attributes.strokeWidth;
        }
        const cx = this.localAttributes["cx"];
        const cy = this.localAttributes["cy"];
        const rx = this.localAttributes["rx"];
        const ry = this.localAttributes["ry"];
        const r = this.localAttributes["r"];
        const isCircle = this.htmlElement.tagName === "ellipse" || this.htmlElement.tagName === "circle";
        if (rx) {
            this.attributes.rx = parseFloat(rx);
            if (isCircle) this.attributes.width = this.attributes.rx * 2;
        }
        if (ry) {
            this.attributes.ry = parseFloat(ry);
            if (isCircle) this.attributes.height = this.attributes.ry * 2;
        }
        if (r) {
            this.attributes.rx = this.attributes.ry = parseFloat(r);
            if (isCircle) this.attributes.width = this.attributes.height = this.attributes.rx * 2;
        }
        if (cx) {
            this.attributes.cx = parseFloat(cx) - parseFloat(r || rx || "0");
            if (isCircle) this.attributes.x = this.attributes.cx;
        }
        if (cy) {
            this.attributes.cy = parseFloat(cy) - parseFloat(r || ry || "0");
            if (isCircle) this.attributes.y = this.attributes.cy;
        }
        const isLine = this.htmlElement.tagName === "line";
        const x1 = this.localAttributes["x1"];
        if (x1) this.attributes.x1 = parseFloat(x1);
        if (isLine && !this.attributes.x) this.attributes.x = this.attributes.x1;
        const y1 = this.localAttributes["y1"];
        if (y1) this.attributes.y1 = parseFloat(y1);
        if (isLine && !this.attributes.y) this.attributes.y = this.attributes.y1;
        const x22 = this.localAttributes["x2"];
        if (x22) this.attributes.x2 = parseFloat(x22);
        const y22 = this.localAttributes["y2"];
        if (y22) this.attributes.y2 = parseFloat(y22);
        const href = this.localAttributes["xlink:href"] ?? this.localAttributes["href"];
        if (href) this.attributes.href = href;
    }
    updateShapeAttrByTransform() {
        const shape2 = this.shape;
        if (!shape2) return;
        let { translate: translate2, rotate, skew, scale } = this.transform.decompose();
        const size2 = shape2.size;
        const w1 = size2.width * scale.x;
        const h1 = size2.height * scale.y;
        if (this.transform.hasRotation()) {
            const res = this.transform.clone().preTranslate(new E([w1 / 2, h1 / 2, 0])).translate(new E([-w1 / 2, -h1 / 2, 0])).decompose();
            translate2 = res.translate;
            rotate = res.rotate;
            skew = res.skew;
            scale = res.scale;
        }
        shape2.size.width = (this.attributes.width || 0) * Math.abs(scale.x || 1);
        shape2.size.height = (this.attributes.height || 0) * Math.abs(scale.y || 1);
        const transform2 = ki(shape2.transform);
        transform2.setTranslate(new E([translate2.x, translate2.y, 0]));
        transform2.setRotateZ(rotate.z);
        transform2.setSkew({ skew });
        transform2.setScale(new E([scale.x, scale.y, scale.z]));
        Fi(shape2.transform, transform2);
    }
    updateShapeStyle() {
        const shape2 = this.shape;
        if (!shape2) return;
        const buildGradientByFillColor = (fillColor2) => {
            const gradient = fillColor2.colorType === "linearGradient" ? fillColor2.linearGradient : fillColor2.radialGradient;
            let from, to2;
            let colorType;
            let elipseLength;
            const opacity2 = gradient.opacity;
            const width = this.attributes.width || 1;
            const height = this.attributes.height || 1;
            if (fillColor2.colorType === "linearGradient") {
                from = new fe(fillColor2.linearGradient.x1, fillColor2.linearGradient.y1);
                to2 = new fe(fillColor2.linearGradient.x2, fillColor2.linearGradient.y2);
                colorType = wt.Linear;
            } else {
                const translate2 = fillColor2.radialGradient.transform.decomposeTranslate();
                from = new fe(translate2.x / width, translate2.y / height);
                const toVec = fillColor2.radialGradient.transform.transform(new E([1, 0, 0]));
                to2 = new fe(toVec.data.get([0, 0]) / width, toVec.data.get([1, 0]) / height);
                colorType = wt.Radial;
                elipseLength = fillColor2.radialGradient.scales[1] / fillColor2.radialGradient.scales[0] * height / width;
            }
            const stops = gradient.stops.map(
                (item, i) => {
                    item.color.a *= item.opacity;
                    return new xe([i], v4(), item.offset, myColorToColor(item.color));
                }
            );
            return new Qi(from, to2, colorType, stops, elipseLength, opacity2);
        };
        const fills = new G();
        const fillColor = this.attributes.fill;
        if (fillColor) {
            const fill = new es(new G(), v4(), true, xt.SolidColor, myColorToColor(fillColor.color));
            fills.push(fill);
            if (fillColor.colorType !== "color") {
                fill.gradient = buildGradientByFillColor(fillColor);
                fill.fillType = xt.Gradient;
            }
            if (this.localAttributes["fill-rule"] === "evenodd") fill.fillRule = yt.Evenodd;
            else fill.fillRule = yt.Nonzero;
        }
        const borders = new G();
        const stroke2 = this.attributes.stroke;
        if (stroke2) {
            const strokeWidth = stroke2.width || 1;
            let position;
            if (stroke2.position === "inside") position = ht.Inner;
            else if (stroke2.position === "center") position = ht.Center;
            else position = ht.Outer;
            let cornerType;
            const corner = this.localAttributes["stroke-linejoin"];
            if (corner) {
                if (corner === "miter") cornerType = ut.Miter;
                else if (corner === "round") cornerType = ut.Round;
                else cornerType = ut.Bevel;
            } else {
                cornerType = ut.Miter;
            }
            const borderStyle = new Kt(stroke2.dashArray[0], stroke2.dashArray[1]);
            const side = new Me(Dt.Normal, strokeWidth, strokeWidth, strokeWidth, strokeWidth);
            const border = new ts([0], v4(), true, xt.SolidColor, myColorToColor(stroke2.color), position, strokeWidth, borderStyle, cornerType, side);
            borders.push(border);
            if (stroke2.colorType !== "color") {
                border.gradient = buildGradientByFillColor(stroke2);
                border.fillType = xt.Gradient;
            }
        }
        const shadows = new G();
        this.style = new is(borders, fills, shadows);
        if (this.attributes.opacity) this.style.contextSettings = new ee(nt.Normal, this.attributes.opacity);
        shape2.style = this.style;
    }
    updateShapeAttr() {
        const shape2 = this.shape;
        if (!shape2) return;
        let x2 = this.attributes.x || 0;
        let y2 = this.attributes.y || 0;
        if (this.parent instanceof SvgCreator && this.parent.viewBox) {
            x2 -= this.parent.viewBox[0];
            y2 -= this.parent.viewBox[1];
        }
        if (x2 !== 0 || y2 !== 0) this.transform.preTranslate(new E([x2, y2, 0]));
        this.updateShapeAttrByTransform();
        this.updateShapeStyle();
    }
}
class SvgCreator extends BaseCreator {
    constructor() {
        super(...arguments);
        __publicField(this, "viewBox");
    }
    createShape() {
        this.shape = jd.newArtboard("容器", new _e(0, 0, this.attributes.width || 0, this.attributes.height || 0));
    }
    afterChildrenCreateShape() {
        if (!this.shape) return;
        const viewBox2 = this.localAttributes["viewBox"];
        if (viewBox2) {
            const viewBoxSplitRes = viewBox2.split(/,|\s+/).filter((arg) => arg && arg.trim()).map((item) => parseFloat(item));
            if (viewBoxSplitRes.length >= 4) {
                const [dx, dy, w0, h0] = viewBoxSplitRes;
                const w2 = this.attributes.width || 0;
                const h2 = this.attributes.height || 0;
                const scaleX = w0 === 0 ? 1 : w2 / w0;
                const scaleY = h0 === 0 ? 1 : h2 / h0;
                if (scaleX !== 1 || scaleY !== 1) for (const item of this.children) {
                }
                if (dx !== 0 || dy !== 0) for (const item of this.children) {
                    item.transform.translate(new E([dx, dy, 0]));
                }
                if (scaleX !== 1 || scaleY !== 1 || dx !== 0 || dy !== 0) for (const item of this.children) {
                    item.updateShapeAttrByTransform();
                }
            }
        }
        const svgShape = this.shape;
        const childrenShapes = this.children.filter((item) => item.shape).map((item) => item.shape);
        svgShape.childs.push(...childrenShapes);
        for (const item of childrenShapes) item.resizingConstraint = 0;
    }
}
class NoneCreator extends BaseCreator {
}
function mergeAttributes(parent, child) {
    const parentShape = parent.shape;
    const childShape = child.shape;
    if (!parentShape || !childShape) return;
    child.transform = child.transform.addTransform(parent.transform);
    child.updateShapeAttrByTransform();
    if (parent.attributes.opacity) {
        if (child.attributes.opacity) child.attributes.opacity *= parent.attributes.opacity;
        else child.attributes.opacity = parent.attributes.opacity;
    }
    if (parent.localAttributes.id) {
        if (child.localAttributes.id) child.localAttributes.id = parent.localAttributes.id + child.localAttributes.id;
        else child.localAttributes.id = parent.localAttributes.id;
    }
    child.updateShapeStyle();
}
class GroupCreator extends BaseCreator {
    createShape() {
        this.shape = jd.newGroupShape("编组", this.style);
    }
    afterChildrenCreateShape() {
        if (!this.shape) return;
        const children = this.children.filter((child) => child.shape).map((child) => {
            return {
                shape: child.shape,
                creator: child
            };
        });
        if (children.length === 0) {
            this.remove();
            return;
        }
        const reservedAttributes = ["fill", "stroke"];
        const isReserved = reservedAttributes.some((attr2) => attr2 in this.attributes && this.attributes[attr2]);
        if (!isReserved && children.length === 1) {
            mergeAttributes(this, children[0].creator);
            this.replaceWithChildren();
            return;
        }
        const groupShape = this.shape;
        groupShape.childs.push(...children.map((child) => child.shape));
        const childShapeBoxes = children.map((child) => {
            const childShape = child.shape;
            const childCreator = child.creator;
            return getRectBox(childShape.frame.x, childShape.frame.y, childShape.frame.width, childShape.frame.height, childCreator.transform);
        });
        const childesShapeBox = mergeRectBox(...childShapeBoxes);
        this.attributes.width = childesShapeBox.w;
        this.attributes.height = childesShapeBox.h;
        for (const child of children) {
            child.creator.transform.translate(new E([-childesShapeBox.lt.x, -childesShapeBox.lt.y, 0]));
            child.creator.updateShapeAttrByTransform();
        }
        this.transform.preTranslate(new E([childesShapeBox.lt.x, childesShapeBox.lt.y, 0]));
        this.updateShapeAttrByTransform();
    }
}
class PathCreator extends BaseCreator {
    afterAllAdjust() {
        var _a2, _b, _c2, _d2, _e2, _f2;
        if (this.attributes.fill || !this.attributes.stroke) return;
        const svgRoot = (_b = (_a2 = this.root) == null ? void 0 : _a2.htmlElement) == null ? void 0 : _b.root;
        if (!svgRoot) return;
        let fillPart;
        let position;
        const findFillPart = (item) => {
            return item instanceof PathCreator && item.attributes.fill && item.attributes.x === this.attributes.x && item.attributes.y === this.attributes.y && item.attributes.width === this.attributes.width && item.attributes.height === this.attributes.height && item.localAttributes["d"] === this.localAttributes["d"];
        };
        const mask = this.localAttributes["mask"];
        const clip = this.localAttributes["clip-path"];
        if (mask && mask.startsWith("url(#") || clip && clip.startsWith("url(#")) {
            position = mask ? "outside" : "inside";
            const urlId = (mask || clip).slice(5, -1);
            const el2 = svgRoot.querySelector(`#${urlId}>path`);
            if (el2) {
                const creator = el2.creator;
                if (creator instanceof PathCreator && creator.localAttributes["d"] === this.localAttributes["d"]) {
                    fillPart = (_c2 = this.parent) == null ? void 0 : _c2.siblings().find(findFillPart);
                    if (!fillPart) fillPart = (_d2 = this.parent) == null ? void 0 : _d2.siblings().reduce((prev, cur) => {
                        prev.push(...cur.children);
                        return prev;
                    }, []).find(findFillPart);
                }
            }
        } else {
            position = "center";
            fillPart = this.siblings().find(findFillPart);
            if (!fillPart) fillPart = (_e2 = this.parent) == null ? void 0 : _e2.siblings().find(findFillPart);
            if (!fillPart) fillPart = (_f2 = this.parent) == null ? void 0 : _f2.siblings().reduce((prev, cur) => {
                prev.push(...cur.children);
                return prev;
            }, []).find(findFillPart);
        }
        if (!fillPart) fillPart = this;
        let strokeWidth = this.attributes.strokeWidth;
        if (strokeWidth && position !== "center") strokeWidth /= 2;
        fillPart.attributes.stroke = {
            ...this.attributes.stroke,
            width: strokeWidth,
            position
        };
        if (fillPart !== this) this.remove();
    }
    createShape() {
        const d2 = this.attributes.d;
        if (!d2) return;
        const x2 = this.attributes.pathX || 0;
        const y2 = this.attributes.pathY || 0;
        const width = this.attributes.width || 0;
        const height = this.attributes.height || 0;
        const path = new pi(d2);
        path.translate(-x2, -y2);
        let diffTranslate = new E([x2, y2, 0]);
        diffTranslate = this.transform.clone().clearTranslate().transform(diffTranslate).col0;
        const x1 = diffTranslate.x + (this.attributes.x || 0);
        const y1 = diffTranslate.y + (this.attributes.y || 0);
        this.transform.translate(new E([x1, y1, 0]));
        this.shape = jd.newPathShape("路径", new _e(x1, y1, width, height), path, this.style);
    }
}
class RectCreator extends BaseCreator {
    createShape() {
        const x2 = this.attributes.x || 0;
        const y2 = this.attributes.y || 0;
        const width = this.attributes.width || 0;
        const height = this.attributes.height || 0;
        this.shape = jd.newRectShape("矩形", new _e(x2, y2, width, height));
        let rx = this.attributes.rx;
        let ry = this.attributes.ry;
        if (rx === void 0) rx = ry;
        if (ry === void 0) ry = rx;
        const r = ((rx || 0) + (ry || 0)) / 2;
        if (r > 0) for (let i = 0; i < 4; i++) this.shape.pathsegs[0].points[i].radius = r;
    }
}
class EllipseCreator extends BaseCreator {
    createShape() {
        const x2 = this.attributes.x || 0;
        const y2 = this.attributes.y || 0;
        let width = 0;
        if (this.attributes.rx) width = this.attributes.rx * 2;
        else if (this.attributes.width) width = this.attributes.width;
        let height = 0;
        if (this.attributes.ry) height = this.attributes.ry * 2;
        else if (this.attributes.height) height = this.attributes.height;
        this.shape = jd.newOvalShape("圆形", new _e(x2, y2, width, height));
    }
}
class LineCreator extends BaseCreator {
    createShape() {
        const x1 = this.attributes.x1 || 0;
        const y1 = this.attributes.y1 || 0;
        this.attributes.x2 || 0;
        this.attributes.y2 || 0;
        this.shape = jd.newLineShape("直线", new _e(x1, y1, 1, 1));
    }
}
class TextCreator extends BaseCreator {
    createShape() {
        var _a2;
        const x2 = this.attributes.x || 0;
        const y2 = this.attributes.y || 0;
        const text = this.htmlElement.node.textContent;
        if (!text) return;
        (_a2 = this.attributes.styleAttributes) == null ? void 0 : _a2.font;
        this.attributes.textFill;
        const textShape = jd.newTextShape("文本", new _e(x2, y2, 0, 0));
        textShape.text.insertText(text, 0);
        this.shape = textShape;
    }
}
class ImageCreator extends BaseCreator {
    createShape() {
        const x2 = this.attributes.x || 0;
        const y2 = this.attributes.y || 0;
        const width = this.attributes.width || 0;
        const height = this.attributes.height || 0;
        const href = this.attributes.href;
        if (!href || !href.startsWith("data:image")) return;
        const media = {
            buff: Uint8Array.from(atob(href.split(",")[1]), (c2) => c2.charCodeAt(0)),
            base64: href
        };
        const format2 = f(href);
        const ref2 = `${v4()}.${format2}`;
        const mediaResourceMgr = this.context.mediaResourceMgr;
        mediaResourceMgr.add(ref2, media);
        this.shape = jd.newImageShape("图片", new _e(x2, y2, width, height), mediaResourceMgr, ref2);
    }
}
class Polyline extends BaseCreator {
    createShape() {
        var _a2;
        const pointsToPathD = this.attributes.pointsToPathD;
        if (!pointsToPathD) return;
        const x2 = this.attributes.polylineX || 0;
        const y2 = this.attributes.polylineY || 0;
        const width = this.attributes.width || 0;
        const height = this.attributes.height || 0;
        const path = new pi(pointsToPathD);
        path.translate(-x2, -y2);
        this.transform.translate(new E([x2 + (this.attributes.x || 0), y2 + (this.attributes.y || 0), 0]));
        this.shape = jd.newPathShape(((_a2 = this.htmlElement) == null ? void 0 : _a2.tagName) || "polyline", new _e(x2, y2, width, height), path, this.style);
    }
}
class UseCreator extends BaseCreator {
    adjust() {
        var _a2;
        const href = this.localAttributes["xlink:href"];
        if (!href) return;
        const id = href.replace("#", "");
        const svgRoot = (_a2 = this.htmlElement) == null ? void 0 : _a2.root;
        if (!svgRoot) return;
        const el2 = svgRoot.querySelector(`#${id}`);
        if (!el2) return;
        const creator = el2.creator;
        this.localAttributes = {
            ...creator.localAttributes,
            ...this.localAttributes
        };
        this.attributes = {
            ...creator.attributes,
            ...this.attributes,
            useTargetCreator: creator
        };
        this.htmlElement.tagName = creator.htmlElement.tagName;
    }
    createShape() {
        this.attributes.useTargetCreator.createShape.call(this);
    }
}
class Parser {
    constructor(root) {
        __publicField(this, "svgRoot");
        __publicField(this, "context");
        __publicField(this, "styleMap", {});
        this.svgRoot = root;
        this.context = {
            mediaResourceMgr: new Z([v4(), "medias"]),
            styleMap: this.styleMap
        };
    }
    create(node) {
        var _a2;
        const children = Array.from(node.children);
        let creatorConstruction;
        if (node.tagName === "g") {
            creatorConstruction = GroupCreator;
        } else if (node.tagName === "svg") {
            creatorConstruction = SvgCreator;
        } else if (node.tagName === "path") {
            creatorConstruction = PathCreator;
        } else if (node.tagName === "rect") {
            creatorConstruction = RectCreator;
        } else if (node.tagName === "circle" || node.tagName === "ellipse") {
            creatorConstruction = EllipseCreator;
        } else if (node.tagName === "line") {
            creatorConstruction = LineCreator;
        } else if (node.tagName === "text") {
            creatorConstruction = TextCreator;
        } else if (node.tagName === "image") {
            creatorConstruction = ImageCreator;
        } else if (node.tagName === "polyline" || node.tagName === "polygon") {
            creatorConstruction = Polyline;
        } else if (node.tagName === "use") {
            creatorConstruction = UseCreator;
        } else {
            creatorConstruction = NoneCreator;
        }
        node.creator = new creatorConstruction(
            this.context,
            // context
            this.svgRoot.creator,
            // root
            (_a2 = node.parentElement) == null ? void 0 : _a2.creator,
            // parent
            {
                root: this.svgRoot,
                // svgRoot
                node
                // svgNode
            }
        );
        return children;
    }
    // 解析css
    parseCSS() {
        for (const style of this.svgRoot.querySelectorAll("style")) {
            const styleInner = style.innerHTML;
            const regex = /(.*?)\{(.*?)}/g;
            let match;
            while ((match = regex.exec(styleInner)) !== null) {
                const selectorText = match[1].trim();
                const selectorList = [];
                for (let selector of selectorText.split(",")) {
                    selector = selector.trim();
                    if (selector) selectorList.push(selector.trim());
                }
                if (selectorList.length === 0) continue;
                const cssContent = match[2].trim();
                if (!cssContent) continue;
                for (const selector of selectorList) {
                    let content = this.styleMap[selector] || "";
                    if (content && !content.endsWith(";")) content += ";";
                    this.styleMap[selector] = content + cssContent;
                }
            }
        }
    }
    parse() {
        this.parseCSS();
        const stack0 = [this.svgRoot];
        while (stack0.length) {
            const node = stack0.pop();
            const children = this.create(node);
            const creator = node.creator;
            const parentNode = node.parentElement;
            if (parentNode) {
                const parentCreator = parentNode.creator;
                parentCreator.children.push(creator);
            }
            stack0.push(...children.slice(0).reverse());
        }
        const rootCreator = this.svgRoot.creator;
        rootCreator.traverse({
            do: BaseCreator.method("parseAttributes")
        });
        rootCreator.traverse({
            do: BaseCreator.method("adjust"),
            afterChildrenDo: BaseCreator.method("afterChildrenAdjust"),
            afterSiblingDo: BaseCreator.method("afterSiblingAdjust"),
            afterAllDo: BaseCreator.method("afterAllAdjust")
        });
        rootCreator.traverse({
            do: BaseCreator.method("_createShape"),
            afterChildrenDo: BaseCreator.method("afterChildrenCreateShape"),
            afterSiblingDo: BaseCreator.method("afterSiblingCreateShape"),
            afterAllDo: BaseCreator.method("afterAllCreateShape")
        });
        return rootCreator.shape;
    }
}
function parse$1(content) {
    const parser = new DOMParser();
    const svgDocument = parser.parseFromString(content, "image/svg+xml");
    const svgElement = svgDocument.documentElement;
    const svgParser = new Parser(svgElement);
    return {
        shape: svgParser.parse(),
        mediaResourceMgr: svgParser.context.mediaResourceMgr
    };
}
function get_fills(shapes) {
    const fills = [];
    const shape2 = shapes[0];
    const stylefills = (shape2 == null ? void 0 : shape2.getFills()) || [];
    const compare_str = [];
    const has_g_str = [];
    const image_str = [];
    for (let i = 0, len = stylefills.length; i < len; i++) {
        const fill = stylefills[i];
        const f2 = { id: i, fill };
        fills.push(f2);
        const str = [fill.isEnabled, fill.color.red, fill.color.green, fill.color.blue, fill.color.blue, fill.fillType].join("-");
        if (fill.fillType === xt.Pattern) {
            image_str.push(get_image_str(fill));
        } else {
            image_str.push("undefined");
        }
        if (fill.gradient) {
            const g_str = get_gradient_str(fill.gradient);
            has_g_str.push(g_str);
        } else {
            has_g_str.push("undefined");
        }
        compare_str.push(str);
    }
    for (let i = 1; i < shapes.length; i++) {
        const shape22 = shapes[i];
        if (shape22.type === Vt.Cutout) continue;
        const stylefills2 = shape22.getFills();
        const len = stylefills2.length;
        if (len !== fills.length) return "mixed";
        const s_fs = stylefills2;
        for (let j2 = 0; j2 < len; j2++) {
            const fill = s_fs[j2];
            const str = [fill.isEnabled, fill.color.red, fill.color.green, fill.color.blue, fill.color.blue, fill.fillType].join("-");
            if (str !== compare_str[j2]) return "mixed";
            if (fill.fillType === xt.SolidColor) continue;
            if (fill.fillType === xt.Pattern) {
                if (image_str[j2] !== get_image_str(fill)) return "mixed";
                continue;
            }
            if (fill.gradient) {
                if (has_g_str[j2] !== get_gradient_str(fill.gradient)) return "mixed";
            } else {
                if (has_g_str[j2] !== "undefined") return "mixed";
            }
        }
    }
    return fills;
}
function get_gradient_str(g2) {
    const str = [g2.elipseLength, g2.gradientType, g2.gradientOpacity, g2.from.x, g2.from.y, g2.to.x, g2.to.y];
    for (let i = 0; i < g2.stops.length; i++) {
        const stop = g2.stops[i];
        str.push(stop.color.red, stop.color.green, stop.color.blue, stop.color.alpha, stop.position);
    }
    return str.join("-");
}
function get_image_str(fill) {
    const str = [fill.imageRef, fill.scale, fill.rotation, fill.originalImageWidth, fill.originalImageHeight, fill.transform, fill.imageScaleMode];
    if (fill.paintFilter) {
        const filter = fill.paintFilter;
        str.push(filter.contrast, filter.exposure, filter.hue, filter.saturation, filter.shadow, filter.temperature, filter.tint);
    }
    if (fill.transform) {
        const trans = fill.transform;
        str.push(trans.m00, trans.m01, trans.m02, trans.m10, trans.m11, trans.m12);
    }
    return str.join("-");
}
function get_borders(shapes) {
    if (shapes.length === 0) return [];
    const borders = [];
    const shape2 = shapes[0];
    const styleborders = shape2.getBorders() || [];
    const compare_str = [];
    const has_g_str = [];
    for (let i = 0, len = styleborders.length; i < len; i++) {
        const border = styleborders[i];
        const b2 = { id: i, border };
        borders.push(b2);
        const str = [
            border.isEnabled,
            border.color.red,
            border.color.green,
            border.color.blue,
            border.color.alpha,
            border.borderStyle.gap,
            border.borderStyle.length,
            border.thickness,
            border.position,
            border.fillType
        ].join("-");
        if (border.gradient) {
            const g_str = get_gradient_str(border.gradient);
            has_g_str.push(g_str);
        } else {
            has_g_str.push("undefined");
        }
        compare_str.push(str);
    }
    for (let i = 1; i < shapes.length; i++) {
        const shape22 = shapes[i];
        if (shapes[i].type === Vt.Cutout) continue;
        const styleborders2 = shape22.getBorders();
        const len = styleborders2.length;
        if (len !== borders.length) return "mixed";
        const s_bs = styleborders2;
        for (let j2 = 0; j2 < len; j2++) {
            const border = s_bs[j2];
            const str = [
                border.isEnabled,
                border.color.red,
                border.color.green,
                border.color.blue,
                border.color.alpha,
                border.borderStyle.gap,
                border.borderStyle.length,
                border.thickness,
                border.position,
                border.fillType
            ].join("-");
            if (str !== compare_str[j2]) return "mixed";
            if (border.fillType === xt.SolidColor) continue;
            if (border.gradient) {
                if (has_g_str[j2] !== get_gradient_str(border.gradient)) return "mixed";
            } else {
                if (has_g_str[j2] !== "undefined") return "mixed";
            }
        }
    }
    return borders;
}
function get_shadows(shapes) {
    const shadows = [];
    const shape2 = shapes[0];
    const styleshadows = shape2 == null ? void 0 : shape2.getShadows();
    const compare_str = [];
    for (let i = 0, len = styleshadows.length; i < len; i++) {
        const shadow2 = styleshadows[i];
        const s = { id: i, shadow: shadow2 };
        shadows.push(s);
        const str = [
            shadow2.isEnabled,
            shadow2.blurRadius,
            shadow2.spread,
            shadow2.offsetX,
            shadow2.offsetY,
            shadow2.position,
            shadow2.color.red,
            shadow2.color.green,
            shadow2.color.blue,
            shadow2.color.alpha
        ].join("-");
        compare_str.push(str);
    }
    for (let i = 1; i < shapes.length; i++) {
        const shape22 = shapes[i];
        if (shapes[i].type === Vt.Cutout) continue;
        const styleshadows2 = shape22.getShadows();
        const len = styleshadows2.length;
        if (len !== shadows.length) return "mixed";
        const s_bs = styleshadows2;
        for (let j2 = 0; j2 < len; j2++) {
            const shadow2 = s_bs[j2];
            const str = [
                shadow2.isEnabled,
                shadow2.blurRadius,
                shadow2.spread,
                shadow2.offsetX,
                shadow2.offsetY,
                shadow2.position,
                shadow2.color.red,
                shadow2.color.green,
                shadow2.color.blue,
                shadow2.color.alpha
            ].join("-");
            if (str !== compare_str[j2]) return "mixed";
        }
    }
    return shadows;
}
function get_blur(shapes) {
    const has_blur_shapes = shapes.filter((shape22) => shape22.blur);
    if (has_blur_shapes.length === 0) return void 0;
    if (has_blur_shapes.length !== shapes.length) return "mixed";
    const shape2 = has_blur_shapes[0];
    const firstBlur = shape2.blur;
    for (let i = 1; i < shapes.length; i++) {
        const blur2 = shapes[i].blur;
        if (firstBlur.type !== blur2.type) return "mixed";
        if (firstBlur.type === ot.Gaussian) {
            if (firstBlur.saturation !== blur2.saturation) return "mixed";
        } else if (firstBlur.type === ot.Background) {
            if (firstBlur.saturation !== blur2.saturation) return "mixed";
        }
    }
    return firstBlur;
}
function flattenShapes(shapes) {
    return shapes.reduce((result, item) => {
        if (item.type === Vt.Group) {
            const childs = item.childs;
            if (Array.isArray(childs)) {
                result = result.concat(flattenShapes(childs));
            }
        }
        return result.concat(item);
    }, []);
}
const identity = "design.moss";
const paras = "design.moss/paras";
const properties = "design.moss/properties";
class Clipboard {
    constructor(context) {
        __publicField(this, "context");
        __publicField(this, "cache");
        __publicField(this, "m_envs", /* @__PURE__ */ new Set());
        this.context = context;
    }
    get text() {
        const textshape = this.context.selection.textshape;
        if (textshape) {
            const selection = this.context.textSelection;
            const start2 = selection.cursorStart;
            const end2 = selection.cursorEnd;
            if (start2 === end2) {
                return;
            }
            const s = Math.min(start2, end2);
            const len = Math.abs(start2 - end2);
            return textshape.text.getTextWithFormat(s, len);
        }
        const table2 = this.context.selection.tableshape;
        if (!table2) {
            return;
        }
        const ts2 = this.context.tableSelection;
        if (ts2.tableColStart < 0 && ts2.tableRowStart < 0) {
            return;
        }
        let _text = "";
        const cells = ts2.getSelectedCells(true);
        let first_text = void 0;
        cells.forEach((i) => {
            var _a2, _b, _c2;
            if (((_a2 = i.cell) == null ? void 0 : _a2.cellType) !== Wt.Text) {
                return;
            }
            if (!first_text && i.cell.text) {
                first_text = Ap(this.context.data, i.cell.text);
            }
            const t22 = ((_c2 = i.cell.text) == null ? void 0 : _c2.getText(0, ((_b = i.cell.text) == null ? void 0 : _b.length) || 0)) || "";
            if (!t22.length) {
                return;
            }
            _text += t22;
        });
        if (!first_text || !_text) {
            console.log("!first_text || !_text");
            return;
        }
        const t4 = first_text;
        t4.deleteText(0, t4.length);
        t4.insertText(_text, 0);
        return t4;
    }
    modify_cache(type, data) {
        this.cache = { type, data };
    }
    write(event) {
        try {
            const text = this.text;
            if (text) {
                return this.write_text(text, event);
            } else {
                return this.write_shapes(event);
            }
        } catch (error) {
            console.log("write error:", error);
            return false;
        }
    }
    write_text(text, event) {
        const _text = Ep(text);
        const plain_text = text.getText(0, text.length);
        const h2 = encode_html(paras, _text, plain_text);
        let is_async_plan_enable = false;
        if (navigator.clipboard && navigator.clipboard.read) {
            const text_html = new Blob([h2 || ""], { type: "text/html" });
            const text_plain = new Blob([plain_text], { type: "text/plain" });
            const content = [new ClipboardItem({ "text/plain": text_plain, "text/html": text_html })];
            navigator.clipboard.write(content);
            is_async_plan_enable = true;
        }
        if (!event) return is_async_plan_enable;
        if (!event.clipboardData) return false;
        event.clipboardData.setData("text/plain", plain_text);
        event.clipboardData.setData("text/html", h2);
        event.preventDefault();
        this.modify_cache("double", { "text/plain": plain_text, "text/html": h2 });
        return true;
    }
    write_shapes(event) {
        let shapes = compare_layer_3(this.context.selection.selectedShapes, -1);
        if (!shapes.length) {
            return false;
        }
        const origin_transform_map = {};
        const position_map = /* @__PURE__ */ new Map();
        const points_map = /* @__PURE__ */ new Map();
        this.m_envs.clear();
        for (let i = 0, len = shapes.length; i < len; i++) {
            const shape2 = shapes[i];
            origin_transform_map[`${shape2.id}`] = shape2.transform.clone();
            position_map.set(shape2.id, Ei(shape2.transform2FromRoot));
            if (shape2 instanceof Cs) {
                points_map.set(shape2.id, shape2.getPoints());
            }
            if ([Vt.Artboard, Vt.Group].includes(shape2.type)) {
                this.m_envs.add(shape2.id);
            }
        }
        const { shapes: _shapes, ctx } = Tp(shapes.map((s) => $c(s)));
        if (!_shapes) return false;
        for (let i = 0, len = _shapes.length; i < len; i++) {
            const shape2 = _shapes[i];
            shape2.transform = position_map.get(shape2.id);
            const points = points_map.get(shape2.id);
            if (points) {
                shape2.pathsegs[0].points = points.map((i2) => new se(i2.crdtidx, v4(), i2.x, i2.y, i2.mode));
            }
        }
        const media = sort_media(this.context.data, ctx);
        const data = {
            originTransform: origin_transform_map,
            shapes: _shapes,
            media
        };
        const h2 = encode_html(identity, data);
        let is_async_plan_enable = false;
        if (navigator.clipboard && navigator.clipboard.write) {
            const blob = new Blob([h2 || ""], { type: "text/html" });
            const item = { "text/html": blob };
            navigator.clipboard.write([new ClipboardItem(item)]);
            is_async_plan_enable = true;
        }
        if (!(event == null ? void 0 : event.clipboardData)) {
            return is_async_plan_enable;
        }
        event.clipboardData.clearData();
        event.clipboardData.setData("text/html", h2);
        event.preventDefault();
        this.modify_cache("inner-html", h2);
        return true;
    }
    write_properties() {
        var _a2;
        try {
            const selected = this.context.selection.selectedShapes;
            const flatten = flattenShapes(selected).filter((s) => s.type !== Vt.Group);
            const fills = get_fills(flatten);
            const borders = get_borders(flatten);
            const shadows = get_shadows(selected);
            const blur2 = get_blur(selected);
            const radius = getRadiusForCopy(selected);
            const contextSetting = getContextSetting(selected);
            const mark = getMarkType(selected);
            const text = getText(selected);
            const data = {};
            if (fills !== "mixed") data["fills"] = fills.map((i) => ir(i.fill));
            if (borders !== "mixed") data["borders"] = borders.map((i) => er(i.border));
            if (shadows !== "mixed") data["shadows"] = shadows.map((i) => $s(i.shadow));
            if (blur2 instanceof ss) data["blur"] = Zs(blur2);
            if (radius) data["radius"] = radius;
            if (contextSetting) data["contextSetting"] = contextSetting;
            if (mark) data["mark"] = mark;
            if (text) data["text"] = text;
            const code2 = encode_html(properties, data);
            if (!((_a2 = navigator.clipboard) == null ? void 0 : _a2.read)) return false;
            const html = new Blob([code2 || ""], { type: "text/html" });
            const content = [new ClipboardItem({ "text/html": html })];
            navigator.clipboard.write(content);
            return true;
        } catch (e) {
            console.log("write_properties error:", e);
            return false;
        }
    }
    async paste_properties(event) {
        try {
            if (navigator.clipboard.read || !event) {
                const data = await navigator.clipboard.read();
                if (!data) throw new Error("No valid data on clipboard.");
                const d2 = data[0];
                if (d2.types.length !== 1 || d2.types[0] !== "text/html") throw new Error("No valid data on clipboard.");
                const val = await d2.getType("text/html");
                if (!val) throw new Error("invalid value");
                let text_html = await val.text();
                text_html = decode_html(text_html);
                if (!(text_html && typeof text_html === "string")) throw new Error("read failure");
                const is_properties = text_html.slice(0, 70).indexOf(properties) > -1;
                if (!is_properties) throw new Error("invalid value");
                const source = JSON.parse(text_html.split(properties)[1]);
                const selection = this.context.selection;
                const editor = this.context.editor4Page(selection.selectedPage);
                editor.pasteProperties(selection.selectedShapes, source);
                hidden_selection(this.context);
            }
        } catch (error) {
            console.log("paste error:", error);
        }
    }
    writeBlob(blob) {
        try {
            if (navigator.clipboard && navigator.clipboard.write) {
                navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
                return true;
            } else {
                throw new Error("navigator.clipboard.write is not supported");
            }
        } catch (e) {
            console.log("write_png error:", e);
            return false;
        }
    }
    write_png(url) {
        try {
            if (navigator.clipboard && navigator.clipboard.write) {
                const bytes = atob(url);
                const ab = new ArrayBuffer(bytes.length);
                const ua2 = new Uint8Array(ab);
                for (let i = 0; i < bytes.length; i++) {
                    ua2[i] = bytes.charCodeAt(i);
                }
                const blob = new Blob([ab], { type: "image/png" });
                navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
                return true;
            } else {
                throw new Error("navigator.clipboard.write is not supported");
            }
        } catch (e) {
            console.log("write_png error:", e);
            return false;
        }
    }
    cut(event) {
        try {
            const res = this.write(event);
            if (!res) return;
            const textshape = this.context.selection.textshape;
            const text = this.text;
            if (text && textshape) {
                const selection = this.context.textSelection;
                const start2 = selection.cursorStart;
                const end2 = selection.cursorEnd;
                if (start2 === end2) return;
                const editor2 = this.context.editor4TextShape(textshape);
                if (editor2.deleteText(Math.min(start2, end2), Math.abs(start2 - end2))) {
                    selection.setCursor(Math.min(start2, end2), false);
                }
                return;
            }
            const table2 = this.context.selection.tableshape;
            if (text && table2) {
                const editor2 = this.context.editor4Table(table2);
                const ts2 = this.context.tableSelection;
                editor2.resetTextCells(ts2.tableRowStart, ts2.tableRowEnd, ts2.tableColStart, ts2.tableColEnd);
                ts2.resetSelection();
                return;
            }
            const page = this.context.selection.selectedPage;
            if (!page) return;
            const editor = this.context.editor4Page(page);
            const delete_res = editor.delete_batch(this.context.selection.selectedShapes);
            if (delete_res) {
                this.context.selection.resetSelectShapes();
            }
        } catch (error) {
            return;
        }
    }
    async paste(t4, event, xy) {
        try {
            if (navigator.clipboard.read) {
                if (await this.paste_async(t4, xy)) return;
            }
            if (!event) return;
            const items = event.clipboardData && event.clipboardData.items;
            if (items == null ? void 0 : items.length) {
                return this.paste_datatransfer_item_list(items, t4, xy);
            }
            this.paste_cache(t4, xy);
        } catch (error) {
            console.log("paste error:", error);
        }
    }
    async paste_async(t4, xy) {
        var _a2;
        try {
            if (!((_a2 = navigator.clipboard) == null ? void 0 : _a2.read)) {
                throw new Error("Not support.");
            }
            const data = await navigator.clipboard.read();
            if (!data) {
                throw new Error("No valid data on clipboard.");
            }
            this.paste_clipboard_items(data, t4, xy);
            return true;
        } catch (error) {
            console.log("paste_async error:", error);
            return this.paste_cache(t4, xy);
        }
    }
    async paste_datatransfer_item_list(data, t4, xy) {
        if (data.length > 1) {
            let h2 = void 0;
            let p2 = void 0;
            for (let i = 0; i < data.length; i++) {
                const d2 = data[i];
                if (d2.type === "text/html") {
                    h2 = d2;
                } else if (d2.type === "text/plain") {
                    p2 = d2;
                }
            }
            if (h2 && p2) {
                let html = await getHtmlAsync(h2);
                let text = await getTextAsync(p2);
                const firstSuccess = handle_text_html_string(this.context, html);
                if (firstSuccess) {
                    this.modify_cache("inner-html", html);
                    return;
                }
                this.modify_cache("plain-text", text);
                clipboard_text_plain2(this.context, text, xy);
                return;
            }
        }
        if (is_html(data)) {
            const html = get_html(data);
            if (!html) {
                return;
            }
            html.getAsString((val) => {
                const html2 = decode_html(val);
                this.modify_cache("inner-html", val);
                handle_text_html_string(this.context, html2);
            });
            return;
        }
        if (is_plain(data)) {
            const plain = get_plain(data);
            if (!plain) {
                return;
            }
            plain.getAsString((text) => {
                this.modify_cache("plain-text", text);
                clipboard_text_plain2(this.context, text, xy);
            });
            return;
        }
        const image = get_image(data);
        if (image) {
            const file = image.getAsFile();
            const type = image.type;
            this.modify_cache("image", { file, type });
            image_reader(this.context, file, type, t4, xy);
        }
    }
    paste_clipboard_items(data, t4, xy) {
        if (!data) {
            message$2("info", t4("clipboard.invalid_data"));
            return;
        }
        const d2 = data[0];
        const __this = this;
        const type = function() {
            const types = d2.types;
            if (types.length > 1 && types.includes("text/plain") && types.includes("text/html")) {
                __this.couple(__this.context, d2, xy);
                return;
            }
            for (let i = 0; i < types.length; i++) {
                const type2 = types[i];
                if (/image/.test(type2)) {
                    return "image";
                } else if (type2 === "text/plain") {
                    return type2;
                } else if (type2 === "text/html") {
                    return type2;
                }
            }
        }();
        if (type === "image") {
            clipboard_image(this.context, d2, t4, xy);
        } else if (type === "text/plain") {
            clipboard_text_plain(this.context, d2, xy);
        } else if (type === "text/html") {
            clipboard_text_html(this.context, d2, xy);
        }
    }
    async couple(context, data, xy) {
        try {
            const val = await data.getType("text/html");
            if (!val) {
                throw new Error("invalid value");
            }
            let text_html = await val.text();
            text_html = decode_html(text_html);
            let successFirst = false;
            if (text_html && typeof text_html === "string") {
                successFirst = handle_text_html_string(context, text_html, xy);
            }
            if (!successFirst) {
                clipboard_text_plain(this.context, data, xy);
            }
        } catch (error) {
            console.log(error);
            message$2("info", context.workspace.t("clipboard.invalid_data"));
        }
    }
    paste_cache(t4, xy) {
        if (!this.cache) return false;
        const { type, data } = this.cache;
        if (type === "inner-html") {
            handle_text_html_string(this.context, decode_html(data), xy);
        } else if (type === "plain-text") {
            clipboard_text_plain2(this.context, data, xy);
        } else if (type === "image") {
            image_reader(this.context, data.file, data.type, t4, xy);
        } else if (type === "double") {
            const text = data["text/plain"];
            clipboard_text_plain2(this.context, text, xy);
        }
        return true;
    }
    paste_cache_for_text() {
        if (!this.cache) return;
        const { data, type } = this.cache;
        let html;
        if (type === "inner-html") {
            html = decode_html(data);
        } else if (type === "double") {
            html = decode_html(data["text/html"]);
        }
        if (html && html.slice(0, 70).indexOf(paras) > -1 && this.insert_paras(html)) return;
        let plain;
        if (type === "plain-text") {
            plain = data;
        } else if (type === "double") {
            plain = decode_html(data["text/plain"]);
        }
        if (!plain) return;
        this.paste_for_no_format_text(plain);
    }
    paste_text(event) {
        try {
            if (!event) {
                return this.paste_text_async();
            }
            const items = event.clipboardData && event.clipboardData.items;
            if (items == null ? void 0 : items.length) {
                return this.paste_text_sync(items);
            }
            this.paste_cache_for_text();
        } catch (error) {
            console.log("paste_text error:", error);
        }
    }
    async paste_text_async() {
        if (navigator.clipboard && navigator.clipboard.read) {
            const data = await navigator.clipboard.read();
            const _d2 = data[0];
            const types = _d2.types;
            const text_shape = this.context.selection.textshape;
            if (!text_shape) {
                return;
            }
            const editor = this.context.editor4TextShape(text_shape);
            if (types.length === 1) {
                const type = types[0];
                if (type === "text/plain") {
                    const val = await _d2.getType("text/plain");
                    const text = await val.text();
                    if (!(text && typeof text === "string")) {
                        throw new Error("invalid text");
                    }
                    const selection = this.context.textSelection;
                    const start2 = selection.cursorStart;
                    const end2 = selection.cursorEnd;
                    const s = Math.min(start2, end2);
                    if (start2 !== end2) {
                        editor.deleteText(Math.min(start2, end2), Math.abs(start2 - end2));
                    }
                    editor.insertText(text, s);
                    selection.setCursor(s + text.length, false);
                } else if (type === "text/html") {
                    paster_html_or_plain_inner_shape(_d2, this.context, editor);
                }
            } else if (types.length === 2) {
                if (types.includes("text/html") && types.includes("text/plain")) {
                    paster_html_or_plain_inner_shape(_d2, this.context, editor);
                }
            }
        } else {
            this.paste_cache_for_text();
        }
    }
    paste_text_sync(items) {
        const html = get_html(items);
        if (html) {
            this.paste_text_sync_for_html(items, html);
            return;
        }
        const plain = get_plain(items);
        if (plain) {
            this.paste_text_sync_for_plain(plain);
        }
    }
    paste_text_sync_for_plain(plain) {
        plain.getAsString((text) => {
            this.paste_for_no_format_text(text);
        });
    }
    paste_text_sync_for_html(items, html) {
        html.getAsString((val) => {
            const html2 = decode_html(val);
            const is_paras = html2.slice(0, 70).indexOf(paras) > -1;
            if (is_paras) {
                this.insert_paras(html2);
                return;
            }
            const plain = get_plain(items);
            if (!plain) {
                return;
            }
            this.paste_text_sync_for_plain(plain);
        });
    }
    async paste_for_no_format_text(t4) {
        const text = t4 || await this.get_plain_text_for_paster_text();
        const l2 = text.length;
        if (!l2) {
            return;
        }
        const text_shape = this.context.selection.textshape;
        if (!text_shape) {
            return;
        }
        const editor = this.context.editor4TextShape(text_shape);
        const selection = this.context.textSelection;
        const start2 = selection.cursorStart;
        const end2 = selection.cursorEnd;
        const s = Math.min(start2, end2);
        if (start2 !== end2) {
            editor.deleteText(s, Math.abs(start2 - end2));
        }
        editor.insertText(text, s);
        selection.setCursor(s + l2, false);
    }
    async get_plain_text_for_paster_text() {
        var _a2;
        if ((_a2 = navigator.clipboard) == null ? void 0 : _a2.read) {
            const data2 = await navigator.clipboard.read();
            if (!(data2 == null ? void 0 : data2.length)) {
                return "";
            }
            const _d2 = data2[0];
            return (await _d2.getType("text/plain")).text() || "";
        }
        if (!this.cache) return "";
        const { data, type } = this.cache;
        if (type === "plain-text") {
            return data;
        } else if (type === "double") {
            return data["text/plain"];
        } else {
            return "";
        }
    }
    insert_paras(html) {
        const text_shape = this.context.selection.textshape;
        if (!text_shape) {
            return false;
        }
        const editor = this.context.editor4TextShape(text_shape);
        const selection = this.context.textSelection;
        const start2 = selection.cursorStart;
        const end2 = selection.cursorEnd;
        const s = Math.min(start2, end2);
        const source = JSON.parse(html.split(`${paras}`)[1]);
        const text = Ap(this.context.data, source, false);
        const res = editor.insertFormatText(text, s, Math.abs(start2 - end2));
        selection.setCursor(s + text.length, false);
        return res;
    }
    async replace() {
        try {
            const src = this.context.selection.selectedShapes;
            if (!src.length) {
                throw new Error("null data");
            }
            if (!navigator.clipboard.read) {
                return this.replace_sync(src);
            }
            const data = await navigator.clipboard.read();
            if (!(data && data.length)) {
                throw new Error("invalid data");
            }
            const is_inner_shape = data[0].types.length === 1 && data[0].types[0] === "text/html";
            if (!is_inner_shape) {
                throw new Error("external data");
            }
            clipboard_text_html_replace(this.context, data[0], src);
            return true;
        } catch (error) {
            console.log("replace error:", error);
            message$2("info", "替换失败");
            return false;
        }
    }
    replace_sync(src) {
        if (!this.cache) {
            throw new Error("no cache");
        }
        const { type, data } = this.cache;
        if (type !== "inner-html") {
            throw new Error("wrong cache");
        }
        replace_action(this.context, data, src);
    }
    get envs() {
        return this.m_envs;
    }
}
function sort_media(document2, exportCtx) {
    const media = {};
    exportCtx.medias.forEach((v2) => {
        var _a2;
        const res = (_a2 = document2.mediasMgr.getSync(v2)) == null ? void 0 : _a2.base64;
        if (!res) return;
        media[v2] = res;
    });
    return media;
}
async function paster_html_or_plain_inner_shape(_d2, context, editor, only_text) {
    {
        const val = await _d2.getType("text/html");
        let text_html = await val.text();
        text_html = decode_html(text_html);
        if (!(text_html && typeof text_html === "string")) {
            console.log("invalid text/html");
            paster_plain_inner_shape(_d2, context, editor);
            return false;
        }
        if (!(text_html.slice(0, 70).indexOf(`${paras}`) > -1)) {
            console.log("wrong text/html");
            paster_plain_inner_shape(_d2, context, editor);
            return false;
        }
        const selection = context.textSelection;
        const start2 = selection.cursorStart;
        const end2 = selection.cursorEnd;
        const s = Math.min(start2, end2);
        const source = JSON.parse(text_html.split(`${paras}`)[1]);
        const text = Ap(context.data, source, false);
        editor.insertFormatText(text, s, Math.abs(start2 - end2));
        selection.setCursor(s + text.length, false);
    }
    return true;
}
async function paster_plain_inner_shape(_d2, context, editor) {
    const selection = context.textSelection;
    const start2 = selection.cursorStart;
    const end2 = selection.cursorEnd;
    const s = Math.min(start2, end2);
    const val = await _d2.getType("text/plain");
    if (!val) {
        console.log("invalid text/plain`");
        return false;
    }
    const text_plain = await val.text();
    if (start2 !== end2) {
        editor.deleteText(s, Math.abs(start2 - end2));
    }
    editor.insertText(text_plain, s);
    selection.setCursor(s + text_plain.length, false);
}
function encode_html(identity2, data, text) {
    const buffer = btoa(`${identity2}${encodeURIComponent(JSON.stringify(data))}`);
    return `<meta charset="utf-8"><div id="carrier" data-buffer="${buffer}">${text || ""}</div>`;
}
function decode_html(html) {
    var _a2;
    let result = "";
    const d2 = document.createElement("div");
    document.body.appendChild(d2);
    d2.innerHTML = html;
    const carrier = d2.querySelector("#carrier");
    result = (_a2 = carrier == null ? void 0 : carrier.dataset) == null ? void 0 : _a2.buffer;
    result = decodeURIComponent(atob(result || ""));
    document.body.removeChild(d2);
    return result;
}
function after_import(context, media) {
    if (!media || !(media instanceof Object)) {
        console.log("!media || !(media instanceof Object)");
        return;
    }
    const values = Array.from(Object.keys(media) || []);
    if (!(values == null ? void 0 : values.length)) {
        return;
    }
    let index2 = 0;
    exe(index2);
    async function exe(index22) {
        const key = values[index22];
        if (!key) {
            console.log("!key");
            return;
        }
        const buff = media[key].buff;
        if (!(buff instanceof Uint8Array)) {
            console.log("!(buff instanceof Uint8Array)");
            return;
        }
        await upload_image(context, key, buff);
        index22++;
        if (index22 >= values.length) {
            return;
        }
        exe(index22);
    }
}
async function clipboard_text_html(context, data, xy) {
    try {
        const val = await data.getType("text/html");
        if (!val) {
            throw new Error("invalid value");
        }
        let text_html = await val.text();
        text_html = decode_html(text_html);
        if (!(text_html && typeof text_html === "string")) {
            throw new Error("read failure");
        }
        handle_text_html_string(context, text_html, xy);
    } catch (error) {
        console.log(error);
        message$2("info", context.workspace.t("clipboard.invalid_data"));
    }
}
function handle_text_html_string(context, text_html, xy) {
    const is_paras = text_html.slice(0, 70).indexOf(paras) > -1;
    const is_shape = text_html.slice(0, 60).indexOf(identity) > -1;
    if (is_paras) {
        const source = JSON.parse(text_html.split(paras)[1]);
        const t_s = Ap(context.data, source, true);
        if (!t_s) throw new Error("invalid paras");
        const page = context.selection.selectedPage;
        const shape2 = t_s;
        const layout = shape2.getLayout();
        shape2.size.width = layout.contentWidth;
        shape2.size.height = layout.contentHeight;
        const _f2 = shape2.size;
        const _xy = adjust_content_xy(context, { width: _f2.width, height: _f2.height });
        const transform2 = new Ii();
        transform2.translateX = (xy == null ? void 0 : xy.x) || _xy.x;
        transform2.translateY = (xy == null ? void 0 : xy.y) || _xy.y;
        shape2.transform = transform2;
        const editor = context.editor4Page(page);
        const r = editor.insert(page.data, page.childs.length, shape2, true);
        context.nextTick(page, () => {
            if (r) context.selection.selectShape(page.shapes.get(r.id));
        });
    } else if (is_shape) {
        const data = JSON.parse(text_html.split(identity)[1]);
        const source = data.shapes;
        if (!source) throw new Error("invalid source");
        const originTransform = data.originTransform;
        const page = context.selection.selectedPage;
        const page_data = $c(page);
        let insert_result = false;
        const selection_envs = get_envs_from_selection(context);
        const is_exist_selection_envs = !!selection_envs.length;
        const medias = data.media;
        const editor = context.editor4Page(page);
        if (xy) {
            const insert_env = fixToXY(context, source, xy);
            const shapes = Ip(context.data, page_data, source, medias);
            if (!shapes.length) {
                throw new Error("invalid source: !shapes.length");
            }
            insert_result = editor.pasteShapes1($c(insert_env), shapes);
            if (!insert_result) return false;
        } else if (is_exist_selection_envs) {
            const actions = [];
            for (let i = 0; i < selection_envs.length; i++) {
                const __source = JSON.parse(JSON.stringify(source));
                const env = selection_envs[i];
                fixToEnv(context, __source, env, originTransform);
                const shapes = i > 0 ? Ip(context.data, page_data, __source) : Ip(context.data, page_data, __source, medias);
                actions.push({ env: $c(env), shapes });
            }
            const __res = editor.pasteShapes3(actions);
            if (__res) {
                insert_result = { shapes: __res };
            }
        } else {
            const bounding = sourceBounding(source);
            const insert_env = get_env_by_xy(context, { x: bounding.left, y: bounding.top });
            fixToEnv(context, source, insert_env, originTransform);
            const shapes = Ip(context.data, page_data, source, medias);
            if (!shapes.length) {
                throw new Error("invalid source: !shapes.length");
            }
            insert_result = editor.pasteShapes1($c(insert_env), shapes);
            if (!insert_result) return false;
        }
        context.nextTick(page, () => {
            if (insert_result) {
                const selects = [];
                insert_result.shapes.forEach((s) => {
                    const v2 = page.shapes.get(s.id);
                    if (v2) selects.push(v2);
                });
                selects.length && context.selection.rangeSelectShape(selects);
            }
        });
        after_import(context, medias);
    } else {
        console.log("handle_text_html_string:", context.workspace.t("clipboard.invalid_data"));
        return false;
    }
    return true;
}
async function get_html_from_datatransferitem(data) {
    const val = await data.getType("text/html");
    if (!val) throw new Error("invalid value");
    return await val.text();
}
function replace_action(context, text_html, src) {
    text_html = decode_html(text_html);
    if (!(text_html && typeof text_html === "string")) {
        throw new Error("read failure");
    }
    const is_shape = text_html.slice(0, 60).indexOf(identity) > -1;
    if (!is_shape) {
        throw new Error("no shapes");
    }
    const page = context.selection.selectedPage;
    if (!page) return;
    const source = JSON.parse(text_html.split(identity)[1]);
    const shapes = Ip(context.data, page.data, source.shapes, source.media);
    if (!shapes.length) {
        throw new Error("invalid source");
    }
    after_import(context, source.media);
    const editor = context.editor4Page(page);
    const r = editor.replace(context.data, shapes, src.map((s) => $c(s)));
    if (!r || !r.length) return;
    context.nextTick(page, () => {
        if (r) {
            const selects = [];
            r.forEach((s) => {
                const v2 = page.shapes.get(s.id);
                if (v2) selects.push(v2);
            });
            context.selection.rangeSelectShape(selects);
        }
    });
}
async function clipboard_text_html_replace(context, data, src) {
    try {
        const text_html = await get_html_from_datatransferitem(data);
        replace_action(context, text_html, src);
    } catch (error) {
        console.log(error);
        message$2("info", context.workspace.t("system.replace_failed"));
    }
}
async function clipboard_image(context, data, t4, _xy) {
    if (navigator.clipboard && navigator.clipboard.read) {
        const type = data.types[0];
        const val = await data.getType(type);
        image_reader(context, val, type, t4, _xy);
    } else {
        const type = data[0].type;
        const val = data[0].getAsFile();
        image_reader(context, val, type, t4, _xy);
    }
}
function image_reader(context, val, contentType, t4, _xy) {
    if (contentType === "image/svg+xml") {
        SVGReader(context, val, _xy);
        return;
    }
    const item = { type: Vt.Image, contentType, content: "" };
    const frame2 = { width: 100, height: 100 };
    const img = new Image();
    img.onload = function() {
        frame2.width = img.width;
        frame2.height = img.height;
        const origin = { width: img.width, height: img.height };
        const fr2 = new FileReader();
        fr2.onload = function(event) {
            var _a2;
            const base64 = (_a2 = event.target) == null ? void 0 : _a2.result;
            if (base64) {
                fr2.onload = function(event2) {
                    var _a3;
                    const buff = (_a3 = event2.target) == null ? void 0 : _a3.result;
                    if (base64 && buff) {
                        item.content = { name: t4("shape.image"), frame: frame2, buff: new Uint8Array(buff), base64 };
                        const content = item.content;
                        const __xy = adjust_content_xy(context, content.frame);
                        const xy = _xy || __xy;
                        paster_image(context, xy, t4, content, origin);
                    }
                };
                fr2.readAsArrayBuffer(val);
            }
        };
        fr2.readAsDataURL(val);
    };
    img.src = URL.createObjectURL(val);
}
function maySvgText(content) {
    if (content.length < 11) {
        return false;
    }
    return content.search(/<svg|<?xml/img) > -1 && new RegExp("</svg>", "img").test(content.slice(content.length - 10).toLowerCase());
}
async function clipboard_text_plain(context, data, _xy) {
    try {
        const val = await data.getType("text/plain");
        if (!val) throw new Error("invalid value");
        const text = await val.text();
        const is_plain2 = text && typeof text === "string";
        if (!is_plain2) throw new Error("read failure");
        if (maySvgText(text)) {
            return handleSvgText(context, text, _xy);
        }
        const frame2 = { width: 400, height: 100 };
        const __xy = adjust_content_xy(context, frame2);
        const xy = _xy || __xy;
        paster_text(context, xy, text);
    } catch (error) {
        console.log(error);
        message$2("info", context.workspace.t("clipboard.invalid_data"));
    }
}
function clipboard_text_plain2(context, data, _xy) {
    if (maySvgText(data)) {
        return handleSvgText(context, data, _xy);
    }
    const frame2 = { width: 400, height: 100 };
    const __xy = adjust_content_xy(context, frame2);
    const xy = _xy || __xy;
    paster_text(context, xy, data);
}
function handleSvgText(context, text, _xy) {
    const parseResult = parse$1(text);
    if (parseResult.shape) {
        const xy = _xy || adjust_content_xy(context, parseResult.shape.frame, false);
        parseResult.shape.transform.translateX = xy.x;
        parseResult.shape.transform.translateY = xy.y;
        const page = context.selection.selectedPage;
        const editor = context.editor4Page(page);
        editor.insert($c(page), page.childs.length, parseResult.shape);
        if (parseResult.mediaResourceMgr) {
            const container = {};
            parseResult.mediaResourceMgr.forEach((v2, k) => {
                container[k] = v2;
            });
            after_import(context, container);
        }
    }
}
function adjust_content_xy(context, m2, fixFrame = true) {
    const workspace = context.workspace;
    const root = workspace.root;
    const matrix = workspace.matrix;
    if (fixFrame) {
        const ratio_wh = m2.width / m2.height;
        const page_height = root.height / matrix.m00, page_width = root.width / matrix.m00;
        if (m2.height >= m2.width) {
            if (m2.height > page_height * 0.95) {
                m2.height = page_height * 0.95;
                m2.width = m2.height * ratio_wh;
            }
        } else {
            if (m2.width > page_width * 0.95) {
                m2.width = page_width * 0.95;
                m2.height = m2.width / ratio_wh;
            }
        }
    }
    const page = context.selection.selectedPage;
    const __m = new o(page.matrix2Root());
    __m.multiAtLeft(matrix);
    const page_center = __m.inverseCoord(root.center);
    return { x: page_center.x - m2.width / 2, y: page_center.y - m2.height / 2 };
}
function paster_image(context, mousedownOnPageXY, t4, media, origin) {
    var _a2;
    const selection = context.selection;
    const workspace = context.workspace;
    const page = selection.selectedPage;
    const parent = selection.selectedPage;
    let asyncCreator;
    let new_shape;
    const frame2 = new _e(mousedownOnPageXY.x, mousedownOnPageXY.y, 100, 100);
    if (page && parent) {
        const editor = context.editor.controller();
        const name = getName(Vt.Image, parent.childs, t4);
        asyncCreator = editor.asyncCreator(mousedownOnPageXY);
        frame2.height = media.frame.height;
        frame2.width = media.frame.width;
        new_shape = asyncCreator.init_media(page.data, parent.data, name, frame2, media, origin);
    }
    if (asyncCreator && new_shape) {
        asyncCreator.close();
        page && context.nextTick(page, () => {
            new_shape && selection.selectShape(page.shapes.get(new_shape.id));
        });
        const fills = new_shape.style.getFills();
        (_a2 = context.net) == null ? void 0 : _a2.upload(fills[0].imageRef || "", media.buff.buffer.slice(0));
    }
    context.tool.setAction(Action.AutoV);
    workspace.creating(false);
}
function paster_text(context, mousedownOnPageXY, content) {
    const selection = context.selection;
    const workspace = context.workspace;
    const page = selection.selectedPage;
    const parent = selection.selectedPage;
    let asyncCreator;
    let new_shape;
    const frame2 = new _e(mousedownOnPageXY.x, mousedownOnPageXY.y, 400, 40);
    if (page && parent) {
        const editor = context.editor.controller();
        asyncCreator = editor.asyncCreator(mousedownOnPageXY);
        new_shape = asyncCreator.init_text(page.data, parent.data, frame2, content);
    }
    if (asyncCreator && new_shape) {
        asyncCreator = asyncCreator.close();
        page && context.nextTick(page, () => {
            new_shape && selection.selectShape(page.shapes.get(new_shape.id));
        });
    }
    context.tool.setAction(Action.AutoV);
    workspace.creating(false);
}
function is_html(items) {
    return items.length === 1 && items[0].type === "text/html";
}
function is_plain(items) {
    if (items.length === 1 && items[0].type === "text/plain") {
        return true;
    }
    for (let i = 0; i < items.length; i++) {
        if (items[i].type === "text/plain") {
            return true;
        }
    }
    return false;
}
function get_image(items) {
    for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf("image") !== -1) {
            return items[i];
        }
    }
    return;
}
function get_html(items) {
    for (let i = 0; i < items.length; i++) {
        if (items[i].type === "text/html") {
            return items[i];
        }
    }
    return;
}
function get_plain(items) {
    for (let i = 0; i < items.length; i++) {
        if (items[i].type === "text/plain") {
            return items[i];
        }
    }
    return;
}
function get_env_by_xy(context, xy) {
    const layers_on_xy = context.selection.getLayers(xy);
    for (let i = 0; i < layers_on_xy.length; i++) {
        const s = layers_on_xy[i];
        if (s.isVirtualShape) continue;
        if (![Vt.Artboard, Vt.Group].includes(s.type)) {
            continue;
        }
        const t4 = s.transform2FromRoot.decomposeTranslate();
        if (Math.abs(t4.x - xy.x) < 1e-3 && Math.abs(t4.y - xy.y) < 0.01) continue;
        return s;
    }
    return context.selection.selectedPage;
}
function get_envs_from_selection(context) {
    const shapes = context.selection.selectedShapes;
    const envs = [];
    for (let i = 0; i < shapes.length; i++) {
        const s = shapes[i];
        if (s.isVirtualShape) continue;
        if (context.workspace.clipboard.envs.has(s.id)) continue;
        if ([Vt.Artboard, Vt.Group].includes(s.type)) {
            envs.push(s);
        } else {
            let p2 = s.parent;
            while (p2) {
                if ([Vt.Artboard, Vt.Group].includes(p2.type)) break;
                p2 = p2.parent;
            }
            if (p2 && [Vt.Artboard, Vt.Group].includes(p2.type)) envs.push(p2);
        }
    }
    return envs;
}
function getHtmlAsync(data) {
    return new Promise((resolve, reject) => {
        data.getAsString((val) => resolve(decode_html(val)));
    });
}
function getTextAsync(data) {
    return new Promise((resolve, reject) => {
        data.getAsString((val) => resolve(val));
    });
}
function sourceBounding(source) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (let i = 0; i < source.length; i++) {
        const shape2 = source[i];
        const __transform = ki(shape2.transform);
        let width, height;
        if (shape2.type === Vt.Group) {
            const children = shape2.childs;
            const __box = sourceBounding(children);
            width = __box.right - __box.left;
            height = __box.bottom - __box.top;
        } else {
            width = shape2.size.width;
            height = shape2.size.height;
        }
        const { col0, col1, col2, col3 } = __transform.transform([
            E.FromXY(0, 0),
            E.FromXY(width, height),
            E.FromXY(width, 0),
            E.FromXY(0, height)
        ]);
        const box = XYsBounding([col0, col1, col2, col3]);
        if (box.top < top) top = box.top;
        if (box.left < left) left = box.left;
        if (box.right > right) right = box.right;
        if (box.bottom > bottom) bottom = box.bottom;
    }
    return { left, top, right, bottom };
}
function sourceOriginTransformBounding(source, originTransform) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (let i = 0; i < source.length; i++) {
        const shape2 = source[i];
        const _t2 = originTransform[`${shape2.id}`];
        if (!_t2) continue;
        const __transform = ki(_t2);
        let width, height;
        if (shape2.type === Vt.Group) {
            const children = shape2.childs;
            const __box = sourceBounding(children);
            width = __box.right - __box.left;
            height = __box.bottom - __box.top;
        } else {
            width = shape2.size.width;
            height = shape2.size.height;
        }
        const { col0, col1, col2, col3 } = __transform.transform([
            E.FromXY(0, 0),
            E.FromXY(width, height),
            E.FromXY(width, 0),
            E.FromXY(0, height)
        ]);
        const box = XYsBounding([col0, col1, col2, col3]);
        if (box.top < top) top = box.top;
        if (box.left < left) left = box.left;
        if (box.right > right) right = box.right;
        if (box.bottom > bottom) bottom = box.bottom;
    }
    return { left, top, right, bottom };
}
function fixToEnv(context, source, env, originTransform) {
    const { left, top, right, bottom } = sourceBounding(source);
    let clientMatrix = ki(context.workspace.matrix);
    const { col0: clientLT, col1: clientRB } = clientMatrix.transform([
        E.FromXY(left, top),
        E.FromXY(right, bottom)
    ]);
    if (env.type === Vt.Page) {
        const root = context.workspace.root;
        const inner = clientLT.x >= 0 && clientLT.y >= 0 && clientRB.x <= root.width && clientRB.y <= root.height;
        if (inner) {
            for (const shape2 of source) {
                const t4 = ki(shape2.transform);
                t4.addTransform(env.transform2FromRoot.getInverse());
                shape2.transform = Ei(t4);
            }
        } else {
            const { width, height } = context.workspace.root;
            const { col0, col1 } = clientMatrix.clone().getInverse().transform([
                E.FromXY(0, 0),
                E.FromXY(width, height)
            ]);
            const containWidth = col1.x - col0.x;
            const containHeight = col1.y - col0.y;
            const ratioW = (right - left) / (containWidth * 0.92);
            const ratioH = (bottom - top) / (containHeight * 0.92);
            const matrix = context.workspace.matrix;
            if (ratioW > 1 || ratioH > 1) {
                matrix.trans(-width / 2, -height / 2);
                matrix.scale(1 / Math.max(ratioW, ratioH));
                matrix.trans(width / 2, height / 2);
                clientMatrix = ki(context.workspace.matrix);
                context.workspace.notify(WorkSpace.MATRIX_TRANSFORMATION);
            }
            const centerAfterScale = clientMatrix.clone().getInverse().transform(E.FromXY(width / 2, height / 2)).col0;
            const dx = centerAfterScale.x - (right + left) / 2;
            const dy = centerAfterScale.y - (bottom + top) / 2;
            const selectionTransform = new P().setTranslate(E.FromXY(dx, dy));
            for (const shape2 of source) {
                const t4 = ki(shape2.transform).clone().addTransform(selectionTransform).addTransform(env.transform2FromRoot.getInverse());
                shape2.transform = Ei(t4);
            }
        }
    } else {
        const { x: envX, y: envY, width: envWidth, height: envHeight } = env.frame;
        const env2root = env.transform2FromRoot;
        const {
            col0: envLT,
            col1: envRT,
            col2: envRB,
            col3: envLB
        } = env2root.transform([
            E.FromXY(envX, envY),
            E.FromXY(envX + envWidth, envY),
            E.FromXY(envX + envWidth, envY + envHeight),
            E.FromXY(envX, envY + envHeight)
        ]);
        const envBound = XYsBounding([envLT, envRT, envRB, envLB]);
        const envBoundWidth = envBound.right - envBound.left;
        const envBoundHeight = envBound.bottom - envBound.top;
        const sourceOriginBound = sourceOriginTransformBounding(source, originTransform);
        const targetSelectionTransform = new P();
        if (sourceOriginBound.left > envBoundWidth || sourceOriginBound.right < 0) {
            const shapeCX = (sourceOriginBound.left + sourceOriginBound.right) / 2;
            targetSelectionTransform.translate(E.FromXY(envBoundWidth / 2 - shapeCX, 0));
        }
        if (sourceOriginBound.top > envBoundHeight || sourceOriginBound.bottom < 0) {
            const shapeCY = (sourceOriginBound.top + sourceOriginBound.bottom) / 2;
            targetSelectionTransform.translate(E.FromXY(0, envBoundHeight / 2 - shapeCY));
        }
        for (const shape2 of source) {
            const _t2 = originTransform[`${shape2.id}`];
            if (!_t2) continue;
            const __transform = ki(_t2).addTransform(targetSelectionTransform);
            shape2.transform = Ei(__transform);
        }
    }
    return { left, top };
}
function fixToXY(context, source, xy) {
    const env = get_env_by_xy(context, xy);
    const bounding = sourceBounding(source);
    const dx = xy.x - bounding.left;
    const dy = xy.y - bounding.top;
    const selectionTransform = new P().setTranslate(E.FromXY(dx, dy));
    for (const shape2 of source) {
        const t4 = ki(shape2.transform).clone().addTransform(selectionTransform).addTransform(env.transform2FromRoot.getInverse());
        shape2.transform = Ei(t4);
    }
    return env;
}
const _WorkSpace = class _WorkSpace extends U {
    constructor(context) {
        super();
        __publicField(this, "m_clipboard");
        __publicField(this, "context");
        __publicField(this, "m_matrix", new o());
        __publicField(this, "m_scaling", false);
        // 编辑器是否正在缩放图形
        __publicField(this, "m_rotating", false);
        // 编辑器是否正在旋转图形
        __publicField(this, "m_translating", false);
        // 编辑器是否正在移动图形
        __publicField(this, "m_creating", false);
        // 编辑器是否正在创建图形
        __publicField(this, "m_selecting", false);
        // 编辑器是否正在选择图形
        __publicField(this, "m_setting", false);
        // 是否正在设置属性
        __publicField(this, "m_page_dragging", false);
        // 编辑器正在拖动页面
        __publicField(this, "m_content_editing", false);
        // 编辑器正在内容编辑
        __publicField(this, "m_path_edit_mode", false);
        __publicField(this, "m_rootId", "content");
        __publicField(this, "m_pageViewId", "pageview");
        __publicField(this, "m_pre_to_translating", false);
        __publicField(this, "m_mousedown_on_page");
        __publicField(this, "m_controller", "page");
        __publicField(this, "m_font_name_list", { zh: [], en: [] });
        // private m_document_perm: number = 3;
        __publicField(this, "m_should_selection_view_update", true);
        __publicField(this, "m_controller_path", "");
        __publicField(this, "m_root", {
            init: false,
            x: 250,
            y: 46,
            bottom: 0,
            right: 0,
            width: 0,
            height: 0,
            element: void 0,
            center: { x: 0, y: 0 }
        });
        __publicField(this, "m_element");
        __publicField(this, "m_t", () => {
        });
        this.context = context;
        this.m_clipboard = new Clipboard(context);
    }
    get curScale() {
        return this.matrix.m00;
    }
    translate(x2, y2) {
        this.m_matrix.trans(x2, y2);
        this.notify(_WorkSpace.MATRIX_TRANSFORMATION);
    }
    scale(ratio) {
        this.m_matrix.scale(ratio, ratio);
        this.notify(_WorkSpace.MATRIX_TRANSFORMATION);
    }
    doc2view(x2, y2) {
        if (typeof x2 === "number") return this.m_matrix.computeCoord(x2, y2);
        return this.m_matrix.computeCoord(x2);
    }
    view2doc(x2, y2) {
        if (typeof x2 === "number") return this.m_matrix.inverseCoord(x2, y2);
        return this.m_matrix.inverseCoord(x2);
    }
    get element() {
        if (this.m_element) return this.m_element;
        const content = document.querySelectorAll("#content");
        this.m_element = Array.from(content).find((i) => {
            var _a2;
            return ((_a2 = i == null ? void 0 : i.dataset) == null ? void 0 : _a2.area) === this.m_rootId;
        });
        return this.m_element;
    }
    get is_path_edit_mode() {
        return this.m_path_edit_mode;
    }
    setPathEditMode(v2) {
        this.m_path_edit_mode = v2;
        this.notify(_WorkSpace.PATH_EDIT_MODE);
    }
    get matrix() {
        return this.m_matrix;
    }
    get root() {
        const root = this.m_root;
        if (!root.init && this.element) {
            const { x: x2, y: y2, bottom, right } = this.element.getBoundingClientRect();
            root.center = { x: (right - x2) / 2, y: (bottom - y2) / 2 };
            root.x = x2;
            root.y = y2;
            root.bottom = bottom;
            root.right = right;
            root.element = this.element;
            root.init = true;
        }
        return root;
    }
    get center_on_page() {
        const { x: x2, right, y: y2, bottom } = this.root;
        return this.matrix.inverseCoord({ x: (right - x2) / 2, y: (bottom - y2) / 2 });
    }
    get pageView() {
        const pageView = document.querySelector(`[data-area="${this.m_pageViewId}"]`);
        if (pageView) return pageView;
    }
    // get documentPerm() {
    //     return this.m_document_perm;
    // }
    get isPreToTranslating() {
        return this.m_pre_to_translating;
    }
    get startPoint() {
        return this.m_mousedown_on_page;
    }
    get transforming() {
        return this.m_scaling || this.m_rotating || this.m_translating || this.m_creating || this.m_setting;
    }
    get select() {
        return this.m_selecting;
    }
    get isTranslating() {
        return this.m_translating;
    }
    get controller() {
        return this.m_controller;
    }
    get isPageDragging() {
        return this.m_page_dragging;
    }
    get isEditing() {
        return this.m_content_editing || this.m_path_edit_mode;
    }
    get shouldSelectionViewUpdate() {
        return this.m_should_selection_view_update;
    }
    get ctrlPath() {
        return this.m_controller_path;
    }
    setCtrlPath(val) {
        this.m_controller_path = val;
    }
    focusText() {
        this.notify(_WorkSpace.TEXT_FORMAT);
    }
    downArtboardTitle(ev) {
        this.notify(_WorkSpace.ONARBOARD__TITLE_MENU, ev);
    }
    // setDocumentPerm(perm: number) {
    //     this.m_document_perm = perm;
    // }
    get clipboard() {
        return this.m_clipboard;
    }
    t(content) {
        return this.m_t.call(this, content);
    }
    init(t4) {
        this.m_t = t4;
    }
    setFreezeStatus(isFreeze) {
        this.notify(isFreeze ? _WorkSpace.FREEZE : _WorkSpace.THAW);
    }
    setSelectionViewUpdater(isWork) {
        this.m_should_selection_view_update = isWork;
        if (isWork) {
            this.notify(_WorkSpace.SELECTION_VIEW_UPDATE);
        }
    }
    updateRoot(root) {
        this.m_root = root;
        this.notify(_WorkSpace.ROOT_UPDATE);
    }
    contentEdit(v2) {
        this.m_content_editing = v2;
        this.notify(_WorkSpace.PRE_EDIT);
    }
    pageDragging(v2) {
        this.m_page_dragging = v2;
        this.notify(_WorkSpace.MATRIX_TRANSFORMATION);
    }
    setCtrl(v2) {
        this.m_controller = v2;
    }
    preToTranslating(from) {
        if (from) {
            this.m_pre_to_translating = true;
            this.m_mousedown_on_page = from;
            this.notify(_WorkSpace.CHECKSTATUS);
        } else {
            this.m_pre_to_translating = false;
            this.m_mousedown_on_page = void 0;
        }
    }
    setRootId(id) {
        this.m_rootId = id;
    }
    setPageViewId(id) {
        this.m_pageViewId = id;
    }
    scaling(v2) {
        this.m_scaling = v2;
    }
    rotating(v2) {
        this.m_rotating = v2;
    }
    translating(v2) {
        this.m_translating = v2;
        this.notify(_WorkSpace.TRANSLATING);
    }
    creating(v2) {
        this.m_creating = v2;
    }
    selecting(v2) {
        this.m_selecting = v2;
        this.notify(_WorkSpace.SELECTING);
    }
    setting(v2) {
        this.m_setting = v2;
    }
    can_translate(e) {
        const shapes = this.context.selection.selectedShapes;
        const action = this.context.tool.action;
        return e.button === 0 && shapes.length > 0 && (action === Action.AutoV || action === Action.AutoK) && !this.context.tool.isLable && !this.isEditing;
    }
    getContentXY(e) {
        return { x: e.clientX - this.root.x, y: e.clientY - this.root.y };
    }
    getRootXY(e) {
        const m2 = new o(this.m_matrix.inverse);
        return m2.computeCoord2(e.clientX - this.root.x, e.clientY - this.root.y);
    }
    setFontNameListZh(zh2) {
        this.m_font_name_list.zh = zh2;
    }
    setFontNameListEn(en2) {
        this.m_font_name_list.en = en2;
    }
    get fontNameList() {
        return this.m_font_name_list;
    }
};
__publicField(_WorkSpace, "MATRIX_TRANSFORMATION", WorkspaceEvents.transform_change);
__publicField(_WorkSpace, "SELECTING", 2);
__publicField(_WorkSpace, "TEXT_FORMAT", 3);
__publicField(_WorkSpace, "TRANSLATING", 4);
__publicField(_WorkSpace, "CHECKSTATUS", 5);
__publicField(_WorkSpace, "SELECTION_VIEW_UPDATE", 6);
__publicField(_WorkSpace, "PASTE_RIGHT", 7);
__publicField(_WorkSpace, "FREEZE", 8);
__publicField(_WorkSpace, "THAW", 9);
__publicField(_WorkSpace, "CLAC_ATTRI", 10);
__publicField(_WorkSpace, "HIDDEN_UI", 11);
__publicField(_WorkSpace, "INIT_DOC_NAME", 12);
__publicField(_WorkSpace, "ONARBOARD__TITLE_MENU", 13);
__publicField(_WorkSpace, "BOLD", 14);
__publicField(_WorkSpace, "UNDER_LINE", 15);
__publicField(_WorkSpace, "ITALIC", 16);
__publicField(_WorkSpace, "DELETE_LINE", 17);
__publicField(_WorkSpace, "INIT_EDITOR", 18);
__publicField(_WorkSpace, "CHANGE_NAVI", 19);
__publicField(_WorkSpace, "PRE_EDIT", 20);
__publicField(_WorkSpace, "PATH_EDIT_MODE", 21);
__publicField(_WorkSpace, "NEW_ENV_MATRIX_CHANGE", 22);
__publicField(_WorkSpace, "TABLE_TEXT_GRADIENT_UPDATE", 23);
__publicField(_WorkSpace, "ROOT_UPDATE", 24);
let WorkSpace = _WorkSpace;
function getName(type, brothers, t4) {
    const name = t4(`shape.${type}`);
    const renamebrothers = brothers.filter((item) => item.type === type);
    const repeats = renamebrothers.length;
    return repeats ? `${name} ${repeats + 1}` : name;
}
function SVGReader(context, file, xy) {
    const reader = new FileReader();
    reader.onload = function(event) {
        var _a2;
        const svg = (_a2 = event.target) == null ? void 0 : _a2.result;
        if (svg) {
            const parseResult = parse$1(svg);
            if (parseResult.shape) {
                parseResult.shape.name = file.name.replace(".svg", "");
                if (xy) {
                    parseResult.shape.x = xy.x - parseResult.shape.frame.width / 2;
                    parseResult.shape.y = xy.y - parseResult.shape.frame.height / 2;
                } else {
                    const __xy = adjust_content_xy(context, parseResult.shape.frame, false);
                    parseResult.shape.x = __xy.x;
                    parseResult.shape.y = __xy.y;
                }
                const page = context.selection.selectedPage;
                const editor = context.editor4Page(page);
                editor.insert($c(page), page.childs.length, parseResult.shape);
                if (parseResult.mediaResourceMgr) {
                    const container = {};
                    parseResult.mediaResourceMgr.forEach((v2, k) => {
                        container[k] = v2;
                    });
                    after_import(context, container);
                }
            }
        }
    };
    reader.readAsText(file);
}
function skipUserSelectShapes(context, shapes) {
    if (!shapes.length) return new o();
    const matrix = context.workspace.matrix;
    const points = [];
    for (let i = 0; i < shapes.length; i++) {
        const item = shapes[i];
        const { x: x2, y: y2, width: width2, height: height2 } = item.frame;
        const m2 = item.transform2FromRoot;
        const clientTransform = ki(matrix);
        m2.addTransform(clientTransform);
        const { col0: lt2, col1: rt2, col2: rb, col3: lb } = m2.transform([
            E.FromXY(x2, y2),
            E.FromXY(x2 + width2, y2),
            E.FromXY(x2 + width2, y2 + height2),
            E.FromXY(x2, y2 + height2)
        ]);
        points.push(lt2, rt2, rb, lb);
    }
    const box = XYsBounding(points);
    const width = box.right - box.left;
    const height = box.bottom - box.top;
    const root = context.workspace.root;
    const p_center = { x: box.left + width / 2, y: box.top + height / 2 };
    const del = { x: root.center.x - p_center.x, y: root.center.y - p_center.y };
    if (del.x || del.y) {
        matrix.trans(del.x, del.y);
    }
    context.workspace.notify(WorkSpace.MATRIX_TRANSFORMATION);
}
async function upload_image(context, ref2, buff) {
    if (!context.net) return false;
    try {
        const __buff = new Uint8Array(buff);
        let count = 0;
        while (count < 3 && !await context.net.upload(ref2, __buff.buffer)) {
            count++;
        }
        if (count >= 3) {
            throw new Error("fail");
        }
        return true;
    } catch (error) {
        message$2("danger", "上传失败");
        console.log("upload_image:", error);
        return false;
    }
}
function hidden_selection(context) {
    if (context.workspace.is_path_edit_mode) {
        return;
    }
    context.selection.notify(Selection.SELECTION_HIDDEN);
}
function _debounceLog(mes, flag) {
    console.log(flag ? `${flag} ${mes}` : mes);
}
lodashExports.debounce(_debounceLog, 300);
function XYsBounding(points) {
    const xs2 = [];
    const ys2 = [];
    for (let i = 0; i < points.length; i++) {
        xs2.push(points[i].x);
        ys2.push(points[i].y);
    }
    const top = Math.min(...ys2);
    const bottom = Math.max(...ys2);
    const left = Math.min(...xs2);
    const right = Math.max(...xs2);
    return { top, bottom, left, right };
}
function is_mac() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
}
function _clear_scroll_target(context) {
    context.component.set_scroll_target(void 0);
}
lodashExports.debounce(_clear_scroll_target, 300);
function is_symbol_or_union(shape2) {
    return shape2.type === Vt.Symbol || shape2.type === Vt.SymbolUnion;
}
const _TableSelection = class _TableSelection extends U {
    constructor(cxt, onCellChange) {
        super();
        __publicField(this, "m_tableRowStart", -1);
        __publicField(this, "m_tableRowEnd", -1);
        __publicField(this, "m_tableColStart", -1);
        __publicField(this, "m_tableColEnd", -1);
        __publicField(this, "m_editing_cell");
        __publicField(this, "m_context");
        __publicField(this, "m_menu_visible", false);
        __publicField(this, "m_onCellChange");
        this.m_context = cxt;
        this.m_onCellChange = onCellChange;
    }
    // get shape() {
    //     return this.m_shape;
    // }
    get tableRowStart() {
        return this.m_tableRowStart;
    }
    get tableRowEnd() {
        return this.m_tableRowEnd;
    }
    get tableColStart() {
        return this.m_tableColStart;
    }
    get tableColEnd() {
        return this.m_tableColEnd;
    }
    get editingCell() {
        return this.m_editing_cell;
    }
    resetSelection() {
        this.m_editing_cell = void 0;
        this.m_tableRowStart = -1;
        this.m_tableRowEnd = -1;
        this.m_tableColStart = -1;
        this.m_tableColEnd = -1;
        this.notify(_TableSelection.CHANGE_TABLE_CELL);
    }
    setEditingCell(cell) {
        if (this.m_editing_cell === cell) return;
        if (cell) this.resetSelection();
        this.m_editing_cell = cell;
        this.m_onCellChange();
        this.notify(_TableSelection.CHANGE_EDITING_CELL);
    }
    getSelectedCells(visible = true) {
        const shape2 = this.m_context.selection.selectedShapes[0];
        if (shape2 && shape2.type === Vt.Table && this.m_tableRowStart > -1) {
            const _shape = shape2;
            if (visible) return _shape.getVisibleCells(
                this.m_tableRowStart,
                this.m_tableRowEnd,
                this.m_tableColStart,
                this.m_tableColEnd
            );
            return _shape.getCells(
                this.m_tableRowStart,
                this.m_tableRowEnd,
                this.m_tableColStart,
                this.m_tableColEnd
            );
        } else return [];
    }
    /**
     * @param gen_menu_posi 默认产生小菜单位置
     */
    selectTableCellRange(rowStart, rowEnd, colStart, colEnd, gen_menu_posi = true) {
        if (this.m_tableRowStart !== rowStart || this.m_tableRowEnd !== rowEnd || this.m_tableColStart !== colStart || this.m_tableColEnd !== colEnd) {
            this.m_tableRowStart = rowStart;
            this.m_tableRowEnd = rowEnd;
            this.m_tableColStart = colStart;
            this.m_tableColEnd = colEnd;
            this.notify(_TableSelection.CHANGE_TABLE_CELL, gen_menu_posi);
            this.m_context.escstack.save("table-selection", () => {
                const achieve = this.m_tableRowStart > -1 || this.m_tableColStart > -1;
                this.resetSelection();
                return achieve;
            });
        }
    }
    selectTableCell(rowIdx, colIdx, gen_menu_posi = true) {
        if (this.m_tableRowStart !== this.m_tableRowEnd || this.m_tableRowStart !== rowIdx || this.m_tableColStart !== this.m_tableColEnd || this.m_tableColStart !== colIdx) {
            this.m_tableRowStart = this.m_tableRowEnd = rowIdx;
            this.m_tableColStart = this.m_tableColEnd = colIdx;
            this.notify(_TableSelection.CHANGE_TABLE_CELL, gen_menu_posi);
            this.m_context.escstack.save("table-selection", () => {
                const achieve = this.m_tableRowStart > -1 || this.m_tableColStart > -1;
                this.resetSelection();
                return achieve;
            });
        }
    }
    setTableMenuVisible(visible) {
        this.m_menu_visible = visible;
    }
    get tableMenuVRowVisible() {
        return this.m_menu_visible;
    }
};
__publicField(_TableSelection, "CHANGE_TABLE_CELL", 1);
__publicField(_TableSelection, "CHANGE_EDITING_CELL", 2);
let TableSelection = _TableSelection;
var pathkit = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
    var PathKitInit2 = (() => {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
        return function(PathKitInit22) {
            PathKitInit22 = PathKitInit22 || {};
            var f2;
            f2 || (f2 = typeof PathKitInit22 !== "undefined" ? PathKitInit22 : {});
            var aa2 = Object.assign, ba2, ca2;
            f2.ready = new Promise(function(b2, a2) {
                ba2 = b2;
                ca2 = a2;
            });
            (function(b2) {
                var a2 = {};
                b2.loadCmdsTypedArray = function(h2) {
                    for (var l2 = 0, m2 = 0; m2 < h2.length; m2++) l2 += h2[m2].length;
                    if (a2[l2]) var n2 = a2[l2];
                    else n2 = new Float32Array(l2), a2[l2] = n2;
                    var p2 = 0;
                    for (m2 = 0; m2 < h2.length; m2++) for (var r = 0; r < h2[m2].length; r++) {
                        var u = h2[m2][r];
                        "string" === typeof u && (u = b2.SkBits2FloatUnsigned(parseInt(u)));
                        n2[p2] = u;
                        p2++;
                    }
                    h2 = b2._malloc(n2.length * n2.BYTES_PER_ELEMENT);
                    b2.HEAPF32.set(n2, h2 / n2.BYTES_PER_ELEMENT);
                    return [h2, l2];
                };
                b2.FromCmds = function(h2) {
                    h2 = b2.loadCmdsTypedArray(h2);
                    var l2 = b2._FromCmds(h2[0], h2[1]);
                    b2._free(h2[0]);
                    return l2;
                };
                var c2, d2, e, g2, k;
                b2.cubicYFromX = function(h2, l2, m2, n2, p2) {
                    c2 && d2 === h2 && e === l2 && g2 === m2 && k === n2 || (c2 && c2.delete(), c2 = new b2._SkCubicMap([h2, l2], [m2, n2]), d2 = h2, e = l2, g2 = m2, k = n2);
                    return c2.computeYFromX(p2);
                };
                b2.cubicPtFromT = function(h2, l2, m2, n2, p2) {
                    c2 && d2 === h2 && e === l2 && g2 === m2 && k === n2 || (c2 && c2.delete(), c2 = new b2._SkCubicMap([h2, l2], [m2, n2]), d2 = h2, e = l2, g2 = m2, k = n2);
                    return c2.computePtFromT(p2);
                };
            })(f2);
            (function(b2) {
                b2.onRuntimeInitialized = function() {
                    b2.SkPath.prototype.addPath = function() {
                        var a2 = arguments[0];
                        if (1 === arguments.length) this._addPath(a2, 1, 0, 0, 0, 1, 0, 0, 0, 1);
                        else if (2 === arguments.length) {
                            var c2 = arguments[1];
                            this._addPath(a2, c2.a, c2.c, c2.e, c2.b, c2.d, c2.f, 0, 0, 1);
                        } else if (7 === arguments.length) c2 = arguments, this._addPath(a2, c2[1], c2[3], c2[5], c2[2], c2[4], c2[6], 0, 0, 1);
                        else if (10 === arguments.length) c2 = arguments, this._addPath(a2, c2[1], c2[2], c2[3], c2[4], c2[5], c2[6], c2[7], c2[8], c2[9]);
                        else return console.Ma("addPath expected to take 1, 2, 7, or 10 args. Got " + arguments.length), null;
                        return this;
                    };
                    b2.SkPath.prototype.arc = function(a2, c2, d2, e, g2, k) {
                        this._arc(a2, c2, d2, e, g2, !!k);
                        return this;
                    };
                    b2.SkPath.prototype.arcTo = function(a2, c2, d2, e, g2) {
                        this._arcTo(a2, c2, d2, e, g2);
                        return this;
                    };
                    b2.SkPath.prototype.bezierCurveTo = function(a2, c2, d2, e, g2, k) {
                        this._cubicTo(a2, c2, d2, e, g2, k);
                        return this;
                    };
                    b2.SkPath.prototype.close = function() {
                        this._close();
                        return this;
                    };
                    b2.SkPath.prototype.closePath = function() {
                        this._close();
                        return this;
                    };
                    b2.SkPath.prototype.conicTo = function(a2, c2, d2, e, g2) {
                        this._conicTo(a2, c2, d2, e, g2);
                        return this;
                    };
                    b2.SkPath.prototype.cubicTo = function(a2, c2, d2, e, g2, k) {
                        this._cubicTo(a2, c2, d2, e, g2, k);
                        return this;
                    };
                    b2.SkPath.prototype.dash = function(a2, c2, d2) {
                        return this._dash(a2, c2, d2) ? this : null;
                    };
                    b2.SkPath.prototype.ellipse = function(a2, c2, d2, e, g2, k, h2, l2) {
                        this._ellipse(a2, c2, d2, e, g2, k, h2, !!l2);
                        return this;
                    };
                    b2.SkPath.prototype.lineTo = function(a2, c2) {
                        this._lineTo(a2, c2);
                        return this;
                    };
                    b2.SkPath.prototype.moveTo = function(a2, c2) {
                        this._moveTo(a2, c2);
                        return this;
                    };
                    b2.SkPath.prototype.op = function(a2, c2) {
                        return this._op(a2, c2) ? this : null;
                    };
                    b2.SkPath.prototype.quadraticCurveTo = function(a2, c2, d2, e) {
                        this._quadTo(a2, c2, d2, e);
                        return this;
                    };
                    b2.SkPath.prototype.quadTo = function(a2, c2, d2, e) {
                        this._quadTo(a2, c2, d2, e);
                        return this;
                    };
                    b2.SkPath.prototype.rect = function(a2, c2, d2, e) {
                        this._rect(a2, c2, d2, e);
                        return this;
                    };
                    b2.SkPath.prototype.simplify = function() {
                        return this._simplify() ? this : null;
                    };
                    b2.SkPath.prototype.stroke = function(a2) {
                        a2 = a2 || {};
                        a2.width = a2.width || 1;
                        a2.miter_limit = a2.miter_limit || 4;
                        a2.cap = a2.cap || b2.StrokeCap.BUTT;
                        a2.join = a2.join || b2.StrokeJoin.MITER;
                        return this._stroke(a2) ? this : null;
                    };
                    b2.SkPath.prototype.transform = function() {
                        if (1 === arguments.length) this._transform(arguments[0]);
                        else if (9 === arguments.length) {
                            var a2 = arguments;
                            this._transform(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8]);
                        } else return console.Ma("transform expected to take 1 or 9 arguments. Got " + arguments.length), null;
                        return this;
                    };
                    b2.SkPath.prototype.trim = function(a2, c2, d2) {
                        return this._trim(a2, c2, !!d2) ? this : null;
                    };
                };
            })(f2);
            var da2 = aa2({}, f2), ea2 = "object" === typeof window, q2 = "function" === typeof importScripts, v2 = "", fa2, ha2, ia2, fs2, ja2, ka2;
            if ("object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node) v2 = q2 ? require$$0.dirname(v2) + "/" : __dirname + "/", ka2 = () => {
                ja2 || (fs2 = require$$0, ja2 = require$$0);
            }, fa2 = function(b2, a2) {
                ka2();
                b2 = ja2.normalize(b2);
                return fs2.readFileSync(b2, a2 ? null : "utf8");
            }, ia2 = (b2) => {
                b2 = fa2(b2, true);
                b2.buffer || (b2 = new Uint8Array(b2));
                return b2;
            }, ha2 = (b2, a2, c2) => {
                ka2();
                b2 = ja2.normalize(b2);
                fs2.readFile(b2, function(d2, e) {
                    d2 ? c2(d2) : a2(e.buffer);
                });
            }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(b2) {
                throw b2;
            }), process.on("unhandledRejection", function(b2) {
                throw b2;
            }), f2.inspect = function() {
                return "[Emscripten Module object]";
            };
            else if (ea2 || q2) q2 ? v2 = self.location.href : "undefined" !== typeof document && document.currentScript && (v2 = document.currentScript.src), _scriptDir && (v2 = _scriptDir), 0 !== v2.indexOf("blob:") ? v2 = v2.substr(0, v2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : v2 = "", fa2 = (b2) => {
                var a2 = new XMLHttpRequest();
                a2.open("GET", b2, false);
                a2.send(null);
                return a2.responseText;
            }, q2 && (ia2 = (b2) => {
                var a2 = new XMLHttpRequest();
                a2.open("GET", b2, false);
                a2.responseType = "arraybuffer";
                a2.send(null);
                return new Uint8Array(a2.response);
            }), ha2 = (b2, a2, c2) => {
                var d2 = new XMLHttpRequest();
                d2.open("GET", b2, true);
                d2.responseType = "arraybuffer";
                d2.onload = () => {
                    200 == d2.status || 0 == d2.status && d2.response ? a2(d2.response) : c2();
                };
                d2.onerror = c2;
                d2.send(null);
            };
            var la2 = f2.print || console.log.bind(console), w2 = f2.printErr || console.warn.bind(console);
            aa2(f2, da2);
            da2 = null;
            var z2;
            f2.wasmBinary && (z2 = f2.wasmBinary);
            f2.noExitRuntime || true;
            "object" !== typeof WebAssembly && A2("no native wasm support detected");
            var ma2, na2 = false, oa2 = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function pa2(b2, a2, c2) {
                var d2 = a2 + c2;
                for (c2 = a2; b2[c2] && !(c2 >= d2); ) ++c2;
                if (16 < c2 - a2 && b2.subarray && oa2) return oa2.decode(b2.subarray(a2, c2));
                for (d2 = ""; a2 < c2; ) {
                    var e = b2[a2++];
                    if (e & 128) {
                        var g2 = b2[a2++] & 63;
                        if (192 == (e & 224)) d2 += String.fromCharCode((e & 31) << 6 | g2);
                        else {
                            var k = b2[a2++] & 63;
                            e = 224 == (e & 240) ? (e & 15) << 12 | g2 << 6 | k : (e & 7) << 18 | g2 << 12 | k << 6 | b2[a2++] & 63;
                            65536 > e ? d2 += String.fromCharCode(e) : (e -= 65536, d2 += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
                        }
                    } else d2 += String.fromCharCode(e);
                }
                return d2;
            }
            function qa2(b2, a2, c2) {
                var d2 = B2;
                if (0 < c2) {
                    c2 = a2 + c2 - 1;
                    for (var e = 0; e < b2.length; ++e) {
                        var g2 = b2.charCodeAt(e);
                        if (55296 <= g2 && 57343 >= g2) {
                            var k = b2.charCodeAt(++e);
                            g2 = 65536 + ((g2 & 1023) << 10) | k & 1023;
                        }
                        if (127 >= g2) {
                            if (a2 >= c2) break;
                            d2[a2++] = g2;
                        } else {
                            if (2047 >= g2) {
                                if (a2 + 1 >= c2) break;
                                d2[a2++] = 192 | g2 >> 6;
                            } else {
                                if (65535 >= g2) {
                                    if (a2 + 2 >= c2) break;
                                    d2[a2++] = 224 | g2 >> 12;
                                } else {
                                    if (a2 + 3 >= c2) break;
                                    d2[a2++] = 240 | g2 >> 18;
                                    d2[a2++] = 128 | g2 >> 12 & 63;
                                }
                                d2[a2++] = 128 | g2 >> 6 & 63;
                            }
                            d2[a2++] = 128 | g2 & 63;
                        }
                    }
                    d2[a2] = 0;
                }
            }
            var ra2 = "undefined" !== typeof TextDecoder ? new TextDecoder("utf-16le") : void 0;
            function sa2(b2, a2) {
                var c2 = b2 >> 1;
                for (var d2 = c2 + a2 / 2; !(c2 >= d2) && C3[c2]; ) ++c2;
                c2 <<= 1;
                if (32 < c2 - b2 && ra2) return ra2.decode(B2.subarray(b2, c2));
                c2 = "";
                for (d2 = 0; !(d2 >= a2 / 2); ++d2) {
                    var e = D2[b2 + 2 * d2 >> 1];
                    if (0 == e) break;
                    c2 += String.fromCharCode(e);
                }
                return c2;
            }
            function ta2(b2, a2, c2) {
                void 0 === c2 && (c2 = 2147483647);
                if (2 > c2) return 0;
                c2 -= 2;
                var d2 = a2;
                c2 = c2 < 2 * b2.length ? c2 / 2 : b2.length;
                for (var e = 0; e < c2; ++e) D2[a2 >> 1] = b2.charCodeAt(e), a2 += 2;
                D2[a2 >> 1] = 0;
                return a2 - d2;
            }
            function ua2(b2) {
                return 2 * b2.length;
            }
            function va2(b2, a2) {
                for (var c2 = 0, d2 = ""; !(c2 >= a2 / 4); ) {
                    var e = F2[b2 + 4 * c2 >> 2];
                    if (0 == e) break;
                    ++c2;
                    65536 <= e ? (e -= 65536, d2 += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d2 += String.fromCharCode(e);
                }
                return d2;
            }
            function wa2(b2, a2, c2) {
                void 0 === c2 && (c2 = 2147483647);
                if (4 > c2) return 0;
                var d2 = a2;
                c2 = d2 + c2 - 4;
                for (var e = 0; e < b2.length; ++e) {
                    var g2 = b2.charCodeAt(e);
                    if (55296 <= g2 && 57343 >= g2) {
                        var k = b2.charCodeAt(++e);
                        g2 = 65536 + ((g2 & 1023) << 10) | k & 1023;
                    }
                    F2[a2 >> 2] = g2;
                    a2 += 4;
                    if (a2 + 4 > c2) break;
                }
                F2[a2 >> 2] = 0;
                return a2 - d2;
            }
            function xa2(b2) {
                for (var a2 = 0, c2 = 0; c2 < b2.length; ++c2) {
                    var d2 = b2.charCodeAt(c2);
                    55296 <= d2 && 57343 >= d2 && ++c2;
                    a2 += 4;
                }
                return a2;
            }
            var ya2, za2, B2, D2, C3, F2, G2, Aa2, Ba2;
            function Ca2() {
                var b2 = ma2.buffer;
                ya2 = b2;
                f2.HEAP8 = za2 = new Int8Array(b2);
                f2.HEAP16 = D2 = new Int16Array(b2);
                f2.HEAP32 = F2 = new Int32Array(b2);
                f2.HEAPU8 = B2 = new Uint8Array(b2);
                f2.HEAPU16 = C3 = new Uint16Array(b2);
                f2.HEAPU32 = G2 = new Uint32Array(b2);
                f2.HEAPF32 = Aa2 = new Float32Array(b2);
                f2.HEAPF64 = Ba2 = new Float64Array(b2);
            }
            var H2, Da2 = [], Ea2 = [], Fa2 = [];
            function Ga2() {
                var b2 = f2.preRun.shift();
                Da2.unshift(b2);
            }
            var I2 = 0, J2 = null;
            f2.preloadedImages = {};
            f2.preloadedAudios = {};
            function A2(b2) {
                if (f2.onAbort) f2.onAbort(b2);
                b2 = "Aborted(" + b2 + ")";
                w2(b2);
                na2 = true;
                b2 = new WebAssembly.RuntimeError(b2 + ". Build with -s ASSERTIONS=1 for more info.");
                ca2(b2);
                throw b2;
            }
            function Ia2() {
                return K2.startsWith("data:application/octet-stream;base64,");
            }
            var K2;
            K2 = "pathkit.wasm";
            if (!Ia2()) {
                var Ja2 = K2;
                K2 = f2.locateFile ? f2.locateFile(Ja2, v2) : v2 + Ja2;
            }
            function Ka2() {
                var b2 = K2;
                try {
                    if (b2 == K2 && z2) return new Uint8Array(z2);
                    if (ia2) return ia2(b2);
                    throw "both async and sync fetching of the wasm failed";
                } catch (a2) {
                    A2(a2);
                }
            }
            function La2() {
                if (!z2 && (ea2 || q2)) {
                    if ("function" === typeof fetch && !K2.startsWith("file://")) return fetch(K2, { credentials: "same-origin" }).then(function(b2) {
                        if (!b2.ok) throw "failed to load wasm binary file at '" + K2 + "'";
                        return b2.arrayBuffer();
                    }).catch(function() {
                        return Ka2();
                    });
                    if (ha2) return new Promise(function(b2, a2) {
                        ha2(K2, function(c2) {
                            b2(new Uint8Array(c2));
                        }, a2);
                    });
                }
                return Promise.resolve().then(function() {
                    return Ka2();
                });
            }
            function Ma2(b2) {
                for (; 0 < b2.length; ) {
                    var a2 = b2.shift();
                    if ("function" == typeof a2) a2(f2);
                    else {
                        var c2 = a2.Wa;
                        "number" === typeof c2 ? void 0 === a2.xa ? H2.get(c2)() : H2.get(c2)(a2.xa) : c2(void 0 === a2.xa ? null : a2.xa);
                    }
                }
            }
            var Na2 = {};
            function Oa2(b2) {
                for (; b2.length; ) {
                    var a2 = b2.pop();
                    b2.pop()(a2);
                }
            }
            function L2(b2) {
                return this.fromWireType(G2[b2 >> 2]);
            }
            var M2 = {}, N2 = {}, Pa2 = {};
            function Qa2(b2) {
                if (void 0 === b2) return "_unknown";
                b2 = b2.replace(/[^a-zA-Z0-9_]/g, "$");
                var a2 = b2.charCodeAt(0);
                return 48 <= a2 && 57 >= a2 ? "_" + b2 : b2;
            }
            function Ra2(b2, a2) {
                b2 = Qa2(b2);
                return function() {
                    return a2.apply(this, arguments);
                };
            }
            function Sa2(b2) {
                var a2 = Error, c2 = Ra2(b2, function(d2) {
                    this.name = b2;
                    this.message = d2;
                    d2 = Error(d2).stack;
                    void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
                });
                c2.prototype = Object.create(a2.prototype);
                c2.prototype.constructor = c2;
                c2.prototype.toString = function() {
                    return void 0 === this.message ? this.name : this.name + ": " + this.message;
                };
                return c2;
            }
            var Ta2 = void 0;
            function Ua2(b2) {
                throw new Ta2(b2);
            }
            function O2(b2, a2, c2) {
                function d2(h2) {
                    h2 = c2(h2);
                    h2.length !== b2.length && Ua2("Mismatched type converter count");
                    for (var l2 = 0; l2 < b2.length; ++l2) Q2(b2[l2], h2[l2]);
                }
                b2.forEach(function(h2) {
                    Pa2[h2] = a2;
                });
                var e = Array(a2.length), g2 = [], k = 0;
                a2.forEach(function(h2, l2) {
                    N2.hasOwnProperty(h2) ? e[l2] = N2[h2] : (g2.push(h2), M2.hasOwnProperty(h2) || (M2[h2] = []), M2[h2].push(function() {
                        e[l2] = N2[h2];
                        ++k;
                        k === g2.length && d2(e);
                    }));
                });
                0 === g2.length && d2(e);
            }
            var Va = {};
            function Wa2(b2) {
                switch (b2) {
                    case 1:
                        return 0;
                    case 2:
                        return 1;
                    case 4:
                        return 2;
                    case 8:
                        return 3;
                    default:
                        throw new TypeError("Unknown type size: " + b2);
                }
            }
            var Xa2 = void 0;
            function R2(b2) {
                for (var a2 = ""; B2[b2]; ) a2 += Xa2[B2[b2++]];
                return a2;
            }
            var S2 = void 0;
            function T2(b2) {
                throw new S2(b2);
            }
            function Q2(b2, a2, c2 = {}) {
                if (!("argPackAdvance" in a2)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                var d2 = a2.name;
                b2 || T2('type "' + d2 + '" must have a positive integer typeid pointer');
                if (N2.hasOwnProperty(b2)) {
                    if (c2.Qa) return;
                    T2("Cannot register type '" + d2 + "' twice");
                }
                N2[b2] = a2;
                delete Pa2[b2];
                M2.hasOwnProperty(b2) && (a2 = M2[b2], delete M2[b2], a2.forEach(function(e) {
                    e();
                }));
            }
            function Ya2(b2) {
                T2(b2.ea.ha.fa.name + " instance already deleted");
            }
            var Za2 = false;
            function $a2() {
            }
            function ab(b2) {
                --b2.count.value;
                0 === b2.count.value && (b2.ka ? b2.ma.la(b2.ka) : b2.ha.fa.la(b2.ga));
            }
            function bb(b2) {
                if ("undefined" === typeof FinalizationGroup) return bb = (a2) => a2, b2;
                Za2 = new FinalizationGroup(function(a2) {
                    for (var c2 = a2.next(); !c2.done; c2 = a2.next()) c2 = c2.value, c2.ga ? ab(c2) : console.warn("object already deleted: " + c2.ga);
                });
                bb = (a2) => {
                    Za2.register(a2, a2.ea, a2.ea);
                    return a2;
                };
                $a2 = (a2) => {
                    Za2.unregister(a2.ea);
                };
                return bb(b2);
            }
            var cb = void 0, db = [];
            function eb() {
                for (; db.length; ) {
                    var b2 = db.pop();
                    b2.ea.pa = false;
                    b2["delete"]();
                }
            }
            function U2() {
            }
            var fb = {};
            function gb(b2, a2, c2) {
                if (void 0 === b2[a2].ia) {
                    var d2 = b2[a2];
                    b2[a2] = function() {
                        b2[a2].ia.hasOwnProperty(arguments.length) || T2("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + b2[a2].ia + ")!");
                        return b2[a2].ia[arguments.length].apply(this, arguments);
                    };
                    b2[a2].ia = [];
                    b2[a2].ia[d2.ua] = d2;
                }
            }
            function hb(b2, a2, c2) {
                f2.hasOwnProperty(b2) ? ((void 0 === c2 || void 0 !== f2[b2].ia && void 0 !== f2[b2].ia[c2]) && T2("Cannot register public name '" + b2 + "' twice"), gb(f2, b2, b2), f2.hasOwnProperty(c2) && T2("Cannot register multiple overloads of a function with the same number of arguments (" + c2 + ")!"), f2[b2].ia[c2] = a2) : (f2[b2] = a2, void 0 !== c2 && (f2[b2].Xa = c2));
            }
            function ib(b2, a2, c2, d2, e, g2, k, h2) {
                this.name = b2;
                this.constructor = a2;
                this.qa = c2;
                this.la = d2;
                this.na = e;
                this.Oa = g2;
                this.ta = k;
                this.La = h2;
                this.Ta = [];
            }
            function jb(b2, a2, c2) {
                for (; a2 !== c2; ) a2.ta || T2("Expected null or instance of " + c2.name + ", got an instance of " + a2.name), b2 = a2.ta(b2), a2 = a2.na;
                return b2;
            }
            function kb(b2, a2) {
                if (null === a2) return this.Ba && T2("null is not a valid " + this.name), 0;
                a2.ea || T2('Cannot pass "' + lb(a2) + '" as a ' + this.name);
                a2.ea.ga || T2("Cannot pass deleted object as a pointer of type " + this.name);
                return jb(a2.ea.ga, a2.ea.ha.fa, this.fa);
            }
            function mb(b2, a2) {
                if (null === a2) {
                    this.Ba && T2("null is not a valid " + this.name);
                    if (this.wa) {
                        var c2 = this.sa();
                        null !== b2 && b2.push(this.la, c2);
                        return c2;
                    }
                    return 0;
                }
                a2.ea || T2('Cannot pass "' + lb(a2) + '" as a ' + this.name);
                a2.ea.ga || T2("Cannot pass deleted object as a pointer of type " + this.name);
                !this.va && a2.ea.ha.va && T2("Cannot convert argument of type " + (a2.ea.ma ? a2.ea.ma.name : a2.ea.ha.name) + " to parameter type " + this.name);
                c2 = jb(a2.ea.ga, a2.ea.ha.fa, this.fa);
                if (this.wa) switch (void 0 === a2.ea.ka && T2("Passing raw pointer to smart pointer is illegal"), this.Va) {
                    case 0:
                        a2.ea.ma === this ? c2 = a2.ea.ka : T2("Cannot convert argument of type " + (a2.ea.ma ? a2.ea.ma.name : a2.ea.ha.name) + " to parameter type " + this.name);
                        break;
                    case 1:
                        c2 = a2.ea.ka;
                        break;
                    case 2:
                        if (a2.ea.ma === this) c2 = a2.ea.ka;
                        else {
                            var d2 = a2.clone();
                            c2 = this.Ua(c2, V(function() {
                                d2["delete"]();
                            }));
                            null !== b2 && b2.push(this.la, c2);
                        }
                        break;
                    default:
                        T2("Unsupporting sharing policy");
                }
                return c2;
            }
            function nb(b2, a2) {
                if (null === a2) return this.Ba && T2("null is not a valid " + this.name), 0;
                a2.ea || T2('Cannot pass "' + lb(a2) + '" as a ' + this.name);
                a2.ea.ga || T2("Cannot pass deleted object as a pointer of type " + this.name);
                a2.ea.ha.va && T2("Cannot convert argument of type " + a2.ea.ha.name + " to parameter type " + this.name);
                return jb(a2.ea.ga, a2.ea.ha.fa, this.fa);
            }
            function ob(b2, a2, c2) {
                if (a2 === c2) return b2;
                if (void 0 === c2.na) return null;
                b2 = ob(b2, a2, c2.na);
                return null === b2 ? null : c2.La(b2);
            }
            var pb = {};
            function qb(b2, a2) {
                for (void 0 === a2 && T2("ptr should not be undefined"); b2.na; ) a2 = b2.ta(a2), b2 = b2.na;
                return pb[a2];
            }
            function rb(b2, a2) {
                a2.ha && a2.ga || Ua2("makeClassHandle requires ptr and ptrType");
                !!a2.ma !== !!a2.ka && Ua2("Both smartPtrType and smartPtr must be specified");
                a2.count = { value: 1 };
                return bb(Object.create(b2, { ea: { value: a2 } }));
            }
            function W2(b2, a2, c2, d2) {
                this.name = b2;
                this.fa = a2;
                this.Ba = c2;
                this.va = d2;
                this.wa = false;
                this.la = this.Ua = this.sa = this.Ia = this.Va = this.Sa = void 0;
                void 0 !== a2.na ? this.toWireType = mb : (this.toWireType = d2 ? kb : nb, this.ja = null);
            }
            function sb(b2, a2, c2) {
                f2.hasOwnProperty(b2) || Ua2("Replacing nonexistant public symbol");
                void 0 !== f2[b2].ia && void 0 !== c2 ? f2[b2].ia[c2] = a2 : (f2[b2] = a2, f2[b2].ua = c2);
            }
            function tb(b2, a2) {
                var c2 = [];
                return function() {
                    c2.length = arguments.length;
                    for (var d2 = 0; d2 < arguments.length; d2++) c2[d2] = arguments[d2];
                    b2.includes("j") ? (d2 = f2["dynCall_" + b2], d2 = c2 && c2.length ? d2.apply(null, [a2].concat(c2)) : d2.call(null, a2)) : d2 = H2.get(a2).apply(null, c2);
                    return d2;
                };
            }
            function X2(b2, a2) {
                b2 = R2(b2);
                var c2 = b2.includes("j") ? tb(b2, a2) : H2.get(a2);
                "function" !== typeof c2 && T2("unknown function pointer with signature " + b2 + ": " + a2);
                return c2;
            }
            var ub = void 0;
            function vb(b2) {
                b2 = wb(b2);
                var a2 = R2(b2);
                Y2(b2);
                return a2;
            }
            function xb(b2, a2) {
                function c2(g2) {
                    e[g2] || N2[g2] || (Pa2[g2] ? Pa2[g2].forEach(c2) : (d2.push(g2), e[g2] = true));
                }
                var d2 = [], e = {};
                a2.forEach(c2);
                throw new ub(b2 + ": " + d2.map(vb).join([", "]));
            }
            function Ab(b2, a2) {
                for (var c2 = [], d2 = 0; d2 < b2; d2++) c2.push(F2[(a2 >> 2) + d2]);
                return c2;
            }
            function Bb(b2, a2, c2, d2, e) {
                var g2 = a2.length;
                2 > g2 && T2("argTypes array size mismatch! Must at least get return value and 'this' types!");
                var k = null !== a2[1] && null !== c2, h2 = false;
                for (c2 = 1; c2 < a2.length; ++c2) if (null !== a2[c2] && void 0 === a2[c2].ja) {
                    h2 = true;
                    break;
                }
                var l2 = "void" !== a2[0].name, m2 = g2 - 2, n2 = Array(m2), p2 = [], r = [];
                return function() {
                    arguments.length !== m2 && T2("function " + b2 + " called with " + arguments.length + " arguments, expected " + m2 + " args!");
                    r.length = 0;
                    p2.length = k ? 2 : 1;
                    p2[0] = e;
                    if (k) {
                        var u = a2[1].toWireType(r, this);
                        p2[1] = u;
                    }
                    for (var t4 = 0; t4 < m2; ++t4) n2[t4] = a2[t4 + 2].toWireType(r, arguments[t4]), p2.push(n2[t4]);
                    t4 = d2.apply(null, p2);
                    if (h2) Oa2(r);
                    else for (var x2 = k ? 1 : 2; x2 < a2.length; x2++) {
                        var y2 = 1 === x2 ? u : n2[x2 - 2];
                        null !== a2[x2].ja && a2[x2].ja(y2);
                    }
                    u = l2 ? a2[0].fromWireType(t4) : void 0;
                    return u;
                };
            }
            var Cb = [], Z2 = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
            function Db(b2) {
                4 < b2 && 0 === --Z2[b2].Ca && (Z2[b2] = void 0, Cb.push(b2));
            }
            function Eb(b2) {
                b2 || T2("Cannot use deleted val. handle = " + b2);
                return Z2[b2].value;
            }
            function V(b2) {
                switch (b2) {
                    case void 0:
                        return 1;
                    case null:
                        return 2;
                    case true:
                        return 3;
                    case false:
                        return 4;
                    default:
                        var a2 = Cb.length ? Cb.pop() : Z2.length;
                        Z2[a2] = { Ca: 1, value: b2 };
                        return a2;
                }
            }
            function Fb(b2, a2, c2) {
                switch (a2) {
                    case 0:
                        return function(d2) {
                            return this.fromWireType((c2 ? za2 : B2)[d2]);
                        };
                    case 1:
                        return function(d2) {
                            return this.fromWireType((c2 ? D2 : C3)[d2 >> 1]);
                        };
                    case 2:
                        return function(d2) {
                            return this.fromWireType((c2 ? F2 : G2)[d2 >> 2]);
                        };
                    default:
                        throw new TypeError("Unknown integer type: " + b2);
                }
            }
            function Gb(b2, a2) {
                var c2 = N2[b2];
                void 0 === c2 && T2(a2 + " has unknown type " + vb(b2));
                return c2;
            }
            function lb(b2) {
                if (null === b2) return "null";
                var a2 = typeof b2;
                return "object" === a2 || "array" === a2 || "function" === a2 ? b2.toString() : "" + b2;
            }
            function Hb(b2, a2) {
                switch (a2) {
                    case 2:
                        return function(c2) {
                            return this.fromWireType(Aa2[c2 >> 2]);
                        };
                    case 3:
                        return function(c2) {
                            return this.fromWireType(Ba2[c2 >> 3]);
                        };
                    default:
                        throw new TypeError("Unknown float type: " + b2);
                }
            }
            function Ib(b2, a2, c2) {
                switch (a2) {
                    case 0:
                        return c2 ? function(d2) {
                            return za2[d2];
                        } : function(d2) {
                            return B2[d2];
                        };
                    case 1:
                        return c2 ? function(d2) {
                            return D2[d2 >> 1];
                        } : function(d2) {
                            return C3[d2 >> 1];
                        };
                    case 2:
                        return c2 ? function(d2) {
                            return F2[d2 >> 2];
                        } : function(d2) {
                            return G2[d2 >> 2];
                        };
                    default:
                        throw new TypeError("Unknown integer type: " + b2);
                }
            }
            var Jb = {};
            function Kb(b2) {
                var a2 = Jb[b2];
                return void 0 === a2 ? R2(b2) : a2;
            }
            var Lb = [];
            function Mb() {
                function b2(a2) {
                    a2.$$$embind_global$$$ = a2;
                    var c2 = "object" === typeof $$$embind_global$$$ && a2.$$$embind_global$$$ === a2;
                    c2 || delete a2.$$$embind_global$$$;
                    return c2;
                }
                if ("object" === typeof globalThis) return globalThis;
                if ("object" === typeof $$$embind_global$$$) return $$$embind_global$$$;
                "object" === typeof window && b2(window) ? $$$embind_global$$$ = window : "object" === typeof self && b2(self) && ($$$embind_global$$$ = self);
                if ("object" === typeof $$$embind_global$$$) return $$$embind_global$$$;
                throw Error("unable to get global object.");
            }
            function Nb(b2) {
                var a2 = Lb.length;
                Lb.push(b2);
                return a2;
            }
            function Ob(b2, a2) {
                for (var c2 = Array(b2), d2 = 0; d2 < b2; ++d2) c2[d2] = Gb(F2[(a2 >> 2) + d2], "parameter " + d2);
                return c2;
            }
            var Pb = [];
            function Qb(b2) {
                var a2 = Array(b2 + 1);
                return function(c2, d2, e) {
                    a2[0] = c2;
                    for (var g2 = 0; g2 < b2; ++g2) {
                        var k = Gb(F2[(d2 >> 2) + g2], "parameter " + g2);
                        a2[g2 + 1] = k.readValueFromPointer(e);
                        e += k.argPackAdvance;
                    }
                    c2 = new (c2.bind.apply(c2, a2))();
                    return V(c2);
                };
            }
            var Rb = {}, Sb = [null, [], []];
            Ta2 = f2.InternalError = Sa2("InternalError");
            for (var Tb = Array(256), Ub = 0; 256 > Ub; ++Ub) Tb[Ub] = String.fromCharCode(Ub);
            Xa2 = Tb;
            S2 = f2.BindingError = Sa2("BindingError");
            U2.prototype.isAliasOf = function(b2) {
                if (!(this instanceof U2 && b2 instanceof U2)) return false;
                var a2 = this.ea.ha.fa, c2 = this.ea.ga, d2 = b2.ea.ha.fa;
                for (b2 = b2.ea.ga; a2.na; ) c2 = a2.ta(c2), a2 = a2.na;
                for (; d2.na; ) b2 = d2.ta(b2), d2 = d2.na;
                return a2 === d2 && c2 === b2;
            };
            U2.prototype.clone = function() {
                this.ea.ga || Ya2(this);
                if (this.ea.ra) return this.ea.count.value += 1, this;
                var b2 = bb, a2 = Object, c2 = a2.create, d2 = Object.getPrototypeOf(this), e = this.ea;
                b2 = b2(c2.call(a2, d2, { ea: { value: { count: e.count, pa: e.pa, ra: e.ra, ga: e.ga, ha: e.ha, ka: e.ka, ma: e.ma } } }));
                b2.ea.count.value += 1;
                b2.ea.pa = false;
                return b2;
            };
            U2.prototype["delete"] = function() {
                this.ea.ga || Ya2(this);
                this.ea.pa && !this.ea.ra && T2("Object already scheduled for deletion");
                $a2(this);
                ab(this.ea);
                this.ea.ra || (this.ea.ka = void 0, this.ea.ga = void 0);
            };
            U2.prototype.isDeleted = function() {
                return !this.ea.ga;
            };
            U2.prototype.deleteLater = function() {
                this.ea.ga || Ya2(this);
                this.ea.pa && !this.ea.ra && T2("Object already scheduled for deletion");
                db.push(this);
                1 === db.length && cb && cb(eb);
                this.ea.pa = true;
                return this;
            };
            W2.prototype.Pa = function(b2) {
                this.Ia && (b2 = this.Ia(b2));
                return b2;
            };
            W2.prototype.Ga = function(b2) {
                this.la && this.la(b2);
            };
            W2.prototype.argPackAdvance = 8;
            W2.prototype.readValueFromPointer = L2;
            W2.prototype.deleteObject = function(b2) {
                if (null !== b2) b2["delete"]();
            };
            W2.prototype.fromWireType = function(b2) {
                function a2() {
                    return this.wa ? rb(this.fa.qa, { ha: this.Sa, ga: c2, ma: this, ka: b2 }) : rb(this.fa.qa, { ha: this, ga: b2 });
                }
                var c2 = this.Pa(b2);
                if (!c2) return this.Ga(b2), null;
                var d2 = qb(this.fa, c2);
                if (void 0 !== d2) {
                    if (0 === d2.ea.count.value) return d2.ea.ga = c2, d2.ea.ka = b2, d2.clone();
                    d2 = d2.clone();
                    this.Ga(b2);
                    return d2;
                }
                d2 = this.fa.Oa(c2);
                d2 = fb[d2];
                if (!d2) return a2.call(this);
                d2 = this.va ? d2.Ja : d2.pointerType;
                var e = ob(c2, this.fa, d2.fa);
                return null === e ? a2.call(this) : this.wa ? rb(d2.fa.qa, { ha: d2, ga: e, ma: this, ka: b2 }) : rb(
                    d2.fa.qa,
                    { ha: d2, ga: e }
                );
            };
            f2.getInheritedInstanceCount = function() {
                return Object.keys(pb).length;
            };
            f2.getLiveInheritedInstances = function() {
                var b2 = [], a2;
                for (a2 in pb) pb.hasOwnProperty(a2) && b2.push(pb[a2]);
                return b2;
            };
            f2.flushPendingDeletes = eb;
            f2.setDelayFunction = function(b2) {
                cb = b2;
                db.length && cb && cb(eb);
            };
            ub = f2.UnboundTypeError = Sa2("UnboundTypeError");
            f2.count_emval_handles = function() {
                for (var b2 = 0, a2 = 5; a2 < Z2.length; ++a2) void 0 !== Z2[a2] && ++b2;
                return b2;
            };
            f2.get_first_emval = function() {
                for (var b2 = 5; b2 < Z2.length; ++b2) if (void 0 !== Z2[b2]) return Z2[b2];
                return null;
            };
            var Wb = { r: function(b2) {
                    var a2 = Na2[b2];
                    delete Na2[b2];
                    var c2 = a2.elements, d2 = c2.length, e = c2.map(function(h2) {
                        return h2.Aa;
                    }).concat(c2.map(function(h2) {
                        return h2.Ea;
                    })), g2 = a2.sa, k = a2.la;
                    O2([b2], e, function(h2) {
                        c2.forEach(function(l2, m2) {
                            var n2 = h2[m2], p2 = l2.ya, r = l2.za, u = h2[m2 + d2], t4 = l2.Da, x2 = l2.Fa;
                            l2.read = (y2) => n2.fromWireType(p2(r, y2));
                            l2.write = (y2, P2) => {
                                var E2 = [];
                                t4(x2, y2, u.toWireType(E2, P2));
                                Oa2(E2);
                            };
                        });
                        return [{ name: a2.name, fromWireType: function(l2) {
                                for (var m2 = Array(d2), n2 = 0; n2 < d2; ++n2) m2[n2] = c2[n2].read(l2);
                                k(l2);
                                return m2;
                            }, toWireType: function(l2, m2) {
                                if (d2 !== m2.length) throw new TypeError("Incorrect number of tuple elements for " + a2.name + ": expected=" + d2 + ", actual=" + m2.length);
                                for (var n2 = g2(), p2 = 0; p2 < d2; ++p2) c2[p2].write(n2, m2[p2]);
                                null !== l2 && l2.push(k, n2);
                                return n2;
                            }, argPackAdvance: 8, readValueFromPointer: L2, ja: k }];
                    });
                }, u: function(b2) {
                    var a2 = Va[b2];
                    delete Va[b2];
                    var c2 = a2.sa, d2 = a2.la, e = a2.Ha, g2 = e.map(function(k) {
                        return k.Aa;
                    }).concat(e.map(function(k) {
                        return k.Ea;
                    }));
                    O2([b2], g2, function(k) {
                        var h2 = {};
                        e.forEach(function(l2, m2) {
                            var n2 = k[m2], p2 = l2.ya, r = l2.za, u = k[m2 + e.length], t4 = l2.Da, x2 = l2.Fa;
                            h2[l2.Na] = { read: function(y2) {
                                    return n2.fromWireType(p2(r, y2));
                                }, write: function(y2, P2) {
                                    var E2 = [];
                                    t4(x2, y2, u.toWireType(E2, P2));
                                    Oa2(E2);
                                } };
                        });
                        return [{ name: a2.name, fromWireType: function(l2) {
                                var m2 = {}, n2;
                                for (n2 in h2) m2[n2] = h2[n2].read(l2);
                                d2(l2);
                                return m2;
                            }, toWireType: function(l2, m2) {
                                for (var n2 in h2) if (!(n2 in m2)) throw new TypeError('Missing field:  "' + n2 + '"');
                                var p2 = c2();
                                for (n2 in h2) h2[n2].write(p2, m2[n2]);
                                null !== l2 && l2.push(d2, p2);
                                return p2;
                            }, argPackAdvance: 8, readValueFromPointer: L2, ja: d2 }];
                    });
                }, z: function() {
                }, F: function(b2, a2, c2, d2, e) {
                    var g2 = Wa2(c2);
                    a2 = R2(a2);
                    Q2(b2, {
                        name: a2,
                        fromWireType: function(k) {
                            return !!k;
                        },
                        toWireType: function(k, h2) {
                            return h2 ? d2 : e;
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: function(k) {
                            if (1 === c2) var h2 = za2;
                            else if (2 === c2) h2 = D2;
                            else if (4 === c2) h2 = F2;
                            else throw new TypeError("Unknown boolean type size: " + a2);
                            return this.fromWireType(h2[k >> g2]);
                        },
                        ja: null
                    });
                }, l: function(b2, a2, c2, d2, e, g2, k, h2, l2, m2, n2, p2, r) {
                    n2 = R2(n2);
                    g2 = X2(e, g2);
                    h2 && (h2 = X2(k, h2));
                    m2 && (m2 = X2(l2, m2));
                    r = X2(p2, r);
                    var u = Qa2(n2);
                    hb(u, function() {
                        xb("Cannot construct " + n2 + " due to unbound types", [d2]);
                    });
                    O2([b2, a2, c2], d2 ? [d2] : [], function(t4) {
                        t4 = t4[0];
                        if (d2) {
                            var x2 = t4.fa;
                            var y2 = x2.qa;
                        } else y2 = U2.prototype;
                        t4 = Ra2(u, function() {
                            if (Object.getPrototypeOf(this) !== P2) throw new S2("Use 'new' to construct " + n2);
                            if (void 0 === E2.oa) throw new S2(n2 + " has no accessible constructor");
                            var yb = E2.oa[arguments.length];
                            if (void 0 === yb) throw new S2("Tried to invoke ctor of " + n2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(E2.oa).toString() + ") parameters instead!");
                            return yb.apply(this, arguments);
                        });
                        var P2 = Object.create(y2, { constructor: { value: t4 } });
                        t4.prototype = P2;
                        var E2 = new ib(n2, t4, P2, r, x2, g2, h2, m2);
                        x2 = new W2(n2, E2, true, false);
                        y2 = new W2(n2 + "*", E2, false, false);
                        var zb = new W2(n2 + " const*", E2, false, true);
                        fb[b2] = { pointerType: y2, Ja: zb };
                        sb(u, t4);
                        return [x2, y2, zb];
                    });
                }, i: function(b2, a2, c2, d2, e, g2) {
                    0 < a2 || A2(void 0);
                    var k = Ab(a2, c2);
                    e = X2(d2, e);
                    O2([], [b2], function(h2) {
                        h2 = h2[0];
                        var l2 = "constructor " + h2.name;
                        void 0 === h2.fa.oa && (h2.fa.oa = []);
                        if (void 0 !== h2.fa.oa[a2 - 1]) throw new S2("Cannot register multiple constructors with identical number of parameters (" + (a2 - 1) + ") for class '" + h2.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                        h2.fa.oa[a2 - 1] = () => {
                            xb("Cannot construct " + h2.name + " due to unbound types", k);
                        };
                        O2([], k, function(m2) {
                            m2.splice(1, 0, null);
                            h2.fa.oa[a2 - 1] = Bb(l2, m2, null, e, g2);
                            return [];
                        });
                        return [];
                    });
                }, a: function(b2, a2, c2, d2, e, g2, k, h2) {
                    var l2 = Ab(c2, d2);
                    a2 = R2(a2);
                    g2 = X2(e, g2);
                    O2([], [b2], function(m2) {
                        function n2() {
                            xb("Cannot call " + p2 + " due to unbound types", l2);
                        }
                        m2 = m2[0];
                        var p2 = m2.name + "." + a2;
                        a2.startsWith("@@") && (a2 = Symbol[a2.substring(2)]);
                        h2 && m2.fa.Ta.push(a2);
                        var r = m2.fa.qa, u = r[a2];
                        void 0 === u || void 0 === u.ia && u.className !== m2.name && u.ua === c2 - 2 ? (n2.ua = c2 - 2, n2.className = m2.name, r[a2] = n2) : (gb(r, a2, p2), r[a2].ia[c2 - 2] = n2);
                        O2([], l2, function(t4) {
                            t4 = Bb(p2, t4, m2, g2, k);
                            void 0 === r[a2].ia ? (t4.ua = c2 - 2, r[a2] = t4) : r[a2].ia[c2 - 2] = t4;
                            return [];
                        });
                        return [];
                    });
                }, I: function(b2, a2, c2) {
                    b2 = R2(b2);
                    O2([], [a2], function(d2) {
                        d2 = d2[0];
                        f2[b2] = d2.fromWireType(c2);
                        return [];
                    });
                }, E: function(b2, a2) {
                    a2 = R2(a2);
                    Q2(b2, { name: a2, fromWireType: function(c2) {
                            var d2 = Eb(c2);
                            Db(c2);
                            return d2;
                        }, toWireType: function(c2, d2) {
                            return V(d2);
                        }, argPackAdvance: 8, readValueFromPointer: L2, ja: null });
                }, h: function(b2, a2, c2, d2) {
                    function e() {
                    }
                    c2 = Wa2(c2);
                    a2 = R2(a2);
                    e.values = {};
                    Q2(b2, {
                        name: a2,
                        constructor: e,
                        fromWireType: function(g2) {
                            return this.constructor.values[g2];
                        },
                        toWireType: function(g2, k) {
                            return k.value;
                        },
                        argPackAdvance: 8,
                        readValueFromPointer: Fb(a2, c2, d2),
                        ja: null
                    });
                    hb(a2, e);
                }, k: function(b2, a2, c2) {
                    var d2 = Gb(b2, "enum");
                    a2 = R2(a2);
                    b2 = d2.constructor;
                    d2 = Object.create(d2.constructor.prototype, { value: { value: c2 }, constructor: { value: Ra2(d2.name + "_" + a2, function() {
                            }) } });
                    b2.values[c2] = d2;
                    b2[a2] = d2;
                }, q: function(b2, a2, c2) {
                    c2 = Wa2(c2);
                    a2 = R2(a2);
                    Q2(b2, { name: a2, fromWireType: function(d2) {
                            return d2;
                        }, toWireType: function(d2, e) {
                            return e;
                        }, argPackAdvance: 8, readValueFromPointer: Hb(a2, c2), ja: null });
                }, f: function(b2, a2, c2, d2, e, g2) {
                    var k = Ab(a2, c2);
                    b2 = R2(b2);
                    e = X2(d2, e);
                    hb(b2, function() {
                        xb("Cannot call " + b2 + " due to unbound types", k);
                    }, a2 - 1);
                    O2([], k, function(h2) {
                        h2 = [h2[0], null].concat(h2.slice(1));
                        sb(b2, Bb(b2, h2, null, e, g2), a2 - 1);
                        return [];
                    });
                }, e: function(b2, a2, c2, d2, e) {
                    a2 = R2(a2);
                    -1 === e && (e = 4294967295);
                    e = Wa2(c2);
                    var g2 = (h2) => h2;
                    if (0 === d2) {
                        var k = 32 - 8 * c2;
                        g2 = (h2) => h2 << k >>> k;
                    }
                    c2 = a2.includes("unsigned") ? function(h2, l2) {
                        return l2 >>> 0;
                    } : function(h2, l2) {
                        return l2;
                    };
                    Q2(b2, { name: a2, fromWireType: g2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: Ib(a2, e, 0 !== d2), ja: null });
                }, b: function(b2, a2, c2) {
                    function d2(g2) {
                        g2 >>= 2;
                        var k = G2;
                        return new e(ya2, k[g2 + 1], k[g2]);
                    }
                    var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][a2];
                    c2 = R2(c2);
                    Q2(b2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { Qa: true });
                }, p: function(b2, a2) {
                    a2 = R2(a2);
                    var c2 = "std::string" === a2;
                    Q2(b2, { name: a2, fromWireType: function(d2) {
                            var e = G2[d2 >> 2];
                            if (c2) for (var g2 = d2 + 4, k = 0; k <= e; ++k) {
                                var h2 = d2 + 4 + k;
                                if (k == e || 0 == B2[h2]) {
                                    g2 = g2 ? pa2(B2, g2, h2 - g2) : "";
                                    if (void 0 === l2) var l2 = g2;
                                    else l2 += String.fromCharCode(0), l2 += g2;
                                    g2 = h2 + 1;
                                }
                            }
                            else {
                                l2 = Array(e);
                                for (k = 0; k < e; ++k) l2[k] = String.fromCharCode(B2[d2 + 4 + k]);
                                l2 = l2.join("");
                            }
                            Y2(d2);
                            return l2;
                        }, toWireType: function(d2, e) {
                            e instanceof ArrayBuffer && (e = new Uint8Array(e));
                            var g2 = "string" === typeof e;
                            g2 || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || T2("Cannot pass non-string to std::string");
                            var k = (c2 && g2 ? () => {
                                for (var m2 = 0, n2 = 0; n2 < e.length; ++n2) {
                                    var p2 = e.charCodeAt(n2);
                                    55296 <= p2 && 57343 >= p2 && (p2 = 65536 + ((p2 & 1023) << 10) | e.charCodeAt(++n2) & 1023);
                                    127 >= p2 ? ++m2 : m2 = 2047 >= p2 ? m2 + 2 : 65535 >= p2 ? m2 + 3 : m2 + 4;
                                }
                                return m2;
                            } : () => e.length)(), h2 = Vb(4 + k + 1);
                            G2[h2 >> 2] = k;
                            if (c2 && g2) qa2(e, h2 + 4, k + 1);
                            else if (g2) for (g2 = 0; g2 < k; ++g2) {
                                var l2 = e.charCodeAt(g2);
                                255 < l2 && (Y2(h2), T2("String has UTF-16 code units that do not fit in 8 bits"));
                                B2[h2 + 4 + g2] = l2;
                            }
                            else for (g2 = 0; g2 < k; ++g2) B2[h2 + 4 + g2] = e[g2];
                            null !== d2 && d2.push(Y2, h2);
                            return h2;
                        }, argPackAdvance: 8, readValueFromPointer: L2, ja: function(d2) {
                            Y2(d2);
                        } });
                }, m: function(b2, a2, c2) {
                    c2 = R2(c2);
                    if (2 === a2) {
                        var d2 = sa2;
                        var e = ta2;
                        var g2 = ua2;
                        var k = () => C3;
                        var h2 = 1;
                    } else 4 === a2 && (d2 = va2, e = wa2, g2 = xa2, k = () => G2, h2 = 2);
                    Q2(b2, { name: c2, fromWireType: function(l2) {
                            for (var m2 = G2[l2 >> 2], n2 = k(), p2, r = l2 + 4, u = 0; u <= m2; ++u) {
                                var t4 = l2 + 4 + u * a2;
                                if (u == m2 || 0 == n2[t4 >> h2]) r = d2(r, t4 - r), void 0 === p2 ? p2 = r : (p2 += String.fromCharCode(0), p2 += r), r = t4 + a2;
                            }
                            Y2(l2);
                            return p2;
                        }, toWireType: function(l2, m2) {
                            "string" !== typeof m2 && T2("Cannot pass non-string to C++ string type " + c2);
                            var n2 = g2(m2), p2 = Vb(4 + n2 + a2);
                            G2[p2 >> 2] = n2 >> h2;
                            e(m2, p2 + 4, n2 + a2);
                            null !== l2 && l2.push(Y2, p2);
                            return p2;
                        }, argPackAdvance: 8, readValueFromPointer: L2, ja: function(l2) {
                            Y2(l2);
                        } });
                }, t: function(b2, a2, c2, d2, e, g2) {
                    Na2[b2] = { name: R2(a2), sa: X2(c2, d2), la: X2(e, g2), elements: [] };
                }, s: function(b2, a2, c2, d2, e, g2, k, h2, l2) {
                    Na2[b2].elements.push({ Aa: a2, ya: X2(c2, d2), za: e, Ea: g2, Da: X2(
                            k,
                            h2
                        ), Fa: l2 });
                }, v: function(b2, a2, c2, d2, e, g2) {
                    Va[b2] = { name: R2(a2), sa: X2(c2, d2), la: X2(e, g2), Ha: [] };
                }, j: function(b2, a2, c2, d2, e, g2, k, h2, l2, m2) {
                    Va[b2].Ha.push({ Na: R2(a2), Aa: c2, ya: X2(d2, e), za: g2, Ea: k, Da: X2(h2, l2), Fa: m2 });
                }, G: function(b2, a2) {
                    a2 = R2(a2);
                    Q2(b2, { Ra: true, name: a2, argPackAdvance: 0, fromWireType: function() {
                        }, toWireType: function() {
                        } });
                }, d: function(b2, a2, c2, d2) {
                    b2 = Lb[b2];
                    a2 = Eb(a2);
                    c2 = Kb(c2);
                    b2(a2, c2, null, d2);
                }, J: Db, x: function(b2) {
                    if (0 === b2) return V(Mb());
                    b2 = Kb(b2);
                    return V(Mb()[b2]);
                }, c: function(b2, a2) {
                    var c2 = Ob(b2, a2), d2 = c2[0];
                    a2 = d2.name + "_$" + c2.slice(1).map(function(k) {
                        return k.name;
                    }).join("_") + "$";
                    var e = Pb[a2];
                    if (void 0 !== e) return e;
                    var g2 = Array(b2 - 1);
                    e = Nb((k, h2, l2, m2) => {
                        for (var n2 = 0, p2 = 0; p2 < b2 - 1; ++p2) g2[p2] = c2[p2 + 1].readValueFromPointer(m2 + n2), n2 += c2[p2 + 1].argPackAdvance;
                        k = k[h2].apply(k, g2);
                        for (p2 = 0; p2 < b2 - 1; ++p2) c2[p2 + 1].Ka && c2[p2 + 1].Ka(g2[p2]);
                        if (!d2.Ra) return d2.toWireType(l2, k);
                    });
                    return Pb[a2] = e;
                }, n: function(b2) {
                    4 < b2 && (Z2[b2].Ca += 1);
                }, w: function(b2, a2, c2, d2) {
                    b2 = Eb(b2);
                    var e = Rb[a2];
                    e || (e = Qb(a2), Rb[a2] = e);
                    return e(b2, c2, d2);
                }, K: function() {
                    return V([]);
                }, D: function(b2) {
                    return V(Kb(b2));
                }, H: function(b2, a2) {
                    b2 = Gb(b2, "_emval_take_value");
                    b2 = b2.readValueFromPointer(a2);
                    return V(b2);
                }, g: function() {
                    A2("");
                }, B: function(b2) {
                    var a2 = B2.length;
                    b2 >>>= 0;
                    if (2147483648 < b2) return false;
                    for (var c2 = 1; 4 >= c2; c2 *= 2) {
                        var d2 = a2 * (1 + 0.2 / c2);
                        d2 = Math.min(d2, b2 + 100663296);
                        d2 = Math.max(b2, d2);
                        0 < d2 % 65536 && (d2 += 65536 - d2 % 65536);
                        a: {
                            try {
                                ma2.grow(Math.min(2147483648, d2) - ya2.byteLength + 65535 >>> 16);
                                Ca2();
                                var e = 1;
                                break a;
                            } catch (g2) {
                            }
                            e = void 0;
                        }
                        if (e) return true;
                    }
                    return false;
                }, C: function() {
                    return 0;
                }, y: function() {
                }, o: function(b2, a2, c2, d2) {
                    for (var e = 0, g2 = 0; g2 < c2; g2++) {
                        var k = F2[a2 >> 2], h2 = F2[a2 + 4 >> 2];
                        a2 += 8;
                        for (var l2 = 0; l2 < h2; l2++) {
                            var m2 = B2[k + l2], n2 = Sb[b2];
                            0 === m2 || 10 === m2 ? ((1 === b2 ? la2 : w2)(pa2(n2, 0)), n2.length = 0) : n2.push(m2);
                        }
                        e += h2;
                    }
                    F2[d2 >> 2] = e;
                    return 0;
                }, A: function() {
                } };
            (function() {
                function b2(e) {
                    f2.asm = e.exports;
                    ma2 = f2.asm.L;
                    Ca2();
                    H2 = f2.asm._;
                    Ea2.unshift(f2.asm.M);
                    I2--;
                    f2.monitorRunDependencies && f2.monitorRunDependencies(I2);
                    0 == I2 && (J2 && (e = J2, J2 = null, e()));
                }
                function a2(e) {
                    b2(e.instance);
                }
                function c2(e) {
                    return La2().then(function(g2) {
                        return WebAssembly.instantiate(g2, d2);
                    }).then(function(g2) {
                        return g2;
                    }).then(e, function(g2) {
                        w2("failed to asynchronously prepare wasm: " + g2);
                        A2(g2);
                    });
                }
                var d2 = { a: Wb };
                I2++;
                f2.monitorRunDependencies && f2.monitorRunDependencies(I2);
                if (f2.instantiateWasm) try {
                    return f2.instantiateWasm(
                        d2,
                        b2
                    );
                } catch (e) {
                    return w2("Module.instantiateWasm callback failed with error: " + e), false;
                }
                (function() {
                    return z2 || "function" !== typeof WebAssembly.instantiateStreaming || Ia2() || K2.startsWith("file://") || "function" !== typeof fetch ? c2(a2) : fetch(K2, { credentials: "same-origin" }).then(function(e) {
                        return WebAssembly.instantiateStreaming(e, d2).then(a2, function(g2) {
                            w2("wasm streaming compile failed: " + g2);
                            w2("falling back to ArrayBuffer instantiation");
                            return c2(a2);
                        });
                    });
                })().catch(ca2);
                return {};
            })();
            f2.___wasm_call_ctors = function() {
                return (f2.___wasm_call_ctors = f2.asm.M).apply(null, arguments);
            };
            f2.__Z6ToCmdsRK6SkPath = function() {
                return (f2.__Z6ToCmdsRK6SkPath = f2.asm.N).apply(null, arguments);
            };
            f2.__Z8FromCmdsmi = function() {
                return (f2.__Z8FromCmdsmi = f2.asm.O).apply(null, arguments);
            };
            f2.__Z7NewPathv = function() {
                return (f2.__Z7NewPathv = f2.asm.P).apply(null, arguments);
            };
            f2.__Z8CopyPathRK6SkPath = function() {
                return (f2.__Z8CopyPathRK6SkPath = f2.asm.Q).apply(null, arguments);
            };
            f2.__Z6EqualsRK6SkPathS1_ = function() {
                return (f2.__Z6EqualsRK6SkPathS1_ = f2.asm.R).apply(null, arguments);
            };
            f2.__Z11ToSVGStringRK6SkPath = function() {
                return (f2.__Z11ToSVGStringRK6SkPath = f2.asm.S).apply(null, arguments);
            };
            f2.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = function() {
                return (f2.__Z13FromSVGStringNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE = f2.asm.T).apply(null, arguments);
            };
            f2.__Z13ApplySimplifyR6SkPath = function() {
                return (f2.__Z13ApplySimplifyR6SkPath = f2.asm.U).apply(null, arguments);
            };
            f2.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = function() {
                return (f2.__Z11ApplyPathOpR6SkPathRKS_8SkPathOp = f2.asm.V).apply(null, arguments);
            };
            f2.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = function() {
                return (f2.__Z10MakeFromOpRK6SkPathS1_8SkPathOp = f2.asm.W).apply(null, arguments);
            };
            f2.__Z14ResolveBuilderR11SkOpBuilder = function() {
                return (f2.__Z14ResolveBuilderR11SkOpBuilder = f2.asm.X).apply(null, arguments);
            };
            f2.__Z8ToCanvasRK6SkPathN10emscripten3valE = function() {
                return (f2.__Z8ToCanvasRK6SkPathN10emscripten3valE = f2.asm.Y).apply(null, arguments);
            };
            f2.__Z8ToPath2DRK6SkPath = function() {
                return (f2.__Z8ToPath2DRK6SkPath = f2.asm.Z).apply(null, arguments);
            };
            var Y2 = f2._free = function() {
                return (Y2 = f2._free = f2.asm.$).apply(null, arguments);
            }, Vb = f2._malloc = function() {
                return (Vb = f2._malloc = f2.asm.aa).apply(null, arguments);
            }, wb = f2.___getTypeName = function() {
                return (wb = f2.___getTypeName = f2.asm.ba).apply(null, arguments);
            };
            f2.___embind_register_native_and_builtin_types = function() {
                return (f2.___embind_register_native_and_builtin_types = f2.asm.ca).apply(null, arguments);
            };
            f2.dynCall_jiji = function() {
                return (f2.dynCall_jiji = f2.asm.da).apply(null, arguments);
            };
            var Xb;
            J2 = function Yb() {
                Xb || Zb();
                Xb || (J2 = Yb);
            };
            function Zb() {
                function b2() {
                    if (!Xb && (Xb = true, f2.calledRun = true, !na2)) {
                        Ma2(Ea2);
                        ba2(f2);
                        if (f2.onRuntimeInitialized) f2.onRuntimeInitialized();
                        if (f2.postRun) for ("function" == typeof f2.postRun && (f2.postRun = [f2.postRun]); f2.postRun.length; ) {
                            var a2 = f2.postRun.shift();
                            Fa2.unshift(a2);
                        }
                        Ma2(Fa2);
                    }
                }
                if (!(0 < I2)) {
                    if (f2.preRun) for ("function" == typeof f2.preRun && (f2.preRun = [f2.preRun]); f2.preRun.length; ) Ga2();
                    Ma2(Da2);
                    0 < I2 || (f2.setStatus ? (f2.setStatus("Running..."), setTimeout(function() {
                        setTimeout(function() {
                            f2.setStatus("");
                        }, 1);
                        b2();
                    }, 1)) : b2());
                }
            }
            f2.run = Zb;
            if (f2.preInit) for ("function" == typeof f2.preInit && (f2.preInit = [f2.preInit]); 0 < f2.preInit.length; ) f2.preInit.pop()();
            Zb();
            return PathKitInit22.ready;
        };
    })();
    module.exports = PathKitInit2;
})(pathkit);
var pathkitExports = pathkit.exports;
const PathKitInit = /* @__PURE__ */ getDefaultExportFromCjs(pathkitExports);
function b64ToUint6(nChr) {
    return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function base64ToUint8(sBase64, nBlocksSize) {
    const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, "");
    const nInLen = sB64Enc.length;
    const nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;
    const taBytes = new Uint8Array(nOutLen);
    let nMod3;
    let nMod4;
    let nUint24 = 0;
    let nOutIdx = 0;
    for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            nMod3 = 0;
            while (nMod3 < 3 && nOutIdx < nOutLen) {
                taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
                nMod3++;
                nOutIdx++;
            }
            nUint24 = 0;
        }
    }
    return taBytes;
}
function toUint8(b64) {
    let bin = atob(b64);
    let len = bin.length;
    let bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = bin.charCodeAt(i);
    }
    return bytes;
}
const decode64 = typeof atob === "function" ? toUint8 : base64ToUint8;
const wasm = decode64("AGFzbQEAAAABoQd0YAJ/fwF/YAF/AX9gA39/fwF/YAJ/fwBgAX8AYAN/f38AYAN/f3wAYAR/f39/AGAEf399fABgBH9/f38Bf2AEf3x8fwBgBX9/f39/AX9gBH99f38AYAV/f39/fwBgBH99fX8Bf2ADf399AGAAAX9gA399fQBgA398fwF/YAZ/f3x8fH8Bf2ACfX0Bf2AFf35+fn4AYAZ/f39/f38Bf2AEf319fwBgBX99fX19AGAGf39/f39/AGAAAGACf30AYAF9AX1gAX8BfWAJf39/f399fX9/AGACfX0BfWAEf3x8fAF8YAN/fX8Bf2AEf3x8fwF/YAN/f30Bf2AEf35+fwBgAn9/AXxgB399fX19fX0AYAp/fX19fX19fX19AGAEf398fABgAn99AX1gA39/fAF/YAt/f319fX19fX19fQBgBn99fX19fQBgA399fQF/YAR8fHx/AX9gAn99AX9gBH19fX8Bf2ABfAF9YAJ8fwF8YAJ/fwF9YAF8AXxgAnx8AXxgBn9/fX9/fwF9YAZ/fH9/f38Bf2AEf399fQBgCH9/f3x8fHx/AX9gA39+fwF+YAR9fX19AX1gBH99fX0Bf2AJf319fX19fX1/AGAHf319fX19fwBgCH9/f39/f39/AGAKf39/f39/f39/fwBgDX9/f39/f39/f39/f38AYAl/f39/f39/f38AYAd/f39/f39/AGAGf319fX19AX9gBX9/fH9/AGADf39/AXxgA399fwBgAnx8AX9gAn98AGAEfn5+fgF/YAJ/fAF/YAJ+fwF/YAJ8fwF9YAV/fX1/fwBgBn9/fX9/fwBgA319fQF/YAR/f39/AXxgBX98fH9/AGAEf39/fQBgBXx8fHx/AX9gBX9/fX9/AGAIf39/fHx/f38Bf2ADfn5+AX9gAn1/AX9gCH9/fX9/f39/AX1gBX9/fX1/AGAEf398fwF/YAZ/f398f38Bf2AEf39+fgBgAn5+AXxgB39/f39/f38Bf2ABfwF+YAN9f38Bf2AHfX9/f39/fwBgA399fwF9YAR/fX9/AX9gBX19fX1/AX9gBX9/f3x/AGADf3x8AX9gBH98f38Bf2AEf39/fAF/YAV/fX19fQF/YAN/f30BfWAFf399fX8Bf2AFf399fX0Bf2AGf399fX19AGAKf399fX19fX19fwBgCH9/fX19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AkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtB7NYAQezWACgCAEEBayIAQX8gABs2AgALC2IBAn8CfyAAi0MAAIA4XwRAQQEgAYtDAACAOF8NARoLQQAgALwiAkH/////B3FrIAIgAkEASBsiA0EAIAG8IgJB/////wdxayACIAJBAEgbIgJBgAJqSCACIANBgAJqSHELC8UKAgV/D34jAEHgAGsiBSQAIARC////////P4MhDCACIASFQoCAgICAgICAgH+DIQogAkL///////8/gyINQiCIIQ4gBEIwiKdB//8BcSEHAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgB0H//wFrQYGAfksNAQsgAVAgAkL///////////8AgyILQoCAgICAgMD//wBUIAtCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhCgwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEKIAMhAQwCCyABIAtCgICAgICAwP//AIWEUARAIAIgA4RQBEBCgICAgICA4P//ACEKQgAhAQwDCyAKQoCAgICAgMD//wCEIQpCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEAgASALhCECQgAhASACUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASALhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgC0L///////8/WARAIAVB0ABqIAEgDSABIA0gDVAiBht5IAZBBnStfKciBkEPaxBLQRAgBmshBiAFKQNYIg1CIIghDiAFKQNQIQELIAJC////////P1YNACAFQUBrIAMgDCADIAwgDFAiCBt5IAhBBnStfKciCEEPaxBLIAYgCGtBEGohBiAFKQNIIQwgBSkDQCEDCyADQg+GIgtCgID+/w+DIgIgAUIgiCIEfiIQIAtCIIgiEyABQv////8PgyIBfnwiD0IghiIRIAEgAn58IgsgEVStIAIgDUL/////D4MiDX4iFSAEIBN+fCIRIAxCD4YgA0IxiIQiEkL/////D4MiAyABfnwiFCAPIBBUrUIghiAPQiCIhHwiDyACIA5CgIAEhCIMfiIWIA0gE358Ig4gEkIgiEKAgICACIQiAiABfnwiECADIAR+fCISQiCGfCIXfCEBIAcgCWogBmpB//8AayEGAkAgAiAEfiIYIAwgE358IgQgGFStIAQgBCADIA1+fCIEVq18IAIgDH58IAQgBCARIBVUrSARIBRWrXx8IgRWrXwgAyAMfiIDIAIgDX58IgIgA1StQiCGIAJCIIiEfCAEIAJCIIZ8IgIgBFStfCACIAIgECASVq0gDiAWVK0gDiAQVq18fEIghiASQiCIhHwiAlatfCACIAIgDyAUVK0gDyAXVq18fCICVq18IgRCgICAgICAwACDUEUEQCAGQQFqIQYMAQsgC0I/iCEDIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAMgAUIBhoQhAQsgBkH//wFOBEAgCkKAgICAgIDA//8AhCEKQgAhAQwBCwJ+IAZBAEwEQEEBIAZrIgdBgAFPBEBCACEBDAMLIAVBMGogCyABIAZB/wBqIgYQSyAFQSBqIAIgBCAGEEsgBUEQaiALIAEgBxCWASAFIAIgBCAHEJYBIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAELIARC////////P4MgBq1CMIaECyAKhCEKIAtQIAFCAFkgAUKAgICAgICAgIB/URtFBEAgCiACQgF8IgEgAlStfCEKDAELIAsgAUKAgICAgICAgIB/hYRQRQRAIAIhAQwBCyAKIAIgAkIBg3wiASACVK18IQoLIAAgATcDACAAIAo3AwggBUHgAGokAAtzAQJ/IAFBBk0EQCABQQJ0QbwmaigCACEEQoCCiKCAASABrUIDhoinIQMLIABBADsBViAAQQE6AFQgACAALQBaIANyOgBaIABBIGoQWyABOgAAIAFBA0YEQCAAQSxqQQEQXCACOAIACyAAQRRqIARBABBBC/IBAQR/AkAgAUFyTw0AIAFBDmoiA0EAIAJrSw0AIAAoAgwiAUE/cSIEQQJ0IgVBxM4AaigCACEGIAIgA2pBAWshAwJAIARBLk8EQCABQQZ2IQIMAQsgBUHIzgBqKAIAQX8gAUEGdiICbk8NACAAIAFBAWpBP3EgAUFAcXI2AgwLIAIgBmwiASADIAEgA0sbIgFB/x9BDyABQYCAAksbIgJBf3MiA0sNACAAIAEgAmogA3EiAhAzIgEgAmo2AgggACgCACECIAFBADoACCABQfoBNgAEIAEgAjYAACAAIAFBCWoiATYCACAAIAE2AgQPCxAGAAsUAQF/QQQQMyIBIAAoAgA2AgAgAQs0AQF/IABBASAAGyEAAkADQCAAEJgBIgENAUG82gAoAgAiAQRAIAERGgAMAQsLEAYACyABC6kEAhB9An8gAkEATARAIABCADcCACAAQgA3AghBAQ8LQQEhEwJ9IAJBAXEEQEF/IRQgASoCACIDIQQgASoCBCIFDAELIAEqAAghBCABKgAEIQUgASoAACEDQX4hFEECIRMgASoADAsiBkMAAAAAlCEPIARDAAAAAJQhECAFQwAAAACUIREgA0MAAAAAlCESAkAgAiAUaiICRQRAIAMhByAFIQggBCEJIAYhCgwBCyABIBNBA3RqIQEgBiEKIAQhCSAFIQggAyEHA0AgCiABKgAMIgsgCiALXhshCiAGIAsgBiALXRshBiAJIAEqAAgiDCAJIAxeGyEJIAggASoABCINIAggDV4bIQggByABKgAAIg4gByAOXhshByAEIAwgBCAMXRshBCAFIA0gBSANXRshBSADIA4gAyAOXRshAyABQRBqIQEgECAMlCEQIBEgDZQhESASIA6UIRIgDyALlCEPIAJBAmsiAg0ACwtBf0EAIBJDAAAAAJRDAAAAAFsbvkMAAAAAW0F/QQAgEUMAAAAAlEMAAAAAWxu+QwAAAABbckF/QQAgEEMAAAAAlEMAAAAAWxu+QwAAAABbQX9BACAPQwAAAACUQwAAAABbG75DAAAAAFtyckUEQCAAIAogCCAIIApdGzgCDCAAIAkgByAHIAldGzgCCCAAIAYgBSAFIAZeGzgCBCAAIAQgAyADIAReGzgCAEEBDwsgAEIANwIAIABCADcCCEEACy4BAX8QaSEBIABBfzYCBCAAIAE2AgAgAEGCBDsBCCAAIAAtAApB+AFxOgAKIAALYAECfwJ/IACLQwAAgDVfBEBBASABi0MAAIA1Xw0BGgtBACAAvCICQf////8HcWsgAiACQQBIGyIDQQAgAbwiAkH/////B3FrIAIgAkEASBsiAkEQakggAiADQRBqSHELCykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAAC+ABAgZ8AX8CQCAAKwMAIgIgASsDACIEoZlEAAAAAAAAgD5jBEBBASEIIAArAwggASsDCKGZRAAAAAAAAIA+Yw0BC0EAIQggArYgBLYQLkUNACAAKwMItiABKwMIthAuRQ0AIAErAwgiAiAAKwMIIgQgASsDACIFIAArAwAiByAFIAdjGyIDIAMgBGQbIgMgAiADYxuaIgMgAiAEIAUgByAFIAdkGyIGIAQgBmQbIgYgAiAGZBsiBiADIAZkGyIDtiAHIAWhIgUgBaIgBCACoSICIAKioJ8gA6C2EFUhCAsgCAudAgIDfwJ9IwBBEGsiByQAAkAgBUMAAAAAXkUEQCAAIAMgBBAnGgwBCyAFvEGAgID8B3FBgICA/AdGBEAgACABIAIQJyADIAQQJxoMAQsgBUMAAIA/WwRAIAAgASACIAMgBBBSDAELIAAoAgQiBkEASARAIAAoAgAiCCgCKARAIAgoAhQgBkF/c0EDdGoiBioCBCEKIAYqAgAhCQsgB0EIaiAAQQBBABAqIQYgACAAKAIAKAIcNgIEIAYoAgBBAEMAAAAAEDAiBiAKOAIEIAYgCTgCACAAQYIEOwEICyAHIABBAEEAECooAgBBAyAFEDAiBiADOAIIIAYgAjgCBCAGIAE4AgAgBiAEOAIMIABBggQ7AQgLIAdBEGokACAACxkAIAAoAgAgATgCACAAIAAoAgBBCGo2AgAL5QEDBn0BfAF/AkAgACoCACICuyABKgIAIgO7oZlEAAAAAAAAgD5jBEBBASEJIAAqAgS7IAEqAgS7oZlEAAAAAAAAgD5jDQELQQAhCSACIAMQLkUNACAAKgIEIAEqAgQQLkUNACABKgIEIgIgACoCBCIDIAEqAgAiBiAAKgIAIgcgBiAHXRsiBCADIARdGyIEIAIgBF0bjCIEIAIgAyAGIAcgBiAHXhsiBSADIAVeGyIFIAIgBV4bIgUgBCAFXhu7IgggCCAHuyAGu6EiCCAIoiADuyACu6EiCCAIoqCfoBBhIQkLIAkLJAEBfyAAIQIDQCAAIAIoAhQiAkcEQCABIAJHDQELCyAAIAJHCwsAIAAoAtABKAIgC4IDAgR/An4CQCAAKQNwIgVQRSAFIAApA3ggACgCBCIBIAAoAiwiAmusfCIGV3FFBEAjAEEQayICJABBfyEBAkACfyAAIAAoAkgiA0EBayADcjYCSCAAKAIUIAAoAhxHBEAgAEEAQQAgACgCJBECABoLIABBADYCHCAAQgA3AxAgACgCACIDQQRxBEAgACADQSByNgIAQX8MAQsgACAAKAIsIAAoAjBqIgQ2AgggACAENgIEIANBG3RBH3ULDQAgACACQQ9qQQEgACgCIBECAEEBRw0AIAItAA8hAQsgAkEQaiQAIAEiA0EATg0BIAAoAgQhASAAKAIsIQILIABCfzcDcCAAIAE2AmggACAGIAIgAWusfDcDeEF/DwsgBkIBfCEGIAAoAgQhASAAKAIIIQICQCAAKQNwIgVQDQAgBSAGfSIFIAIgAWusWQ0AIAEgBadqIQILIAAgAjYCaCAAIAYgACgCLCIAIAFrrHw3A3ggACABTwRAIAFBAWsgAzoAAAsgAwuyCAELfwJ/IABFBEAgARCYAQwBCyABQUBPBEBBmNUAQTA2AgBBAAwBCwJ/QRAgAUELakF4cSABQQtJGyEGIABBCGsiBSgCBCIJQXhxIQQCQCAJQQNxRQRAQQAgBkGAAkkNAhogBkEEaiAETQRAIAUhAiAEIAZrQazaACgCAEEBdE0NAgtBAAwCCyAEIAVqIQcCQCAEIAZPBEAgBCAGayIDQRBJDQEgBSAJQQFxIAZyQQJyNgIEIAUgBmoiAiADQQNyNgIEIAcgBygCBEEBcjYCBCACIAMQ5AIMAQsgB0Hk1gAoAgBGBEBB2NYAKAIAIARqIgQgBk0NAiAFIAlBAXEgBnJBAnI2AgQgBSAGaiIDIAQgBmsiAkEBcjYCBEHY1gAgAjYCAEHk1gAgAzYCAAwBCyAHQeDWACgCAEYEQEHU1gAoAgAgBGoiAyAGSQ0CAkAgAyAGayICQRBPBEAgBSAJQQFxIAZyQQJyNgIEIAUgBmoiBCACQQFyNgIEIAMgBWoiAyACNgIAIAMgAygCBEF+cTYCBAwBCyAFIAlBAXEgA3JBAnI2AgQgAyAFaiICIAIoAgRBAXI2AgRBACECQQAhBAtB4NYAIAQ2AgBB1NYAIAI2AgAMAQsgBygCBCIDQQJxDQEgA0F4cSAEaiIKIAZJDQEgCiAGayEMAkAgA0H/AU0EQCAHKAIIIgQgA0EDdiICQQN0QfTWAGpGGiAEIAcoAgwiA0YEQEHM1gBBzNYAKAIAQX4gAndxNgIADAILIAQgAzYCDCADIAQ2AggMAQsgBygCGCELAkAgByAHKAIMIghHBEAgBygCCCICQdzWACgCAEkaIAIgCDYCDCAIIAI2AggMAQsCQCAHQRRqIgQoAgAiAg0AIAdBEGoiBCgCACICDQBBACEIDAELA0AgBCEDIAIiCEEUaiIEKAIAIgINACAIQRBqIQQgCCgCECICDQALIANBADYCAAsgC0UNAAJAIAcgBygCHCIDQQJ0QfzYAGoiAigCAEYEQCACIAg2AgAgCA0BQdDWAEHQ1gAoAgBBfiADd3E2AgAMAgsgC0EQQRQgCygCECAHRhtqIAg2AgAgCEUNAQsgCCALNgIYIAcoAhAiAgRAIAggAjYCECACIAg2AhgLIAcoAhQiAkUNACAIIAI2AhQgAiAINgIYCyAMQQ9NBEAgBSAJQQFxIApyQQJyNgIEIAUgCmoiAiACKAIEQQFyNgIEDAELIAUgCUEBcSAGckECcjYCBCAFIAZqIgMgDEEDcjYCBCAFIApqIgIgAigCBEEBcjYCBCADIAwQ5AILIAUhAgsgAgsiAgRAIAJBCGoMAQtBACABEJgBIgVFDQAaIAUgAEF8QXggAEEEaygCACICQQNxGyACQXhxaiICIAEgASACSxsQLBogABAtIAULIgAgAUVyRQRAEAYACyAAC4YCAQR/QQ8hAQJAIAAqAhhDAAAAAFwNACAAKgIcQwAAAABcDQAgACoCIEMAAIA/XA0AQQAgACgCECIBQf////8HcWsgASABQQBIGyEBQQAgACgCACICQf////8HcWsgAiACQQBIGyECIAAqAghDAAAAAFwgACoCFEMAAAAAXHIhBEEAIAAoAgwiA0H/////B3FrIAMgA0EASBsiA0EAIAAoAgQiAEH/////B3FrIAAgAEEASBsiAHIEQCABIAJyRUEEdEEAIAMbQQAgABsgBHJBBnIPCyAEIARBAnIiACABQYCAgPwDRhsgACACQYCAgPwDRhsgAUEAR0EEdEEAIAIbciEBCyABC+ABAQR/IwBBIGsiAyQAIAAoAgghBQJAAkACQCABRQ0AIAEgBWoiBkEASA0BIAYgACgCBEoEQCAGQQRqIgRBAnYgBGoiBEEASA0DIAAgBDYCBCAAIAAoAgAgBEEDdBA/NgIACyAAIAY2AgggAkUNACAAKAIAIAVBA3RqIAIgAUEDdBAsGgsgACgCACEAIANBIGokACAAIAVBA3RqDwsgA0HiAjYCFCADQZkWNgIYIANB2Qw2AhBB1xkgA0EQahApAAsgA0H2AjYCBCADQbYWNgIIIANB2Qw2AgBB1xkgAxApAAu2AgEFfyAALQAUBEBBACAAKAIAKAIAKAIAIgEoAgQiAmtBA3EiA0EQciABKAIIIAJrSwRAIAFBEEEEEDFBACABKAIEIgJrQQNxIQMLIAEgAiADaiIDQRBqNgIEIAMgACkCDDcCCCADIAApAgQ3AgAgACgCACICIAIoAvQBIgFBAWo2AvQBAkAgAQRAQQAgAigCACgCACIEKAIEIgFrQQdxIgVB0AFyIAQoAgggAWtLBEAgBEHQAUEIEDFBACAEKAIEIgFrQQdxIQULIAQgASAFaiIBQdABajYCBCABQQBB0AEQNxoMAQsgAkEIaiEBCyABIAIoAtgBIgQ2AqABIAQEQCAEIAE2ApwBCyACIAE2AtgBIAEgA0MAAIA/IAJBARDiASABQagBaiADQQIQNBogAEEAOgAUCwu/AQEDfyAALQAAQSBxRQRAAkAgASEDAkAgAiAAIgEoAhAiAAR/IAAFIAEQ7AINASABKAIQCyABKAIUIgVrSwRAIAEgAyACIAEoAiQRAgAaDAILAkAgASgCUEEASA0AIAIhAANAIAAiBEUNASADIARBAWsiAGotAABBCkcNAAsgASADIAQgASgCJBECACAESQ0BIAMgBGohAyACIARrIQIgASgCFCEFCyAFIAMgAhAsGiABIAEoAhQgAmo2AhQLCwsL6AMCA38CfSMAQdAAayIDJAAgACoCDEMAAIA5lCIGIAAqAjwgASoCAJOLYARAIABBQGsqAgAgASoCBJOLIAZfIQQLQQAQjAIhBQJAIAQEQCAFIAAoAlhGDQELAkAgBEUNACAALQCNAQ0BIAJFDQAgAyACKAIgNgJIIANBQGsgAikCGDcDACADIAIpAhA3AzggAyACKQIINwMwIAMgAikCADcDKANAAkACQAJAIANBKGogAxCPAQ4HBAABAQIEBAMLIAMqAgAgAyoCCFwNBCADKgIEIAMqAgxbDQIMBAsgAyoCACIGIAMqAghcDQMgAyoCBCIHIAMqAgxcDQMgBiADKgIQXA0DIAcgAyoCFFsNAQwDCyADKgIAIgYgAyoCCFwNAiADKgIEIgcgAyoCDFwNAiAGIAMqAhBcDQIgByADKgIUXA0CIAYgAyoCGFwNAiAHIAMqAhxbDQALDAELIAAgASADQShqIANBARDJAUUNACAAQewAaiABKgIAIAMqAiiSIAEqAgQgAyoCLJIQJxogAEHgAGogASoCACADKgIokyABKgIEIAMqAiyTECcaIABBAToAjQEgACABKQIANwI8IAAgAykDADcCLCAAIAMpAyg3AhwgACAAKAJQQQFqNgJQCyADQdAAaiQACzMBAn8gACgCACIABEADQCAAQQFrLQAAIQEgACAAQQVrKAAAEQEAIgIgAWshACACDQALCwttAQF/IwBBgAJrIgUkACAEQYDABHEgAiADTHJFBEAgBSABQf8BcSACIANrIgJBgAIgAkGAAkkiARsQNxogAUUEQANAIAAgBUGAAhBDIAJBgAJrIgJB/wFLDQALCyAAIAUgAhBDCyAFQYACaiQACyEAIABBPGoQtAEgACgCLBAlIAAoAiAQJSAAKAIUECUgAAtUAQJ/IwBBEGsiBCQAIARBCGogAEEAQQAQKiEDIAAgACgCACgCHDYCBCADKAIAQQBDAAAAABAwIgMgAjgCBCADIAE4AgAgAEGCBDsBCCAEQRBqJAALkAMCAX8CfCMAQYAEayIFJAAgBUHwA2ogASACIAEoAgAoAhwRBgAgBSADKQMINwPYAyAFIAMpAwA3A9ADIAUgAysDACAFKwP4A6A5A+ADIAUgAysDCCAFKwPwA6E5A+gDIAVBADsBxAMgBUEAOgDJAyAFQQBBwAMQNyIBQQA6AMYDIAFBgAI7AMcDIAFBADYCwAMCQAJAAkAgBCABIAFB0ANqIAQoAgAoAjARAgAiBA4EAAEBAAELIABBADoAGCAAQoCAgICAgID4v383AxAgAEKAgICAgICA/P8ANwMIIABCgICAgICAgPz/ADcDAAwBCyAAIAErA/ABOQMQIAAgASkDADcDACAAIAEpAwg3AwgCQCAEQQJHDQAgASsDECADKwMAIgKhIgYgBqIgASsDGCADKwMIIgahIgcgB6KgIAArAwAgAqEiAiACoiAAKwMIIAahIgIgAqKgY0UNACAAIAErA/gBOQMQIAAgASkDEDcDACAAIAEpAxg3AwgLIAAgAyAAEDg6ABgLIAFBgARqJAALdQEBfiAAIAEgBH4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCABIAJ+IANC/////w+DfCIBQiCIfDcDCCAAIAVC/////w+DIAFCIIaENwMAC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC+MDAgV/AnwjAEEQayIFJAACQAJ/AkACQCAARAAAAAAAAAAAYQRAIAGZRAAAAAAAAIA+Yw0BIAUgApogAaMiADkDAAwCCyAAmUQAAAAAAACAPmNFQQEgASAAIACgoyIJmUQAAAAAAABgQWQgAiAAoyIKmUQAAAAAAABgQWQbRXJFBEAgAZlEAAAAAAAAgD5jDQEgBSACmiABoyIAOQMADAILIAkgCaIiACAKEGEhBiAAIApjBEAgBkUNBAsgBSAAIAqhn0QAAAAAAAAAACAAIApkGyIBIAmhIgA5AwAgBSABmiAJoSIBOQMIQQFBAiAAIAEQYRsMAgsgBUIANwMARAAAAAAAAAAAIQAgAkQAAAAAAAAAAGINAgtBAQshCEEAIQYDQAJAIABEAAAAAAAAgL5kRSAARAAAACAAAPA/Y0VyDQBEAAAAAAAAAABEAAAAAAAA8D8gACAARAAAAMD//+8/ZBsgAEQAAAAAAACAPmMbIQBBACEHIARBAEoEQANAIAMgB0EDdGorAwAgAKGZRAAAAAAAAIA+Yw0CIAdBAWoiByAERw0ACwsgAyAEQQN0aiAAOQMAIARBAWohBAsgBkEBaiIGIAhGDQEgBSAGQQN0aisDACEADAALAAsgBUEQaiQAIAQL3QMCC3wCfSAAKwMAtiABKwMAtiAAKwMQthCkAUUEQEQAAAAAAADwvw8LIAArAwi2IAErAwi2IAArAxi2EKQBRQRARAAAAAAAAPC/DwtEAAAAAAAAAAAgACsDECIIIAArAwAiA6EiBCABKwMAIgwgA6GiIAArAxgiCSAAKwMIIgehIgogASsDCCINIAehoqAiBaEgBCAEoiAKIAqioCIGIAWhokQAAAAAAAAAAGVFBEBEAAAAAAAA8L8PCwJAIAZEAAAAAAAAAABhDQAgByEKAnwgAyAFIAajIgVEAAAAAAAAAABhDQAaIAkhCiAIIAVEAAAAAAAA8D9hDQAaRAAAAAAAAPA/IAWhIgQgB6IgBSAJoqAhCiAEIAOiIAUgCKKgCyEERAAAAAAAAPC/IQsgCSAIIAcgAyADIAdkGyIGIAYgCGQbIgYgBiAJZBuaIgYgCSAIIAcgAyADIAdjGyIDIAMgCGMbIgMgAyAJYxsiAyADIAZjGyIDtiIOIAQgDKEiBCAEoiAKIA2hIgQgBKKgnyADoLYiDxDYAUUNACACBEAgAiAOIA9cOgAAC0QAAAAAAAAAAEQAAAAAAADwPyAFIAVE+P//////7z9kGyAFRAAAAAAAANA8YxshCwsgCwvqAQEIfCACRAAAAAAAAAAAYQRAIAAgASkDADcDACAAIAEpAwg3AwgPCyACRAAAAAAAAPA/YQRAIAAgASkDMDcDACAAIAEpAzg3AwgPCyABKwMwIQQgASsDICEFIAErAxAhBiABKwMAIQcgACACIAKiIgMgAqIiCCABKwM4oiADRAAAAAAAAPA/IAKhIgNEAAAAAAAACECioiIJIAErAyiiIAMgAyADoiIDoiIKIAErAwiiIANEAAAAAAAACECiIAKiIgIgASsDGKKgoKA5AwggACAIIASiIAkgBaIgCiAHoiACIAaioKCgOQMAC8QDAQZ/AkAgAbwiBkEBdCIERSAGQf////8HcUGAgID8B0tyRQRAIAC8IgdBF3ZB/wFxIgNB/wFHDQELIAAgAZQiACAAlQ8LIAQgB0EBdCICTwRAIABDAAAAAJQgACACIARGGw8LIAZBF3ZB/wFxIQUCfyADRQRAQQAhAyAHQQl0IgJBAE4EQANAIANBAWshAyACQQF0IgJBAE4NAAsLIAdBASADa3QMAQsgB0H///8DcUGAgIAEcgshAgJ/IAVFBEBBACEFIAZBCXQiBEEATgRAA0AgBUEBayEFIARBAXQiBEEATg0ACwsgBkEBIAVrdAwBCyAGQf///wNxQYCAgARyCyEGIAMgBUoEQANAAkAgAiAGayIEQQBIDQAgBCICDQAgAEMAAAAAlA8LIAJBAXQhAiADQQFrIgMgBUoNAAsgBSEDCwJAIAIgBmsiBEEASA0AIAQiAg0AIABDAAAAAJQPCwJAIAJB////A0sEQCACIQQMAQsDQCADQQFrIQMgAkGAgIACSSEFIAJBAXQiBCECIAUNAAsLIAdBgICAgHhxIQIgA0EASgR/IARBgICABGsgA0EXdHIFIARBASADa3YLIAJyvguaAQECfyAAIAFHBEAgASgCACIDIAMoAgBBAWo2AgAgACgCACECIAAgAzYCAAJAIAJFDQAgAiACKAIAIgNBAWs2AgAgA0EBRw0AIAIQRxAtCyAAIAEoAgQ2AgQgACAALQAKQXxxIAEtAApBA3FyIgI6AAogACACQfsBcSABLQAKQQRxcjoACiAAIAEtAAg6AAggACABLQAJOgAJCwu/CQIEfgR/IwBB8ABrIgokACAEQv///////////wCDIQUCQAJAIAFQIgkgAkL///////////8AgyIGQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIAZQG0UEQCADQgBSIAVCgICAgICAwP//AH0iB0KAgICAgIDAgIB/ViAHQoCAgICAgMCAgH9RGw0BCyAJIAZCgICAgICAwP//AFQgBkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIAZCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIJGyEEQgAgASAJGyEDDAILIAMgBUKAgICAgIDA//8AhYRQDQEgASAGhFAEQCADIAWEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAWEUEUNACABIQMgAiEEDAELIAMgASABIANUIAUgBlYgBSAGURsiCxshBSAEIAIgCxsiB0L///////8/gyEGIAIgBCALGyICQjCIp0H//wFxIQwgB0IwiKdB//8BcSIJRQRAIApB4ABqIAUgBiAFIAYgBlAiCRt5IAlBBnStfKciCUEPaxBLIAopA2ghBiAKKQNgIQVBECAJayEJCyABIAMgCxshAyACQv///////z+DIQQgDEUEQCAKQdAAaiADIAQgAyAEIARQIgsbeSALQQZ0rXynIgtBD2sQS0EQIAtrIQwgCikDWCEEIAopA1AhAwsgBEIDhiADQj2IhEKAgICAgICABIQhBCAGQgOGIAVCPYiEIQYgAiAHhSEIAn4gA0IDhiIBIAkgDGsiC0UNABogC0H/AEsEQEIAIQRCAQwBCyAKQUBrIAEgBEGAASALaxBLIApBMGogASAEIAsQlgEgCikDOCEEIAopAzAgCikDQCAKKQNIhEIAUq2ECyEBIAZCgICAgICAgASEIQMgBUIDhiECAkAgCEIAUwRAIAIgAX0iBSADIAR9IAEgAlatfSIEhFAEQEIAIQNCACEEDAMLIARC/////////wNWDQEgCkEgaiAFIAQgBSAEIARQIgsbeSALQQZ0rXynQQxrIgsQSyAJIAtrIQkgCikDKCEEIAopAyAhBQwBCyABIAJ8IgUgAVStIAMgBHx8IgRCgICAgICAgAiDUA0AIAVCAYMgBEI/hiAFQgGIhIQhBSAJQQFqIQkgBEIBiCEECyAHQoCAgICAgICAgH+DIQEgCUH//wFOBEAgAUKAgICAgIDA//8AhCEEQgAhAwwBC0EAIQsCQCAJQQBKBEAgCSELDAELIApBEGogBSAEIAlB/wBqEEsgCiAFIARBASAJaxCWASAKKQMAIAopAxAgCikDGIRCAFKthCEFIAopAwghBAsgBEI9hiAFQgOIhCICIAWnQQdxIglBBEutfCIDIAJUrSAEQgOIQv///////z+DIAutQjCGhCABhHwhBAJAIAlBBEYEQCAEIANCAYMiASADfCIDIAFUrXwhBAwBCyAJRQ0BCwsgACADNwMAIAAgBDcDCCAKQfAAaiQAC8YBAgN/An0jAEEQayIGJAAgACgCBCIFQQBIBEAgACgCACIHKAIoBEAgBygCFCAFQX9zQQN0aiIFKgIEIQkgBSoCACEICyAGQQhqIABBAEEAECohBSAAIAAoAgAoAhw2AgQgBSgCAEEAQwAAAAAQMCIFIAk4AgQgBSAIOAIAIABBggQ7AQgLIAYgAEEAQQAQKigCAEECQwAAAAAQMCIFIAM4AgggBSACOAIEIAUgATgCACAFIAQ4AgwgAEGCBDsBCCAGQRBqJAALVwECfxBpIQIgACgCACEBIAAgAjYCAAJAIAFFDQAgASABKAIAIgJBAWs2AgAgAkEBRw0AIAEQRxAtCyAAQX82AgQgAEGCBDsBCCAAIAAtAApB/AFxOgAKC34CAn8BfiMAQRBrIgMkACAAAn4gAUUEQEIADAELIAMgASABQR91IgJqIAJzIgKtQgAgAmciAkHRAGoQSyADKQMIQoCAgICAgMAAhUGegAEgAmutQjCGfCABQYCAgIB4ca1CIIaEIQQgAykDAAs3AwAgACAENwMIIANBEGokAAtgAQJ/An8gAItDAAAANV8EQEEBIAGLQwAAADVfDQEaC0EAIAC8IgJB/////wdxayACIAJBAEgbIgNBACABvCICQf////8HcWsgAiACQQBIGyICQQhqSCACIANBCGpIcQsLXwECfCABKwMIIQICfCABKwMAIgMgACsDAGEEQEQAAAAAAAAAACACIAArAwhhDQEaC0QAAAAAAADwP0QAAAAAAADwvyACIAArAxhhG0QAAAAAAADwvyADIAArAxBhGwsLCwAgACABEJ4DEHYLYAECfwJ/IACLQwAAADRfBEBBASABi0MAAAA0Xw0BGgtBACAAvCICQf////8HcWsgAiACQQBIGyIDQQAgAbwiAkH/////B3FrIAIgAkEASBsiAkECakggAiADQQJqSHELC7QBAQZ8IAJEAAAAAAAAAABhBEAgACABKQMANwMAIAAgASkDCDcDCA8LIAJEAAAAAAAA8D9hBEAgACABKQMgNwMAIAAgASkDKDcDCA8LIAErAyAhBCABKwMQIQUgASsDACEGIAAgAiACoiIHIAErAyiiRAAAAAAAAPA/IAKhIgMgA6IiCCABKwMIoiADIAOgIAKiIgIgASsDGKKgoDkDCCAAIAcgBKIgCCAGoiACIAWioKA5AwAL8QECBnwBfSACRAAAAAAAAAAAYQRAIAAgASkDADcDACAAIAEpAwg3AwgPCyACRAAAAAAAAPA/YQRAIAAgASkDIDcDACAAIAEpAyg3AwgPCyABKwMgIQYgASsDECEHIAErAwAhBSAAIAErAwgiAyABKwMoIAErAxggASoCMCIJuyIIoiIEIASgoaAgAqIgBCADoSIEIASgoCACoiADoCAJQwAAgL+SIgkgCZK7IgMgAyACoqEgAqJEAAAAAAAA8D+gIgSjOQMIIAAgBSAFIAYgByAIoiIDIAOgoaAgAqIgAyAFoSIFIAWgoCACoqAgBKM5AwALuwEBBH8jAEEgayIBJAACQCAAKAIIIgNBAWoiBEEATgRAAkAgBCAAKAIETARAIAAoAgAhAgwBCyADQQVqIgJBAnYgAmoiAkEASA0CIAAgAjYCBCAAIAAoAgAgAhA/IgI2AgALIAAgBDYCCCABQSBqJAAgAiADag8LIAFB4gI2AhQgAUGZFjYCGCABQdkMNgIQQdcZIAFBEGoQKQALIAFB9gI2AgQgAUG2FjYCCCABQdkMNgIAQdcZIAEQKQALwwEBA38jAEEgayICJAAgACgCCCEEAkACQCABBEAgASAEaiIBQQBIDQEgASAAKAIESgRAIAFBBGoiA0ECdiADaiIDQQBIDQMgACADNgIEIAAgACgCACADQQJ0ED82AgALIAAgATYCCAsgACgCACEAIAJBIGokACAAIARBAnRqDwsgAkHiAjYCFCACQZkWNgIYIAJB2Qw2AhBB1xkgAkEQahApAAsgAkH2AjYCBCACQbYWNgIIIAJB2Qw2AgBB1xkgAhApAAuYAQMCfQF/A3wgAAJ9QwAAAAAgAbsgACoCALsiBSAFoiAAKgIEuyIGIAaioJ+jIgcgBaK2IgG8QYCAgPwHcUGAgID8B0YNABpDAAAAACAHIAaitiIDvEGAgID8B3FBgICA/AdGDQAaIAFDAAAAAFsEQEMAAAAAIANDAAAAAFsNARoLQQEhBCABIQIgAws4AgQgACACOAIAIAQLIgEBfSAAKgIAIQMgAiAAKgIEIAGUOAIEIAIgAyABlDgCAAvUAQIDfwJ9IwBBEGsiCCQAIAAoAgQiB0EASARAIAAoAgAiCSgCKARAIAkoAhQgB0F/c0EDdGoiByoCBCELIAcqAgAhCgsgCEEIaiAAQQBBABAqIQcgACAAKAIAKAIcNgIEIAcoAgBBAEMAAAAAEDAiByALOAIEIAcgCjgCACAAQYIEOwEICyAIIABBAEEAECooAgBBBEMAAAAAEDAiByAFOAIQIAcgAzgCCCAHIAI4AgQgByABOAIAIAcgBjgCFCAHIAQ4AgwgAEGCBDsBCCAIQRBqJAAL4wMDA38CfQF8AkAgAEMAAAAAWwRAIAIgAowgAkMAAAAAXiIFGyIAIAGMIAEgBRsiAWAgAUMAAAAAW3IgAEMAAAAAW3INASAAIAGVIgBDAAAAAF4gAEMAAAAAXXJFDQEgAyAAOAIAQQEPCyABuyIJIAmiIAC7RAAAAAAAABDAoiACu6KgIglEAAAAAAAAAABjDQAgCZ+2Ige8QYCAgPwHcUGAgID8B0YNACADAn9BACAHjCAHIAFDAAAAAF0bIAGSQwAAAL+UIgGMIgggASABQwAAAABdIgYbIgcgAIwgACAGGyIAYA0AGkEAIABDAAAAAFsNABpBACAHQwAAAABbDQAaQQAgByAAlSIAQwAAAABeIABDAAAAAF1yRQ0AGiADIAA4AgBBAQtBAnRqIQQCQCACjCACIAJDAAAAAF0iBhsiACAIIAEgBhsiAWAgAEMAAAAAW3IgAUMAAAAAW3INACAAIAGVIgBDAAAAAF4gAEMAAAAAXXJFDQAgBCAAOAIAQQEhBQsCQCAEIAVBAnRqIgUgA2siBEEIRw0AIAMqAgAiACADKgIEIgFeBEAgAyAAOAIEIAMgATgCAEEIIQQMAQsgACABXARAQQghBAwBCyAFIANrQQRrIQQLIARBAnUhBAsgBAuIAQICfwJ8IACZIgREAAAA4P//70djRSABmSIFRAAAAOD//+9HY0VyRQRAQQAgALa8IgJB/////wdxayACIAJBAEgbIgNBACABtrwiAkH/////B3FrIAIgAkEASBsiAkEQakggAiADQRBqSHEPCyAAIAGhmSAFIAQgBCAFYxujRAAAAAAAAMA+YwvYBAIEfwJ8IAAgATYCACAAQYQIaiAAQQRqQYAIQeAEEKIBIQMgAEGfCGpCADcAACAAQgA3ApgIIAAoAgAhBUEAIABBiAhqKAIAIgJrQQdxIgRBmAFyIABBjAhqKAIAIAJrSwRAIANBmAFBCBAxQQAgACgCiAgiAmtBB3EhBAsgACACIARqIgJBmAFqNgKICCACQQA6ACAgAkKAgICAgICA+L9/NwMYIAJCgICAgICAgPz/ADcDECACQQA6AEAgAkKAgICAgICA+L9/NwM4IAJCgICAgICAgPz/ADcDCCACQoCAgICAgID8/wA3AzAgAkKAgICAgICA/P8ANwMoIAUgAyAFKAIAKAI4EQAAIQMgAkEAOgCUASACQQA6AJEBIAIgAzYCACAAIAI2ApQIIAAgACgCoAhBAWo2AqAIIAJCgICAgICAgPg/NwOAASACQgA3A3ggAkEANgJQIAJCADcDSCACQQA7AZIBIAFEAAAAAAAAAABEAAAAAAAA8D8gAyABKAIAKAJUEQoAIAJB2ABqIAIoAgAQYyACQQA6ACAgAkKAgICAgICA+L9/NwMYIAJCgICAgICAgPz/ADcDECACQQA6AEAgAkKAgICAgICA+L9/NwM4IAJCgICAgICAgPz/ADcDCCACQoCAgICAgID8/wA3AzAgAkKAgICAgICA/P8ANwMoIAIgAisDcCACKwNgoSIGIAIrA2ggAisDWKEiByAGIAdkGzkDiAEgAigCACIBIAEoAgAoAhARAQAhASACQQA6AJQBIAJBADoAkQEgAiABOgCQASAACxEAIAEgACABKAIAKAJQEQMAC+gCAgN/AXwjAEEQayIBJAACfSAAvCIDQf////8HcSICQdqfpPoDTQRAQwAAgD8gAkGAgIDMA0kNARogALsQZgwBCyACQdGn7YMETQRAIAC7IQQgAkHkl9uABE8EQEQYLURU+yEJwEQYLURU+yEJQCADQQBOGyAEoBBmjAwCCyADQQBIBEAgBEQYLURU+yH5P6AQZQwCC0QYLURU+yH5PyAEoRBlDAELIAJB1eOIhwRNBEAgAkHg27+FBE8EQEQYLURU+yEZwEQYLURU+yEZQCADQQBOGyAAu6AQZgwCCyADQQBIBEBE0iEzf3zZEsAgALuhEGUMAgsgALtE0iEzf3zZEsCgEGUMAQsgACAAkyACQYCAgPwHTw0AGgJAAkACQAJAIAAgAUEIahCCAkEDcQ4DAAECAwsgASsDCBBmDAMLIAErAwiaEGUMAgsgASsDCBBmjAwBCyABKwMIEGULIQAgAUEQaiQAIAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYL+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahBLIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAuMAgEDfwJAIAJFDQAgACgCCCIDBEAg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BKE5A/gDQQAhCCADQQA7AdQDIANBADoA2QMgA0EQaiIEQQBBwAMQNxogA0EAOgDWAyADQYACOwDXAyADQQA2AtADIAsoAqQBIAsqArgBIANB4ANqIAQgCygCxAFBAnRBgMkAaigCABEMACADLQDWAyIERQ0AA0BEAAAAAAAAAAAgCEEDdCADaisDgAIiEKFEAAAAAAAA8D8gEKGiRAAAAAAAAAAAZQRAIAMgA0EQaiAIQQR0aiIEKQMINwMIIAMgBCkDADcDACADIAEqAgi7OQOQBCADIAEqAgy7OQOYBAJAIAMgA0GQBGoQOEUNACALIBAQkgEiBCAFRg0AIAQoAhAgARDfARogBC0AGA0AIAEoAiAhCSAEECghDAJ/AkACQCAJKALEASIGIAwoAsQBIgdIDQAgBiAHSg0BIAYgBkEBakECdWtBAXRBAmoiD0EATA0AIAkoAqQBIQYgDCgCpAEhB0EAIQ0DQCAGKgIAIhUgByoCACIWXQ0BIBUgFl4NAiAHQQRqIQcgBkEEaiEGIA1BAWoiDSAPRw0ACwsgCSEGIAEhByAFIQkgAgwBCyAMIQYgCSEMIAQhByABIQQgAiEJIAULIQ0gBCsDACEQIAkrAwAhEwJAIAcrAwAiEiANKwMAIhFkRQRAIBIhFCARIRIgECERIBMhEAwBCyARIRQgEyERCyAAIAYgDCAUIBIgESAQIANBkARqEIcERQ0GCyADLQDWAyEECyAIQQFqIgggBEH/AXFJDQALCyAOQQFrIQggBSgCFCIFIAJHDQELCyAOQQFLDAELQQALIQUgA0GgBGokACAFC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLUgECf0H40wAoAgAiASAAQQNqQXxxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABAbRQ0BC0H40wAgADYCACABDwtBmNUAQTA2AgBBfwv+AgIBfAN/IwBBEGsiAiQAAkAgALwiBEH/////B3EiA0Han6T6A00EQCADQYCAgMwDSQ0BIAC7EGUhAAwBCyADQdGn7YMETQRAIAC7IQEgA0Hjl9uABE0EQCAEQQBIBEAgAUQYLURU+yH5P6AQZowhAAwDCyABRBgtRFT7Ifm/oBBmIQAMAgtEGC1EVPshCcBEGC1EVPshCUAgBEEAThsgAaCaEGUhAAwBCyADQdXjiIcETQRAIAC7IQEgA0Hf27+FBE0EQCAEQQBIBEAgAUTSITN/fNkSQKAQZiEADAMLIAFE0iEzf3zZEsCgEGaMIQAMAgtEGC1EVPshGcBEGC1EVPshGUAgBEEAThsgAaAQZSEADAELIANBgICA/AdPBEAgACAAkyEADAELAkACQAJAAkAgACACQQhqEIICQQNxDgMAAQIDCyACKwMIEGUhAAwDCyACKwMIEGYhAAwCCyACKwMImhBlIQAMAQsgAisDCBBmjCEACyACQRBqJAAgAAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSRtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEsbQZIPaiEBCyAAIAFB/wdqrUI0hr+iC9oFAwV/BH0BfgJAIAAoAgQiAyAAKAIIIgVGBEAgAC0AIUUEQEEGDwsCQCAAKgIYIgcgACoCECIIWyAAKgIUIgkgACoCHCIKW3FFBEAgByAHXCAKIApcciAIIAhcIAkgCVxycg0BDAMLIAEgACkCEDcCAAsgAEEAOgAhQQUPCyAAIANBAWoiBjYCBCAAKAIAIQICQAJAAkACQAJAAkACQCADLQAAIgQOBgABAwIEBQYLIAAtACEEQCAAIAM2AgQCQCAAKgIYIgcgACoCECIIWyAAKgIUIgkgACoCHCIKW3FFBEAgByAHXCAKIApcciAIIAhcIAkgCVxycg0BDAkLIAEgACkCEDcCAAsgAEEAOgAhQQUPCyAFIAZGBEBBBg8LIAAgAikCADcCECABIAIpAgA3AgAgACAAKQIQNwIYIAAgAC0AIDoAISAAIAJBCGo2AgBBAA8LIAEgACkCGDcCACABIAIpAgA3AgggAikCACELIABBADoAIiAAIAs3AhggACACQQhqNgIAQQEPCyAAIAAoAgxBBGo2AgwLIAEgACkCGDcCACABIAIpAgA3AgggASACKQIINwIQIAAgAikCCDcCGCAAIAJBEGo2AgAgBA8LIAEgACkCGDcCACABIAIpAgA3AgggASACKQIINwIQIAEgAikCEDcCGCAAIAIpAhA3AhggACACQRhqNgIAQQQPCwJ/AkAgACoCGCIHIAAqAhAiCFsgACoCFCIJIAAqAhwiCltxRQRAIAcgB1wgCiAKXHIgCCAIXCAJIAlccnINASABIAApAhg3AgAgASAAKQIQNwIIIABBAToAIiAAIAAoAgRBAWs2AgQgACkCECELQQEMAgsgASAAKQIQNwIACyAAQQA6ACEgACkCECELQQULIQQgACALNwIYCyAAIAI2AgAgBA8LIAEgACkCGDcCACABIAApAhA3AgggAEEBOgAiIAAgACkCEDcCGEEBCzgBAX8gACgCJCIEQYABcQRAIAAgABBAIgQ2AiQLIAAgASACIAMgBEEPcUECdEGA0ABqKAIAEQcAC8MBAgR9A38gACoCDCEDIAAoAhQhByAAKgIIIQQgACgCECEIIAEgACgCACIJrSAAKAIEIgCtQiCGhDcCACABIAitIAetQiCGhDcCICABIAQgCb4iBZMgApQgBZIiBbytIAMgAL4iBpMgApQgBpIiBrytQiCGhDcCCCABIAQgCL4gBJMgApSSIgS8rSADIAe+IAOTIAKUkiIDvK1CIIaENwIYIAEgBSAEIAWTIAKUkrytIAYgAyAGkyAClJK8rUIghoQ3AhALSgECfyMAQRBrIgIkACACQQhqIgMgACgCpAEgACoCuAEgASAAKALEAUECdEHgygBqKAIAEQgAIAAgASADEOYBIQAgAkEQaiQAIAALpQQBCH8CQAJAAkAgASgCyAEiBEUEQCABIQMMAQsgACECA0ACQCADIQUgAigCyAEiAkUNACAFQQFqIQMgACACRw0BCwtBACEDAkAgASAERiIGDQAgBCECA0AgA0EBaiEDIAIoAsgBIgJFDQEgASACRw0ACwsCQCADIAVNBEAgASECA0AgACACRg0CIAIoAsgBIgIgAUcNAAsgAUEANgLIASAAIAEQ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AFUgAygCACEBCyABKAIUIQYgASgCLCEBIANCADcCICADQQA6ABwgAyABNgIUIAMgBjYCECADIAU2AgwgA0IANwIoIANCADcCMCADQwAAgD8gApVDAAAAP5Q4AhggACgCACEBIAAgAzYCACABDQEMAgsgACgCACEBIABBADYCACABRQ0BCyABKAIsECUgASgCIBAlIAEQKyABEC0LIAAhASAAQQA2AgQgBEEIaiABEIIDIAQoAgghAyAEQQA2AgggACgCBCEBIAAgAzYCBAJAIAFFDQAgASABKAIEIgNBAWs2AgQgA0EBRgRAIAEgASgCACgCCBEEAAsgBCgCCCIBRQ0AIAEgASgCBCIDQQFrNgIEIANBAUcNACABIAEoAgAoAggRBAALIARBEGokACAAC8kDAgF/A30jAEFAaiIGJAAgASACIAMgBkE4ahC4AQJAIAYqAjhDAAAAAFwNACAGKgI8QwAAAABcDQACQCACi0MAAIA5XwRAIAEqAhQhByABKgIEIQggBiABKgIQIAEqAgCTIgI4AjggBiAHIAiTIgc4AjwMAQtDAACAPyACk4tDAACAOV8EQCABKgIMIQcgASoCHCEIIAYgASoCGCABKgIIkyICOAI4IAYgCCAHkyIHOAI8DAELIAEgBiACEHkgBiAGKgIcIgggBioCFJMiBzgCPCAGIAYqAhgiCSAGKgIQkyICOAI4IAJDAAAAAFwgB0MAAAAAXHINACAGIAggBioCDJMiBzgCPCAGIAkgBioCCJMiAjgCOCAGIQELIAJDAAAAAFwgB0MAAAAAXHINACABKgIcIQIgASoCBCEHIAYgASoCGCABKgIAkzgCOCAGIAIgB5M4AjwLIAZBOGoiASAAIAEgACoCABBdIgEbKgIAIQIgBCAAKAKEAbIiByAGKgI8QwAAAAAgARsiCJQgAyoCAJIiCTgCACAEIAMqAgQgByAClJMiBzgCBCAFBEAgBSAHIAiSOAIEIAUgCSACkjgCAAsgBkFAayQACy0AIAIgASgCACIBKAIcSQRAIAAgASgCFCACQQN0aikCADcCAA8LIABCADcCAAv0AQEBfyMAQSBrIgQkACAAIAE2AgQgACABNgIAIAAgASACajYCCCAAIAMgAkGACCACGyADGyIDQQZ0NgIMAkAgA0H///8fcSIDQf///x9HBEAgAw0BIARBLTYCBCAEQdUONgIIIARB+ww2AgBB1xkgBBApAAsgBEEuNgIUIARBzhY2AhggBEH7DDYCEEHXGSAEQRBqECkACwJAIAJBBE0EQCAAQQA2AgggAEIANwIADAELIAFFDQAgAUH5ATYAACAAIAAoAgQiAUEEajYCBCABQQA6AAQgACAAKAIEQQFqIgE2AgAgACABNgIECyAEQSBqJAAgAAvBAQEGfwJAA0AgACECA0ACQCACLQD8AQ0AIAIoAvQBBEAgAkEIaiEDQQEhBQNAAkAgAygCwAEgAygCvAFGDQAgAyEBA0AgASgCQCEGIAEtAFhFBEAgASgCREGBgICAeEcNCCABIAAQtAMNCAtBACEFIAYrAwBEAAAAAAAA8D9hDQEgBiIBDQALCyADKAKcASIDDQALIAVFDQELIAJBAToA/AELIAIoAtwBIgINAAsgBEEBaiIEQQpHDQALQQAhAQsgAQuEAwICfwF9AkAgACACXwRAAkAgAItDAAAANF9FIAGLIgVDAAAANF9FckUEQCABQwAAgDSSIABeDQEMAwtBACABvCIEQf////8HcWsgBCAEQQBIG0ECakEAIAC8IgRB/////wdxayAEIARBAEgbTA0CCyAFQwAAADRfRSACi0MAAAA0X0VyRQRAIAJDAACANJIgAV4PC0EAIAK8IgNB/////wdxayADIANBAEgbQQJqQQAgAbwiA0H/////B3FrIAMgA0EASBtKDwsCQCABiyIFQwAAADRfRSAAi0MAAAA0X0VyRQRAIABDAACANJIgAV4NAQwCC0EAIAC8IgRB/////wdxayAEIARBAEgbQQJqQQAgAbwiBEH/////B3FrIAQgBEEASBtMDQELIAKLQwAAADRfRSAFQwAAADRfRXJFBEAgAUMAAIA0kiACXg8LQQAgAbwiA0H/////B3FrIAMgA0EASBtBAmpBACACvCIDQf////8HcWsgAyADQQBIG0ohAwsgAwvucAMXfwp8A34jAEHACGsiDCQAIAJBADoAxgMgAkEBOgDIAyACQQA2AsADIAIgACgCACIDIAMoAgAoAjwRAQBBBGo6AMcDAkAgACAAKAKUCCIEIAEgASgClAgiBSAMQbwIahC+AyIDRQ0AAkAgA0ECRw0AIAwoArwIQQJHDQAgACABIAIQuwMaDAELIABBhAhqIRQgAEEAIABBiAhqKAIA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QQBMDQAgACgCGCEMA0AgDCAEQQJ0aiIFKAIAIQIgAUEoahA1IQsgAUGIAWoQNSEHIAEgCzYCrAEgAUEANgKoASABQgA3A6ABIAFCATcDmAEgAUEANgKUASAHEFMgAUEANgK4ASABQgA3A7ABAkAgAisDACIYRAAAAAAAAAAAYiAYRAAAAAAAAPA/YnENAANAIAEgAigCECICQSxBwAAgGEQAAAAAAAAAAGIiAxtqKAIANgJYIAFBAUF/IAMbNgLYASACKAIgIAFB2ABqIAFB2AFqQQBBABBuIgZFDQEgASgCWCIDIANBLEHAACADKwMAIhhEAAAAAAAAAABiG2ooAgAiAiAYIAIrAwBjGy0AWQ0BIAYgAyACIAFBiAFqEG8aIAUgAjYCACACKwMAIhhEAAAAAAAAAABhIBhEAAAAAAAA8D9hcg0ACwsgAUGIAWoQgAECQCABKAKYAUF+cUUNACAAKAIMIARBAXZBDGxqIQIgASgClAEhBSAEQQFxBEAgAUKAgID8gwI3A3ggAUIANwNwIAFCgICA/AM3A2ggAUIANwNgIAFCgICA/AM3A1ggAUHYAGoiAxBsIAIgBSADQQEQawwBCyABQdgBahA1IgMgBRCPAyABQoCAgPyDAjcDeCABQgA3A3AgAUKAgID8AzcDaCABQgA3A2AgAUKAgID8AzcDWCABQdgAaiIFEGwgAyACIAVBARBrIAIgAxBQIAMQKwsgASgCoAEQJUEAIQIgASkDmAEiFUL+////D4NQRQRAA0AgASgClAEgAkEMbGoQKyACQQFqIgIgASkDmAEiFadBAXZJDQALCyAVQgGDUEUEQCABKAKUARAlCyAHECsgCxArIARBAWoiBCAIRw0ACyAIQQJtIQsCfwJAAkACQCAIQQFqIhJBA0kNACAIQX5MDQFBACEFQQAgC0EFbEEUakF8cSICED8hCUEAIAIQPyEKQQAhAiALQQFrQQNPBEAgC0F8cSEHQQAhAwNAIAogAkECdCIEakH/////BzYCACAEIAlqQf////8HNgIAIAogBEEEciIGakH/////BzYCACAGIAlqQf////8HNgIAIAogBEEIciIGakH/////BzYCACAGIAlqQf////8HNgIAIAogBEEMciIEakH/////BzYCACAEIAlqQf////8HNgIAIAJBBGohAiADQQRqIgMgB0cNAAsLIAtBA3EiBEUNAANAIAogAkECdCIDakH/////BzYCACADIAlqQf////8HNgIAIAJBAWohAiAFQQFqIgUgBEcNAAsLIAhBAWsiFCAIbCINQQJtIQ4gASABQYgBajYCyAEgDUECSA0BIA1BfnEhAiAOrSEXQoCAgICAAiEWIAECfkKAgICAgAIgDkEJSSIDDQAaQoCAgICAAiACQRBGDQAaIAEgF0L/////ByAXQv////8HVBsiFUIhhjcCzAEgFadBCBBXIQQgASkCzAEiFadBAnRBeHEiBwRAIAQgASgCyAEgBxAsGiABKQLMASEVCyAVQgGDUEUEQCABKALIARAlIAEpAswBIRULIAEgBDYCyAEgFUL+////b4NCAYQLIhVCIIZCgICAgBCDIBVC/////2+DhDcCzAEgASABQdgAajYCeCADIAJBEEZyIgRFBEAgASAXQv////8HIBdC/////wdUGyIVQiGGNwJ8IBWnQQQQVyECIAEpAnwiFadBAXRBfHEiAwRAIAIgASgCeCADECwaIAEpAnwhFQsgFUIBg1BFBEAgASgCeBAlIAEpAnwhFQsgASACNgJ4IBVC/v///2+DQgGEIRYLIAEgFkIghkKAgICAEIMgFkL/////b4OENwJ8IAEgAUEoajYCSEKAgICAgAIhFSABQfgAaiEGIARFBEAgASAXQv////8HIBdC/////wdUGyIVQiGGNwJMIBWnQQQQVyECIAEpAkwiFadBAXRBfHEiBARAIAIgASgCSCAEECwaIAEpAkwhFQsgFUIBg1BFBEAgASgCSBAlIAEpAkwhFQsgASACNgJIIBVC/v///2+DQgGEIRULIBVCIIZCgICAgBCDIBVC/////2+DhCEVIAFByABqDAILIAFB4gI2AgQgAUGZFjYCCCABQdkMNgIAQdcZIAEQKQALQoCAgICAAiEVIAFCgICAgIACNwLMASABQoCAgICAAjcCfCABIAFB2ABqNgJ4IAEgAUEoajYCSCABQfgAaiEGIAFByABqCyEPIAEgFTcCTCASQQNPBEBBACECQQAhAwNAIAggAkEBaiIESgRAIAwgAkECdGooAgAhECAEIQIDQCADIQcgDCACQQJ0aigCACIDKgIIIBAqAgiTIRkgAyoCDCAQKgIMkyEaIAEpAkwiFUIhiCEXQgEgFUKAgICAEIMgFUIB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gID8B0YNACABvCIEQYCAgPwHcUGAgID8B0YNACAAi0MAAIA1XwRAQQEhAiABi0MAAIA1Xw0BC0EAIANB/////wdxayADIANBAEgbIgJBACAEQf////8HcWsgBCAEQQBIGyIDQRBqSCADIAJBEGpIcSECCyACC7kPAgl/BHwjAEEQayIJJAACQCABKwN4IgwgDGINACABKwOAASINIA1iDQAgACgCACIDIAwgDSABKAIAIAMoAgAoAlQRCgAgAUHYAGoiCyABKAIAEGNBACEDIAFBADoAICABQoCAgICAgID4v383AxggAUKAgICAgICA/P8ANwMQIAFBQGtBADoAACABQoCAgICAgID4v383AzggAUKAgICAgICA/P8ANwMIIAFCgICAgICAgPz/ADcDMCABQoCAgICAgID8/wA3AyggASABKwNwIAErA2ChIgwgASsDaCABKwNYoSINIAwgDWQbOQOIASABKAIAIgUgBSgCACgCEBEBACEFIAFBADoAlAEgAUEAOgCRASABIAU6AJABIAErA1ggASsDaGVFDQAgASsDYCABKwNwZUUNAAJAIAEoAkgiCkUNAANAIAoiAygCBCEKAkAgACABIAIgAygCACIEIAlBDGoQvgMiA0EASgRAIAkoAgxBAkYEQAJAIAQrA3giDCAMYg0AIAQrA4ABIg0gDWINACACKAIAIgUgDCANIAQoAgAgBSgCACgCVBEKACAEQdgAaiAEKAIAEGMgBEEAOgAgIARCgICAgICAgPi/fzcDGCAEQoCAgICAgID8/wA3AxAgBEFAa0EAOgAAIARCgICAgICAgPi/fzcDOCAEQoCAgICAgID8/wA3AwggBEKAgICAgICA/P8ANwMwIARCgICAgICAgPz/ADcDKCAEIAQrA3AgBCsDYKEiDCAEKwNoIAQrA1ihIg0gDCANZBs5A4gBIAQoAgAiBSAFKAIAKAIQEQEAIQUgBEEAOgCUASAEQQA6AJEBIAQgBToAkAELIAEgBCAAELwDCyADQQJHDQECQCABKwN4IgwgDGINACABKwOAASINIA1iDQAgACgCACIAIAwgDSABKAIAIAAoAgAoAlQRCgAgCyABKAIAEGMgAUEAOgAgIAFCgICAgICAgPi/fzcDGCABQoCAgICAgID8/wA3AxAgAUEAOgBAIAFCgICAgICAgPi/fzcDOCABQoCAgICAgID8/wA3AwggAUKAgICAgICA/P8ANwMwIAFCgICAgICAgPz/ADcDKCABIAErA3AgASsDYKEiDCABKwNoIAErA1ihIg0gDCANZBs5A4gBIAEoAgAiACAAKAIAKAIQEQEAIQMgAUEAOgCUASABQQA6AJEBIAEgAzoAkAELIAQgASACELwDDAMLAkAgAS0AkQFFBEAgASgCSCEFDAELIAEoAkgiBQRAIAErAzghDCABKwMYIQ1BACEGIAUhA0EAIQcDQCAEIAMoAgAiCEcEQCAHIAgrA3giDiAMoSAIKwOAASIPIAyhokQAAAAAAAAAAGVyIQcgBiAOIA2hIA8gDaGiRAAAAAAAAAAAZXIhBgsgAygCBCIDDQALIAYgB3FBAXENAQsgAUEAOgAgIAFCgICAgICAgPi/fzcDGCABQQA6AJEBIAFCgICAgICAgPz/ADcDECABQQA6AEAgAUKAgICAgICA+L9/NwM4IAFCgICAgICAgPz/ADcDCCABQoCAgICAgID8/wA3AzAgAUKAgICAgICA/P8ANwMoC0EAIQMCQANAIAMhBiAFIgNFDQEgAygCBCEFIAMoAgAgBEcNAAsgBgRAIAYgBTYCBAwBCyABIAU2AkggBQ0AIAErA3hEAAAAAAAAAABhBEAgAEEBOgCkCAsgASsDgAFEAAAAAAAA8D9hBEAgAEEBOgClCAsgASgCUCEDAkAgASgCTCIFBEAgBSADNgJQIANFDQEgAyAFNgJMIAMrA3ggAysDgAFkRQ0BDAILIAAgAzYClAggA0UNACADQQA2AkwLIAAgACgCoAgiA0EBazYCoAggA0EATA0AIAEgACgCnAg2AlAgACABNgKcCCABQQE6AJQBCwJAIAQtAJEBRQRAIAQoAkghBQwBCyAEKAJIIgUEQCAEKwM4IQwgBCsDGCENQQAhBiAFIQNBACEHA0AgASADKAIAIghHBEAgByAIKwN4Ig4gDKEgCCsDgAEiDyAMoaJEAAAAAAAAAABlciEHIAYgDiANoSAPIA2hokQAAAAAAAAAAGVyIQYLIAMoAgQiAw0ACyAGIAdxQQFxDQELIARCgICAgICAgPi/fzcDGCAEQQA6AJEBIARCgICAgICAgPi/fzcDOCAEQoCAgICAgID8/wA3AwggBEKAgICAgICA/P8ANwMoIARBADoAICAEQoCAgICAgID8/wA3AxAgBEFAa0EAOgAAIARCgICAgICAgPz/ADcDMAtBACEDA0AgAyEGIAUiA0UNASADKAIEIQUgAygCACABRw0ACyAGBEAgBiAFNgIEDAELIAQgBTYCSCAFDQAgBCsDeEQAAAAAAAAAAGEEQCACQQE6AKQICyAEKwOAAUQAAAAAAADwP2EEQCACQQE6AKUICyAEKAJQIQMCQCAEKAJMIgUEQCAFIAM2AlAgA0UNASADIAU2AkwgAysDeCADKwOAAWRFDQEMAgsgAiADNgKUCCADRQ0AIANBADYCTAsgAiACKAKgCCIDQQFrNgKgCCADQQBMDQAgBCACKAKcCDYCUCACIAQ2ApwIIARBAToAlAELIAoNAAsLQQEhAwsgCUEQaiQAIAMLhgMCCH8EfCAAKAJIIgcEQANAAkAgBygCACIBLQCRAUUEQCABKAJIIQMMAQsgASgCSCIDBEAgASsDOCEJIAErAxghCkEAIQQgAyECQQAhBQNAIAAgAigCACIIRwRAIAUgCCsDeCILIAmhIAgrA4ABIgwgCaGiRAAAAAAAAAAAZXIhBSAEIAsgCqEgDCAKoaJEAAAAAAAAAABlciEECyACKAIEIgINAAsgBCAFcUEBcQ0BCyABQoCAgICAgID4v383AxggAUEAOgCRASABQoCAgICAgID4v383AzggAUKAgICAgICA/P8ANwMIIAFCgICAgICAgPz/ADcDKCABQQA6ACAgAUKAgICAgICA/P8ANwMQIAFBQGtBADoAACABQoCAgICAgID8/wA3AzALQQAhBEEAIQICQANAIAIhBSADIgJFDQEgAigCBCEDIAIoAgAgAEcNAAsgBQRAIAUgAzYCBAwBCyABIAM2AkggA0UhBAsgBCAGciEGIAcoAgQiBw0ACwsgBkEBcQvVAQIDfAJ/RAAAAAAAAPC/IQQgACgCSCIABEBE////////738hAwNAIAAoAgAiBigCACIFQQAgBSgCACgCDBEAACIFKwMAIAErAwChIgIgAqIgBSsDCCABKwMIoSICIAKioCICIANjBEAgBisDeCEEIAIhAwsgBigCACIFIAUgBSgCACgCSBEBACAFKAIAKAIMEQAAIgUrAwAgASsDAKEiAiACoiAFKwMIIAErAwihIgIgAqKgIgIgA2MEQCAGKwOAASEEIAIhAwsgACgCBCIADQAL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AAAAAABjDQAgCEEERgRAIAQgBysDECIGokQAAAAAAAAAAGMgBSAGokQAAAAAAAAAAGNyDQELIAREAAAAAAAAAABiBEAgBEQAAAAAAAAAAGMhAgwBCyAFRAAAAAAAAAAAYgRAIAVEAAAAAAAAAABjIQIMAQtBfiECIAhBBEcNACAHKwMQIgREAAAAAAAAAABhDQAgBEQAAAAAAAAAAGMhAgsgB0EgaiQAIAILsAECBH8BfkEBIQEgACAAKQIEIgVCgYCAgHCDIAWnIgIgAkEBdiIDQQF0ayIEQX5xrYQ3AgQCQCACQQJJDQAgACgCACAEQQF2QQxsahArIANBAUYNAANAIAAoAgAgACgCBEEBdiABakEMbGoQKyABQQFqIgEgA0cNAAsLIABBAEECEPUBIAAgACkCBEL/////b4M3AgQgACgCDCIBBEAgARAlIABBADYCFCAAQgA3AgwLC6oCAgN+AX8gACkCBCIEQiGIIQUgBKdBAXYgAWqsIQNBACEBAkBBACADIAVXQgEgBEKAgICAEIMgBEIBg1AgBSADQgN+V3IbUBsNACADIANCAXxCAYd8Qgd8QniDIAMgAhsiAyAFUQ0AIAAgBEL/////H4MgA0L/////ByADQv////8HUxsiA0KBgICAeCADQoGAgIB4VRsiA0IhhoQ3AgQgA6dB/////wdxQQwQVyECIAApAgQiA0L+////D4NQRQRAA0AgAiABQQxsIgZqIAAoAgAgBmoQfhogACgCACAGahArIAFBAWoiASAAKQIEIgOnQQF2SQ0ACwsgA0IBg1BFBEAgACgCABAlIAApAgQhAwsgACACNgIAIAAgA0L+////b4NCAYQ3AgQLCwQAQQALTQEDfyMAQRBrIgMkACMAQRBrIgIkACACIANBCGoiBDYCDCACQQxqQQwQMyABEH4QlQEgAkEQaiQAIABBtdQAIAQQITYCACADQRBqJAALDAAgACABKAIANgIACwQAQQQLBABBAwtEAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRBRIAUpAwAhASAAIAUpAwg3AwggACABNwMAIAVBEGokAAvEAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQBBACACQv//////////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IABBADYCDCACEFMgAEEANgIwIABCADcCKCAACygAIABBgAI7ABEgAEEANgIMIAAgATYCCCAAQQA2AgQgACACNgIAIAALCgAgAC0ACkEDcQv4AwICfwF8AkAgA0UNACABKAIAIQUDQAJAIAItAJEBDQAgAi0AkAENAAJAIAQEQCACIAQpAyg3AwggAiAEQUBrLQAAOgAgIAIgBCkDODcDGCACIAQpAzA3AxAMAQsgAkEIaiAAKAIAIAIrA3ggAigCACIEQQAgBCgCACgCDBEAACAFEEkLAkAgAi0AIEUNACACKwMYIQYCQCABKAKYCCIERQ0AA0AgBCsDeCAGoSAEKwOAASAGoaJEAAAAAAAAAABlRQRAIAQoAlAiBA0BDAILCyACQQA6ACAgAkKAgICAgICA+L9/NwMYIAJCgICAgICAgPz/ADcDCCACQoCAgICAgID8/wA3AxAMAQsgASACIAYQwwMLIAJBKGogACgCACACKwOAASACKAIAIgQgBCAEKAIAKAJIEQEAIAQoAgAoAgwRAAAgBRBJAkAgAkFAay0AAEUNACACKwM4IQYCQCABKAKYCCIERQ0AA0AgBCsDeCAGoSAEKwOAASAGoaJEAAAAAAAAAABlRQRAIAQoAlAiBA0BDAILCyACQQA6AEAgAkKAgICAgICA+L9/NwM4IAJCgICAgICAgPz/ADcDKCACQoCAgICAgID8/wA3AzAMAQsgASACIAYQwwMLIAJBAToAkQELIAIgA0YNASACIgQoAlAhAgwACwALC48DAgN/AXwgACACOQN4IAAgASsDgAEiBzkDgAECQCACIAdiBH8gASACOQOAASABKwN4IAJiDQEgAQUgAAtBAToAkAFBAA8LIAAgATYCTCAAIAEoAlA2AlAgACABLQCSAToAkgEgACABLQCTAToAkwEgASAANgJQIAAoAlAiBARAIAQgADYCTAsgASgCSCEFIABBADYCSAJAIAVFDQADQCAFKAIAIQYgA0EAIAMoAgQiBGtBA3EiAUEIciADKAIIIARrSwR/IANBCEEEEDFBACADKAIEIgRrQQNxBSABCyAEaiIBQQhqNgIEIAFCADcCACABIAY2AgAgASAAKAJINgIEIAAgATYCSCAFKAIEIgUNAAsgBEUNAANAIAEoAgAhBUEAIAMoAgQiBGtBA3EiBkEIciADKAIIIARr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QwAAAABgDQAgHyAflCAbIBuUkiIbIBqMIhpfDQAgGiAblSIfQwAAAABeRSAfQwAAgD9dRXINACAAICG8rSAevK1CIIaENwIgIAAgI7ytICC8rUIghoQ3AgAgACAfIByUICOSIhy8rSAfIB2UICCSIh28rUIghoQ3AgggACAkIB8gISAkk5SSIhu8rSAiIB8gHiAik5SSIhq8rUIghoQ3AhggACAcIB8gGyAck5SSvK0gHSAfIBogHZOUkrytQiCGhDcCEEECDAELIAAgBCkCADcCACAAIAQpAhA3AhAgACAEKQIINwIIQQELQQFGDQUgAioCQCIiQwAAAACUIAIqAkQiI5QgAioCSCIglCACKgJMIiGUIAIqAlAiH5QgAioCVCIelCACKgJYIhyUIAIqAlwiHZQgAioCYCIblCACKgJkIhqUQwAAAABcDRAgAkEAICK8IAIpA0AiOKdB/////wdxvkMAAAA2XRs2AkAgAkEAICC8IAIpA0giOadB/////wdxvkMAAAA2XRs2AkggAkEAIB+8IAIpA1AiOqdB/////wdxvkMAAAA2XRs2AlAgAkEAIBy8IAIpA1giO6dB/////wdxvkMAAAA2XRs2AlggAkEAIBu8IAIpA2AiN6dB/////wdxvkMAAAA2XRs2AmAgAkEAICO8IDhCIIinQf////8Hcb5DAAAANl0bNgJEIAJBACAhvCA5QiCIp0H/////B3G+QwAAADZdGzYCTCACQQAgHrwgOkIgiKdB/////wdxvkMAAAA2XRs2AlQgAkEAIB28IDtCIIinQf////8Hcb5DAAAANl0bNgJcIAJBACAavCA3QiCIp0H/////B3G+QwAAADZdGzYCZCACQUBrIAJBsANqENYBIQUgEyASENYBIQsgBUUNBSACQbADaiACQUBrIAVBAUYiAxshCSAFIAVBAWoiAUECdSIATgRAIAEgAGshAEEAIQEDQCAJIAFBA3RqIgZBACAGKAIAIAYpAwAiN6dB/////wdxvkMAAAA2XRs2AgAgBkEAIAYoAgQgN0IgiKdB/////wdxvkMAAAA2XRs2AgQgAUEBaiIBIABHDQALCwJAIAMEQCAJIBEQOyEAIAtFDQcgAEUNAQwHCyALRQ0GCyASIBMgC0EBRiIDGyEGIAsgC0EBaiIBQQJ1IgBOBEAgASAAayEAQQAhAQNA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hiAAQjyIhCEDIABC//////////8PgyIAQoGAgICAgICACFoEQCADQoGAgICAgICAwAB8IQIMAgsgA0KAgICAgICAgEB9IQIgAEKAgICAgICAgAiFQgBSDQEgAiADQgGDfCECDAELIABQIANCgICAgICAwP//AFQgA0KAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgA0L///////+//8MAVg0AQgAhAiADQjCIpyIFQZH3AEkNACAEQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiAiAFQYH3AGsQSyAEIAAgAkGB+AAgBWsQlgEgBCkDCEIEhiAEKQMAIgBCPIiEIQIgBCkDECAEKQMYhEIAUq0gAEL//////////w+DhCIAQoGAgICAgICACFoEQCACQgF8IQIMAQsgAEKAgICAgICAgAiFQgBSDQAgAkIBgyACfCECCyAEQSBqJAAgAiABQoCAgICAgICAgH+DhL8LRwEBfyMAQRBrIgMkACADIAI2AgxB3dQAIAFBitQAQfIhQdwAIANBDGoQMkGK1ABB9iFB3QAgA0EMahAyEAkgA0EQaiQAIAALog8CBX8OfiMAQdACayIFJAAgBEL///////8/gyEKIAJC////////P4MhDCACIASFQoCAgICAgICAgH+DIQ0gBEIwiKdB//8BcSEIAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgCEH//wFrQYGAfksNAQsgAVAgAkL///////////8AgyIPQoCAgICAgMD//wBUIA9CgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhDQwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCENIAMhAQwCCyABIA9CgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhDQwDCyANQoCAgICAgMD//wCEIQ1CACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgD4RQBEBCgICAgICA4P//ACANIAIgA4RQGyENQgAhAQwCCyACIAOEUARAIA1CgICAgICAwP//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AiADcjYCACABDAELIAEoAggLIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIDwtBHyECIABCADcCECABQf///wdNBEAgAUEIdiICIAJBgP4/akEQdkEIcSIEdCICIAJBgOAfakEQdkEEcSIDdCICIAJBgIAPakEQdkECcSICdEEPdiADIARyIAJyayICQQF0IAEgAkEVanZBAXFyQRxqIQILIAAgAjYCHCACQQJ0QfzYAGohBwJAAkBB0NYAKAIAIgRBASACdCIDcUUEQEHQ1gAgAyAEcjYCACAHIAA2AgAgACAHNgIYDAELIAFBAEEZIAJBAXZrIAJBH0YbdCECIAcoAgAhAwNAIAMiBCgCBEF4cSABRg0CIAJBHXYhAyACQQF0IQIgBCADQQRxaiIHQRBqKAIAIgMNAAsgByAANgIQIAAgBDYCGAsgACAANgIMIAAgADYCCA8LIAQoAggiASAANgIMIAQgADYCCCAAQQA2AhggACAENgIMIAAgATYCCAsLmQIAIABFBEBBAA8LAn8CQCAABH8gAUH/AE0NAQJAQbTWACgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAgwECyABQYBAcUGAwANHIAFBgLADT3FFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAwwECyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBAwECwtBmNUAQRk2AgBBfwVBAQsMAQsgACABOgAAQQELCxEAIAAgASACQbMCQbQCEOoCC8QCAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAKCwwKCwIDBAUMCwwMCgsHCAkLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LAAsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsACyACIAIoAgBBB2pBeHEi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AigCgEZBAXI2AoBGQdyPASEKCwJ/IAkoAgQiBCAJKAJoRwRAIAkgBEEBajYCBCAELQAADAELIAkQPgsiA0EuRiIEIANBMGsiDkEKSXINAAsLIBggGSALGyEYIAdFIANBX3FBxQBHckUEQAJAIAkQ7gIiGkKAgICAgICAgIB/Ug0AQgAhGiAJKQNwQgBTDQAgCSAJKAIEQQFrNgIECyAHRQ0DIBggGnwhGAwECyAHRSEEIANBAEgNAQsgCSkDcEIAUw0AIAkgCSgCBEEBazYCBAsgBEUNAQtBmNUAQRw2AgBCACEZIAkQgAJCAAwBCyACKAKQBiIERQRAIAIgDbdEAAAAAAAAAACiEGcgAikDACEZIAIpAwgMAQsgGCAZUiAZQglVciARQR5MQQAgBCARdhtyRQRAIAJBMGogDRBUIAJBIGogBBCXASACQRBqIAIpAzAgAikDOCACKQMgIAIpAygQLyACKQMQIRkgAikDGAwBCyASQX5trSAYUwRAQZjVAEHEADYCACACQeAAaiANEFQgAkHQAGogAikDYCACKQNoQn9C////////v///ABAvIAJBQGsgAikDUCACKQNYQn9C////////v///ABAvIAIpA0AhGSACKQNIDAELIBJB4gFrrCAYVQRAQZjVAEHEADYCACACQZABaiANEFQgAkGAAWogAikDkAEgAikDmAFCAEKAgICAgIDAABAvIAJB8ABqIAIpA4ABIAIpA4gBQgBCgICAgICAwAAQLyACKQNwIRkgAikDeAwBCyAMBEAgDEEITARAIAJBkAZqIAhBAnRqIgQoAgAhBgNAIAZBCmwhBiAMQQFqIgxBCUcNAAsgBCAGNgIACyAIQQFqIQgLAkAgCiAYpyILSiAKQQlOciALQRFKcg0AIAtBCUYEQCACQcABaiANEFQgAkGwAWogAigCkAYQlwEgAkGgAWogAikDwAEgAikDyAEgAikDsAEgAikDuAEQLyACKQOgASEZIAIpA6gBDAILIAtBCEwEQCACQZACaiANEFQgAkGAAmogAigCkAYQlwEgAkHwAWogAikDkAIgAikDmAIgAikDgAIgAikDiAIQLyACQeABakEAIAtrQQJ0QZDDAGooAgAQVCACQdABaiACKQPwASACKQP4ASACKQPgASACKQPoARDiAiACKQPQASEZIAIpA9gBDAILIBEg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QCAFQdAAaiADIAlCAEKAgICAgIDAu8AAEC8gBSkDWCIJQjCIp0H4AGshByAFKQNQIQMLIAlC////////P4NCgICAgICAwACEIQkgCkL///////8/g0KAgICAgIDAAIQhCiAGIAdKBEADQAJ+IAogCX0gAyAEVq19IgtCAFkEQCALIAQgA30iBIRQBEAgBUEgaiABIAJCAEIAEC8gBSkDKCECIAUpAyAhBAwFCyALQgGGIARCP4iEDAELIApCAYYgBEI/iIQLIQogBEIBhiEEIAZBAWsiBiAHSg0ACyAHIQYLAkAgCiAJfSADIARWrX0iCUIAUwRAIAohCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQLyAFKQM4IQIgBSkDMCEEDAELIAlC////////P1gEQANAIARCP4ghASAGQQFrIQYgBEIBhiEEIAEgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/EC8gBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3KtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALvwIBAX8jAEHQAGsiBCQAAkAgA0GAgAFOBEAgBEEgaiABIAJCAEKAgICAgICA//8AEC8gBCkDKCECIAQpAyAhASADQf//AUkEQCADQf//AGshAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQLyADQf3/AiADQf3/AkkbQf7/AWshAyAEKQMYIQIgBCkDECEBDAELIANBgYB/Sg0AIARBQGsgASACQgBCgICAgICAgDkQLyAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQLyADQeiBfSADQeiBfUsbQZr+AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQLyAAIAQpAwg3AwggACAEKQMANwMAIARB0ABqJAALNQAgACABNwMAIAAgAkL///////8/gyAEQjCIp0GAgAJxIAJCMIinQf//AXFyrUIwhoQ3AwgLRgEBfwJ/QQAgAEEXdkH/AXEiAUH/AEkNABpBAiABQZYBSw0AGkEA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AUEEajYCBCABQQE2AgAgACgCACIBIAk4AgggASAFIAYgBBs4AgQgASAJOAIAIAEgBiAFIAQbOAIMIAAgAUEQajYCAAwBCyACKgIIIgggB18EQCAALQAIDQEgAyoCBCEGIAAgACgCBCIBQQRqNgIEIAFBATYCACAAKAIAIgEgCDgCCCABIAUgBiAEGzgCBCABIAg4AgAgASAGIAUgBBs4AgwgACABQRBqNgIADAELAkAgByAJXQRAIAYgByADKgIIIgWTIAWTkiAFIAeTIgUgBZIgByAJkyADQSBqEGBFDQEgAyADQSBqIAMqAiAQkQEgAyoCNCEGIAIqAgAhBSADKgIkIQcgACAAKAIEIgFBBGo2AgQgAUEBNgIAIAAoAgAiASAFOAIIIAEgBiAHIAQbOAIEIAEgBTgCACABIAcgBiAEGzgCDCAAIAFBEGo2AgAgAyAFOAIwIAUgAyoCOF4EQCADIAU4AjgLIAMgAykDMCIKNwMAIAMgAykDODcDCCAKp74hByACKgIIIQggAyoCECEGCyADQRBqIQEgBiAIXgRAIAYgByADKgIIIgWTIAWTkiAFIAeTIgUgBZIgByAIkyADQcgAahBgBEAgAyADQSBqIAMqAkgQkQEgAioCCCIFIAMqAihdBEAgAyAFOAIoCyADIAU4AjAgACAAKAIEIgFBBGo2AgQgAUECNgIAAn8gBARAIAAoAgAgAykDMDcCACADQSBqDAELIAAoAgAgAykDIDcCACADQTBqCyEBIAAoAgAgASkCADcCECAAKAIAIAMpAyg3AgggAioCCCEFIAMqAkQhBiADKgI0IQcgACAAKAIEIgJBBGo2AgQgACgCACEBIAJBATYCACABIAcgBiAEGzgCJCABIAU4AiAgASAGIAcgBBs4AhwgASAFOAIYIAAgAUEoajYCAAwDCyADIAIqAggiBSADKgIIIgYgBSAGXRs4AgggAyAFIAMqAhAiBiAFIAZdGzgCECAAIAAoAgQiAkEEajYCBCACQQI2AgAgACgCACADQRBqIAMgBBspAwA3AgAgACgCACADIAEgBBspAwA3AhAgACgCACADKQMINwIIIAAgACgCAEEYajYCAAwCCyAAIAAoAgQiAkEEajYCBCACQQI2AgAgACgCACADQRBqIAMgBBspAwA3AgAgACgCACADIAEgBBspAwA3AhAgACgCACADKQMINwIIIAAgACgCAEEYajYCAAwBCyACKgIAIQUgAyoCBCEGIAMqAhQhByAAIAAoAgQiAUEEajYCBCABQQE2AgAgACgCACIBIAU4AgggASAHIAYgBBs4AgQgASAFOAIAIAEgBiAHIAQbOAIMIAAgAUEQajYCAAsgA0HQAGokAAuICgMEfwd9BHwjAEEwayIEJAACQCABKgIEIgkgACAAKgIEIgogACoCDCILXSIGQQN0aioCBGANACAAIAZFIgdBA3RqKgIEIgggASoCDCIMYA0AIAQgACkCADcDICAEIAApAgg3AyggCCAJXQRAIAAqAgAhCAJ9IAsgCpOLQwAAgDlfBEAgCCAAKgIIkkMAAAA/lAwBCwJAIAAqAggiDbsiEiAIuyIRIAggDV4iBRsiECAJuyAKuyIPoSASIBGhoiALuyAPoaMgEaAiD2QNACAPIhAgESASIAUbIg9kRQ0AIA8hEAsgELYLIQggBEEgaiAHQQN0ciIFIAk4AgQgBSAIOAIACwJAIARBIGogBkEDdHIiBSoCBCAMXkUEQCAAKgIIIQggACoCACEJDAELIAVBBHIhBSAAKgIAIQkgBEEgaiAGQQN0cgJ9IAsgCpOLQwAAgDlfBEAgCSAAKgIIIgiSQwAAAD+UDAELAkAgACoCCCIIuyISIAm7IhEgCCAJXSIAGyIQIAy7IAq7Ig+hIBIgEaGiIAu7IA+hoyARoCIPZA0AIA8iECARIBIgABsiD2RFDQAgDyEQCyAQtgs4AgAgBSAMOAIACwJAAkAgBEEgaiAIIAleIgBBA3RyIgUqAgAiDiABKgIAIgxfBEAgBCAMOAIgIAQgDDgCKAwBCyAEQSBqIABFIgZBA3RyIgcqAgAiCCABKgIIIg1gBEBBACEFIAMNAyAEIA04AiAgBCANOAIoDAELAn8gCCAMXQRAIAQgDDgCACAEIARBIGogBkEDdHIqAgQ4AgQCQAJ9IAQqAigiCSAEKgIgIgiTi0MAAIA5XwRAIAQqAiQiCiAEKgIsIgiSQwAAAD+UDAELIAy7IAi7IhChIAQqAiwiCLsgBCoCJCIKuyIPoaIgCbsgEKGjIA+gtgsiCyAIIAogCCAKXSIBGyIJXQ0AIAsiCSAKIAggARsiCF5FDQAgCCEJCyAEIAk4AgwgBCAMOAIIIARBCHIMAQsgBCAHKQMANwMAIAQLIQECQCANIA5dBEACQAJ9IAQqAigiCCAEKgIgIgmTi0MAAIA5XwRAIAQqAiQiCSAEKgIsIguSQwAAAD+UDAELIA27IAm7IhChIAQqAiwiC7sgBCoCJCIJuyIPoaIgCLsgEKGjIA+gtgsiCiALIAkgCSALXiIDGyIIXQ0AIAoiCCAJIAsgAxsiCV5FDQAgCSEICyABIA04AgggASAIOAIMIAEgBEEgaiAAQQN0cioCBDgCFCABIA04AhAgAUEQaiEBDAELIAFBCGoiASAFKQMANwIACyABIARrIgNBA3UhBSAEIQEgAA0BQQAhACADQQBIDQIgBUEAIAVBAEobIgFBAWoiBkEDcSEDIAFBA08EQCAGQfz///8HcSEGQQAhAQNAIAIgBSAAa0EDdGogBCAAQQN0aikDADcCACACIAUgAEEBciIHa0EDdGogBCAHQQN0aikDADcCACACIAUgAEECciIHa0EDdGogBCAHQQN0aikDADcCACACIAUgAEEDciIHa0EDdGogBCAHQQN0aikDADcCACAAQQRqIQAgAUEEaiIBIAZHDQALCyADRQ0CQQAhAQNAIAIgBSAAa0EDdGogBCAAQQN0aikDADcCACAAQQFqIQAgAUEBaiIBIANHDQALDAILIARBIGohAUEBIQULIAIgASAFQQN0QQhqECwaCyAEQTBqJAAgBQs6ACADIAEgACoCAJQgAiAAKgIElCAAKgIIkpI4AgAgAyABIAAqAgyUIAIgACoCEJQgACoCFJKSOAIEC70FAgJ/CH0jAEEgayIEJAAgACgCJCIDQYABcQRAIAAgABBAIgM2AiQLAkAgA0EOcUUEQCACKgIIIQcgAioCACEGIAAqAgghCCABIAAqAhQiBSACKgIEkiIJIAUgAioCDJIiCiAJIApeIgIbOAAMIAEgCCAGkiIGIAggB5IiBSAFIAZdIgAbOAAIIAEgCiAJIAIbOAAEIAEgBSAGIAAbOAAADAELIANBgAFxBEAgACAAEEAiAzYCJAsgA0EMcUUEQCACKgIIIQogACoCCCELIAIqAgAhByAAKgIAIQwgASAAKgIUIgYgACoCECIFIAIqAgSUkiIIIAYgBSACKgIMlJIiCSAIIAleIgIbOAAMIAEgCyAMIAeUkiIGIAsgDCAKlJIiBSAFIAZdIgAbOAAIIAEgCSAIIAIbOAAEIAEgBSAGIAAbOAAADAELIANBwAFxQYABRgRAIABBD0EPQQ9BwAEgACoCIEMAAIA/XBsgACoCHEMAAAAAXBsgACoCGEMAAAAAXBsiAzYCJAsgA0EIcQRAIAQQNSIDIAJBAEEAEH0gAyAAIAMQzQEgAygCACICLQBUBEAgAkEEaiACKAIUIAIoAhwQNCEAIAJBADoAVCACIAA6AFULIAEgAikCBDcCACABIAIpAgw3AgggAxArDAELIAIqAgAhByAEIAIqAgQiBTgCBCAEIAc4AgAgAioCCCEGIAQgBTgCDCAEIAY4AgggBCACKgIMIgU4AhwgBCAHOAIYIAQgBTgCFCAEIAY4AhAgACgCJCIDQYABcQRAIAAgABBAIgM2AiQLIAAgBCAEQQQgA0EPcUECdEGA0ABqKAIAEQcAIAEgBEEEEDRFBEAgAUKAgID+h4CA4P8ANwIIIAFCgICA/oeAgOD/ADcCAAsgACgCJEGAAXEEQCAAIAAQQDYCJAsLIARBIGokAAvXCQMDfwV8BH0jAEEwayIDJAAgACgCJCICQYABcQRAIAAgABBAIgI2AiQLAkAgAkEPcSIEQQNNBEAgAQRAIAJBAnEEQEEAIQIgACoCACIKQwAAAABbDQMgACoCECILQwAAAABbDQMgAUEANgIYIAFCgICAgICAgMA/NwIcIAFBADYCDCABQQA2AgQgAUMAAIA/IAuVIgs4AhAgAUMAAIA/IAqVIgo4AgAgASAKIAAqAgiMlDgCCCAAKgIUIQogASAEQRByNgIkIAEgCyAKjJQ4AhRBASECDAMLIAAqAgghCiAAKgIUIQsgAUGAgID8AzYCICABQgA3AhggAUKAgICAgICAwD83AgwgAUKAgID8AzcCACABIAuMOAIUIAEgCow4AgggAUERQRFBECALQwAAAABcGyAKQwAAAABcGzYCJEEBIQIMAgsgACoCAEMAAAAAXCAAKgIQQwAAAABccSECDAELIAAqAhC7IQUgACoCALshBgJ8IAJBCHEiBARAIAAqAgi7IAAqAgy7IgcgACoCHLsiCKIgBSAAKgIYuyIJoqGiIAYgBSAAKgIguyIFoiAAKgIUuyIGIAiioaIgBiAJoiAFIAeioSAAKgIEu6KgoAwBCyAGIAWiIAAqAgS7IAAqAgy7oqELIQVBACECRAAAAAAAAAAARAAAAAAAAPA/IAWjIAW2i0MAAIAtXxsiBUQAAAAAAAAAAGENACADQoCAgPyDAjcDKCADQgA3AyAgA0KAgID8AzcDGCADQgA3AxAgA0KAgID8AzcDCCADQQhqIAEgAUUgACABRnIbIQIgACoCECEKAkAgBARAIAIgCiAAKgIglCAAKgIcIAAqAhSUk7sgBaK2OAIAIAIgACoCCCAAKgIclCAAKgIgIAAqAgSUk7sgBaK2OAIEIAIgACoCBCAAKgIUlCAAKgIQIAAqAgiUk7sgBaK2OAIIIAIgACoCFCAAKgIYlCAAKgIgIAAqAgyUk7sgBaK2OAIMIAIgACoCACAAKgIglCAAKgIYIAAqAgiUk7sgBaK2OAIQIAIgACoCCCAAKgIMlCAAKgIUIAAqAgCUk7sgBaK2OAIUIAIgACoCDCAAKgIclCAAKgIYIAAqAhCUk7sgBaK2OAIYIAIgACoCBCAAKgIYlCAAKgIcIAAqAgCUk7sgBaK2OAIcIAIgACoCACAAKgIQlCAAKgIMIAAqAgSUk7sgBaK2OAIgDAELIAIgCrsgBaK2OAIAIAIgACoCBIy7IAWitjgCBCACIAAqAgS7IAAqAhS7oiAAKgIQuyAAKgIIu6KhIAWitjgCCCACIAAqAgyMuyAForY4AgwgAiAAKgIAuyAForY4AhAgACoCDCEKIAAqAgghCyAAKgIAIQwgACoCFCENIAJCADcCGCACIAq7IAu7oiAMuyANu6KhIAWitjgCFCACQwAAgD84AiALAkAgAioCAEMAAAAAlCACKgIElCACKgIIlCACKgIMlCACKgIQlCACKgIUlCACKgIYlCACKgIclCACKgIglCIKQwAAAABcDQAgAiAAKAIkNgIkIAAgAUcNACAAIAMpAwg3AgAgACADKQMoNwIgIAAgAykDIDcCGCAAIAMpAxg3AhAgACADKQMQNwIICyAKQwAAAABbIQILIANBMGokACACC3UBAX0gAEEANgIcIABBADYCCCAAQoCAgPyDGDcCICAAQgA3AhQgAEMAAAAAIAFDNfqOPJQiARBkIgIgAotDAACAOV8bIgI4AhAgAEMAAAAAIAEQjQEiASABi0MAAIA5XxsiATgCDCAAIAI4AgAgACABjDgCBAuiAQIBfwF9IAFDAACAP1sgAkMAAIA/W3FFBEAgACAAKgIAIAGUIgQ4AgAgACAAKgIMIAGUOAIMIAAgACoCGCABlDgCGCAAIAAqAgQgApQ4AgQgACAAKgIQIAKUIgE4AhAgACAAKgIcIAKUOAIcIAAoAiQiA0EMcSAEQwAAgD9cIAFDAACAP1xyckUEQCAAIANBfXE2AiQPCyAAIANBAnI2AiQLC44CAQJ/IwBBMGsiAyQAIAAoAiQiBEHAAXFBgAFGBEAgAEEPQQ9BD0HAASAAKgIgQwAAgD9cGyAAKgIcQwAAAABcGyAAKgIYQwAAAABcGyIENgIkCwJAIARBCHEEQCADQYCAgPwDNgIoIANCADcDICADQoCAgICAgIDAPzcCFCADQoCAgPwDNwMIIAMgAjgCHCADIAE4AhAgA0ERQRFBECACQwAAAABcGyABQwAAAABcGyIENgIsIARBAXFFDQEgACADQQhqIAAQmwIMAQsgACAAKgIIIAGSIgE4AgggACAAKgIUIAKSIgI4AhQgACAEQX5xIAFDAAAAAFwgAkMAAAAAXHJyNgIkCyADQTBqJAALFwEBfkF/IACtIAGtfiICpyACQiCIpxsLnQcDBn8FfQF+IwBBMGsiBSQAIAAqAgAiCyABKgIAIg2UIAAqAgQiDiABKgIEIg+UkiEMAkACQCALIA+UIA0gDpSTIguLQwAAgDlfRSAMQwAAAABeRXINACACRSALQwAAAABgcQ0BIAJBAUcNACALQwAAAABfDQELQQIhBwJAAkAgC4wgCyACQQFGGyILQwAAAABbDQAgDEMAAAAAWwRAQQFBAyALQwAAAABeGyEHDAELIAtDAAAAAF0iAUEBdCAMQwAAAABdIAFzciIHRQ0BC0EAIQEgB0EBRwRAIAdBAnEhCQNAIAQgAUEcbGoiBiABQQR0QdAlaiIIKQIANwIAIAYgCCkCEDcCECAGIAgpAgg3AgggBkHzidT5AzYCGCAEIAFBAXIiCEEcbGoiBiAIQQR0QdAlaiIIKQIQNwIQIAYgCCkCCDcCCCAGIAgpAgA3AgAgBkHzidT5AzYCGCABQQJqIQEgCkECaiIKIAlHDQALCyAHQQFxRQ0AIAQgAUEcbGoiBiABQQR0QdAlaiIBKQIANwIAIAYgASkCEDcCECAGIAEpAgg3AgggBkHzidT5AzYCGAsCQCAHQQR0QdAlaiIGKgIAIg0gDJQgCyAGKgIEIg6UkiIPQwAAgD9dRQ0AIAUgCyAOkjgCDCAFIAwgDZI4AgggBUEIakMAAIA/IA9DAACAP5JDAAAAP5SRIg+VEF0aIA0gBSoCCJMiDbxBgICA/AdxQYCAgPwHRg0AIA4gBSoCDJMiDrxBgICA/AdxQYCAgPwHRiANQwAAAABbIA5DAAAAAFtxcg0AIAQgB0EcbGoiASAGKQMANwIAIAUpAwghECABIA84AhggASALOAIUIAEgDDgCECABIBA3AgggB0EBaiEHCyAFQoCAgPyDAjcDKCAFQgA3AyAgBUKAgID8AzcDGCAFQgA3AxAgBUKAgID8AzcDCCAAKgIEIQwgACoCACELIAVBADYCJCAFIAs4AhggBSAMOAIUIAVBADYCECAFIAs4AgggBUKAgID8gxg3AiggBUIANwIcIAUgDIw4AgwgAkEBRgRAIAVBCGpDAACAP0MAAIC/EJwDCyADBEAgBUEIaiEAIAMoAiQiAUGAAXEEQCADIAMQQCIBNgIkCyABQQ9xBEAgACADIAAQmwILC0EAIQEgB0EATA0AA0AgBUEIaiAEIAFBHGxqIgAgAEEDEJABIAFBAWoiASAHRw0ACwsgBUEwaiQAIAcLowMEBH8IfQF+AXwjAEHgAGsiAyQAIAIoAiQiBEHAAXFBgAFGBEAgAiACENMBIgQ2AiQLIARBCHEEQCAAKQIAIQ8gA0GAgID8AzYCOCADIA83AzAgACoCDCEHIAAqAgghCCADIAE4AkQgA0FAayAHIAGUOAIAIAMgCCABlDgCPCAAKQIQIQ8gA0GAgID8AzYCUCADIA83A0ggAyEAIANBMGohBEEDIQUgAigCJCIGQYABcQRAIAIgAhBAIgY2AiQLAkAgBkEPcQRAA0AgAioCCCEJIAIqAgAhCiACKgIEIQsgAioCFCEMIAIqAgwhDSACKgIQIQ4gACAEKgIIIgEgAioCIJQgBCoCACIHIAIqAhiUIAQqAgQiCCACKgIclJKSOAIIIAAgASAMlCAHIA2UIAggDpSSkjgCBCAAIAEgCZQgByAKlCAIIAuUkpI4AgAgAEEMaiEAIARBDGohBCAFQQFrIgUNAAwCCwALIAAgBEYNACAAIARBJBAsGgsgAyoCFLsiECAQoiADKgIIuyADKgIgu6Kjn7YhAQsgA0HgAGokACABC/0BAgd9AX8CQCABvEGAgID8B3FBgICA/AdGIAFDAAAAAF1yDQAgACoCACIFQwAAAACUIAAqAgQiBpQgACoCCCIClCAAKgIMIgSUIAAqAhAiB5QgACoCFCIIlEMAAAAAXA0AIAAqAhhDAACAv5IiAyADQwAAAECSQwAAgECUlSIDIAUgAiACkpMgB5KUIgIgApQgAyAGIAQgBJKTIAiSlCICIAKUkpEiAiABXw0AQQEhCSACQwAAgD6UIgIgAV8NAEECIQkgAkMAAIA+lCICIAFfDQBBAyEJIAJDAACAPpQiAiABXw0AQQQhCSACQwAAgD6UIAFfDQBBBSEJCyAJC98CAw59AnwBfiAAKgIYIgNDAAAAP5RDAAAAP5KRIQhDAACAPyADQwAAgD+SlSICIAAqAhAiCSAAKgIAIgogAyAAKgIIIg2UIgUgBZKSkpRDAAAAP5QiBEMAAAAAlCACIAAqAhQiCyAAKgIEIgwgAyAAKgIMIg6UIgYgBpKSkpRDAAAAP5QiB5QiDyAPXARARAAAAAAAAPA/IAO7IhBEAAAAAAAA8D+go0QAAAAAAADgP6IiESAQIBCgIhAgDruiIAy7oCALu6CitiEHIBEgECANu6IgCrugIAm7oKK2IQQLIAApAgAhEiABIAc4AiAgASAEOAIcIAEgEjcCACABIAc4AhQgASAEOAIQIAEgAiAKIAWSlLytIAIgDCAGkpS8rUIghoQ3AgggASACIAUgCZKUvK0gAiAGIAuSlLytQiCGhDcCJCAAKQIQIRIgASAIOAI0IAEgEjcCLCABIAg4AhgLCwAgACABIAAQzQELpQEBB30gASoCFCEHIAEqAgwhCCABKgIEIQYgACABKgIAIgMgASoCCCABKgIYIgSUIgUgA5MiCSAJkiADIAEqAhAgBSAFkpOSIAKUkiAClJIgBEMAAIC/kiIDIAOSIgNDAAAAACADkyAClJIgApRDAACAP5IiBZU4AgAgACAGIAggBJQiAyAGkyIEIASSIAYgByADIAOSk5IgApSSIAKUkiAFlTgCBAsOACAAIAEgAkH9ARCmAwvfAgIBfwF8IwBB0AFrIgQkACAEIAAqAgC7OQOQASAEIAAqAgS7OQOYASAEIAAqAgi7OQOgASAEIAAqAgy7OQOoASAEIAAqAhC7OQOwASAEIAAqAhS7OQO4ASAEIAAqAhi7OQPAASAEIAAqAhy7OQPIASAEQZABaiABuyAEQfAAaiADERIAIgBBAEoEQCAEIARBkAFqIAQrA3AQ2QMgBCsDACEFIAIgBCsDCLY4AgQgAiAFtjgCACAEKwMQIQUgAiAEKwMYtjgCDCACIAW2OAIIIAQrAyAhBSACIAQrAyi2OAIUIAIgBbY4AhAgBCsDMCEFIAIgBCsDOLY4AhwgAiAFtjgCGCAEKwNAIQUgAiAEKwNItjgCJCACIAW2OAIgIAQrA1AhBSACIAQrA1i2OAIsIAIgBbY4AiggBCsDYCEFIAIgBCsDaLY4AjQgAiAFtjgCMAsgBEHQAWokACAAQQBKC5EIAwh9AX8BfiAAKgIEIgMgACoCFCICIAAqAgwiBSAFkpOSIgggCJIgCJQgBSADkyIEIAUgApNDAABAQJQgACoCHJIgA5MiB5SSIAAqAgAiBSAAKgIQIgMgACoCCCIGIAaSk5IiCSAJkiAJlCAGIAWTIgIgBiADk0MAAEBAlCAAKgIYkiAFkyIGlJKSIQUgBCAIlCACIAmUkiEEIAhDAABAQJQgB5QgCUMAAEBAlCAGlJIhAyAHIAeUIAYgBpSSIgKLQwAAgDlfBEAgAyAFIAQgARBgDwtDAACAPyAClSICIAOUIgNDAABAQJUhBwJAAkACQCACIASUQwAA2EGUIAMgAyADkpQgA5QgA0MAABDBlCACIAWUIgKUkpJDAABYQpUiBiAGlCADIAOUIAJDAABAwJSSQwAAEEGVIgQgBCAElJQiA5MiAkMAAAAAXQRAIAEgBJFDAAAAwJQiBQJ9IAYgA5GVQwAAgD+WIgJDAACAvyACQwAAgL9eGyICvCIAQf////8HcSIKQYCAgPwDTwRAQwAAAABD2g9JQCAAQQBOGyAKQYCAgPwDRg0BGkMAAAAAIAIgApOVDAELAn0gCkH////3A00EQEPaD8k/IApBgYCAlANJDQEaQ2ghojMgAiACIAKUEIUClJMgApND2g/JP5IMAgsgAEEASARAQ9oPyT8gAkMAAIA/kkMAAAA/lCIDkSICIAIgAxCFApRDaCGis5KSkyICIAKSDAILQwAAgD8gApNDAAAAP5QiA5EiAiADEIUClCADIAK8QYBgcb4iAyADlJMgAiADkpWSIAOSIgIgApILCyIDQwAAQECVEGSUIAeTQwAAgD+WIgJDAAAAACACQwAAAABeGyIEOAIAIAEgBSADQ9sPycCSQwAAQECVEGSUIAeTQwAAgD+WIgJDAAAAACACQwAAAABeGyICOAIIIAEgBSADQ9sPyUCSQwAAQECVEGSUIAeTQwAAgD+WIgNDAAAAACADQwAAAABeGyIDOAIEAkAgAiADXUUEQCACIQUgAyECDAELIAEgAjgCBCABIAM4AgggAyEFCwJAIAIgBF1FBEAgBCEDIAIhBAwBCyABIAI4AgAgASAEOAIEIAIhAwsgAyAEXg0BIAQhAiADIQQMAgsgASAGiyACkZJDqqqqPhD0AiICjCACIAZDAAAAAF4bIgJDAAAAAFwEfSACIAQgApWSBSACCyAHk0MAAIA/liICQwAAAAAgAkMAAAAAXhs4AgBBASEADAILIAEgBDgCACABIAM4AgQgAyECCwJ/IAIgBFwEQCABQQRqIQFBAwwBCyABIAEpAgQiCzcCACALQiCIp74hBSALp74hAkECCyEAIAIgBVwNACABIAEoAgQ2AgAgAEEBaw8LIAALuAICCH0CfiAAKgIMIQIgACoCFCEEIAAqAgghAyAAKgIQIQUgACkCACEKIAEgACkCGCILNwIwIAEgCjcCACABIAUgC6e+IAWTQwAAAD+UkiIIOAIoIAEgAyAKp74iBpNDAAAAP5QgBpIiBjgCCCABIAQgC0IgiKe+IASTQwAAAD+UkiIJOAIsIAEgAiAKQiCIp74iB5NDAAAAP5QgB5IiBzgCDCABIAMgBSADk0MAAAA/lJIiAyAIIAOTQwAAAD+UkiIFOAIgIAEgBiADIAaTQwAAAD+UkiIDOAIQIAEgAiAEIAKTQwAAAD+UkiICIAkgApNDAAAAP5SSIgQ4AiQgASAHIAIgB5NDAAAAP5SSIgI4AhQgASADIAUgA5NDAAAAP5SSOAIYIAEgAiAEIAKTQwAAAD+UkjgCHAueDAMSfQR/An4CQCABRQ0AAn8CQCADBEACQAJAIANBAUoEQCADQQFrIRkgACEWA0AgAiAXIhhBAnRqIgAqAAQhBSAAKgAAIQQgFwRAIAUgAEEEayoCACIIk0MAAIA/IAiTIgaVQwAAgD+WIgVDAAAAACAFQwAAAABeGyEFIAQgCJMgBpVDAACAP5YiBEMAAAAAIARDAAAAAF4bIQQLAkAgBUMAAIA/WwRAIAECfyAEQwAAgD9bBEAgASAWKQIANwIAIAEgFkEYaiIXKQIANwIYIAEgFikCEDcCECABIBYpAgg3AgggASAWKQIYIho3AiggASAaNwIwQQQMAQsgFioCDCEFIBYqAhQhCCAWKgIIIQYgFioCECEJIBYpAhghGiABIBYpAgAiGzcCACABIAkgBCAap74gCZOUkiIMOAIoIAEgBCAGIBunviIKk5QgCpIiCjgCCCABIAggBCAaQiCIp74gCJOUkiILOAIsIAEgBCAFIBtCIIinviIHk5QgB5IiBzgCDCABIAYgBCAJIAaTlJIiBiAEIAwgBpOUkiIJOAIgIAEgCiAEIAYgCpOUkiIGOAIQIAEgBSAEIAggBZOUkiIFIAQgCyAFk5SSIgg4AiQgASAHIAQgBSAHk5SSIgU4AhQgASAGIAQgCSAGk5SSOAIYIAEgBSAEIAggBZOUkjgCHCAWQRhqIRdBBgtBA3RqIBo3AgAgASAXKQIAIho3AkAgASAaNwJIIAEgGjcCOAwBCyAWKgIMIQggFioCFCEGIBYqAgghCSAWKgIQIQogFioCACEHIBYqAgQhDCAWKgIYIQsgASAWKgIcIg44AkwgASALOAJIIAEgDDgCBCABIAc4AgAgASAKIAUgCyAKkyIPlJIiELytIAYgBSAOIAaTIhKUkiIRvK1CIIaENwJAIAEgByAEIAkgB5MiDZSSIgu8rSAMIAQgCCAMkyITlJIiDrytQiCGhDcCCCABIAcgBSANlJIiDSAFIAkgBSAKIAmTIhSUkiIHIA2TlJIiDSAEIAcgBSAQIAeTlJIiECANkyIVlJI4ACggASALIAQgCSAEIBSUkiIHIAuTlJIiCSAFIAcgBCAKIAQgD5SSIAeTlJIgCZMiC5SSOAAgIAEgDCAFIBOUkiIHIAUgCCAFIAYgCJMiDJSSIgogB5OUkiIHIAQgCiAFIBEgCpOUkiIPIAeTIhGUkjgALCABIA4gBCAIIAQgDJSSIgogDpOUkiIIIAUgCiAEIAYgBCASlJIgCpOUkiAIkyIGlJI4ACQgASAJvK0gCLytQiCGhDcCECABIBC8rSAPvK1CIIaENwI4IAEgCSAEIAuUkrytIAggBCAGlJK8rUIghoQ3AhggASANIAUgFZSSvK0gByAFIBGUkrytQiCGhDcCMAsgAUEwaiIWIQEgGEECaiIXIBlIDQALIAMgF0wNBkMAAAAAIQQgFiEAIAIgF0ECdGoqAgAgAiAYQQJ0QQRyaioCACIFk0MAAIA/IAWTlUMAAIA/liIFQwAAAABeDQEMAgsgA0EBRw0FIAIqAgAhBSABIRYLIAVDAACAP1sNAiAFIQQLIAAqAgwhBSAAKgIUIQggACoCCCEGIAAqAhAhCSAAKQIYIRogFiAAKQIAIhs3AgAgFiAJIAQgGqe+IAmTlJIiDDgCKCAWIAQgBiAbp74iCpOUIAqSIgo4AgggFiAIIAQgGkIgiKe+IAiTlJIiCzgCLCAWIAQgBSAbQiCIp74iB5OUIAeSIgc4AgwgFiAGIAQgCSAGk5SSIgYgBCAMIAaTlJIiCTgCICAWIAogBCAGIAqTlJIiBjgCECAWIAUgBCAIIAWTlJIiBSAEIAsgBZOUkiIIOAIkIBYgByAEIAUgB5OUkiIFOAIUIBYgBiAEIAkgBpOUkjgCGCAWIAUgBCAIIAWTlJI4AhxBBgwCCyABIAApAgA3AgAgASAAKQIYNwIYIAEgACkCEDcCECABIAApAgg3AggPCyAWIAApAgA3AgAgFiAAQRhqKQIANwIYIBYgACkCEDcCECAWIAApAgg3AgggFiAAKQIYIho3AiggFiAaNwIwQQQLQQN0IBZqIBo3AgALCywAIAEgApNDAABAQJQgAyAAk5IgACABkyABkyACkiICIAKSIAEgAJMgBBBgC5ADAgd9AX8gACoCACIHIAAqAggiApMiBUMAAAAAXSEJAkBBACAFQwAAAABcIAIgACoCECIIkyIGjCAGIAkbQwAAAABdG0UEQCAFjCAFIAkbIgMgCCAFIAKTkiIEjCAEIAkbIgRgIANDAAAAAFtyIARDAAAAAFtyRQRAIAMgBJUiA0MAAAAAXiADQwAAAABdcg0CCyAHIAggBYsgBotdGyECCyABIAAqAgQ4AgQgASAHOAIAIAEgACoCDDgCDCABIAI4AgggASAAKgIUOAIUIAEgCDgCEEEADwsgACgCFCEJIAEgAyACIAeTlCAHkiIFvK0gAyAAKgIMIgYgACgCBCIAviIEk5QgBJIiBLytQiCGhDcCCCABIAIgAyAIIAKTlJIiArytIAYgAyAJviAGk5SSIga8rUIghoQ3AhggASAHvK0gAK1CIIaENwIAIAEgCLytIAmtQiCGhDcCICABIAUgAyACIAWTlJIiAjgCCCABIAI4AhggASACvK0gBCADIAYgBJOUkrytQiCGhDcCEEEBC54DAgd9AX8gACoCDCICIAAqAhQiB5MhBSAAKgIEIgggApMiBEMAAAAAXSEJAkBBACAEQwAAAABcIAWMIAUgCRtDAAAAAF0bRQRAIASMIAQgCRsiAyAHIAQgApOSIgaMIAYgCRsiBmAgA0MAAAAAW3IgBkMAAAAAW3JFBEAgAyAGlSIDQwAAAABeIANDAAAAAF1yDQILIAggByAEiyAFi10bIQILIAAqAgAhAyABIAg4AgQgASADOAIAIAAqAgghAyABIAI4AgwgASADOAIIIAAqAhAhAiABIAc4AhQgASACOAIQQQAPCyAAKAIQIQkgASADIAAqAggiBCAAKAIAIgC+IgWTlCAFkiIFvK0gAyACIAiTlCAIkiIGvK1CIIaENwIIIAEgBCADIAm+IASTlJIiBLytIAIgAyAHIAKTlJIiArytQiCGhDcCGCABIACtIAi8rUIghoQ3AgAgASAJrSAHvK1CIIaENwIgIAEgBiADIAIgBpOUkiICOAIMIAEgAjgCHCABIAUgAyAEIAWTlJK8rSACvK1CIIaENwIQQQELbQICfwF9AkAgACABkyIAjCAAIABDAAAAAF0iBRsiBiAAIAGTIAKSIgCMIAAgBRsiAGAgBkMAAAAAW3IgAEMAAAAAW3INACAGIACVIgBDAAAAAF4gAEMAAAAAXXJFDQAgAyAAOAIAQQEhBAsgBAvVAQMCfwF8AX0jAEHwAGsiAiQAIAIgACoCALs5A0AgAiAAKgIEuzkDSCACIAAqAgi7OQNQIAIgACoCDLs5A1ggAiAAKgIQuzkDYCACIAAqAhS7OQNoIAIgAkFAaxCvAyIDQQJGBEAgAisDACEEIAEgAisDCLY4AgQgASAEtjgCACACKwMQIQQgASACKwMYtjgCDCABIAS2OAIICyAAKgIYIQUgAkHwAGokAEECQQNBASADQQFrdCIAQQF1IgEgAUECRhsiASAFQwAAgD9bGyABIABBA0obC6wDAwZ/A3wBfiABKwMoIQggASABKwMIIAErAxhkIgJBBHRqKwMIIQkgASsDACIKtiABQQIgCiABKwMQZCIDIAEgA0EEdGorAwAgASsDIGQbQQR0aiIDKwMAthA2IQQgASsDCLYgAUECIAIgCCAJYxtBBHRqIgIrAwi2EDYhBSABKwMQtiADKwMAthA2IQYgASsDGLYgAisDCLYQNiEHIARBAkEAIAYbckEEQQAgASsDILYgAysDALYQNhtyIgMgBUECQQAgBxtyQQRBACABKwMotiACKwMIthA2G3IiAnFBBXFBBUYEQCAAIAEpAwA3AxAgACABKQMINwMYIAEpAwAhCyAAIAEpAwg3AwggACALNwMAQQEPCwJAIANBB0YEQAwBCyACQQdGBEAMAQsgARDMAwRADAELIAAgASkDADcDACAAIAEpAyg3AyggACABKQMgNwMgIAAgASkDGDcDGCAAIAEpAxA3AxAgACABKQMINwMIQQMPCyAAIAEpAwA3AwAgACABKQMINwMIIAAgASkDIDcDECAAIAEpAyg3AxhBAUECIAAgAEEQahA4GwvGBwIGfwF8IAJBIEoEQANAIABFBEAgASEEIAMhByACIgVBAk8EQCAFQQF2IQMDQCAEIAMiAUEBayIDQQJ0aigCACEIIAMhAgJAIAFBAXQiACAFSw0AIAcoAgAiBiAIQQN0aisDACEKA0AgAUEBayEBIAAgBUkEQCAAIAYgBCAAQQJ0aiICQQRrKAIAQQN0aisDACAGIAIoAgBBA3RqKwMAY3IhAAsgCiAGIAQgAEEBayICQQJ0aigCACIJQQN0aisDAGNFBEAgASECDAILIAQgAUECdGogCTYCACAAIgFBAXQiACAFTQ0ACwsgBCACQQJ0aiAINgIAIAMNAAsLAkAgBUEBayIDRQ0AA0AgBCgCACEAIAQgBCADQQJ0aiIBKAIANgIAIAEgADYCACADQQFGDQEgBygCACEFIAQoAgAhBkECIQFBASECA0AgAkECdCAEakEEayABIANPBH8gAQUgASAFIAQgAUECdGoiAEEEaygCAEEDdGorAwAgBSAAKAIAQQN0aisDAGNyCyIAQQJ0IARqQQRrKAIANgIAIAAhAiAAQQF0IgEgA00NAAsCQCAAQQJJBEAgACEBDAELIAcoAgAiAiAGQQN0aisDACEKA0AgAiAAQQF2IgFBAnQgBGpBBGsoAgAiBUEDdGorAwAgCmNFBEAgACEBDAILIABBAnQgBGpBBGsgBTYCACAAQQNLIQUgASEAIAUNAAsLIAFBAnQgBGpBBGsgBjYCACADQQFrIgMNAAsLDwsgASACQQF0QQJrQXxxaiIEKAIAIQUgAygCACEGIAQgASACQQJ0akEEayIHKAIANgIAIAcgBTYCACAAQQFrIQACQCABIAdPBEAgASEEDAELIAYgBUEDdGorAwAhCiABIgQhBQNAIAogBiAFKAIAIghBA3RqKwMAZARAIAUgBCgCADYCACAEIAg2AgAgBEEEaiEECyAFQQRqIgUgB0kNAAsgBygCACEFCyAEKAIAIQYgBCAFNgIAIAcgBjYCACAAIAEgBCABa0ECdSIEIAMQsAMgASAEQQFqIgRBAnRqIQEgAiAEayICQSFODQALCyACQQJOBEAgAkECdCABakEEayEHIAMoAgAhAyABQQRqIQUgASEEA0AgBSEAIAMgBCgCBCIGQQN0aisDACIKIAMgBCgCAEEDdGorAwBjBEADQAJAIAUgBUEEayICKAIANgIAIAEgAk8NACAFQQhrIQQgAiEFIAogAyAEKAIAQQN0aisDAGMNAQsLIAIgBjYCAAsgACIEQQRqIgUgB00NAAsLCzIBAX8gACgCACIABEAgACAAKAIEIgFBAWs2AgQgAUEBRgRAIAAgACgCACgCCBEEAAsLC70GAQV/IAJBIEoEQANAIABFBEAgASEEIAMhBSACIgNBAk8EQCADQQF2IQIDQCAEIAIiAEEBayICQQJ0aigCACEHIAIhBgJAIABBAXQiASADSw0AA0AgASADSQRAIAQgAUECdGoiBkEEaygCACAGKAIAIAURAAAgAXIhAQsgByAEIAFBAWsiBkECdGoiCCgCACAFEQAARQRAIABBAWshBgwCCyAAQQJ0IARqQQRrIAgoAgA2AgAgASIAQQF0IgEgA00NAAsLIAQgBkECdGogBzYCACACDQALCwJAIANBAWsiA0UNAANAIAQoAgAhACAEIAQgA0ECdGoiASgCADYCACABIAA2AgAgA0EBRg0BIAQoAgAhBkECIQBBASECA0AgAkECdCAEakEEayAAIANPBH8gAAUgBCAAQQJ0aiIBQQRrKAIAIAEoAgAgBREAACAAcgsiAUECdCAEakEEaygCADYCACABIgJBAXQiACADTQ0ACyACIQACQCABQQJJDQADQCABQQF2IgBBAnQgBGpBBGsiAigCACAGIAURAABFBEAgASEADAILIAFBAnQgBGpBBGsgAigCADYCACABQQNLIQIgACEBIAINAAsLIABBAnQgBGpBBGsgBjYCACADQQFrIgMNAAsLDwsgASACQQF0QQJrQXxxaiIEKAIAIQcgBCABIAJBAnRqQQRrIgYoAgA2AgAgBiAH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ahA7DQMLIA4gFEgEQCAFIAMoAtQIaigCBEEIaiALQQhqEDsNAwsgASACIA8Q6AEiERshDCACIAEgERshBiAIKAJMIQECfyAVQQBHIBZEAAAAAAAAAABkc0UiBARAQQAgAWshAUEAIAgoAlBrDAELIAgoAlALIQIgCCgCRCEFIAEgBmoiEiAGIAYgEhD3AxshEyAFQYGAgIB4RyIFRQRAIAggExC6AQsgCCgCSCEBIAIgDGoiBiAMIAwgBhD3AxshAiABQYGAgIB4RgRAIAggAhC1AgsCQCAFDQAgABDnAy0AEkEDRgRAIA8oApgBIAQ2AvABDAELIA8gCCAIKAJAIBMgAkEAELsBGiAPIAgoAkAgCCATIAJBABC7ARoLIAAQ5wMiASABKAIMQQFqNgIMIBIgBiARGyECIAYgEiARGyEBIAtBCGohBAtBASEGIA5BAWoiDiAJRw0ACwsgAy0A2AhBAXFFDQAgAygC1AgQJQsgEBBFIANB4AhqJAAgBgtgAQJ/An8gAItDAACANV8EQEEAIAGLQwAAgDVfDQEaC0EAIAC8IgJB/////wdxayACIAJBAEgbIgNBACABvCICQf////8HcWsgAiACQQBIGyICQRBqTiACIANBEGpOcgsLtAIBAX8jAEHgEWsiAyQAIANB/MsANgKYESADQagRaiABKQMINwMAIANBsBFqIAEpAxA3AwAgA0G4EWogASkDGDcDACADQcARaiABKQMgNwMAIANByBFqIAEpAyg3AwAgA0HQEWogASkDMDcDACADQdgRaiABKQM4NwMAIAMgASkDADcDoBEgA0GcywA2AtgQIANB6BBqIAIpAwg3AwAgA0HwEGogAikDEDcDACADQfgQaiACKQMYNwMAIANBgBFqIAIpAyA3AwAgA0GIEWogAikDKDcDACADQZARaiACKQMwNwMAIAMgAikDADcD4BAgA0GwCGogA0GYEWoQYiIBIANBCGogA0HYEGoQYiICIAAQpQEgAC0AxgMhACACQYQIahBFIAFBhAhqEEUgA0HgEWokACAAC6MCAQF/IwBB0BFrIgMkACADQfzLADYCiBEgA0GYEWogASkDCDcDACADQaARaiABKQMQNwMAIANBqBFqIAEpAxg3AwAgA0GwEWogASkDIDcDACADQbgRaiABKQMoNwMAIANBwBFqIAEpAzA3AwAgA0HIEWogASkDODcDACADIAEpAwA3A5ARIANB/MwANgLQECADQeAQaiACKQMINwMAIANB6BBqIAIpAxA3AwAgA0HwEGogAikDGDcDACADQfgQaiACKQMgNwMAIANBgBFqIAIpAyg3AwAgAyACKQMANwPYECADQagIaiADQYgRahBiIgEgAyADQdAQahBiIgIgABClASAALQDGAyEAIAJBhAhqEEUgAUGECGoQRSADQdARaiQAIAALmAIBAX8jAEHQEWsiAyQAIANBnMsANgKQESADQaARaiABKQMINwMAIANBqBFqIAEpAxA3AwAgA0GwEWogASkDGDcDACADQbgRaiABKQMgNwMAIANBwBFqIAEpAyg3AwAgA0HIEWogASkDMDcDACADIAEpAwA3A5gRIANB/MwANgLYECADQegQaiACKQMINwMAIANB8BBqIAIpAxA3AwAgA0H4EGogAikDGDcDACADQYARaiACKQMgNwMAIANBiBFqIAIpAyg3AwAgAyACKQMANwPgECADQbAIaiADQZARahBiIgEgA0EIaiADQdgQahBiIgIgABClASAALQDGAyEAIAJBhAhqEEUgAUGECGoQRSADQdARaiQAIAAL1QYCBH8BfCACQSBKBEADQCAARQRAIAEhBCACIgVBAk8EQCAFQQF2IQIDQCAEIAIiAUEBayICQQJ0aigCACEGIAIhAwJAIAFBAXQiACAFSw0AIAYrAyghCANAIAFBAWshASAAIAVJBEAgACAEIABBAnRqIgNBBGsoAgArAyggAygCACsDKGNyIQALIAggBCAAQQFrIgNBAnRqKAIAIgcrAyhjRQRAIAEhAwwCCyAEIAFBAnRqIAc2AgAgACIBQQF0IgAgBU0NAAsLIAQgA0ECdGogBjYCACACDQALCwJAIAVBAWsiA0UNAANAIAQoAgAhACAEIAQgA0ECdGoiASgCADYCACABIAA2AgAgA0EBRg0BIAQoAgAhBUECIQFBASECA0AgAkECdCAEakEEayABIANPBH8gAQUgASAEIAFBAnRqIgBBBGsoAgArAyggACgCACsDKGNyCyIAQQJ0IARqQQRrKAIANgIAIAAhAiAAQQF0IgEgA00NAAsCQCAAQQJJBEAgACEBDAELIAUrAyghCANAIABBAXYiAUECdCAEakEEaygCACICKwMoIAhjRQRAIAAhAQwCCyAAQQJ0IARqQQRrIAI2AgAgAEEDSyECIAEhACACDQALCyABQQJ0IARqQQRrIAU2AgAgA0EBayIDDQALCw8LIAEgAkEBdEECa0F8cWoiBCgCACEFIAQgASACQQJ0akEEayIGKAIANgIAIAYgBTYCACAAQQFrIQACQCABIAZPBEAgASEEDAELIAUrAyghCCABIgQhBQNAIAggBSgCACIHKwMoZARAIAUgBCgCADYCACAEIAc2AgAgBEEEaiEECyAFQQRqIgUgBkkNAAsgBigCACEFCyAEKAIAIQcgBCAFNgIAIAYgBzYCACAAIAEgBCABa0ECdSIEIAMQuQMgASAEQQFqIgRBAnRqIQEgAiAEayICQSFODQALCyACQQJOBEAgAkECdCABakEEayEDIAFBBGohBSABIQQDQCAFIQAgBCgCBCIGKwMoIgggBCgCACsDKGMEQANAAkAgBSAFQQRrIgIoAgA2AgAgASACTw0AIAVBCGshBCACIQUgCCAEKAIAKwMoYw0BCwsgAiAGNgIACyAAIgRBBGoiBSADTQ0ACwsL+QECA34CfwJAQQAgACkCBCIBQiGIIgMgAadBAXZBAWqsIgJZQgEgAUKAgICAEIMgAUIBg1AgAyACQgN+V3IbUBsNACACIAJCAXxCAYd8Qgd8QniDIgIgA1ENACAAIAFC/////x+DIAJC/////wcgAkL/////B1MbIgFCgYCAgHggAUKBgICAeFUbIgFCIYaENwIEIAGnQf////8HcUE4EFchBCAAKQIEIgGnQQF2QThsIgUEQCAEIAAoAgAgBRAsGiAAKQIEIQELIAFCAYNQRQRAIAAoAgAQJSAAKQIEIQELIAAgBDYCACAAIAFC/v///2+DQgGENwIECwuDCQEDfyAAKAIAIgRBACAEKAIAKAIIEQAAIQMgASgCACIEQQAgBCgCACgCCBEAACEFAn9BACADKwMAIAUrAwBiDQAaQQAgAysDCCAFKwMIYg0AGiACRAAAAAAAAAAARAAAAAAAAAAAIAAoAgAiBEEAIAQoAgAoAggRAAAQJhpBBQshBCAAKAIAIgNBACADKAIAKAIIEQAAIQUgASgCACIDIAMgAygCACgCSBEBACADKAIAKAIIEQAAIQMCQCAFKwMAIAMrAwBiDQAgBSsDCCADKwMIYg0AIAJEAAAAAAAAAABEAAAAAAAA8D8gACgCACIDQQAgAygCACgCCBEAABAmGiAEQQlyIQQLIAAoAgAiAyADIAMoAgAoAkgRAQAgAygCACgCCBEAACEDIAEoAgAiBUEAIAUoAgAoAggRAAAhBQJAIAMrAwAgBSsDAGINACADKwMIIAUrAwhiDQAgAkQAAAAAAADwP0QAAAAAAAAAACAAKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAQJhogBEEGciEECyAAKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAhBSABKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAhAwJAIAUrAwAgAysDAGINACAFKwMIIAMrAwhiDQAgAkQAAAAAAADwP0QAAAAAAADwPyAAKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAQJhogBEEKciEECwJAIARBBXENACAAKAIAIgNBACADKAIAKAIIEQAAIAEoAgAiA0EAIAMoAgAoAggRAAAQOEUNACACRAAAAAAAAAAARAAAAAAAAAAAIAAoAgAiA0EAIAMoAgAoAggRAAAgASgCACIDQQAgAygCACgCCBEAABCpASAEQQVyIQQLAkAgBEEJcQ0AIAAoAgAiA0EAIAMoAgAoAggRAAAgASgCACIDIAMgAygCACgCSBEBACADKAIAKAIIEQAAEDhFDQAgAkQAAAAAAAAAAEQAAAAAAADwPyAAKAIAIgNBACADKAIAKAIIEQAAIAEoAgAiAyADIAMoAgAoAkgRAQAgAygCACgCCBEAABCpASAEQQlyIQQLAkAgBEEGcQ0AIAAoAgAiAyADIAMoAgAoAkgRAQAgAygCACgCCBEAACABKAIAIgNBACADKAIAKAIIEQAAEDhFDQAgAkQAAAAAAADwP0QAAAAAAAAAACAAKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAgASgCACIDQQAgAygCACgCCBEAABCpASAEQQZyIQQLAkAgBEEKcQ0AIAAoAgAiAyADIAMoAgAoAkgRAQAgAygCACgCCBEAACABKAIAIgMgAyADKAIAKAJIEQEAIAMoAgAoAggRAAAQOEUNACACRAAAAAAAAPA/RAAAAAAAAPA/IAAoAgAiACAAIAAoAgAoAkgRAQAgACgCACgCCBEAACABKAIAIgAgACAAKAIAKAJI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BEAgBCACNgJQIAJFDQEgAiAENgJMIAIrA3ggAisDgAFkRQ0BDAMLIAAgAjYClAggAkUNACACQQA2AkwLIAAgBUEBayIENgKgCCAFQQBMDQEgASAGNgJQIAAgATYCnAggAUEBOgCUASABIQYgBCEFIANFDQEMAgsgA0EASg0BC0EADwsgA0EBayEDIAIiAQ0ACwtBAQvNBgIDfwF8AkAgACgCnAgiAwRAIAAgAygCUDYCnAgMAQsgACgCACEEQQAgAEGICGooAgAiA2tBB3EiBUGYAXIgAEGMCGooAgAgA2tLBEAgAEGECGpBmAFBCBAxQQAgACgCiAgiA2tBB3EhBQsgACADIAVqIgNBmAFqNgKICCADQQA6ACAgA0KAgICAgICA+L9/NwMYIANCgICAgICAgPz/ADcDECADQQA6AEAgA0KAgICAgICA+L9/NwM4IANCgICAgICAgPz/ADcDCCADQoCAgICAgID8/wA3AzAgA0KAgICAgICA/P8ANwMoIAMgBCAAQYQIaiAEKAIAKAI4EQAANgIACyADQQA6AJQBIANBADoAkQEgA0EANgJIIAAgACgCoAhBAWo2AqAIIAMgASACIABBhAhqEKkCGiAAKAIAIQQCQCADKwN4IgIgAmINACADKwOAASIGIAZiDQAgBCACIAYgAygCACAEKAIAKAJUEQoAIANB2ABqIAMoAgAQYyADQQA6ACAgA0KAgICAgICA+L9/NwMYIANCgICAgICAgPz/ADcDECADQUBrQQA6AAAgA0KAgICAgICA+L9/NwM4IANCgICAgICAgPz/ADcDCCADQoCAgICAgID8/wA3AzAgA0KAgICAgICA/P8ANwMoIAMgAysDcCADKwNgoSICIAMrA2ggAysDWKEiBiACIAZkGzkDiAEgAygCACIEIAQoAgAoAhARAQAhBCADQQA6AJQBIANBADoAkQEgAyAEOgCQASAAKAIAIQQLAkAgASsDeCICIAJiDQAgASsDgAEiBiAGYg0AIAQgAiAGIAEoAgAgBCgCACgCVBEKACABQdgAaiABKAIAEGMgAUEAOgAgIAFCgICAgICAgPi/fzcDGCABQoCAgICAgID8/wA3AxAgAUFAa0EAOgAAIAFCgICAgICAgPi/fzcDOCABQoCAgICAgID8/wA3AwggAUKAgICAgICA/P8ANwMwIAFCgICA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QZgBciAAQYwIaigCACADa0sEQCAAQYQIakGYAUEIEDFBACAAKAKICCIDa0EHcSEGCyAAIAMgBmoiA0GYAWo2AogIIANBADoAICADQoCAgICAgID4v383AxggA0KAgICAgICA/P8ANwMQIANBADoAQCADQoCAgICAgID4v383AzggA0KAgICAgICA/P8ANwMIIANCgICAgICAgPz/ADcDMCADQoCAgICAgID8/wA3AyggAyAFIABBhAhqIAUoAgAoAjgRAAA2AgALIANBADoAlAEgA0EAOgCRASADQQA2AkggACAAKAKgCEEBajYCoAggAwJ8IAQEQCAEQdAAaiEFIAQrA4ABDAELIABBlAhqIQVEAAAAAAAAAAALIgc5A3ggBSgCACIFBHwgBSsDeAVEAAAAAAAA8D8LIQIgAyAFNgJQIAMgBDYCTCADIAI5A4ABAkAgBARAIAQgAzYCUAwBCyAAIAM2ApQICyAFBEAgBSADNgJMCyAAKAIAIQQgA0EAOwGSASAHIAdiIAIgAmJyRQRAIAQgByACIAMoAgAgBCgCACgCVBEKACADQdgAaiADKAIAEGMgA0EAOgAgIANCgICAgICAgPi/fzcDGCADQoCAgICAgID8/wA3AxAgA0FAa0EAOgAAIANCgICAgICAgPi/fzcDOCADQoCAgICAgID8/wA3AwggA0KAgICAgICA/P8ANwMwIANCgICAgICAgPz/ADcDKCADIAMrA3AgAysDYKEiAiADKwNoIAMrA1ihIgcgAiAHZBs5A4gBIAMoAgAiBCAEKAIAKAIQEQEAIQQgA0EAOgCUASADQQA6AJEBIAMgBDoAkAELCyAAQYQIaiEGQQAgAEGICGooAgAiBGtBA3EiBUEIciAAQYwIaigCACAEa0sEQCAGQQhBBBAxQQAgACgCiAgiBGtBA3EhBQsgACAEIAVqIgRBCGo2AogIIARCADcCACAEIAE2AgAgBCADKAJINgIEIAMgBDYCSEEAIAAoAogIIgRrQQNxIgVBCHIgACgCjAggBGtLBEAgBkEIQQQQMUEAIAAoAogIIgRrQQNxIQULIAAgBCAFaiIAQQhqNgKICCAAQgA3AgAgACADNgIAIAAgASgCSDYCBCABIAA2AkgLC8kFAgN8A38jAEEwayIGJAAgACACKwMAIgM5AwAgACADOQMQIAAgAisDCCIE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EPQBDAQLIAooAgAgE2oiBCgCACgCKARAIwBB0CNrIgMkAEEAIAQtAApBA3EiDyAPQQFGGyEGIANBwAVqIANBwANqQYACQYACEKIBIQ0gBCgCACgCKCILIAMoAsgFIAMoAsQFIgJrSwRAIA0gC0EBEDEgAygCxAUhAgsgAyACIAtqNgLEBSAEIgcoAgAiBSgCKCIJIAsgCSALSBsiBAR/IAIgBSgCICAEECwaIAcoAgAoAigFIAkLGkECIAYgD0EDRhshEQJAAkACQCALQQJOBEAgAi0AAQRAQQIhBQNAIAsgBSIERwRAIARBAWohBSACIARqLQAADQELCyANEEUgBCALSA0DDAILIA0QRQwCCyANEEULAkACQCAHEJkCDgMAAQIBCyADQcADahA1IQQgByADQbgBahB4GiAEIAMqArgBIAMqArwBEEggBCAHELABIAQQaiAHIAQQUCAEECsLIAcgBy0ACkH8AXEgEXI6AApBASECDAELIANBwCNqIANBwANqQYAgQYAgEKIBIQ1BACECIANBADoAtAMgA0EANgKsAyADQgA3A5ADIANBoAFqIANBuAFqIgQgDRCmAiELIANCADcDWCADQgA3A2AgA0IANwNoIANBADYCcCADQQA6AIgBIANCADcDUCADIAc2AkwgAyALNgJIIANBADoAnQEgAyAENgKMASADIAQ2AnQgA0HIAGoQ2AICQCADLQCeAQ0AIANByABqENYCRQ0AAkAgAygCrANFDQAgAygClANFDQEgA0GsA2ohD0EBIQIgA0G4AWohBQNAIAIEQCAFQRxqIQkgBUEIaiIGIQIDQCACKAJ0IQQgAiACKAKcASICIAYgAhs2AnQgAkEUaiAJIAIbIAQ2AgAgAg0ACwsgBSgC3AEiBQRAIAUoAvQBIQIMAQVBASEFIANBuAFqIQIDQCAFBEAgAkEAOgD+ASACQX82AvABCyACKALcASICBEAgAigC9AEhBQwBCwsgC0EDOgASAkAgA0G4AWoQowEiAgRAQQAhBQNAIAstAAxBAXFFIAIoAiAoApgBIgQoAvABQQBHc0UEQCAEQQE6AP4BQQEhBQsgBEEIaiECA0AgAhDhASACKAKcASICDQALIAtBADYCDCADQbgBahCjASICDQALIAVBAXENAQsgByAHLQAKQfwBcSARcjoACgwDCyADQbgBaiEC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IAIhBSAHIAQqAgBdDQELCyACIAc4AgALIAAiBEEEaiIFIANNDQALCwvwCgMLfwF+AX0jAEEwayICJAACQCAAKAIEKAIAIgQtAFRFBEAgBC0AVSEFDAELIARBBGogBCgCFCAEKAIcEDQhBSAEQQA6AFQgBCAFOgBVCwJ/IAVB/wFxRQRAIABBAToAVkEADAELIAAoAgQiBCgCACIBKAIgIQUCfyABLQBURQRAIAEtAFUhAyAFDAELIAFBBGogASgCFCABKAIcEDQhAyABQQA6AFQgASADOgBVIAQoAgAiASgCIAshBCAAQSBqIQggA0H/AXEEQCAEIAEoAihqQQAgBBshBAsCQCAEIAVGDQAgAEEUaiELIABBCGohCSACQQhyIQogASgCFCEDIAEoAiwhBwNAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBS0AAA4GAAEFAgMECAsgAC0AVSAGRXJFBEAgACACIAJBKGoQ1wILQQAhBiAIEFtBADoAACADKAIEIQEgAkEAIAMoAgAgAykCACIMp0H/////B3G+QwAAADZdGzYCACACQQAgASAMQiCIp0H/////B3G+QwAAADZdGzYCBCAJQQFBABBBIAIpAwA3AgAgAiACKQMANwMoDAYLIAMoAgQhASACQQAgAygCACADKQIAIgynQf////8Hcb5DAAAANl0bNgIIIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIMQQEhASACIAoQO0UNBCAAKAIoIAAoAiBqQQFrLQAAQQJJDQUgAiACKQMIIgw3AwAgACgCCCAAKAIQQQN0akEIayAMNwIADAULIAMoAgQhASACQQAgAygCACADKQIAIgynQf////8Hcb5DAAAANl0bNgIIIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIMIAMoAgwhASACQQAgAygCCCADKQIIIgynQf////8Hcb5DAAAANl0bNgIQIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIUAkAgAiACENYBIgEOAwUEAAQLQQMhASAHKgIAQwAAgD9cDQNBAiEBDAMLIAMoAgQhASACQQAgAygCACADKQIAIgynQf////8Hcb5DAAAANl0bNgIIIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIMIAMoAgwhASACQQAgAygCCCADKQIIIgynQf////8Hcb5DAAAANl0bNgIQIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIUIAMoAhQhASACQQAgAygCECADKQIQIgynQf////8Hcb5DAAAANl0bNgIYIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIcIAIgAhCjAiIBDQIMAwsgACACIAJBKGoQ1wJBACEGDAILIAMoAgQhASACQQAgAygCACADKQIAIgynQf////8Hcb5DAAAANl0bNgIIIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIMIAMoAgwhASACQQAgAygCCCADKQIIIgynQf////8Hcb5DAAAANl0bNgIQIAJBACABIAxCIIinQf////8Hcb5DAAAANl0bNgIUIAIgAhDWASIBRQ0BCyAIEFsgAToAACAJIAEgAUEBakECdWsiBiAKEEEaIAFBA0YEQCAHKgIAIQ0gC0EBEFwgDTgCAAsgAiACIAZBA3RqKQMANwMAQQEhBgtBASEBAkACQCAFLQAADgYEBAMFAAECC0EDIQEMAwtBACEBDAILAAtBAiEBCyADIAFBA3RqDAELIAdBBGohByADQRBqCyEDIAVBAWoiBSAERw0ACyAALQBVIAZFcg0AIAAgAiACQShqENcCCyAIEFtBBjoAACAAKAIoQQFrCyEDIAJBMGokACADC6IDAgR/A3wjAEFAaiIDJAAgACAAKAL0ASICQQFqNgL0AQJAIAIEQEEAIAAoAgAoAgAiBCgCBCICa0EHcSIFQdABciAEKAIIIAJrSwRAIARB0AFBCBAxQQAgBCgCBCICa0EHcSEFCyAEIAIgBWoiAkHQAWo2AgQgAkEAQdABEDcaDAELIABBCGohAgsgAiAAKALYASIENgKgASAEBEAgBCACNgKcAQsgACACNgLYASACIAFDAACAPyAAQQIQ4gEgAyABKgIAuzkDACADIAEqAgS7OQMIIAMgASoCCLs5AxAgAyABKgIMuzkDGCADIAEqAhC7OQMgIAMgASoCFLs5AygjAEHQAGsiACQAIAAgASoCALs5AyAgACABKgIEuzkDKCAAIAEqAgi7OQMwIAAgASoCDLs5AzggACABKgIQuzkDQCAAIAEqAhS7OQNIIAAgAEEgaiADEMYDIAArAwAhBiAAKwMIIQcgACsDECEI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qNQALQAAQQFxBEBBpNQAKAIAIQEMAQtBAkGQGxACIQFBqNQAQQE6AABBpNQAIAE2AgALIAVBEGokACABIARBzgwCfyMAQRBrIgEkACABIANBCGoiBDYCDCABQQxqQZAaKAIAEJUBIAFBEGokACAECxADIANBEGokAAsgACgCACEFIAJBGGohAyMAQRBrIgQkACMAQRBrIgYkAAJAQbDUAC0AAEEBcQRAQazUACgCACEBDAELQQJBmBsQAiEBQbDUAEEBOgAAQazUACABNgIACyAGQRBqJAAgASAFQc4MAn8jAEEQayIBJAAgASAEQQhqIgU2AgwgAUEMaiADEL4BEJUBIAFBEGokACAFCxADIARBEGokACADEIIBIAJBQGsiASABKAIAIgNBAWo2AgAgAy0AACIDQQZPBEAACyABIAEoAgQgA0ECdEHwImooAgBBA3RqNgIEIANBA0YEQCABIAEoAghBBGo2AggLDAELCyACQeAAaiQACysCAX8BfSMAQRBrIgIkACACIAEgABEdADgCDCACKgIMIQMgAkEQaiQAIAMLEQEBf0EIEDMiAEIANwMAIAALDABBJBAzQQBBJBA3Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACw8AIAEgACgCAGogAjoAAAsNACABIAAoAgBqLQAACywBAX8jAEEQayIFJAAgBSABIAIgAyAEIAARGAAgBRC2BCEAIAVBEGokACAACzQBAn8jAEEQayIEJAAgBEEIaiIFIAEgAiADIAARBwAgBRC+ASEAIAUQggEgBEEQaiQAIAALMgECfyMAQRBrIgMkACADQQhqIgQgASACIAARBQAgBBC+ASEAIAQQggEgA0EQaiQAIAALKgEBfyMAQRBrIgIkACACIAEgABEDACACEM8BIQAgAhArIAJBEGokACAACygBAX8jAEEQayIBJAAgASAAEQQAIAEQzwEhACABECsgAUEQaiQAIAALBABBAQuYAgEHfyMAQSBrIgQkACABQQRqIQYgASgCACEDIwBBEGsiByQAIwBBEGsiBSQAIARBCGohAQJAIANBb00EQAJAIANBCk0EQCABIAM6AAsgASECDAELIANBC08EfyADQRBqQXBxIgIgAkEBayICIAJBC0YbBUEKC0EBaiIIIgJBf0sEQBDOAQALIAEgAhAzIgI2AgAgASAI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BiAAKgIclCAAKgIgkpIiBJUgBCAEQwAAAABcGyIElDgCACABIAcgBSAIlCAGIAmUkpIgBJQ4AgQgAUEIaiEBIAJBCGohAiADQQFrIgMNAAsLC4kDAQd9AkAgA0EATA0AIAAqAhAhBCAAKgIAIQUgACoCFCEGIAAqAgghByADQQFxBEAgASACKgIAIAWUIAeSOAIAIAEgAioCBCAElCAGkjgCBCACQQhqIQIgAUEIaiEBCyADQQJxBEAgAioADCEIIAIqAAAhCSACKgAEIQogASAHIAUgAioACJSSOAAIIAEgBiAEIAqUkjgABCABIAcgBSAJlJI4AAAgASAGIAQgCJSSOAAMIAJBEGohAiABQRBqIQELIANBBEkNACADQQJ2IQBBACEDA0AgAioADCEIIAIqAAAhCSACKgAEIQogASAHIAUgAioACJSSOAAIIAEgBiAEIAqUkjgABCABIAcgBSAJlJI4AAAgASAGIAQgCJSSOAAMIAIqABQhCCACKgAQIQkgAioAGCEKIAEgBiAEIAIqAByUkjgAHCABIAcgBSAKlJI4ABggASAGIAQgCJSSOAAUIAEgByAFIAmUkjgAECABQSBqIQEgAkEgaiECIANBAWoiAyAARw0ACwsLBQAgAL4L0QIBBX0CQCADQQBMDQAgACoCFCEEIAAqAgghBSADQQFxBEAgASAFIAIqAgCSOAIAIAEgBCACKgIEkjgCBCACQQhqIQIgAUEIaiEBCyADQQJxBEAgAioADCEGIAIqAAAhByACKgAEIQggASAFIAIqAAiSOAAIIAEgBCAIkjgABCABIAUgB5I4AAAgASAEIAaSOAAMIAJBEGohAiABQRBqIQELIANBBEkNACADQQJ2IQBBACEDA0AgAioADCEGIAIqAAAhByACKgAEIQggASAFIAIqAAiSOAAIIAEgBCAIkjgABCABIAUgB5I4AAAgASAEIAaSOAAMIAIqABQhBiACKgAQIQcgAioAGCEIIAEgBCACKgAckjgAHCABIAUgCJI4ABggASAEIAaSOAAUIAEgBSAHkjgAECABQSBqIQEgAkEgaiECIANBAWoiAyAARw0ACwsLHQAgASACRiADQQBMckUEQCABIAIgA0EDdBAsGgsLNwECfyMAQTBrIgokACAKQQhqIgsgASACIAMgBCAFIAYgByAIIAkQqgIgACALEKMD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KSApXA0AIAMgIyAhICEgI10bIik4AgwgAyAiICAgICAiXRsiKzgCCCADICMgISAhICNeGyIjOAIEIAMgIiAgICAgIl4bIiE4AgAgISArXSAjICldcUUEQCADQgA3AhAgA0EANgIwIANCADcCKCADQgA3AiAgA0IANwIYDAILIB9DAAAAACAfvEGAgID8B3FBgICA/AdHIgIgAnEiAhsiICAgkiEiICsgIZMiKyAfQwAAAAAgAhsiISAhkiIsXSApICOTIiMgIl1yBEAgICAjICKVIiAgKyAslSIiICAgIl0bIiKUISAgISAilCEhCwJAICFDAAAAAF8gIEMAAAAAX3JFBEAgA0EDNgIwIAMgITgCECADICA4AiwgAyAhOAIoIAMgIDgCJCADICE4AiAgAyAgOAIcIAMgITgCGCADICA4AhQgISArQwAAAD+UYEUgICAjQwAAAD+UYEVyDQEgA0ECNgIwDAMLIAQqAgAiIEMAAAAAlCAEKgIEIiGUIAQqAggiIpQgBCoCDCIjlCIpIClcDQEgAyAjICEgISAjXRsiKTgCDCADICIgICAgICJdGyIrOAIIIAMgIyAhICEgI14bIiE4AgQgAyAiICAgICAiXhsiIDgCACAgICtdICEgKV1xRQRAIANCADcCECADQQA2AjAgA0IANwIoIANCADcCICADQgA3AhgMAwsgA0IANwIQIANCADcCKCADQgA3AiAgA0IANwIYIANBATYCMAsMAQsgA0IANwIAIANBADYCMCADQgA3AiggA0IANwIgIANCADcCGCADQgA3AhAgA0IANwIIC0EHQQYgABshBiMAQZABayICJAACf0EBIAcoAgAiCCgCKCIRQQBMDQAaQQAgCCgCICIJLQAAQQFrQf8BcUEESQ0AGgNAIBEgBUEBaiIFRwRAIAlBAWoiCS0AAEEBa0H/AXFBBE8NAQsLIAUgEU4LIRcCQAJAAkACQCADKAIwDgMAAAECCyAHIAMgACAGQQFqQQF2EH0MAgsgByADIAAgBkEBdhCTAgwBC0EAIQkgBwJ/IAAgEUEATA0AGiAIKAIgIgUtAABBAWtB/wFxQQRPBEADQCARIAlBAWoiCUcEQCAFQQFqIgUtAABBAWtB/wFxQQRPDQELCyAAIAkgEU4NARoLQQILOgAJIAJB8ABqIAcgAxCVAiEJIActAAkhESAC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oCIGoSAFu6IgCqO2iyIDEF0aIAAgASADIAi2lJMgAiADIAm2lJMQJyABIAIgDSoCACABkiANKgIEIAKSIAZEAAAAAAAA4D+iRAAAAAAAAOA/oLaREDkaCyANQRBqJAALXwECfyMAQRBrIgQkACAAKAIEIgNBAXUgAWohASAAKAIAIQAgA0EBcQRAIAEoAgAgAGooAgAhAAsgBEEIaiIDIAEgAiAAEQ8AQQgQMyIAIAMpAgA3AwAgBEEQaiQAIAALVQECfyMAQRBrIgMkACAAKAIEIgRBAXUgAWohASAAKAIAIQAgAyABIAIgBEEBcQR/IAEoAgAgAGooAgAFIAALESkAOAIMIAMqAgwhAiADQRBqJAAgAgs0AQJ/IwBBEGsiAyQAIANBCGoiBCABELQEIAMgAhC0BCAEIAMgABEAACEAIANBEGokACAACzkBAX8gACgCBCIEQQF1IAFqIQEgACgCACEAIAEgAiADIARBAXEEfyABKAIAIABqKAIABSAACxEFAAs1AQJ/IwBBEGsiAyQAIAAoAgAhBCADQQhqIgAgAhC2ASABIAAgBBEDACAAEIIBIANBEGokAAsQACABIAIgAyAAKAIAEQIACwwAIAEgACgCABEBAAseACABIAIgAyAEIAUgBiAHIAggCSAKIAAoAgARJwALDgAgASACIAAoAgARAwALPAEBfyMAQRBrIgMkACAAKAIAIQAgAyACKQIINwMIIAMgAikCADcDACABIAMgABEAACEAIANBEGokACAACxIAIAEgAiADIAQgACgCABEOAAsSACABIAIgAyAEIAAoAgARPAALLQEBfyMAQRBrIgIkACACIAEgACgCABEDACACEM8BIQAgAhArIAJBEGokACAACw4AIAEgAiAAKAIAEQAAC04BAn8jAEEQayICJAAgACgCACEDIAIgACgCBCIAQQF1IAFqIgEgAEEBcQR/IAEoAgAgA2ooAgAFIAMLEQMAIAIQtgQhACACQRBqJAAgAAtPAQF/IAAoAgAhAiAAKAIEIgBBAXUgAWoiASAAQQFxBH8gASgCACACaigCAAUgAgsRAQAhAEEQEDMiASAAKQIINwIIIAEgACkCADcCACABCzMBAX8gACgCACECIAAoAgQiAEEBdSABaiIBIABBAXEEfyABKAIAIAJqKAIABSACCxEBAAs3AQF/IAAoAgQiA0EBdSABaiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALEQMACxQAIAEgAiADIAQgBSAAKAIAERgACxAAIAEgAiADIAAoAgAREQALHAAgASACIAMgBCAFIAYgByAIIAkgACgCABE9AAsYACABIAIgAyAEIAUgBiAHIAAoAgARJgALDAAgASAAKAIAEQQACxYAIAEgAiADIAQgBSAGIAAoAgARLAALGAAgASACIAMgBCAFIAYgByAAKAIAET4ACyAAIAEgAiADIAQgBSAGIAcgCCAJIAogCyAAKAIAESsACwkAIAEgABEBAAsEAEEGCwMAAQsLzEY/AEGACAuREmluZmluaXR5AGNvcHkAX3NpbXBsaWZ5AFNrTWF0cml4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAdW5zaWduZWQgc2hvcnQAU2tQb2ludAB1bnNpZ25lZCBpbnQAbWl0ZXJfbGltaXQAZlJpZ2h0AGZMZWZ0AF9yZWN0AFNrUmVjdABMVFJCUmVjdABmbG9hdAB1aW50NjRfdABTdHJva2VPcHRzAGVxdWFscwBjb21wdXRlVGlnaHRCb3VuZHMAZ2V0Qm91bmRzAHRvQ21kcwBfRnJvbUNtZHMAdG9DYW52YXMAU2tPcEJ1aWxkZXIAdW5zaWduZWQgY2hhcgAhcQAuLi8uLi9zcmMvY29yZS9Ta1N0cmluZy5jcHAALi4vLi4vc3JjL2NvcmUvU2tDb250b3VyTWVhc3VyZS5jcHAAX29wAGZUb3AAY2FwAF9Ta0N1YmljTWFwAFN0cm9rZUNhcABNYWtlRnJvbU9wAFBhdGhPcAAlcABub256ZXJvAGJlemllckN1cnZlVG8AcXVhZHJhdGljQ3VydmVUbwBfbW92ZVRvAF9saW5lVG8AX3F1YWRUbwBfYXJjVG8AX2NvbmljVG8AX2N1YmljVG8Aam9pbgBTdHJva2VKb2luAG5hbgBfdHJhbnNmb3JtAGZCb3R0b20AX3RyaW0AU2tEYXNoSW1wbABib29sAGVtc2NyaXB0ZW46OnZhbAAhawB3aWR0aABOZXdQYXRoAFNrUGF0aABjbG9zZVBhdGgAX2FkZFBhdGgAcHVzaABfZGFzaAAuLi8uLi9pbmNsdWRlL3ByaXZhdGUvU2tUREFycmF5LmgALi4vLi4vc3JjL2NvcmUvU2tBcmVuYUFsbG9jLmgAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZ2V0RmlsbFR5cGVTdHJpbmcAdG9TVkdTdHJpbmcARnJvbVNWR1N0cmluZwAlZwBpbmYAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAwIDwgZkJsb2NrVW5pdFNpemUAcmVzb2x2ZQBfZWxsaXBzZQBfY2xvc2UAc2V0RmlsbFR5cGUAZ2V0RmlsbFR5cGUAZG91YmxlAF9zdHJva2UAbWFrZQB2b2lkAFNrQml0czJGbG9hdFVuc2lnbmVkAGV2ZW5vZGQAYWRkAF9hcmMAIWMAWgBjb21wdXRlWUZyb21YAGNvbXB1dGVQdEZyb21UAEJVVFQASU5URVJTRUNUAFhPUgBNSVRFUgBVTklPTgBOQU4AQkVWRUwASU5WRVJTRV9XSU5ESU5HAElORgBTUVVBUkUAU2tUcmltUEUAUkVWRVJTRV9ESUZGRVJFTkNFAFJPVU5EAElOVkVSU0VfRVZFTk9ERAB0b1BhdGgyRABNT1ZFX1ZFUkIAQ0xPU0VfVkVSQgBMSU5FX1ZFUkIAUVVBRF9WRVJCAENPTklDX1ZFUkIAQ1VCSUNfVkVSQgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AC4AU2tURml0c0luPGludD4oY291bnQpAChudWxsKQBTa1RGaXRzSW48aW50PihyZXNlcnZlKQBmQmxvY2tVbml0U2l6ZSA8IHN0ZDo6bWluKGtNYXhTaXplLCAoMXUgPDwgMjYpIC0gMSkAc2FmZS5vaygpACAATm90IGVub3VnaCBhcmdzIHRvIG1hdGNoIHRoZSB2ZXJicy4gU2F3ICVkIGNvbW1hbmRzCgB3YXJuaW5nOiBjYW4ndCB0cmFuc2xhdGUgaW52ZXJ0ZWQgZmlsbHR5cGUgdG8gSFRNTCBDYW52YXMKAENvdWxkIG5vdCB0cmltIHBhdGgKAENvdWxkIG5vdCBtYWtlIGRhc2hlZCBwYXRoCgBJbnZhbGlkIGFyZ3MgdG8gdHJpbSgpOiBzdGFydFQgYW5kIHN0b3BUIG11c3QgYmUgaW4gWzAsMV0KACAgcGF0aDogVU5LTk9XTiBjb21tYW5kICVmLCBhYm9ydGluZyBkdW1wLi4uCgBJbnZhbGlkIGFyZ3MgdG8gZGFzaCgpCgAlczolZDogZmF0YWwgZXJyb3I6ICJ1bmtub3duIHNlZ1R5cGUiCgAlczolZDogZmF0YWwgZXJyb3I6ICJhc3NlcnQoJXMpIgoAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAEGgGgsmCCoAAAkqAAAKKgAACioAAAgqAAAJKgAACioAAAoqAAAKKgAACioAQdAaC3IIKgAACSoAAAoqAAAKKgAACioAAAoqAAAKKgAAAAAAAAgqAAAJKgAACioAAAoqAAAKKgAACioAAAoqAAAKKgAACCoAAAkqAAAIKgAANCoAAAgqAAAKKgAACioAAAAAAAAIKgAACioAAAoqAAAKKgAACioAQdAbCzcIKgAACioAAAoqAAAKKgAACioAAAoqAAAKKgAACCoAAGlpAHYAdmkAWCoAAFgqAAA1KgAAaWlpAEGQHAujAQgqAAA1KgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAHZpaWlmZmZmZmZmZmYAAAAIKgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAAWioAAHZpaWZmZmZmaQAAAAAAAAAIKgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAAdmlpZmZmZmYAAAAACCoAADUqAAB2aWkAQcAdC2MIKgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAHZpaWZmZmZmZgAAAAAAAAAIKgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAAoqAABaKgAAdmlpZmZmZmZmZmkAQbAeCxUIKgAANSoAAAoqAAAKKgAAdmlpZmYAQdAeC8IBCCoAADUqAAAKKgAACioAAAoqAAAKKgAAdmlpZmZmZgAIKgAAWCoAAFsqAAB2aWlpAAAAAFsqAABZKgAANCoAADUqAABcKgAAWSoAAFwqAABZKgAAWioAADUqAAA1KgAAaWlpaQAAAAA1KgAANSoAAFoqAAA1KgAACioAAAoqAAAKKgAAaWlpZmZmAAAAAAAAWioAADUqAAAKKgAACioAAFoqAABpaWlmZmkAAFoqAAA1KgAAXSoAAAgqAAA1KgAAXioAQaAgC0IIKgAANSoAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAAoqAAAKKgAACioAAHZpaWZmZmZmZmZmZgAAAABaKgAANSoAQfAgC2ZaKgAANSoAADUqAABfKgAAaWlpaWkAAAAIKgAANSoAADQqAABhKgAACAAAAAAAAAAIKgAAYSoAADUqAABfKgAAdmlpaWkAAAA0KgAAYCoAADQqAABjKgAANSoAADQqAABkKgAACSoAQeAhC6EBNCoAADUqAAA1KgAAXyoAAGkAZmlpAHZpaWYAAAAAAABcKgAACioAAAoqAAAKKgAACioAAGlpZmZmZgAAaSoAAGcqAABnKgAACioAAGoqAAAKKgAAZmlpZgAAAABnKgAAaioAAAoqAABpaWlmAAAAAAoqAABrKgAAAAAAAP//////////////////////////AQAAAAEAAAACAAAAAgAAAAMAQZYjC3PwvwAAAAAAAPC/BAAAAAMAAAACAAAABwAAAP////8PAAAACgAAAAsAAAAMAAAABQAAAP////8BAAAA////////////////CQAAAP////8NAAAABgAAAAMAAAAAAAAABwAAAP////8PAAAACAAAAAsAAAAOAEGUJAs/AQABAAEBAAAAAQEAAAAAAAABAAEAAAEBAAEBAAABAQABAQAAAQABAAAAAAAAAQEAAQAAAQEAAAEAAQEAAAEBAEHkJAtFAQAAAAIAAAAEAAAAAQAAAAAAAAAEAAAAAgAAAAIAAAAEAAAAAAAAAAEAAAADAAAAAwAAAAMAAAADAAAABAAAAAIAAAABAEGyJQsQAQAAAAABAAEBAQABAQAAAQBB0iULe4A/AAAAAAAAgD8AAIA/AAAAAAAAgD8AAIC/AACAPwAAgL8AAAAAAACAvwAAgL8AAAAAAACAvwAAgD8AAIC/AQECAgMAAAABAAAAAAAAAAIAAAAAAAAA//////////////////////////8BAAAAAQAAAAIAAAACAAAAAwBB4CYLtxYPAAAAGAAAACEAAAAhAAAAAQAAAAAAAADbD0k/2w9Jv+TLFkDkyxbAAAAAAAAAAIDbD0lA2w9JwAAAAAAAAAAAOGPtPtoPST9emHs/2g/JP2k3rDFoISIztA8UM2ghojMDAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+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").buffer;
let _ck;
async function init() {
    if (_ck) return;
    _ck = await PathKitInit({
        wasmBinary: wasm
    });
}
function difference(path0, path1) {
    if (!_ck) throw Error("Not init");
    const p0 = _ck.FromSVGString(path0);
    const p1 = _ck.FromSVGString(path1);
    if (p0 && p1) {
        p0.op(p1, _ck.PathOp.XOR);
        const path = p0.toSVGString();
        p0.delete();
        p1.delete();
        return path;
    }
    console.log("difference op failed");
    return "";
}
function intersection(path0, path1) {
    if (!_ck) throw Error("Not init");
    const p0 = _ck.FromSVGString(path0);
    const p1 = _ck.FromSVGString(path1);
    if (p0 && p1) {
        p0.op(p1, _ck.PathOp.INTERSECT);
        const path = p0.toSVGString();
        p0.delete();
        p1.delete();
        return path;
    }
    console.log("intersect op failed");
    return "";
}
function subtract(path0, path1) {
    if (!_ck) throw Error("Not init");
    const p0 = _ck.FromSVGString(path0);
    const p1 = _ck.FromSVGString(path1);
    if (p0 && p1) {
        p0.op(p1, _ck.PathOp.DIFFERENCE);
        const path = p0.toSVGString();
        p0.delete();
        p1.delete();
        return path;
    }
    console.log("subtract op failed");
    return "";
}
function union(path0, path1) {
    if (!_ck) throw Error("Not init");
    const p0 = _ck.FromSVGString(path0);
    const p1 = _ck.FromSVGString(path1);
    if (p0 && p1) {
        p0.op(p1, _ck.PathOp.UNION);
        const path = p0.toSVGString();
        p0.delete();
        p1.delete();
        return path;
    }
    console.log("union op failed");
    return "";
}
function stroke(ops) {
    throw new Error("not implemented");
}
function noneZero2evenOdd(path) {
    if (!_ck) throw Error("Not init");
    const p0 = _ck.FromSVGString(path);
    p0.setFillType(
        0
        /* WINDING */
    );
    const p1 = p0.simplify();
    const ret = p1 ? p1.toSVGString() : "";
    p0.delete();
    return ret;
}
class PalPath {
    constructor(path) {
        __publicField(this, "_path");
        if (!_ck) throw Error("Not init");
        this._path = _ck.FromSVGString(path);
    }
    difference(path) {
        return this._path.op(path._path, _ck.PathOp.XOR);
    }
    intersection(path) {
        return this._path.op(path._path, _ck.PathOp.INTERSECT);
    }
    subtract(path) {
        return this._path.op(path._path, _ck.PathOp.DIFFERENCE);
    }
    union(path) {
        return this._path.op(path._path, _ck.PathOp.UNION);
    }
    stroke(ops) {
        const path = this._path.stroke(ops);
        if (!path) return "";
        path.setFillType(
            0
            /* WINDING */
        );
        path.simplify();
        return path.toSVGString();
    }
    addPath(path) {
        this._path.addPath(path._path);
        return true;
    }
    dash(on2, off, phase) {
        return !!this._path.dash(on2, off, phase);
    }
    toSVGString() {
        return this._path.toSVGString();
    }
    delete() {
        this._path.delete();
    }
}
const boolop = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    PalPath,
    difference,
    init,
    intersection,
    noneZero2evenOdd,
    stroke,
    subtract,
    union
}, Symbol.toStringTag, { value: "Module" }));
class Point {
    constructor(x2, y2) {
        __publicField(this, "x");
        __publicField(this, "y");
        this.x = x2 || 0;
        this.y = y2 || 0;
    }
    copy() {
        return new Point(this.x, this.y);
    }
}
function fixed(number2) {
    return number2.toString();
}
function mod(a2, n2) {
    return a2 >= n2 ? a2 % n2 : a2 >= 0 ? a2 : n2 - 1 - (-1 - a2) % n2;
}
function xprod(p1, p2) {
    return p1.x * p2.y - p1.y * p2.x;
}
function cyclic(a2, b2, c2) {
    if (a2 <= c2) {
        return a2 <= b2 && b2 < c2;
    } else {
        return a2 <= b2 || b2 < c2;
    }
}
function sign(i) {
    return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function quadform(Q2, w2) {
    const v2 = new Array(3);
    let i, j2, sum;
    v2[0] = w2.x;
    v2[1] = w2.y;
    v2[2] = 1;
    sum = 0;
    for (i = 0; i < 3; i++) {
        for (j2 = 0; j2 < 3; j2++) {
            sum += v2[i] * Q2.at(i, j2) * v2[j2];
        }
    }
    return sum;
}
function interval(lambda, a2, b2) {
    const res = new Point();
    res.x = a2.x + lambda * (b2.x - a2.x);
    res.y = a2.y + lambda * (b2.y - a2.y);
    return res;
}
function dorth_infty(p0, p2) {
    const r = new Point();
    r.y = sign(p2.x - p0.x);
    r.x = -sign(p2.y - p0.y);
    return r;
}
function ddenom(p0, p2) {
    const r = dorth_infty(p0, p2);
    return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
}
function dpara(p0, p1, p2) {
    const x1 = p1.x - p0.x;
    const y1 = p1.y - p0.y;
    const x2 = p2.x - p0.x;
    const y2 = p2.y - p0.y;
    return x1 * y2 - x2 * y1;
}
function cprod(p0, p1, p2, p3) {
    const x1 = p1.x - p0.x;
    const y1 = p1.y - p0.y;
    const x2 = p3.x - p2.x;
    const y2 = p3.y - p2.y;
    return x1 * y2 - x2 * y1;
}
function iprod(p0, p1, p2) {
    const x1 = p1.x - p0.x;
    const y1 = p1.y - p0.y;
    const x2 = p2.x - p0.x;
    const y2 = p2.y - p0.y;
    return x1 * x2 + y1 * y2;
}
function iprod1(p0, p1, p2, p3) {
    const x1 = p1.x - p0.x;
    const y1 = p1.y - p0.y;
    const x2 = p3.x - p2.x;
    const y2 = p3.y - p2.y;
    return x1 * x2 + y1 * y2;
}
function ddist(p2, q2) {
    return Math.sqrt((p2.x - q2.x) * (p2.x - q2.x) + (p2.y - q2.y) * (p2.y - q2.y));
}
function luminance(r, g2, b2) {
    return Math.round(0.2126 * r + 0.7153 * g2 + 0.0721 * b2);
}
function between(val, min, max) {
    return val >= min && val <= max;
}
function clamp(val, min, max) {
    return Math.min(max, Math.max(min, val));
}
function renderCurve(curve, scale, trans) {
    const startingPoint = curve.c[(curve.n - 1) * 3 + 2];
    const path = [
        "M " + fixed(startingPoint.x * scale.x + trans.x) + " " + fixed(startingPoint.y * scale.y + trans.y)
    ];
    curve.tag.forEach(function(tag, i) {
        const i3 = i * 3;
        const p0 = curve.c[i3];
        const p1 = curve.c[i3 + 1];
        const p2 = curve.c[i3 + 2];
        if (tag === "CURVE") {
            path.push(
                "C " + fixed(p0.x * scale.x + trans.x) + " " + fixed(p0.y * scale.y + trans.y) + ", " + fixed(p1.x * scale.x + trans.x) + " " + fixed(p1.y * scale.y + trans.y) + ", " + fixed(p2.x * scale.x + trans.x) + " " + fixed(p2.y * scale.y + trans.y)
            );
        } else if (tag === "CORNER") {
            path.push(
                "L " + fixed(p1.x * scale.x + trans.x) + " " + fixed(p1.y * scale.y + trans.y) + " " + fixed(p2.x * scale.x + trans.x) + " " + fixed(p2.y * scale.y + trans.y)
            );
        }
    });
    return path.join(" ");
}
function bezier(t4, p0, p1, p2, p3) {
    const s = 1 - t4, res = new Point();
    res.x = s * s * s * p0.x + 3 * (s * s * t4) * p1.x + 3 * (t4 * t4 * s) * p2.x + t4 * t4 * t4 * p3.x;
    res.y = s * s * s * p0.y + 3 * (s * s * t4) * p1.y + 3 * (t4 * t4 * s) * p2.y + t4 * t4 * t4 * p3.y;
    return res;
}
function tangent(p0, p1, p2, p3, q0, q1) {
    const A2 = cprod(p0, p1, q0, q1);
    const B2 = cprod(p1, p2, q0, q1);
    const C3 = cprod(p2, p3, q0, q1);
    const a2 = A2 - 2 * B2 + C3;
    const b2 = -2 * A2 + 2 * B2;
    const c2 = A2;
    const d2 = b2 * b2 - 4 * a2 * c2;
    if (a2 === 0 || d2 < 0) {
        return -1;
    }
    const s = Math.sqrt(d2);
    const r1 = (-b2 + s) / (2 * a2);
    const r2 = (-b2 - s) / (2 * a2);
    if (r1 >= 0 && r1 <= 1) {
        return r1;
    } else if (r2 >= 0 && r2 <= 1) {
        return r2;
    } else {
        return -1;
    }
}
const COLOR_DEPTH = 256;
const COLOR_RANGE_END = COLOR_DEPTH - 1;
function index(x2, y2) {
    return COLOR_DEPTH * x2 + y2;
}
function normalizeMinMax(levelMin, levelMax) {
    levelMin = typeof levelMin === "number" ? clamp(Math.round(levelMin), 0, COLOR_RANGE_END) : 0;
    levelMax = typeof levelMax === "number" ? clamp(Math.round(levelMax), 0, COLOR_RANGE_END) : COLOR_RANGE_END;
    if (levelMin > levelMax) {
        throw new Error('Invalid range "' + levelMin + "..." + levelMax + '"');
    }
    return [levelMin, levelMax];
}
const _Histogram = class _Histogram {
    constructor(imageSource, mode = "luminance") {
        __publicField(this, "data");
        __publicField(this, "pixels");
        __publicField(this, "_sortedIndexes");
        __publicField(this, "_cachedStats", {});
        __publicField(this, "_lookupTableH");
        this.pixels = 0;
        if (typeof imageSource === "number") {
            this.data = this._createArray(imageSource);
        } else if (imageSource instanceof Bitmap) {
            this.data = this._collectValuesBitmap(imageSource);
        } else if (imageSource instanceof ImageData) {
            this.data = this._collectValuesJimp(imageSource, mode);
        } else {
            throw new Error("Unsupported image source");
        }
    }
    /**
     * Initializes data array for an image of given pixel size
     * @param imageSize
     * @returns {Uint8Array|Uint16Array|Uint32Array}
     * @private
     */
    _createArray(imageSize) {
        const ArrayType = imageSize <= Math.pow(2, 8) ? Uint8Array : imageSize <= Math.pow(2, 16) ? Uint16Array : Uint32Array;
        this.pixels = imageSize;
        return new ArrayType(COLOR_DEPTH);
    }
    /**
     * Aggregates color data from {@link Jimp} instance
     * @param {Jimp} source
     * @param mode
     * @private
     */
    _collectValuesJimp(source, mode) {
        const pixelData = source.data;
        const data = this._createArray(source.width * source.height);
        const w2 = source.width;
        const h2 = source.height;
        for (let x2 = 0; x2 < w2; x2++) {
            for (let y2 = 0; y2 < h2; y2++) {
                const idx = (y2 * w2 + x2) * 4;
                const val = mode === _Histogram.MODE_R ? pixelData[idx] : mode === _Histogram.MODE_G ? pixelData[idx + 1] : mode === _Histogram.MODE_B ? pixelData[idx + 2] : luminance(pixelData[idx], pixelData[idx + 1], pixelData[idx + 2]);
                data[val]++;
            }
        }
        return data;
    }
    /**
     * Aggregates color data from {@link Bitmap} instance
     * @param {Bitmap} source
     * @private
     */
    _collectValuesBitmap(source) {
        const data = this._createArray(source.size);
        const len = source.data.length;
        let color2;
        for (let i = 0; i < len; i++) {
            color2 = source.data[i];
            data[color2]++;
        }
        return data;
    }
    /**
     * Returns array of color indexes in ascending order
     * @param refresh
     * @returns {*}
     * @private
     */
    _getSortedIndexes(refresh) {
        if (!refresh && this._sortedIndexes) {
            return this._sortedIndexes;
        }
        const data = this.data;
        const indexes = new Array(COLOR_DEPTH);
        let i = 0;
        for (i; i < COLOR_DEPTH; i++) {
            indexes[i] = i;
        }
        indexes.sort(function(a2, b2) {
            return data[a2] > data[b2] ? 1 : data[a2] < data[b2] ? -1 : 0;
        });
        this._sortedIndexes = indexes;
        return indexes;
    }
    /**
     * Builds lookup table H from lookup tables P and S.
     * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details
     *
     * @returns {Float64Array}
     * @private
     */
    _thresholdingBuildLookupTable() {
        const P2 = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        const S2 = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        const H2 = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        const pixelsTotal = this.pixels;
        let i, j2, idx, tmp;
        for (i = 1; i < COLOR_DEPTH; ++i) {
            idx = index(i, i);
            tmp = this.data[i] / pixelsTotal;
            P2[idx] = tmp;
            S2[idx] = i * tmp;
        }
        for (i = 1; i < COLOR_DEPTH - 1; ++i) {
            tmp = this.data[i + 1] / pixelsTotal;
            idx = index(1, i);
            P2[idx + 1] = P2[idx] + tmp;
            S2[idx + 1] = S2[idx] + (i + 1) * tmp;
        }
        for (i = 2; i < COLOR_DEPTH; i++) {
            for (j2 = i + 1; j2 < COLOR_DEPTH; j2++) {
                P2[index(i, j2)] = P2[index(1, j2)] - P2[index(1, i - 1)];
                S2[index(i, j2)] = S2[index(1, j2)] - S2[index(1, i - 1)];
            }
        }
        for (i = 1; i < COLOR_DEPTH; ++i) {
            for (j2 = i + 1; j2 < COLOR_DEPTH; j2++) {
                idx = index(i, j2);
                H2[idx] = P2[idx] !== 0 ? S2[idx] * S2[idx] / P2[idx] : 0;
            }
        }
        return this._lookupTableH = H2;
    }
    /**
     * Implements Algorithm For Multilevel Thresholding
     * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax
     *
     * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram
     *
     * @param amount - how many thresholds should be calculated
     * @param [levelMin=0] - histogram segment start
     * @param [levelMax=255] - histogram segment end
     * @returns {number[]}
     */
    multilevelThresholding(amount, levelMin, levelMax) {
        const normalizedLevelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = normalizedLevelMin[1];
        levelMin = normalizedLevelMin[0];
        amount = Math.min(levelMax - levelMin - 2, ~~amount);
        if (amount < 1) {
            return [];
        }
        if (!this._lookupTableH) {
            this._thresholdingBuildLookupTable();
        }
        const H2 = this._lookupTableH;
        let colorStops = null;
        let maxSig = 0;
        if (amount > 4) {
            console.log("[Warning]: Threshold computation for more than 5 levels may take a long time");
        }
        const iterateRecursive = function(startingPoint, prevVariance, indexes, previousDepth) {
            startingPoint = (startingPoint || 0) + 1;
            prevVariance = prevVariance || 0;
            indexes = indexes || new Array(amount);
            previousDepth = previousDepth || 0;
            const depth = previousDepth + 1;
            let variance;
            for (let i = startingPoint; i < levelMax - amount + previousDepth; i++) {
                variance = prevVariance + H2[index(startingPoint, i)];
                indexes[depth - 1] = i;
                if (depth + 1 < amount + 1) {
                    iterateRecursive(i, variance, indexes, depth);
                } else {
                    variance += H2[index(i + 1, levelMax)];
                    if (maxSig < variance) {
                        maxSig = variance;
                        colorStops = indexes.slice();
                    }
                }
            }
        };
        iterateRecursive(levelMin || 0);
        return colorStops ? colorStops : [];
    }
    /**
     * Automatically finds threshold value using Algorithm For Multilevel Thresholding
     *
     * @param {number} [levelMin]
     * @param {number} [levelMax]
     * @returns {null|number}
     */
    autoThreshold(levelMin, levelMax) {
        const value = this.multilevelThresholding(1, levelMin, levelMax);
        return value.length ? value[0] : null;
    }
    /**
     * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image
     *
     * @param [levelMin=0]
     * @param [levelMax=255]
     * @param [tolerance=1]
     * @returns {number}
     */
    getDominantColor(levelMin, levelMax, tolerance) {
        const normalized = normalizeMinMax(levelMin, levelMax);
        levelMax = normalized[1];
        levelMin = normalized[0];
        tolerance = tolerance || 1;
        const colors = this.data;
        let dominantIndex = -1, dominantValue = -1, i, j2, tmp;
        if (levelMin === levelMax) {
            return colors[levelMin] ? levelMin : -1;
        }
        for (i = levelMin; i <= levelMax; i++) {
            tmp = 0;
            for (j2 = ~~(tolerance / -2); j2 < tolerance; j2++) {
                tmp += between(i + j2, 0, COLOR_RANGE_END) ? colors[i + j2] : 0;
            }
            const summIsBigger = tmp > dominantValue;
            const summEqualButMainColorIsBigger = dominantValue === tmp && (dominantIndex < 0 || colors[i] > colors[dominantIndex]);
            if (summIsBigger || summEqualButMainColorIsBigger) {
                dominantIndex = i;
                dominantValue = tmp;
            }
        }
        return dominantValue <= 0 ? -1 : dominantIndex;
    }
    /**
     * Returns stats for histogram or its segment.
     *
     * Returned object contains median, mean and standard deviation for pixel values;
     * peak, mean and median number of pixels per level and few other values
     *
     * If no pixels colors from specified range present on the image - most values will be NaN
     *
     * @param {Number} [levelMin=0] - histogram segment start
     * @param {Number} [levelMax=255] - histogram segment end
     * @param {Boolean} [refresh=false] - if cached result can be returned
     * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}
     */
    getStats(levelMin, levelMax, refresh) {
        const normalized = normalizeMinMax(levelMin, levelMax);
        levelMax = normalized[1];
        levelMin = normalized[0];
        if (!refresh && this._cachedStats[levelMin + "-" + levelMax]) {
            return this._cachedStats[levelMin + "-" + levelMax];
        }
        const data = this.data;
        const sortedIndexes = this._getSortedIndexes();
        let pixelsTotal = 0;
        let medianValue = null;
        let tmpSumOfDeviations = 0;
        let tmpPixelsIterated = 0;
        let allPixelValuesCombined = 0;
        let i, tmpPixels, tmpPixelValue;
        let uniqueValues = 0;
        let mostPixelsPerLevel = 0;
        for (i = levelMin; i <= levelMax; i++) {
            pixelsTotal += data[i];
            allPixelValuesCombined += data[i] * i;
            uniqueValues += data[i] === 0 ? 0 : 1;
            if (mostPixelsPerLevel < data[i]) {
                mostPixelsPerLevel = data[i];
            }
        }
        const meanValue = allPixelValuesCombined / pixelsTotal;
        const pixelsPerLevelMean = pixelsTotal / (levelMax - levelMin);
        const pixelsPerLevelMedian = pixelsTotal / uniqueValues;
        const medianPixelIndex = Math.floor(pixelsTotal / 2);
        for (i = 0; i < COLOR_DEPTH; i++) {
            tmpPixelValue = sortedIndexes[i];
            tmpPixels = data[tmpPixelValue];
            if (tmpPixelValue < levelMin || tmpPixelValue > levelMax) {
                continue;
            }
            tmpPixelsIterated += tmpPixels;
            tmpSumOfDeviations += Math.pow(tmpPixelValue - meanValue, 2) * tmpPixels;
            if (medianValue === null && tmpPixelsIterated >= medianPixelIndex) {
                medianValue = tmpPixelValue;
            }
        }
        return this._cachedStats[levelMin + "-" + levelMax] = {
            // various pixel counts for levels (0..255)
            levels: {
                mean: meanValue,
                median: medianValue,
                stdDev: Math.sqrt(tmpSumOfDeviations / pixelsTotal),
                unique: uniqueValues
            },
            // what's visually represented as bars
            pixelsPerLevel: {
                mean: pixelsPerLevelMean,
                median: pixelsPerLevelMedian,
                peak: mostPixelsPerLevel
            },
            pixels: pixelsTotal
        };
    }
};
__publicField(_Histogram, "MODE_LUMINANCE", "luminance");
__publicField(_Histogram, "MODE_R", "r");
__publicField(_Histogram, "MODE_G", "g");
__publicField(_Histogram, "MODE_B", "b");
let Histogram = _Histogram;
class Bitmap {
    constructor(w2, h2) {
        __publicField(this, "_histogram");
        __publicField(this, "width");
        __publicField(this, "height");
        __publicField(this, "size");
        __publicField(this, "arrayBuffer");
        __publicField(this, "data");
        this.width = w2;
        this.height = h2;
        this.size = w2 * h2;
        this.arrayBuffer = new ArrayBuffer(this.size);
        this.data = new Uint8Array(this.arrayBuffer);
    }
    /**
     * Returns pixel value
     *
     * @param {Number|Point} x - index, point or x
     * @param {Number} [y]
     */
    getValueAt(x2, y2) {
        const index2 = this.pointToIndex(x2, y2);
        return this.data[index2];
    }
    /**
     * Converts {@link Point} to index value
     *
     * @param {Number} index
     * @returns {Point}
     */
    indexToPoint(index2, point) {
        point = point ?? new Point();
        if (between(index2, 0, this.size)) {
            point.y = Math.floor(index2 / this.width);
            point.x = index2 - point.y * this.width;
        } else {
            point.x = -1;
            point.y = -1;
        }
        return point;
    }
    pointToIndex(pointOrX, y2) {
        let _x = pointOrX, _y = y2 || 0;
        if (pointOrX instanceof Point) {
            _x = pointOrX.x;
            _y = pointOrX.y;
        }
        if (!between(_x, 0, this.width) || !between(_y, 0, this.height)) {
            return -1;
        }
        return this.width * _y + _x;
    }
    /**
     * Makes a copy of current bitmap
     *
     * @param {Function} [iterator] optional callback, used for processing pixel value. Accepted arguments: value, index
     * @returns {Bitmap}
     */
    copy(iterator) {
        const bm = new Bitmap(this.width, this.height), iteratorPresent = typeof iterator === "function";
        if (iteratorPresent) {
            bm.data = this.data.map(iterator);
        } else {
            bm.data = this.data.slice(0);
        }
        return bm;
    }
    histogram() {
        if (this._histogram) {
            return this._histogram;
        }
        this._histogram = new Histogram(this);
        return this._histogram;
    }
}
class Curve {
    constructor(n2) {
        __publicField(this, "n");
        __publicField(this, "tag");
        __publicField(this, "c");
        __publicField(this, "alphaCurve");
        __publicField(this, "vertex");
        __publicField(this, "alpha");
        __publicField(this, "alpha0");
        __publicField(this, "beta");
        this.n = n2;
        this.tag = new Array(n2);
        this.c = new Array(n2 * 3);
        this.alphaCurve = 0;
        this.vertex = new Array(n2);
        this.alpha = new Array(n2);
        this.alpha0 = new Array(n2);
        this.beta = new Array(n2);
    }
}
let Path$1 = class Path {
    constructor() {
        __publicField(this, "area", 0);
        __publicField(this, "len", 0);
        __publicField(this, "curve", new Curve(0));
        __publicField(this, "pt", []);
        __publicField(this, "minX", 1e5);
        __publicField(this, "minY", 1e5);
        __publicField(this, "maxX", -1);
        __publicField(this, "maxY", -1);
    }
};
class Quad {
    constructor() {
        __publicField(this, "data");
        this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    at(x2, y2) {
        return this.data[x2 * 3 + y2];
    }
}
class Sum {
    constructor(x2, y2, xy, x22, y22) {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "xy");
        __publicField(this, "x2");
        __publicField(this, "y2");
        this.x = x2;
        this.y = y2;
        this.xy = xy;
        this.x2 = x22;
        this.y2 = y22;
    }
}
class Opti {
    constructor() {
        __publicField(this, "pen", 0);
        __publicField(this, "c", [new Point(), new Point()]);
        __publicField(this, "t", 0);
        __publicField(this, "s", 0);
        __publicField(this, "alpha", 0);
    }
}
const _Potrace = class _Potrace {
    constructor(target, callback, options) {
        __publicField(this, "_luminanceData");
        __publicField(this, "_pathlist");
        __publicField(this, "_processed");
        __publicField(this, "_params");
        this._pathlist = [];
        this._processed = false;
        this._params = {
            turnPolicy: _Potrace.TURNPOLICY_MINORITY,
            turdSize: 2,
            alphaMax: 1,
            optCurve: true,
            optTolerance: 0.2,
            threshold: _Potrace.THRESHOLD_AUTO,
            blackOnWhite: true,
            color: _Potrace.COLOR_AUTO,
            background: _Potrace.COLOR_TRANSPARENT,
            width: 0,
            height: 0
        };
        if (options) {
            this.setParameters(options);
        }
        this._luminanceData = this._processLoadedImage(target);
        callback.call(this);
    }
    /**
     * Creating a new {@link Path} for every group of black pixels.
     * @private
     */
    _bmToPathlist() {
        const self2 = this;
        let threshold = this._params.threshold;
        const blackOnWhite = this._params.blackOnWhite;
        let path;
        if (threshold === _Potrace.THRESHOLD_AUTO) {
            threshold = this._luminanceData.histogram().autoThreshold() || 128;
        }
        const blackMap = blackOnWhite ? this._luminanceData.copy(function(lum, i) {
            return lum > threshold ? 0 : 1;
        }) : this._luminanceData.copy(function(lum, i) {
            return lum < threshold ? 0 : 1;
        });
        const saveBlackMap = blackMap.copy();
        function findNext(point) {
            let i = blackMap.pointToIndex(point);
            while (i < blackMap.size && blackMap.data[i] !== 1) {
                i++;
            }
            if (i < blackMap.size) {
                blackMap.indexToPoint(i, point);
                return true;
            }
            return false;
        }
        function majority(x2, y2) {
            let i, a2, ct2;
            for (i = 2; i < 5; i++) {
                ct2 = 0;
                for (a2 = -i + 1; a2 <= i - 1; a2++) {
                    ct2 += blackMap.getValueAt(x2 + a2, y2 + i - 1) ? 1 : -1;
                    ct2 += blackMap.getValueAt(x2 + i - 1, y2 + a2 - 1) ? 1 : -1;
                    ct2 += blackMap.getValueAt(x2 + a2 - 1, y2 - i) ? 1 : -1;
                    ct2 += blackMap.getValueAt(x2 - i, y2 + a2) ? 1 : -1;
                }
                if (ct2 > 0) {
                    return 1;
                } else if (ct2 < 0) {
                    return 0;
                }
            }
            return 0;
        }
        function findPath(point) {
            const path2 = new Path$1();
            let x2 = point.x, y2 = point.y, dirx = 0, diry = 1, tmp;
            path2.sign = saveBlackMap.getValueAt(point.x, point.y) ? "+" : "-";
            const turnPolicy = self2._params.turnPolicy;
            for (; ; ) {
                path2.pt.push(new Point(x2, y2));
                if (x2 > path2.maxX)
                    path2.maxX = x2;
                if (x2 < path2.minX)
                    path2.minX = x2;
                if (y2 > path2.maxY)
                    path2.maxY = y2;
                if (y2 < path2.minY)
                    path2.minY = y2;
                path2.len++;
                x2 += dirx;
                y2 += diry;
                path2.area -= x2 * diry;
                if (x2 === point.x && y2 === point.y)
                    break;
                const l2 = blackMap.getValueAt(x2 + (dirx + diry - 1) / 2, y2 + (diry - dirx - 1) / 2);
                const r = blackMap.getValueAt(x2 + (dirx - diry - 1) / 2, y2 + (diry + dirx - 1) / 2);
                if (r && !l2) {
                    if (turnPolicy === _Potrace.TURNPOLICY_RIGHT || turnPolicy === _Potrace.TURNPOLICY_BLACK && path2.sign === "+" || turnPolicy === _Potrace.TURNPOLICY_WHITE && path2.sign === "-" || turnPolicy === _Potrace.TURNPOLICY_MAJORITY && majority(x2, y2) || turnPolicy === _Potrace.TURNPOLICY_MINORITY && !majority(x2, y2)) {
                        tmp = dirx;
                        dirx = -diry;
                        diry = tmp;
                    } else {
                        tmp = dirx;
                        dirx = diry;
                        diry = -tmp;
                    }
                } else if (r) {
                    tmp = dirx;
                    dirx = -diry;
                    diry = tmp;
                } else if (!l2) {
                    tmp = dirx;
                    dirx = diry;
                    diry = -tmp;
                }
            }
            return path2;
        }
        function xorPath(path2) {
            let y1 = path2.pt[0].y;
            for (let i = 1, len = path2.len; i < len; i++) {
                const pt2 = path2.pt[i];
                const x2 = pt2.x;
                const y2 = pt2.y;
                if (y2 !== y1) {
                    const minY = y1 < y2 ? y1 : y2;
                    const maxX = path2.maxX;
                    for (let j2 = x2; j2 < maxX; j2++) {
                        const indx = blackMap.pointToIndex(j2, minY);
                        blackMap.data[indx] = blackMap.data[indx] ? 0 : 1;
                    }
                    y1 = y2;
                }
            }
        }
        this._pathlist = [];
        const currentPoint = new Point(0, 0);
        while (findNext(currentPoint)) {
            path = findPath(currentPoint);
            xorPath(path);
            if (path.area > self2._params.turdSize) {
                this._pathlist.push(path);
            }
        }
    }
    /**
     * Processes path list created by _bmToPathlist method creating and optimizing {@link Curve}'s
     * @private
     */
    _processPath() {
        const self2 = this;
        function calcSums(path) {
            let i, x2, y2;
            path.x0 = path.pt[0].x;
            path.y0 = path.pt[0].y;
            path.sums = [];
            const s = path.sums;
            s.push(new Sum(0, 0, 0, 0, 0));
            for (i = 0; i < path.len; i++) {
                x2 = path.pt[i].x - path.x0;
                y2 = path.pt[i].y - path.y0;
                s.push(new Sum(
                    s[i].x + x2,
                    s[i].y + y2,
                    s[i].xy + x2 * y2,
                    s[i].x2 + x2 * x2,
                    s[i].y2 + y2 * y2
                ));
            }
        }
        function calcLon(path) {
            const n2 = path.len, pt2 = path.pt, pivk = new Array(n2), nc2 = new Array(n2), ct2 = new Array(4);
            let dir;
            path.lon = new Array(n2);
            const constraint = [new Point(), new Point()], cur = new Point(), off = new Point(), dk = new Point();
            let foundk;
            let i, j2, k1, a2, b2, c2, d2, k = 0;
            for (i = n2 - 1; i >= 0; i--) {
                if (pt2[i].x != pt2[k].x && pt2[i].y != pt2[k].y) {
                    k = i + 1;
                }
                nc2[i] = k;
            }
            for (i = n2 - 1; i >= 0; i--) {
                ct2[0] = ct2[1] = ct2[2] = ct2[3] = 0;
                dir = (3 + 3 * (pt2[mod(i + 1, n2)].x - pt2[i].x) + (pt2[mod(i + 1, n2)].y - pt2[i].y)) / 2;
                ct2[dir]++;
                constraint[0].x = 0;
                constraint[0].y = 0;
                constraint[1].x = 0;
                constraint[1].y = 0;
                k = nc2[i];
                k1 = i;
                for (; ; ) {
                    foundk = 0;
                    dir = (3 + 3 * sign(pt2[k].x - pt2[k1].x) + sign(pt2[k].y - pt2[k1].y)) / 2;
                    ct2[dir]++;
                    if (ct2[0] && ct2[1] && ct2[2] && ct2[3]) {
                        pivk[i] = k1;
                        foundk = 1;
                        break;
                    }
                    cur.x = pt2[k].x - pt2[i].x;
                    cur.y = pt2[k].y - pt2[i].y;
                    if (xprod(constraint[0], cur) < 0 || xprod(constraint[1], cur) > 0) {
                        break;
                    }
                    if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) ;
                    else {
                        off.x = cur.x + (cur.y >= 0 && (cur.y > 0 || cur.x < 0) ? 1 : -1);
                        off.y = cur.y + (cur.x <= 0 && (cur.x < 0 || cur.y < 0) ? 1 : -1);
                        if (xprod(constraint[0], off) >= 0) {
                            constraint[0].x = off.x;
                            constraint[0].y = off.y;
                        }
                        off.x = cur.x + (cur.y <= 0 && (cur.y < 0 || cur.x < 0) ? 1 : -1);
                        off.y = cur.y + (cur.x >= 0 && (cur.x > 0 || cur.y < 0) ? 1 : -1);
                        if (xprod(constraint[1], off) <= 0) {
                            constraint[1].x = off.x;
                            constraint[1].y = off.y;
                        }
                    }
                    k1 = k;
                    k = nc2[k1];
                    if (!cyclic(k, i, k1)) {
                        break;
                    }
                }
                if (foundk === 0) {
                    dk.x = sign(pt2[k].x - pt2[k1].x);
                    dk.y = sign(pt2[k].y - pt2[k1].y);
                    cur.x = pt2[k1].x - pt2[i].x;
                    cur.y = pt2[k1].y - pt2[i].y;
                    a2 = xprod(constraint[0], cur);
                    b2 = xprod(constraint[0], dk);
                    c2 = xprod(constraint[1], cur);
                    d2 = xprod(constraint[1], dk);
                    j2 = 1e7;
                    if (b2 < 0) {
                        j2 = Math.floor(a2 / -b2);
                    }
                    if (d2 > 0) {
                        j2 = Math.min(j2, Math.floor(-c2 / d2));
                    }
                    pivk[i] = mod(k1 + j2, n2);
                }
            }
            j2 = pivk[n2 - 1];
            path.lon[n2 - 1] = j2;
            for (i = n2 - 2; i >= 0; i--) {
                if (cyclic(i + 1, pivk[i], j2)) {
                    j2 = pivk[i];
                }
                path.lon[i] = j2;
            }
            for (i = n2 - 1; cyclic(mod(i + 1, n2), j2, path.lon[i]); i--) {
                path.lon[i] = j2;
            }
        }
        function bestPolygon(path) {
            function penalty3(path2, i2, j22) {
                const n22 = path2.len, pt2 = path2.pt, sums = path2.sums;
                let x2, y2, xy, x22, y22, k2, r = 0;
                if (j22 >= n22) {
                    j22 -= n22;
                    r = 1;
                }
                if (r === 0) {
                    x2 = sums[j22 + 1].x - sums[i2].x;
                    y2 = sums[j22 + 1].y - sums[i2].y;
                    x22 = sums[j22 + 1].x2 - sums[i2].x2;
                    xy = sums[j22 + 1].xy - sums[i2].xy;
                    y22 = sums[j22 + 1].y2 - sums[i2].y2;
                    k2 = j22 + 1 - i2;
                } else {
                    x2 = sums[j22 + 1].x - sums[i2].x + sums[n22].x;
                    y2 = sums[j22 + 1].y - sums[i2].y + sums[n22].y;
                    x22 = sums[j22 + 1].x2 - sums[i2].x2 + sums[n22].x2;
                    xy = sums[j22 + 1].xy - sums[i2].xy + sums[n22].xy;
                    y22 = sums[j22 + 1].y2 - sums[i2].y2 + sums[n22].y2;
                    k2 = j22 + 1 - i2 + n22;
                }
                const px = (pt2[i2].x + pt2[j22].x) / 2 - pt2[0].x;
                const py = (pt2[i2].y + pt2[j22].y) / 2 - pt2[0].y;
                const ey = pt2[j22].x - pt2[i2].x;
                const ex = -(pt2[j22].y - pt2[i2].y);
                const a2 = (x22 - 2 * x2 * px) / k2 + px * px;
                const b2 = (xy - x2 * py - y2 * px) / k2 + px * py;
                const c22 = (y22 - 2 * y2 * py) / k2 + py * py;
                const s = ex * ex * a2 + 2 * ex * ey * b2 + ey * ey * c22;
                return Math.sqrt(s);
            }
            let i, j2, k;
            const n2 = path.len, pen = new Array(n2 + 1), prev = new Array(n2 + 1), clip0 = new Array(n2), clip1 = new Array(n2 + 1), seg0 = new Array(n2 + 1), seg1 = new Array(n2 + 1);
            let thispen, best, c2;
            for (i = 0; i < n2; i++) {
                c2 = mod(path.lon[mod(i - 1, n2)] - 1, n2);
                if (c2 == i) {
                    c2 = mod(i + 1, n2);
                }
                if (c2 < i) {
                    clip0[i] = n2;
                } else {
                    clip0[i] = c2;
                }
            }
            j2 = 1;
            for (i = 0; i < n2; i++) {
                while (j2 <= clip0[i]) {
                    clip1[j2] = i;
                    j2++;
                }
            }
            i = 0;
            for (j2 = 0; i < n2; j2++) {
                seg0[j2] = i;
                i = clip0[i];
            }
            seg0[j2] = n2;
            const m2 = j2;
            i = n2;
            for (j2 = m2; j2 > 0; j2--) {
                seg1[j2] = i;
                i = clip1[i];
            }
            seg1[0] = 0;
            pen[0] = 0;
            for (j2 = 1; j2 <= m2; j2++) {
                for (i = seg1[j2]; i <= seg0[j2]; i++) {
                    best = -1;
                    for (k = seg0[j2 - 1]; k >= clip1[i]; k--) {
                        thispen = penalty3(path, k, i) + pen[k];
                        if (best < 0 || thispen < best) {
                            prev[i] = k;
                            best = thispen;
                        }
                    }
                    pen[i] = best;
                }
            }
            path.m = m2;
            path.po = new Array(m2);
            for (i = n2, j2 = m2 - 1; i > 0; j2--) {
                i = prev[i];
                path.po[j2] = i;
            }
        }
        function adjustVertices(path) {
            function pointslope(path2, i2, j22, ctr2, dir2) {
                const n22 = path2.len, sums = path2.sums;
                let a2, c2, l22, r = 0;
                while (j22 >= n22) {
                    j22 -= n22;
                    r += 1;
                }
                while (i2 >= n22) {
                    i2 -= n22;
                    r -= 1;
                }
                while (j22 < 0) {
                    j22 += n22;
                    r -= 1;
                }
                while (i2 < 0) {
                    i2 += n22;
                    r += 1;
                }
                const x2 = sums[j22 + 1].x - sums[i2].x + r * sums[n22].x;
                const y2 = sums[j22 + 1].y - sums[i2].y + r * sums[n22].y;
                const x22 = sums[j22 + 1].x2 - sums[i2].x2 + r * sums[n22].x2;
                const xy = sums[j22 + 1].xy - sums[i2].xy + r * sums[n22].xy;
                const y22 = sums[j22 + 1].y2 - sums[i2].y2 + r * sums[n22].y2;
                const k2 = j22 + 1 - i2 + r * n22;
                ctr2.x = x2 / k2;
                ctr2.y = y2 / k2;
                a2 = (x22 - x2 * x2 / k2) / k2;
                const b2 = (xy - x2 * y2 / k2) / k2;
                c2 = (y22 - y2 * y2 / k2) / k2;
                const lambda2 = (a2 + c2 + Math.sqrt((a2 - c2) * (a2 - c2) + 4 * b2 * b2)) / 2;
                a2 -= lambda2;
                c2 -= lambda2;
                if (Math.abs(a2) >= Math.abs(c2)) {
                    l22 = Math.sqrt(a2 * a2 + b2 * b2);
                    if (l22 !== 0) {
                        dir2.x = -b2 / l22;
                        dir2.y = a2 / l22;
                    }
                } else {
                    l22 = Math.sqrt(c2 * c2 + b2 * b2);
                    if (l22 !== 0) {
                        dir2.x = -c2 / l22;
                        dir2.y = b2 / l22;
                    }
                }
                if (l22 === 0) {
                    dir2.x = dir2.y = 0;
                }
            }
            const m2 = path.m, po2 = path.po, n2 = path.len, pt2 = path.pt, x0 = path.x0, y0 = path.y0, ctr = new Array(m2), dir = new Array(m2), q2 = new Array(m2), v2 = new Array(3), s = new Point();
            let d2, i, j2, k, l2;
            path.curve = new Curve(m2);
            for (i = 0; i < m2; i++) {
                j2 = po2[mod(i + 1, m2)];
                j2 = mod(j2 - po2[i], n2) + po2[i];
                ctr[i] = new Point();
                dir[i] = new Point();
                pointslope(path, po2[i], j2, ctr[i], dir[i]);
            }
            for (i = 0; i < m2; i++) {
                q2[i] = new Quad();
                d2 = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
                if (d2 === 0) {
                    for (j2 = 0; j2 < 3; j2++) {
                        for (k = 0; k < 3; k++) {
                            q2[i].data[j2 * 3 + k] = 0;
                        }
                    }
                } else {
                    v2[0] = dir[i].y;
                    v2[1] = -dir[i].x;
                    v2[2] = -v2[1] * ctr[i].y - v2[0] * ctr[i].x;
                    for (l2 = 0; l2 < 3; l2++) {
                        for (k = 0; k < 3; k++) {
                            q2[i].data[l2 * 3 + k] = v2[l2] * v2[k] / d2;
                        }
                    }
                }
            }
            let Q2, w2, dx, dy, det, min, cand, xmin, ymin, z2;
            for (i = 0; i < m2; i++) {
                Q2 = new Quad();
                w2 = new Point();
                s.x = pt2[po2[i]].x - x0;
                s.y = pt2[po2[i]].y - y0;
                j2 = mod(i - 1, m2);
                for (l2 = 0; l2 < 3; l2++) {
                    for (k = 0; k < 3; k++) {
                        Q2.data[l2 * 3 + k] = q2[j2].at(l2, k) + q2[i].at(l2, k);
                    }
                }
                for (; ; ) {
                    det = Q2.at(0, 0) * Q2.at(1, 1) - Q2.at(0, 1) * Q2.at(1, 0);
                    if (det !== 0) {
                        w2.x = (-Q2.at(0, 2) * Q2.at(1, 1) + Q2.at(1, 2) * Q2.at(0, 1)) / det;
                        w2.y = (Q2.at(0, 2) * Q2.at(1, 0) - Q2.at(1, 2) * Q2.at(0, 0)) / det;
                        break;
                    }
                    if (Q2.at(0, 0) > Q2.at(1, 1)) {
                        v2[0] = -Q2.at(0, 1);
                        v2[1] = Q2.at(0, 0);
                    } else if (Q2.at(1, 1)) {
                        v2[0] = -Q2.at(1, 1);
                        v2[1] = Q2.at(1, 0);
                    } else {
                        v2[0] = 1;
                        v2[1] = 0;
                    }
                    d2 = v2[0] * v2[0] + v2[1] * v2[1];
                    v2[2] = -v2[1] * s.y - v2[0] * s.x;
                    for (l2 = 0; l2 < 3; l2++) {
                        for (k = 0; k < 3; k++) {
                            Q2.data[l2 * 3 + k] += v2[l2] * v2[k] / d2;
                        }
                    }
                }
                dx = Math.abs(w2.x - s.x);
                dy = Math.abs(w2.y - s.y);
                if (dx <= 0.5 && dy <= 0.5) {
                    path.curve.vertex[i] = new Point(w2.x + x0, w2.y + y0);
                    continue;
                }
                min = quadform(Q2, s);
                xmin = s.x;
                ymin = s.y;
                if (Q2.at(0, 0) !== 0) {
                    for (z2 = 0; z2 < 2; z2++) {
                        w2.y = s.y - 0.5 + z2;
                        w2.x = -(Q2.at(0, 1) * w2.y + Q2.at(0, 2)) / Q2.at(0, 0);
                        dx = Math.abs(w2.x - s.x);
                        cand = quadform(Q2, w2);
                        if (dx <= 0.5 && cand < min) {
                            min = cand;
                            xmin = w2.x;
                            ymin = w2.y;
                        }
                    }
                }
                if (Q2.at(1, 1) !== 0) {
                    for (z2 = 0; z2 < 2; z2++) {
                        w2.x = s.x - 0.5 + z2;
                        w2.y = -(Q2.at(1, 0) * w2.x + Q2.at(1, 2)) / Q2.at(1, 1);
                        dy = Math.abs(w2.y - s.y);
                        cand = quadform(Q2, w2);
                        if (dy <= 0.5 && cand < min) {
                            min = cand;
                            xmin = w2.x;
                            ymin = w2.y;
                        }
                    }
                }
                for (l2 = 0; l2 < 2; l2++) {
                    for (k = 0; k < 2; k++) {
                        w2.x = s.x - 0.5 + l2;
                        w2.y = s.y - 0.5 + k;
                        cand = quadform(Q2, w2);
                        if (cand < min) {
                            min = cand;
                            xmin = w2.x;
                            ymin = w2.y;
                        }
                    }
                }
                path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
            }
        }
        function reverse(path) {
            const curve = path.curve, m2 = curve.n, v2 = curve.vertex;
            for (let i = 0, j2 = m2 - 1; i < j2; i++, j2--) {
                const tmp = v2[i];
                v2[i] = v2[j2];
                v2[j2] = tmp;
            }
        }
        function smooth(path) {
            const m2 = path.curve.n, curve = path.curve;
            let i, j2, k, dd, denom, alpha, p2, p3, p4;
            for (i = 0; i < m2; i++) {
                j2 = mod(i + 1, m2);
                k = mod(i + 2, m2);
                p4 = interval(1 / 2, curve.vertex[k], curve.vertex[j2]);
                denom = ddenom(curve.vertex[i], curve.vertex[k]);
                if (denom !== 0) {
                    dd = dpara(curve.vertex[i], curve.vertex[j2], curve.vertex[k]) / denom;
                    dd = Math.abs(dd);
                    alpha = dd > 1 ? 1 - 1 / dd : 0;
                    alpha = alpha / 0.75;
                } else {
                    alpha = 4 / 3;
                }
                curve.alpha0[j2] = alpha;
                if (alpha >= self2._params.alphaMax) {
                    curve.tag[j2] = "CORNER";
                    curve.c[3 * j2 + 1] = curve.vertex[j2];
                    curve.c[3 * j2 + 2] = p4;
                } else {
                    if (alpha < 0.55) {
                        alpha = 0.55;
                    } else if (alpha > 1) {
                        alpha = 1;
                    }
                    p2 = interval(0.5 + 0.5 * alpha, curve.vertex[i], curve.vertex[j2]);
                    p3 = interval(0.5 + 0.5 * alpha, curve.vertex[k], curve.vertex[j2]);
                    curve.tag[j2] = "CURVE";
                    curve.c[3 * j2 + 0] = p2;
                    curve.c[3 * j2 + 1] = p3;
                    curve.c[3 * j2 + 2] = p4;
                }
                curve.alpha[j2] = alpha;
                curve.beta[j2] = 0.5;
            }
            curve.alphaCurve = 1;
        }
        function optiCurve(path) {
            function opti_penalty(path2, i2, j22, res, opttolerance, convc2, areac2) {
                const m22 = path2.curve.n, curve2 = path2.curve, vertex = curve2.vertex;
                let k, k1, k2, area2, d2, d1, d22, p1, p2, pt22, t22;
                if (i2 == j22) {
                    return 1;
                }
                k = i2;
                const i12 = mod(i2 + 1, m22);
                k1 = mod(k + 1, m22);
                const conv = convc2[k1];
                if (conv === 0) {
                    return 1;
                }
                d2 = ddist(vertex[i2], vertex[i12]);
                for (k = k1; k != j22; k = k1) {
                    k1 = mod(k + 1, m22);
                    k2 = mod(k + 2, m22);
                    if (convc2[k1] != conv) {
                        return 1;
                    }
                    if (sign(cprod(vertex[i2], vertex[i12], vertex[k1], vertex[k2])) != conv) {
                        return 1;
                    }
                    if (iprod1(vertex[i2], vertex[i12], vertex[k1], vertex[k2]) < d2 * ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
                        return 1;
                    }
                }
                const p02 = curve2.c[mod(i2, m22) * 3 + 2].copy();
                p1 = vertex[mod(i2 + 1, m22)].copy();
                p2 = vertex[mod(j22, m22)].copy();
                const p3 = curve2.c[mod(j22, m22) * 3 + 2].copy();
                area2 = areac2[j22] - areac2[i2];
                area2 -= dpara(vertex[0], curve2.c[i2 * 3 + 2], curve2.c[j22 * 3 + 2]) / 2;
                if (i2 >= j22) {
                    area2 += areac2[m22];
                }
                const A1 = dpara(p02, p1, p2);
                const A2 = dpara(p02, p1, p3);
                const A3 = dpara(p02, p2, p3);
                const A4 = A1 + A3 - A2;
                if (A2 == A1) {
                    return 1;
                }
                t22 = A3 / (A3 - A4);
                const s2 = A2 / (A2 - A1);
                const A5 = A2 * t22 / 2;
                if (A5 === 0) {
                    return 1;
                }
                const R2 = area2 / A5;
                const alpha2 = 2 - Math.sqrt(4 - R2 / 0.3);
                res.c[0] = interval(t22 * alpha2, p02, p1);
                res.c[1] = interval(s2 * alpha2, p3, p2);
                res.alpha = alpha2;
                res.t = t22;
                res.s = s2;
                p1 = res.c[0].copy();
                p2 = res.c[1].copy();
                res.pen = 0;
                for (k = mod(i2 + 1, m22); k != j22; k = k1) {
                    k1 = mod(k + 1, m22);
                    t22 = tangent(p02, p1, p2, p3, vertex[k], vertex[k1]);
                    if (t22 < -0.5) {
                        return 1;
                    }
                    pt22 = bezier(t22, p02, p1, p2, p3);
                    d2 = ddist(vertex[k], vertex[k1]);
                    if (d2 === 0) {
                        return 1;
                    }
                    d1 = dpara(vertex[k], vertex[k1], pt22) / d2;
                    if (Math.abs(d1) > opttolerance) {
                        return 1;
                    }
                    if (iprod(vertex[k], vertex[k1], pt22) < 0 || iprod(vertex[k1], vertex[k], pt22) < 0) {
                        return 1;
                    }
                    res.pen += d1 * d1;
                }
                for (k = i2; k != j22; k = k1) {
                    k1 = mod(k + 1, m22);
                    t22 = tangent(p02, p1, p2, p3, curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2]);
                    if (t22 < -0.5) {
                        return 1;
                    }
                    pt22 = bezier(t22, p02, p1, p2, p3);
                    d2 = ddist(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2]);
                    if (d2 === 0) {
                        return 1;
                    }
                    d1 = dpara(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2], pt22) / d2;
                    d22 = dpara(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2], vertex[k1]) / d2;
                    d22 *= 0.75 * curve2.alpha[k1];
                    if (d22 < 0) {
                        d1 = -d1;
                        d22 = -d22;
                    }
                    if (d1 < d22 - opttolerance) {
                        return 1;
                    }
                    if (d1 < d22) {
                        res.pen += (d1 - d22) * (d1 - d22);
                    }
                }
                return 0;
            }
            const curve = path.curve, m2 = curve.n, vert = curve.vertex, pt2 = new Array(m2 + 1), pen = new Array(m2 + 1), len = new Array(m2 + 1), opt = new Array(m2 + 1);
            let o2 = new Opti();
            let i, j2, r, i1, area, alpha;
            const convc = new Array(m2), areac = new Array(m2 + 1);
            for (i = 0; i < m2; i++) {
                if (curve.tag[i] == "CURVE") {
                    convc[i] = sign(dpara(vert[mod(i - 1, m2)], vert[i], vert[mod(i + 1, m2)]));
                } else {
                    convc[i] = 0;
                }
            }
            area = 0;
            areac[0] = 0;
            const p0 = curve.vertex[0];
            for (i = 0; i < m2; i++) {
                i1 = mod(i + 1, m2);
                if (curve.tag[i1] == "CURVE") {
                    alpha = curve.alpha[i1];
                    area += 0.3 * alpha * (4 - alpha) * dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) / 2;
                    area += dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
                }
                areac[i + 1] = area;
            }
            pt2[0] = -1;
            pen[0] = 0;
            len[0] = 0;
            for (j2 = 1; j2 <= m2; j2++) {
                pt2[j2] = j2 - 1;
                pen[j2] = pen[j2 - 1];
                len[j2] = len[j2 - 1] + 1;
                for (i = j2 - 2; i >= 0; i--) {
                    r = opti_penalty(
                        path,
                        i,
                        mod(j2, m2),
                        o2,
                        self2._params.optTolerance,
                        convc,
                        areac
                    );
                    if (r) {
                        break;
                    }
                    if (len[j2] > len[i] + 1 || len[j2] == len[i] + 1 && pen[j2] > pen[i] + o2.pen) {
                        pt2[j2] = i;
                        pen[j2] = pen[i] + o2.pen;
                        len[j2] = len[i] + 1;
                        opt[j2] = o2;
                        o2 = new Opti();
                    }
                }
            }
            const om2 = len[m2];
            const ocurve = new Curve(om2);
            const s = new Array(om2);
            const t4 = new Array(om2);
            j2 = m2;
            for (i = om2 - 1; i >= 0; i--) {
                if (pt2[j2] == j2 - 1) {
                    ocurve.tag[i] = curve.tag[mod(j2, m2)];
                    ocurve.c[i * 3 + 0] = curve.c[mod(j2, m2) * 3 + 0];
                    ocurve.c[i * 3 + 1] = curve.c[mod(j2, m2) * 3 + 1];
                    ocurve.c[i * 3 + 2] = curve.c[mod(j2, m2) * 3 + 2];
                    ocurve.vertex[i] = curve.vertex[mod(j2, m2)];
                    ocurve.alpha[i] = curve.alpha[mod(j2, m2)];
                    ocurve.alpha0[i] = curve.alpha0[mod(j2, m2)];
                    ocurve.beta[i] = curve.beta[mod(j2, m2)];
                    s[i] = t4[i] = 1;
                } else {
                    ocurve.tag[i] = "CURVE";
                    ocurve.c[i * 3 + 0] = opt[j2].c[0];
                    ocurve.c[i * 3 + 1] = opt[j2].c[1];
                    ocurve.c[i * 3 + 2] = curve.c[mod(j2, m2) * 3 + 2];
                    ocurve.vertex[i] = interval(
                        opt[j2].s,
                        curve.c[mod(j2, m2) * 3 + 2],
                        vert[mod(j2, m2)]
                    );
                    ocurve.alpha[i] = opt[j2].alpha;
                    ocurve.alpha0[i] = opt[j2].alpha;
                    s[i] = opt[j2].s;
                    t4[i] = opt[j2].t;
                }
                j2 = pt2[j2];
            }
            for (i = 0; i < om2; i++) {
                i1 = mod(i + 1, om2);
                ocurve.beta[i] = s[i] / (s[i] + t4[i1]);
            }
            ocurve.alphaCurve = 1;
            path.curve = ocurve;
        }
        for (let i = 0; i < this._pathlist.length; i++) {
            const path = this._pathlist[i];
            calcSums(path);
            calcLon(path);
            bestPolygon(path);
            adjustVertices(path);
            if (path.sign === "-") {
                reverse(path);
            }
            smooth(path);
            if (self2._params.optCurve) {
                optiCurve(path);
            }
        }
    }
    /**
     * Validates some of parameters
     * @param params
     * @private
     */
    _validateParameters(params) {
        if (params && params.turnPolicy && _Potrace.SUPPORTED_TURNPOLICY_VALUES.indexOf(params.turnPolicy) === -1) {
            const goodVals = "'" + _Potrace.SUPPORTED_TURNPOLICY_VALUES.join("', '") + "'";
            throw new Error("Bad turnPolicy value. Allowed values are: " + goodVals);
        }
        if (params && params.threshold != null && params.threshold !== _Potrace.THRESHOLD_AUTO) {
            if (typeof params.threshold !== "number" || !between(params.threshold, 0, 255)) {
                throw new Error("Bad threshold value. Expected to be an integer in range 0..255");
            }
        }
        if (params && params.optCurve != null && typeof params.optCurve !== "boolean") {
            throw new Error("'optCurve' must be Boolean");
        }
    }
    _processLoadedImage(image) {
        const bitmap = new Bitmap(image.width, image.height);
        const pixels = image.data;
        const w2 = image.width;
        const h2 = image.height;
        for (let x2 = 0; x2 < w2; x2++) {
            for (let y2 = 0; y2 < h2; y2++) {
                const idx = (y2 * w2 + x2) * 4;
                const opacity2 = pixels[idx + 3] / 255, r = 255 + (pixels[idx + 0] - 255) * opacity2, g2 = 255 + (pixels[idx + 1] - 255) * opacity2, b2 = 255 + (pixels[idx + 2] - 255) * opacity2;
                bitmap.data[idx / 4] = luminance(r, g2, b2);
            }
        }
        return bitmap;
    }
    /**
     * Sets algorithm parameters
     * @param {Potrace~Options} newParams
     */
    setParameters(newParams) {
        let key, tmpOldVal;
        this._validateParameters(newParams);
        const thisParams = this._params;
        for (key in this._params) {
            if (Object.prototype.hasOwnProperty.call(this, key) && Object.prototype.hasOwnProperty.call(newParams, key)) {
                tmpOldVal = thisParams[key];
                thisParams[key] = newParams[key];
                if (tmpOldVal !== thisParams[key] && ["color", "background"].indexOf(key) === -1) {
                    this._processed = false;
                }
            }
        }
    }
    /**
     * Generates just <path> tag without rest of the SVG file
     *
     * @param {String} [fillColor] - overrides color from parameters
     * @returns {String}
     */
    getPathTag(fillColor, scale = { x: 1, y: 1 }, trans = { x: 0, y: 0 }) {
        fillColor = arguments.length === 0 ? this._params.color : fillColor;
        if (fillColor === _Potrace.COLOR_AUTO) {
            fillColor = this._params.blackOnWhite ? "black" : "white";
        }
        if (!this._processed) {
            this._bmToPathlist();
            this._processPath();
            this._processed = true;
        }
        let tag = '<path d="';
        tag += this._pathlist.map(function(path) {
            return renderCurve(path.curve, scale, trans);
        }).join(" ");
        tag += '" stroke="none" fill="' + fillColor + '" fill-rule="evenodd"/>';
        return tag;
    }
    /**
     * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
     * so it could be changed with <use> tag
     *
     * @param id
     * @returns {string}
     */
    getSymbol(id) {
        return '<symbol viewBox="0 0 ' + this._luminanceData.width + " " + this._luminanceData.height + '" id="' + id + '">' + this.getPathTag("") + "</symbol>";
    }
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG(scale) {
        const width = this._params.width || this._luminanceData.width;
        const height = this._params.height || this._luminanceData.height;
        const scale_ = scale ?? {
            x: this._params.width ? this._params.width / this._luminanceData.width : 1,
            y: this._params.height ? this._params.height / this._luminanceData.height : 1
        };
        return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '" viewBox="0 0 ' + width + " " + height + '" version="1.1">\n' + (this._params.background !== _Potrace.COLOR_TRANSPARENT ? '	<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + '" />\n' : "") + "	" + this.getPathTag(this._params.color, scale_) + "\n</svg>";
    }
    /**
     * Generates SVG path
     * @returns {String}
     */
    getSVGPath(scale, trans) {
        const scale_ = scale ?? {
            x: this._params.width ? this._params.width / this._luminanceData.width : 1,
            y: this._params.height ? this._params.height / this._luminanceData.height : 1
        };
        if (!this._processed) {
            this._bmToPathlist();
            this._processPath();
            this._processed = true;
        }
        return this._pathlist.map(function(path) {
            return renderCurve(path.curve, scale_, trans);
        }).join(" ");
    }
};
__publicField(_Potrace, "COLOR_AUTO", "auto");
__publicField(_Potrace, "COLOR_TRANSPARENT", "transparent");
__publicField(_Potrace, "THRESHOLD_AUTO", -1);
__publicField(_Potrace, "TURNPOLICY_BLACK", "black");
__publicField(_Potrace, "TURNPOLICY_WHITE", "white");
__publicField(_Potrace, "TURNPOLICY_LEFT", "left");
__publicField(_Potrace, "TURNPOLICY_RIGHT", "right");
__publicField(_Potrace, "TURNPOLICY_MINORITY", "minority");
__publicField(_Potrace, "TURNPOLICY_MAJORITY", "majority");
__publicField(_Potrace, "SUPPORTED_TURNPOLICY_VALUES", [
    _Potrace.TURNPOLICY_BLACK,
    _Potrace.TURNPOLICY_WHITE,
    _Potrace.TURNPOLICY_LEFT,
    _Potrace.TURNPOLICY_RIGHT,
    _Potrace.TURNPOLICY_MINORITY,
    _Potrace.TURNPOLICY_MAJORITY
]);
let Potrace = _Potrace;
const __caches = /* @__PURE__ */ new Map();
let __canvasElement;
function getTextPath(font, fontSize, italic, weight, charCode) {
    const saveFontSize = fontSize;
    fontSize = Math.min(Math.round(fontSize * 16), 1024);
    const scale = fontSize / saveFontSize;
    const cacheId = font + "#" + fontSize + "#" + charCode + (italic ? "#i" : "") + "#" + weight;
    let path = __caches.get(cacheId);
    if (path) return path;
    if (!__canvasElement) {
        __canvasElement = document.createElement("canvas");
    }
    const canvasElement = __canvasElement;
    const size2 = Math.round(fontSize * 1.25);
    canvasElement.width = size2;
    canvasElement.height = size2;
    const canvas = canvasElement.getContext("2d");
    canvas.imageSmoothingEnabled = false;
    canvas.font = (italic ? "italic " : "normal ") + weight + " " + fontSize + "px " + font;
    canvas.fillStyle = "black";
    canvas.textAlign = "left";
    canvas.textBaseline = "alphabetic";
    const offsetX = Math.round(fontSize * 0.1);
    canvas.fillText(String.fromCharCode(charCode), offsetX, fontSize);
    const imgdata = canvas.getImageData(0, 0, size2, size2);
    const potrace = new Potrace(imgdata, () => {
    });
    path = potrace.getSVGPath({ x: 1 / scale, y: 1 / scale }, { x: -offsetX / scale, y: -fontSize / scale });
    __caches.set(cacheId, path);
    return path;
}
const canvas2D = /* @__PURE__ */ (() => {
    let canvas;
    return () => {
        return canvas || (canvas = document.createElement("canvas").getContext("2d"));
    };
})();
function measureText(text, font) {
    const context = canvas2D();
    if (context) {
        context.font = font;
        context.textAlign = "left";
        context.textBaseline = "alphabetic";
        const metrics = context.measureText(text);
        return metrics;
    }
    return void 0;
}
function isEqualWidthCode(code2) {
    return code2 >= 19968 && code2 <= 40869 || code2 >= 11904 && code2 <= 42191 || code2 >= 63744 && code2 <= 64255 || code2 >= 65072 && code2 <= 65103;
}
function isAsciiCode(code2) {
    return code2 <= 255 && code2 >= 0;
}
const _mEWCCache = {};
const _mAsciiCache = {};
const _tabMetrics = new class {
    constructor() {
        __publicField(this, "actualBoundingBoxAscent", 28);
        // textBaseline 属性标明的水平线到渲染文本的矩形边界顶部的距离。多字测量是啥？
        __publicField(this, "actualBoundingBoxDescent", 0);
        // textBaseline 属性标明的水平线到渲染文本的矩形边界底部的距离
        __publicField(this, "actualBoundingBoxLeft", 0);
        // textAlign 属性确定的对齐点到文本矩形边界左侧的距离。左对齐这里应该为0
        __publicField(this, "actualBoundingBoxRight", 28);
        // textAlign 属性确定的对齐点到文本矩形边界右侧的距离。左对齐这里应该为字方框的宽度。
        __publicField(this, "fontBoundingBoxAscent", 28);
        // textBaseline 属性标明的水平线到渲染文本的所有字体的矩形最高边界顶部的距离。单字测量时同actualBoundingBoxAscent
        __publicField(this, "fontBoundingBoxDescent", 0);
        // textBaseline 属性标明的水平线到渲染文本的所有字体的矩形边界最底部的距离
        __publicField(this, "width", 28);
        // 字符串的宽度
        __publicField(this, "hangingBaseline", 28);
        // textBaseline 属性标明的水平线到线框的 hanging 基线的距离
        __publicField(this, "alphabeticBaseline", 0);
        // textBaseline 属性标明的水平线到线框的 alphabetic 基线的距离。textBaseline为alphabetic时这里为0
        __publicField(this, "emHeightAscent", 28);
        // textBaseline 属性标明的水平线到线框中 em 方块顶部的距离
        __publicField(this, "emHeightDescent", 0);
        // textBaseline 属性标明的水平线到线框中 em 方块底部的距离
        __publicField(this, "ideographicBaseline", 0);
    }
    // textBaseline 属性标明的水平线到线框的 ideographic 基线的距离
}();
function measure(text, font) {
    const code2 = text.charCodeAt(0);
    if (isAsciiCode(code2)) {
        if (code2 === 9) return _tabMetrics;
        let cache2 = _mAsciiCache[font];
        if (!cache2) {
            cache2 = {};
            _mAsciiCache[font] = cache2;
        }
        let m2 = cache2[code2];
        if (!m2) {
            m2 = measureText(String.fromCharCode(code2), font);
            cache2[code2] = m2;
        }
        return m2;
    }
    if (isEqualWidthCode(code2)) {
        let m2 = _mEWCCache[font];
        if (!m2) {
            m2 = measureText(String.fromCharCode(code2), font);
            _mEWCCache[font] = m2;
        }
        return m2;
    }
    return measureText(text, font);
}
let __inited = false;
async function initpal() {
    if (__inited) return;
    await init();
    p.boolop = boolop;
    p.text.getTextPath = getTextPath;
    p.text.textMeasure = measure;
    p.makePalPath = (path) => {
        return new PalPath(path);
    };
    __inited = true;
}
const _Selection = class _Selection extends U {
    constructor(document2, context) {
        super();
        // static CHANGE_TEXT_LITE = 16;
        __publicField(this, "m_selectPage");
        __publicField(this, "m_selectShapes", []);
        // private m_selectPreviewShape: Shape | undefined;
        __publicField(this, "m_hoverShape");
        __publicField(this, "m_document");
        // private m_scout: Scout | undefined;
        __publicField(this, "m_tableselection");
        __publicField(this, "m_textselection");
        // private m_comment_id: string = '';
        // private m_comment_status: boolean = false;
        __publicField(this, "m_comment_page_id");
        // private m_select_comment: boolean = false;
        // private m_comment_page_sort: boolean = false;
        // private m_comment_about_me: boolean = false;
        __publicField(this, "m_table_area", []);
        __publicField(this, "m_selected_sym_ref_menber");
        __publicField(this, "m_selected_sym_ref_bros", []);
        __publicField(this, "m_context");
        __publicField(this, "m_is_new_shape_selection", false);
        __publicField(this, "m_shapes_set", /* @__PURE__ */ new Set());
        __publicField(this, "m_interval", false);
        __publicField(this, "m_label_fixed_group", []);
        __publicField(this, "m_label_living_group", []);
        __publicField(this, "userSelectionList", []);
        __publicField(this, "m_hover_stroke", 14);
        __publicField(this, "m_env_shapes", []);
        this.m_document = document2;
        this.m_context = context;
        this.m_textselection = new TextSelectionLite(this);
        this.m_tableselection = new TableSelection(context, () => {
            this.m_textselection.reset();
        });
    }
    get scout() {
        return this.m_context.toolbox.scout;
    }
    scoutMount(context) {
    }
    // get artboarts() {
    //     const abs = Array.from(this.m_artboart_list.values());
    //     return abs;
    // }
    // get commentId() {
    //     return this.m_comment_id;
    // }
    // get commentStatus() { //评论列表是否显示解决
    //     return this.m_comment_status;
    // }
    get commentPageId() {
        return this.m_comment_page_id;
    }
    // get isSelectComment() {
    //     return this.m_select_comment;
    // }
    // get commentPageSort() { //评论是否按页面排序
    //     return this.m_comment_page_sort;
    // }
    // get commentAboutMe() { //评论显示关于我的
    //     return this.m_comment_about_me;
    // }
    get tableSelection() {
        return this.m_tableselection;
    }
    get textSelection() {
        return this.m_textselection;
    }
    get focusTextShape() {
        const selected = this.selectedShapes;
        if (selected.length !== 1) {
            return;
        }
        const shape2 = selected[0];
        if (shape2 instanceof Ic) {
            return shape2;
        }
        if (shape2 instanceof Tc) {
            return this.tableSelection.editingCell;
        }
    }
    // selectCommentPage(id: string) {
    //     this.m_comment_page_id = id
    //     this.notify(Selection.COMMENT_CHANGE_PAGE)
    // }
    // setCommentSelect(s: boolean) {
    //     this.m_select_comment = s
    //     if (!s) {
    //         this.notify(Selection.SKIP_COMMENT)
    //     }
    // }
    // commentSolveMenuStatus(status: boolean) { //设置列表评论菜单解决状态
    //     this.m_comment_status = status
    //     this.notify(Selection.SOLVE_MENU_STATUS)
    // }
    // setPageSort(status: boolean) {
    //     this.m_comment_page_sort = status
    //     this.notify(Selection.PAGE_SORT)
    // }
    // setCommentAboutMe(status: boolean) {
    //     this.m_comment_about_me = status
    //     this.notify(Selection.ABOUT_ME)
    // }
    async selectPage(p2) {
        if (typeof p2 === "string") {
            const id = p2;
            const ctx = this.m_context;
            const pagesMgr = ctx.data.pagesMgr;
            const cur_page = this.m_selectPage;
            if (cur_page && cur_page.id === id) return cur_page;
            const page = await pagesMgr.get(id);
            if (!page) return;
            await initpal();
            p2 = ctx.getPageDom(page).dom;
        }
        if (this.m_selectPage === p2) {
            this.notify(_Selection.CHANGE_PAGE);
            return p2;
        }
        this.m_selectPage = p2;
        this.m_selectShapes.length = 0;
        this.notify(_Selection.CHANGE_PAGE);
        return p2;
    }
    async deletePage(id, index2) {
        var _a2;
        if (id === ((_a2 = this.m_selectPage) == null ? void 0 : _a2.id)) {
            index2 = index2 === this.m_document.pagesList.length ? index2 - 1 : index2;
            await this.m_document.pagesMgr.get(this.m_document.pagesList[index2].id).then((p2) => {
                this.selectPage(p2 ? this.m_context.getPageDom(p2).dom : void 0);
            });
        }
    }
    reName(id) {
        var _a2;
        if (id) {
            this.notify(_Selection.CHANGE_RENAME, id);
        } else {
            this.notify(_Selection.CHANGE_RENAME, (_a2 = this.selectedPage) == null ? void 0 : _a2.id);
        }
    }
    rename() {
        this.notify(_Selection.PAGE_RENAME);
    }
    // selectComment(id: string) {
    //     this.m_comment_id = id
    //     this.notify(Selection.CHANGE_COMMENT);
    // }
    get selectedPage() {
        return this.m_selectPage;
    }
    /**
     * 在page范围内获取一个点上的所有图层
     * @param position 点位置，坐标系时page
     * @returns 符合检索条件的图形
     */
    getLayers(position) {
        position = lodashExports.cloneDeep(position);
        const result = [];
        if (this.scout) {
            const page = this.m_selectPage;
            if (page && page.childs.length) {
                result.push(...finder_layers(this.scout, page.childs, position));
            }
        }
        return result;
    }
    // private m_count = 0;
    // private m_total = 0;
    /**
     * @description 基于SVGGeometryElement的图形检索，与getLayers相比，getShapesByXY返回的结果长度最多为1，而这里可以大于1
     * @param position 点位置，坐标系时page
     * @param isCtrl 是否取消编组、容器等图形的特殊处理
     * @param scope 在scope范围内进行检索，如果没有限定范围则在全域(page)下寻找
     * @returns 符合检索条件的图形
     */
    getShapesByXY(position, isCtrl, scope) {
        let shape2;
        const page = this.m_selectPage;
        const childs = scope || page.childs;
        shape2 = finder2(this.m_context, this.scout, childs, position, this.selectedShapes, isCtrl, this.m_context.tool.isLable);
        return shape2;
    }
    getContactByXY(position, scope) {
        const shapes = [];
        if (this.scout) {
            const page = this.m_selectPage;
            const childs = scope || page.childs;
            shapes.push(...finder_contact(this.scout, childs, position, this.selectedShapes[0]));
        }
        return shapes;
    }
    setShapesSet(shapes) {
        this.m_shapes_set.clear();
        for (let i = 0, l2 = shapes.length; i < l2; i++) {
            this.m_shapes_set.add(shapes[i].id);
        }
    }
    /**
     * @description 获取点上最近的可插入图形
     * @param position
     * @param except
     * @param scope
     */
    getClosestContainer(position, except, scope) {
        var _a2;
        const range = scope || ((_a2 = this.selectedPage) == null ? void 0 : _a2.childs) || [];
        return finder_container(this.scout, range, position, except) || this.selectedPage;
    }
    getEnvForMigrate(position, scope) {
        var _a2;
        const range = scope || ((_a2 = this.selectedPage) == null ? void 0 : _a2.childs) || [];
        return finder_env_for_migrate(this.scout, range, position, this.m_shapes_set) || this.selectedPage;
    }
    selectShape(shape2) {
        if (!shape2) {
            this.resetSelectShapes();
        } else {
            this.m_selectShapes.length = 0;
            this.m_selectShapes.push(shape2);
            this.m_hoverShape = void 0;
            this.notify(_Selection.CHANGE_SHAPE);
        }
    }
    // get selectedPvShape(): Shape | undefined {
    //     return this.m_selectPreviewShape;
    // }
    unSelectShape(shape2) {
        const index2 = this.m_selectShapes.findIndex((s) => s.id === shape2.id);
        if (index2 > -1) {
            this.m_selectShapes.splice(index2, 1);
            this.notify(_Selection.CHANGE_SHAPE);
        }
    }
    rangeSelectShape(shapes) {
        this.m_selectShapes.length = 0;
        this.m_selectShapes.push(...shapes);
        this.m_hoverShape = void 0;
        this.notify(_Selection.CHANGE_SHAPE);
    }
    addSelectShape(shape2) {
        if (this.isSelectedShape(shape2)) {
            return;
        }
        this.m_selectShapes.push(shape2);
        this.notify(_Selection.CHANGE_SHAPE);
    }
    resetSelectShapes() {
        if (this.m_textselection.cursorStart > -1) {
            this.m_textselection.reset();
        }
        if (this.m_tableselection.editingCell || this.m_tableselection.tableColStart > -1) {
            this.m_tableselection.resetSelection();
        }
        if (this.m_selectShapes.length > 0) {
            this.m_selectShapes.length = 0;
            this.notify(_Selection.CHANGE_SHAPE);
        }
    }
    isSelectedShape(shape2) {
        const shapeId = typeof shape2 === "string" ? shape2 : shape2.id;
        const ret = this.m_selectShapes.find((value) => shapeId == value.id);
        return ret !== void 0;
    }
    get selectedShapes() {
        return this.m_selectShapes;
    }
    get hoveredShape() {
        return this.m_hoverShape;
    }
    hoverShape(shape2) {
        var _a2;
        if (shape2.id !== ((_a2 = this.hoveredShape) == null ? void 0 : _a2.id)) {
            this.m_hoverShape = shape2;
            this.notify(_Selection.CHANGE_SHAPE_HOVER);
        }
    }
    unHoverShape() {
        const needNotify = this.m_hoverShape;
        this.m_hoverShape = void 0;
        if (needNotify) {
            this.notify(_Selection.CHANGE_SHAPE_HOVER);
        }
    }
    replaceSelectShape(shape2) {
        this.m_selectShapes.length = 0;
        this.m_selectShapes.push(shape2);
    }
    // 通过id获取shape
    getShapeById(id) {
        const page = this.m_selectPage;
        let shape2;
        if (page) {
            shape2 = page.shapes.get(id);
        }
        return shape2;
    }
    getArea(p2) {
        let area = "invalid";
        if (this.hoveredShape) {
            let m2 = this.hoveredShape.matrix2Root(), wm = this.m_context.workspace.matrix;
            m2.multiAtLeft(wm);
            let path = this.hoveredShape.getPath().clone();
            path.transform(m2);
            if (this.scout.isPointInPath(path.toString(), p2)) return "hover";
        }
        for (let i = 0, len = this.m_table_area.length; i < len; i++) {
            const a2 = this.m_table_area[i];
            if (this.scout.isPointInPath(a2.area, p2)) {
                area = a2.id;
                return area;
            }
        }
        return area;
    }
    setArea(table_area) {
        this.m_table_area = table_area;
    }
    /** @deprecated */
    getTextSelection(shape2) {
        return this.textSelection;
    }
    save() {
        const state = {
            shapes: []
        };
        if (this.selectedShapes.length > 0) {
            state.shapes = this.selectedShapes.map((s) => s.id);
        }
        const tableView = this.tableshape;
        if (tableView) {
            const table2 = tableView.data;
            const rowStart = this.tableSelection.tableRowStart;
            const rowEnd = this.tableSelection.tableRowEnd;
            const colStart = this.tableSelection.tableColStart;
            const colEnd = this.tableSelection.tableColEnd;
            if (!(rowStart < 0 && rowEnd < 0 && colStart < 0 && colEnd < 0)) {
                state.table = { isRowOrCol: false, rows: [], cols: [] };
                const rowCount = table2.rowHeights.length;
                const colCount = table2.colWidths.length;
                if (rowStart === 0 && rowEnd === rowCount - 1) {
                    state.table.isRowOrCol = true;
                    if (colStart < 0) throw new Error();
                    for (let i = colStart; i <= colEnd && i < colCount; ++i) {
                        state.table.cols.push(table2.colWidths[i].id);
                    }
                } else if (colStart === 0 && colEnd === colCount - 1) {
                    state.table.isRowOrCol = true;
                    if (rowStart < 0) throw new Error();
                    for (let i = rowStart; i <= rowEnd && i < rowCount; ++i) {
                        state.table.rows.push(table2.rowHeights[i].id);
                    }
                } else {
                    if (colStart < 0) throw new Error();
                    if (rowStart < 0) throw new Error();
                    for (let i = colStart; i <= colEnd && i < colCount; ++i) {
                        state.table.cols.push(table2.colWidths[i].id);
                    }
                    for (let i = rowStart; i <= rowEnd && i < rowCount; ++i) {
                        state.table.rows.push(table2.rowHeights[i].id);
                    }
                }
            }
        }
        const textShape = this.textSelection.shape;
        if (this.textSelection.cursorStart >= 0 && this.textSelection.cursorEnd >= 0 && textShape) {
            state.text = new ou(
                v4(),
                textShape.text.getCrdtPath(),
                Qp.MAX_SAFE_INTEGER,
                this.textSelection.cursorStart,
                this.textSelection.cursorEnd - this.textSelection.cursorStart
            );
        }
        return state;
    }
    saveText(path) {
        const shape2 = this.focusTextShape;
        if (!shape2) return;
        const text = shape2.text;
        if (!text) return;
        const curPath = text.getCrdtPath();
        if (path.length !== curPath.length) return;
        if (Vp(path, curPath)) return;
        if (this.textSelection.cursorStart >= 0 && this.textSelection.cursorEnd >= 0) {
            return new ou(
                v4(),
                path,
                Qp.MAX_SAFE_INTEGER,
                this.textSelection.cursorStart,
                this.textSelection.cursorEnd - this.textSelection.cursorStart
            );
        }
    }
    restoreText(op) {
        const path = op.path;
        const shape2 = this.focusTextShape;
        if (!shape2) return;
        const text = shape2.text;
        if (!text) return;
        const curPath = text.getCrdtPath();
        if (path.length !== curPath.length) return;
        if (Vp(path, curPath)) return;
        if (this.textSelection.cursorStart !== op.start || this.textSelection.cursorEnd !== op.start + op.length) {
            if (op.length === 0) this.textSelection.setCursor(op.start, false);
            else this.textSelection.selectText(op.start, op.start + op.length);
        }
    }
    restore(state) {
        if (!this.selectedPage) return;
        const shapes = state.shapes.map((id) => {
            var _a2;
            return (_a2 = this.selectedPage) == null ? void 0 : _a2.getShape(id);
        });
        if (shapes.findIndex((s) => s === void 0) >= 0) {
            this.m_context.nextTick(this.selectedPage, () => {
                const shapes2 = state.shapes.map((id) => {
                    var _a2;
                    return (_a2 = this.selectedPage) == null ? void 0 : _a2.getShape(id);
                }).filter((s) => s !== void 0);
                this.rangeSelectShape(shapes2);
            });
        } else if (Vp(state.shapes, this.selectedShapes.map((s) => s.id))) {
            this.rangeSelectShape(shapes);
        }
        let tableView;
        if (state.table && (tableView = this.tableshape)) {
            const table2 = tableView.data;
            const colCount = table2.colWidths.length;
            const rowCount = table2.rowHeights.length;
            let colsIdxs, rowsIdxs;
            if (!state.table.isRowOrCol) {
                colsIdxs = state.table.cols.map((id) => table2.colWidths.findIndex((v2) => v2.id === id)).filter((v2) => v2 >= 0);
                rowsIdxs = state.table.rows.map((id) => table2.rowHeights.findIndex((v2) => v2.id === id)).filter((v2) => v2 >= 0);
            } else if (state.table.cols.length === 0) {
                if (state.table.rows.length === 0) throw new Error();
                rowsIdxs = state.table.rows.map((id) => table2.rowHeights.findIndex((v2) => v2.id === id)).filter((v2) => v2 >= 0);
                colsIdxs = [0, colCount - 1];
            } else {
                if (state.table.rows.length !== 0) throw new Error();
                if (state.table.cols.length === 0) throw new Error();
                colsIdxs = state.table.cols.map((id) => table2.colWidths.findIndex((v2) => v2.id === id)).filter((v2) => v2 >= 0);
                rowsIdxs = [0, rowCount - 1];
            }
            const _colStart = colsIdxs.length === 0 ? -1 : colsIdxs.reduce((m2, c2) => c2 < m2 ? c2 : m2, colCount - 1);
            const _colEnd = colsIdxs.length === 0 ? -1 : colsIdxs.reduce((m2, c2) => c2 < m2 ? m2 : c2, 0);
            const _rowStart = rowsIdxs.length === 0 ? -1 : rowsIdxs.reduce((m2, c2) => c2 < m2 ? c2 : m2, rowCount - 1);
            const _rowEnd = rowsIdxs.length === 0 ? -1 : rowsIdxs.reduce((m2, c2) => c2 < m2 ? m2 : c2, 0);
            if (_colStart < 0 || _colEnd < 0 || _rowStart < 0 || _rowEnd < 0) {
                const rowStart = this.tableSelection.tableRowStart;
                const rowEnd = this.tableSelection.tableRowEnd;
                const colStart = this.tableSelection.tableColStart;
                const colEnd = this.tableSelection.tableColEnd;
                if (rowStart !== -1 || rowEnd !== -1 || colStart !== -1 || colEnd !== -1) this.tableSelection.resetSelection();
            } else {
                this.tableSelection.selectTableCellRange(_rowStart, _rowEnd, _colStart, _colEnd);
            }
        }
        if (state.text && (this.textSelection.cursorStart !== state.text.start || this.textSelection.cursorEnd !== state.text.start + state.text.length)) {
            if (state.text.length === 0) this.textSelection.setCursor(state.text.start, false);
            else this.textSelection.selectText(state.text.start, state.text.start + state.text.length);
        }
    }
    get selectedSymOrRefMenber() {
        return this.m_selected_sym_ref_menber;
    }
    setSelectSoRMenber(shape2) {
        this.m_selected_sym_ref_menber = shape2;
    }
    get selectedSymRefBros() {
        return this.m_selected_sym_ref_bros;
    }
    setSelectedSymRefBros(shapes) {
        this.m_selected_sym_ref_bros = shapes;
    }
    get_closest_container(shape2) {
        let result = this.m_selectPage;
        let p2 = shape2.parent;
        while (p2) {
            if (p2.type === Vt.Artboard) {
                result = p2;
                break;
            }
            p2 = p2.parent;
        }
        return result;
    }
    get isNewShapeSelection() {
        return this.m_is_new_shape_selection;
    }
    setSelectionNewShapeStatus(v2) {
        this.m_is_new_shape_selection = v2;
    }
    setEnvShapes(shapes) {
        this.m_env_shapes = shapes;
    }
    get envShapes() {
        return this.m_env_shapes;
    }
    // #region 特殊类型shape的读取
    get textshape() {
        if (this.selectedShapes.length !== 1) {
            return;
        }
        const _textshape = this.selectedShapes[0] instanceof Ic ? this.selectedShapes[0] : void 0;
        if (_textshape) {
            return _textshape;
        }
        const _tabletext = (() => {
            if (!(this.selectedShapes[0] instanceof Tc)) {
                return;
            }
            const tableSelection = this.m_context.tableSelection;
            if (tableSelection.editingCell && tableSelection.editingCell && tableSelection.editingCell.cellType === Wt.Text) {
                return tableSelection.editingCell;
            }
        })();
        return _tabletext;
    }
    get pathshape() {
        const selected = this.selectedShapes;
        if (selected.length === 1 && selected[0].pathType) {
            return this.selectedShapes[0];
        }
    }
    // get pathshapeview() {
    //     const selected = this.selectedShapes;
    //     if (selected.length === 1 && selected[0] instanceof PathShapeView) {
    //         return (this.selectedShapes[0]) as PathShapeView;
    //     }
    // }
    get symbolshape() {
        return this.selectedShapes.length === 1 && is_symbol_or_union(this.selectedShapes[0]) ? this.selectedShapes[0] : void 0;
    }
    get symbolview() {
        return this.selectedShapes.length === 1 && is_symbol_or_union(this.selectedShapes[0]) ? this.selectedShapes[0] : void 0;
    }
    get unionshape() {
        if (this.selectedShapes.length === 1) {
            const xs2 = this.selectedShapes[0];
            if (xs2.data instanceof zi) {
                return $c(xs2);
            }
        }
    }
    get symbolstate() {
        if (this.selectedShapes.length === 1) {
            const s = this.selectedShapes[0];
            const p2 = s.parent;
            if (!p2 || !(p2.data instanceof zi)) {
                return;
            }
            return s;
        }
    }
    get symbolstateview() {
        if (this.selectedShapes.length === 1) {
            const s = this.selectedShapes[0];
            const p2 = s.parent;
            if (!p2 || !(p2.data instanceof zi)) {
                return;
            }
            return s;
        }
    }
    get symbolrefshape() {
        if (this.selectedShapes.length === 1) {
            const s = this.selectedShapes[0];
            if (s.type === Vt.SymbolRef) {
                return s;
            }
        }
    }
    get symbolrefview() {
        if (this.selectedShapes.length === 1) {
            const s = this.selectedShapes[0];
            if (s.type === Vt.SymbolRef) {
                return s;
            }
        }
    }
    get tableshape() {
        if (this.selectedShapes.length === 1) {
            const s = this.selectedShapes[0];
            if (s instanceof Tc) {
                return s;
            }
        }
    }
    // #endregion
    get is_interval() {
        return this.m_interval;
    }
    setShowInterval(v2) {
        this.m_interval = v2;
        this.notify(_Selection.SHOW_INTERVAL);
    }
    get labelFixedGroup() {
        return this.m_label_fixed_group.length ? this.m_label_fixed_group : void 0;
    }
    setLabelFixedGroup(shapes) {
        this.m_label_fixed_group = shapes;
    }
    get labelLivingGroup() {
        return this.m_label_living_group.length ? this.m_label_living_group : void 0;
    }
    setLabelLivingGroup(shapes) {
        this.m_label_living_group = shapes;
    }
    get hoverStroke() {
        return this.m_hover_stroke;
    }
    setHoverStroke(val) {
        this.m_hover_stroke = val;
    }
    locateShape(shapes) {
        skipUserSelectShapes(this.m_context, shapes);
    }
    get getUserSelection() {
        return this.userSelectionList;
    }
    userSelectionData(data) {
        this.userSelectionList = data;
        this.notify(_Selection.CHANGE_USER_STATE);
    }
    previewHoverShape(shape2) {
        this.m_hoverShape = shape2;
        this.notify(_Selection.PREVIEW_HOVER_CHANGE);
    }
};
__publicField(_Selection, "CHANGE_PAGE", SelectionEvents.page_change);
__publicField(_Selection, "CHANGE_SHAPE", SelectionEvents.shape_change);
__publicField(_Selection, "CHANGE_SHAPE_HOVER", SelectionEvents.shape_hover_change);
__publicField(_Selection, "CHANGE_RENAME", 4);
__publicField(_Selection, "CHANGE_TEXT", SelectionEvents.text_change);
__publicField(_Selection, "PAGE_RENAME", 6);
__publicField(_Selection, "UPDATE_RENDER_ITEM", 7);
// static CHANGE_COMMENT = 8;
// static SOLVE_MENU_STATUS = 9;
// static COMMENT_CHANGE_PAGE = 10;
// static SKIP_COMMENT = 11;
// static PAGE_SORT = 12;
// static ABOUT_ME = 13;
__publicField(_Selection, "EXTEND", 14);
__publicField(_Selection, "PLACEMENT_CHANGE", 15);
__publicField(_Selection, "SELECTION_HIDDEN", 16);
__publicField(_Selection, "SHOW_INTERVAL", 17);
__publicField(_Selection, "PASSIVE_CONTOUR", 18);
__publicField(_Selection, "CHANGE_USER_STATE", 19);
__publicField(_Selection, "PREVIEW_HOVER_CHANGE", 20);
let Selection = _Selection;
const _Menu = class _Menu extends U {
    constructor(context) {
        super();
        __publicField(this, "m_menu_mounted", "");
        __publicField(this, "m_popover", false);
        __publicField(this, "m_color_picker");
        // 编辑器是否已经有调色板🎨
        __publicField(this, "m_user_cursor_visible", true);
        __publicField(this, "m_context");
        __publicField(this, "m_platfrom", 1);
        __publicField(this, "m_mulriple", 1);
        __publicField(this, "m_mulriple_i", 1);
        __publicField(this, "m_lable_menu_mounted", "");
        __publicField(this, "m_cell_menu_type");
        __publicField(this, "m_export_dialog", false);
        this.m_context = context;
    }
    get isMenuMount() {
        return this.m_menu_mounted;
    }
    get ispopover() {
        return this.m_popover;
    }
    get isUserCursorVisible() {
        return this.m_user_cursor_visible;
    }
    setPopoverVisible(v2) {
        this.m_popover = v2;
    }
    menuMount(mount) {
        this.m_menu_mounted = mount || "";
        if (!mount) this.notify(_Menu.SHUTDOWN_MENU);
    }
    get isColorPickerMount() {
        return this.m_color_picker;
    }
    setupColorPicker(id) {
        this.m_color_picker = id;
        this.m_context.escstack.save(v4(), this.removeColorPicker.bind(this));
    }
    clearColorPickerId() {
        this.m_color_picker = void 0;
    }
    removeColorPicker() {
        if (!this.m_color_picker) return false;
        this.notify(_Menu.REMOVE_COLOR_PICKER, this.m_color_picker);
        this.m_color_picker = void 0;
        return true;
    }
    setVisibleCursor(visible) {
        this.m_user_cursor_visible = visible;
        this.notify(_Menu.CHANGE_USER_CURSOR);
    }
    setSplitCell(mount) {
        if (mount) {
            this.notify(_Menu.OPEN_SPLIT_CELL, mount);
        }
    }
    get isPlatfrom() {
        return this.m_platfrom;
    }
    setPlatfrom(v2) {
        this.m_platfrom = v2;
        this.notify(_Menu.LABLE_PLATFROM_CHANGE);
    }
    get isMulriple() {
        return this.m_mulriple;
    }
    get isMulripleI() {
        return this.m_mulriple_i;
    }
    setLableMulriple(v2, i) {
        this.m_mulriple = v2;
        this.m_mulriple_i = i;
        this.notify(_Menu.LABLE_MULRIPLE);
    }
    get isLableMenuMount() {
        return this.m_lable_menu_mounted;
    }
    lableMenuMount(mount) {
        this.m_lable_menu_mounted = mount || "";
        if (!mount) this.notify(_Menu.SHUTDOWN_LABLE_MENU);
    }
    shadowPositionMenu() {
        this.notify(_Menu.SHADOW_POSITION_MENU);
    }
    get cellMenuType() {
        return this.m_cell_menu_type;
    }
    setCellMenuType(type) {
        this.m_cell_menu_type = type;
    }
    get isExportDialog() {
        return this.m_export_dialog;
    }
    setExportDialog(visible) {
        this.m_export_dialog = visible;
        this.notify(_Menu.EXPORT_DIALOG);
    }
};
__publicField(_Menu, "SHUTDOWN_MENU", 1);
__publicField(_Menu, "SHUTDOWN_POPOVER", 2);
__publicField(_Menu, "REMOVE_COLOR_PICKER", 3);
__publicField(_Menu, "SHOW_PLACEMENT", 4);
__publicField(_Menu, "HIDE_PLACEMENT", 5);
__publicField(_Menu, "CHANGE_USER_CURSOR", 6);
__publicField(_Menu, "OPEN_SPLIT_CELL", 7);
__publicField(_Menu, "CLOSE_COMP_MENU", 8);
__publicField(_Menu, "LABLE_PLATFROM_CHANGE", 11);
__publicField(_Menu, "LABLE_MULRIPLE", 9);
__publicField(_Menu, "SHUTDOWN_LABLE_MENU", 10);
__publicField(_Menu, "SHADOW_POSITION_MENU", 11);
__publicField(_Menu, "SHADOW_CUTOUT_ARGS_MENU", 12);
__publicField(_Menu, "CLOSE_INSTANCE_ATTR_MENU", 13);
// static OPEN_SHORTCUTS = 14;
__publicField(_Menu, "WRITE_MEDIA", 15);
__publicField(_Menu, "UPDATE_LOCATE", 16);
__publicField(_Menu, "EXPORT_DIALOG", 17);
__publicField(_Menu, "WRITE_MEDIA_LAZY", 18);
let Menu = _Menu;
var CursorType = /* @__PURE__ */ ((CursorType2) => {
    CursorType2["Auto"] = "auto";
    CursorType2["Rotate"] = "rotate";
    CursorType2["Scale"] = "scale";
    CursorType2["Create"] = "create";
    CursorType2["Extend"] = "extend";
    CursorType2["Text"] = "text";
    CursorType2["Grab"] = "grab";
    CursorType2["Grabbing"] = "grabbing";
    CursorType2["Pen"] = "pen";
    CursorType2["Comment"] = "comment";
    return CursorType2;
})(CursorType || {});
const _CursorPicker = class _CursorPicker {
    constructor() {
        __publicField(this, "m_style");
        __publicField(this, "m_class_map", /* @__PURE__ */ new Map());
        __publicField(this, "m_salt", "");
        this.m_style = document.createElement("style");
        this.m_style.id = "cursor-sheet";
        this.m_salt = v4().split("-").pop() || "cursor";
        this.createClass("auto", 0);
        document.querySelector("head").appendChild(this.m_style);
    }
    getHot(type) {
        if (type === "auto") {
            return [0, 0];
        } else {
            return [16, 16];
        }
    }
    getSource(type) {
        switch (type) {
            case "auto":
                return _CursorPicker.DEFAULT;
            case "create":
                return _CursorPicker.CREATE;
            case "scale":
                return _CursorPicker.SCALE_SLICE;
            case "rotate":
                return _CursorPicker.ROTATE_SLICE;
            case "extend":
                return _CursorPicker.EXTEND;
            case "pen":
                return _CursorPicker.PEN;
            case "comment":
                return _CursorPicker.COMMENT;
            default:
                return _CursorPicker.DEFAULT;
        }
    }
    createClass(type, degree) {
        const _source = this.getSource(type);
        const className = `${type}-${degree}-${this.m_salt}`;
        let classStr = `.${className} {`;
        let url;
        const dynamic = _CursorPicker.DYNAMIC.includes(type);
        if (dynamic) {
            const source = _source;
            url = source[0] + degree + source[1];
        } else {
            url = _source;
        }
        if (type === "auto") {
            classStr += `cursor: url("${url}") 8 5, auto !important;`;
        } else if (type === "grab") {
            classStr += `cursor: grab !important;`;
        } else if (type === "grabbing") {
            classStr += `cursor: grabbing !important;`;
        } else if (type === "text") {
            classStr += "cursor: text !important;";
        } else if (type === "pen") {
            classStr += `cursor: -webkit-image-set(url(${url}) 2x) 13 13, auto !important;`;
        } else if (type === "comment") {
            classStr += `cursor: -webkit-image-set(url(${url}) 2x) 16 14, auto !important;`;
        } else {
            classStr += `cursor: url("${url}") 16 16, auto !important;`;
        }
        classStr += "}";
        this.m_class_map.set(`${type}-${degree}`, className);
        this.m_style.innerText += classStr;
    }
    getClass(type, degree) {
        degree = this.findNearestMultipleOf(degree);
        const name = `${type}-${degree}`;
        const fromMap = this.m_class_map.get(name);
        if (fromMap) {
            return fromMap;
        }
        this.createClass(type, degree);
        return `${type}-${degree}-${this.m_salt}`;
    }
    remove() {
        this.m_style.remove();
    }
    findNearestMultipleOf(num, step = 3) {
        if (num < 0) {
            num = num + 360;
        }
        let closest = Math.round(num / step) * step;
        if (closest < num) {
            closest += step;
        }
        return closest;
    }
};
// 默认
__publicField(_CursorPicker, "DEFAULT", "data:image/svg+xml,<svg width='32' height='32' viewBox='0 0 32 32' fill='none' xmlns='http://www.w3.org/2000/svg'><g filter='url(%23filter0_d_328_9)'><path d='M9.00003 6.00005L10.543 24.0826L15.5 17.0001L23.7339 15.1138L9.00003 6.00005Z' fill='%23141414'/><path fill-rule='evenodd' clip-rule='evenodd' d='M8.00365 6.08507C7.99455 5.97809 8.00246 5.87204 8.02742 5.76761C8.05237 5.66318 8.09309 5.56531 8.14958 5.474C8.21933 5.36122 8.30802 5.26609 8.41563 5.18859C8.52323 5.11109 8.64157 5.05713 8.77064 5.02672C8.89972 4.9963 9.0297 4.99174 9.16058 5.01303C9.29147 5.03432 9.41331 5.07984 9.52608 5.1496L24.2599 14.2634C24.3737 14.3337 24.4694 14.4232 24.5472 14.532C24.625 14.6407 24.6788 14.7602 24.7086 14.8905C24.7233 14.9545 24.7316 15.0194 24.7335 15.085C24.7354 15.1506 24.7309 15.2158 24.7199 15.2805C24.709 15.3453 24.6918 15.4083 24.6684 15.4697C24.6451 15.5311 24.616 15.5896 24.581 15.6452C24.5462 15.7008 24.5062 15.7525 24.4611 15.8002C24.4161 15.848 24.3668 15.8909 24.3132 15.9289C24.2597 15.967 24.203 15.9994 24.1431 16.0263C24.0832 16.0531 24.0212 16.0739 23.9572 16.0886L16.0986 17.8889L11.3623 24.656C11.3203 24.7158 11.2718 24.7712 11.2178 24.8206C11.1638 24.8699 11.1052 24.9128 11.0418 24.9494C10.9784 24.9858 10.9118 25.015 10.842 25.0369C10.7722 25.0587 10.7009 25.0728 10.628 25.079C10.5626 25.0846 10.4973 25.0837 10.432 25.0764C10.3667 25.0691 10.3028 25.0555 10.2402 25.0357C10.1777 25.0158 10.1176 24.99 10.0601 24.9583C10.0026 24.9266 9.94878 24.8896 9.89857 24.8473C9.84836 24.8049 9.80276 24.7581 9.76177 24.7069C9.72078 24.6555 9.68519 24.6007 9.655 24.5425C9.6248 24.4841 9.60059 24.4234 9.58235 24.3604C9.56411 24.2973 9.5522 24.233 9.54662 24.1676L8.00365 6.08507ZM15.5 17.0001L10.543 24.0826L9.00003 6.00005L23.7339 15.1138L15.5 17.0001Z' fill='white'/></g><defs><filter id='filter0_d_328_9' x='6' y='3.99988' width='20.7344' height='24.0828' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'><feFlood flood-opacity='0' result='BackgroundImageFix'/><feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/><feOffset dy='1'/><feGaussianBlur stdDeviation='1'/><feComposite in2='hardAlpha' operator='out'/><feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.15 0'/><feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_328_9'/><feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_328_9' result='shape'/></filter></defs></svg>");
// 旋转
__publicField(_CursorPicker, "ROTATE_SLICE", [
    "data:image/svg+xml,<svg width='32' height='32' viewBox='0 0 32 32' fill='none' xmlns='http://www.w3.org/2000/svg'><g transform='rotate(",
    " 16 16)' filter='url(%23filter0_d_326_2)'><path fill-rule='evenodd' clip-rule='evenodd' d='M13.7201 24.103L14.0655 20.3791C14.0563 20.2158 14.1178 20.0558 14.2338 19.9398C14.4581 19.7155 14.8207 19.7144 15.0437 19.9374L16.0491 20.9428L17.4251 19.5668C18.4014 18.5905 18.8908 17.4133 18.8933 16.035C18.8957 14.6568 18.4106 13.4813 17.4378 12.5085L16.0286 11.0993L15.0196 12.1083C14.7958 12.3321 14.4332 12.3324 14.2097 12.1089C14.0942 11.9933 14.0332 11.8335 14.043 11.6702L13.711 7.94747C13.7097 7.79325 13.7703 7.64497 13.8794 7.53586C13.9885 7.42675 14.1368 7.36608 14.291 7.3675L18.0137 7.69941C18.3295 7.68068 18.6001 7.92152 18.6185 8.23717C18.628 8.40051 18.5676 8.56032 18.4519 8.67607L17.4428 9.68511L18.852 11.0943C20.2139 12.4562 20.8931 14.1019 20.8896 16.0315C20.8862 17.961 20.201 19.6091 18.8342 20.976L17.4582 22.352L18.4636 23.3573C18.5789 23.4727 18.6388 23.6323 18.6287 23.7956C18.6092 24.1114 18.3376 24.3532 18.022 24.3356L14.298 24.6809C14.1438 24.6829 13.9957 24.6227 13.887 24.514C13.7783 24.4053 13.7182 24.2572 13.7201 24.103Z' fill='%23141414'/><path fill-rule='evenodd' clip-rule='evenodd' d='M12.7202 24.0904C12.7205 24.0637 12.7219 24.0372 12.7244 24.0107L13.0642 20.3464C13.061 19.9155 13.2152 19.5442 13.5267 19.2327C13.8333 18.9261 14.2032 18.7721 14.6363 18.7709C15.0718 18.7696 15.4432 18.9228 15.7508 19.2303L16.0491 19.5286L16.718 18.8597C17.4995 18.0782 17.8913 17.136 17.8933 16.0332C17.8952 14.9318 17.5077 13.9926 16.7307 13.2156L16.0286 12.5135L15.7267 12.8154C15.4197 13.1224 15.0493 13.276 14.6153 13.2764C14.1807 13.2766 13.8098 13.1232 13.5026 12.816C13.1905 12.5038 13.0368 12.1316 13.0416 11.6993L12.715 8.03628C12.7126 8.00974 12.7112 7.98315 12.711 7.95652C12.7071 7.51613 12.8608 7.14021 13.1723 6.82875C13.4838 6.51725 13.8597 6.3635 14.3 6.36751C14.3267 6.36774 14.3532 6.36906 14.3798 6.37147L18.0432 6.69808C18.4402 6.69426 18.7898 6.82677 19.0922 7.09562C19.4167 7.38426 19.5916 7.74542 19.6168 8.17911C19.6441 8.64924 19.4915 9.05059 19.159 9.38317L18.857 9.6851L19.5591 10.3872C21.1168 11.9448 21.8936 13.8269 21.8897 16.0332C21.8857 18.2382 21.1029 20.1215 19.5413 21.6831L18.8724 22.352L19.1707 22.6502C19.5039 22.9834 19.6559 23.3857 19.6268 23.8573C19.6001 24.2894 19.4249 24.6495 19.1012 24.9376C18.7996 25.2061 18.4509 25.3392 18.0551 25.3368L14.3904 25.6767C14.3639 25.6791 14.3373 25.6805 14.3107 25.6809C13.8689 25.6865 13.492 25.5332 13.1799 25.2211C12.8678 24.9091 12.7146 24.5321 12.7202 24.0904ZM18.022 24.3356L14.298 24.6809C14.1438 24.6829 13.9957 24.6227 13.887 24.514C13.7783 24.4053 13.7182 24.2572 13.7201 24.103L14.0655 20.3791C14.0563 20.2158 14.1178 20.0558 14.2338 19.9398C14.4581 19.7155 14.8207 19.7144 15.0437 19.9374L16.0491 20.9428L17.4251 19.5668C18.4014 18.5905 18.8908 17.4133 18.8933 16.035C18.8957 14.6568 18.4106 13.4813 17.4378 12.5085L16.0286 11.0993L15.0196 12.1083C14.7958 12.3321 14.4332 12.3324 14.2097 12.1089C14.0942 11.9933 14.0332 11.8335 14.043 11.6702L13.711 7.94747C13.7097 7.79325 13.7703 7.64497 13.8794 7.53586C13.9885 7.42675 14.1368 7.36608 14.291 7.3675L18.0137 7.69941C18.3295 7.68068 18.6001 7.92152 18.6185 8.23717C18.628 8.40051 18.5676 8.56032 18.4519 8.67607L17.4428 9.68511L18.852 11.0943C20.2139 12.4562 20.8931 14.1019 20.8896 16.0315C20.8862 17.961 20.201 19.6091 18.8342 20.976L17.4582 22.352L18.4636 23.3573C18.5789 23.4727 18.6388 23.6323 18.6287 23.7956C18.6092 24.1114 18.3376 24.3532 18.022 24.3356Z' fill='white'/></g><defs><filter id='filter0_d_326_2' x='10.7109' y='5.36743' width='13.1797' height='23.3136' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'><feFlood flood-opacity='0' result='BackgroundImageFix'/><feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/><feOffset dy='1'/><feGaussianBlur stdDeviation='1'/><feComposite in2='hardAlpha' operator='out'/><feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.15 0'/><feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_326_2'/><feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_326_2' result='shape'/></filter></defs></svg>"
]);
// 缩放
__publicField(_CursorPicker, "SCALE_SLICE", [
    "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill='none' width='32' height='32' viewBox='0 0 32 32'><defs><filter id='master_svg0_3051_9937' filterUnits='objectBoundingBox' color-interpolation-filters='sRGB' x='-4' y='-3' width='27.999954223632812' height='13.99998664855957'><feFlood flood-opacity='0' result='BackgroundImageFix'/><feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0'/><feOffset dy='1' dx='0'/><feGaussianBlur stdDeviation='1'/><feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.15000000596046448 0'/><feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow'/><feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow' result='shape'/></filter></defs><g transform='rotate(",
    " 16 16)'><g filter='url(%23master_svg0_3051_9937)'><path d='M9.05007,18.80775L6.172633,16.41007C6.0622299,16.30205,6.000023365,16.15425,6.000023365,15.99997C6.000023365,15.84569,6.0622301,15.697890000000001,6.172634,15.58987L9.05007,13.192233C9.2608,12.9556948,9.6238,12.9345752,9.86088,13.144831C9.98349,13.253574,10.054079999999999,13.409346,10.054079999999999,13.573026L10.054079999999999,15L21.9459,15L21.9459,13.573026C21.9459,13.409346,22.0165,13.253574,22.1391,13.144831C22.3762,12.9345752,22.7392,12.9556948,22.9499,13.192233L25.8274,15.58987C25.9378,15.697890000000001,26,15.84569,26,15.99997C26,16.15425,25.9378,16.30205,25.8274,16.41007L22.9499,18.80775C22.8409,18.93008,22.6843,18.99999,22.5202,18.99999C22.2031,18.99999,21.9459,18.74343,21.9459,18.426949999999998L21.9459,17L10.054079999999999,17L10.054079999999999,18.426949999999998C10.054079999999999,18.74343,9.79694,18.99999,9.47975,18.99999C9.3157,18.99999,9.15905,18.93008,9.05007,18.80775Z' fill-rule='evenodd' fill='%23141414' fill-opacity='1'/><path d='M9.05007,18.80775L6.172633,16.41007C6.0622299,16.30205,6.000023365,16.15425,6.000023365,15.99997C6.000023365,15.84569,6.0622301,15.697890000000001,6.172634,15.58987L9.05007,13.192233C9.2608,12.9556948,9.6238,12.9345752,9.86088,13.144831C9.98349,13.253574,10.054079999999999,13.409346,10.054079999999999,13.573026L10.054079999999999,15L21.9459,15L21.9459,13.573026C21.9459,13.409346,22.0165,13.253574,22.1391,13.144831C22.3762,12.9345752,22.7392,12.9556948,22.9499,13.192233L25.8274,15.58987C25.9378,15.697890000000001,26,15.84569,26,15.99997C26,16.15425,25.9378,16.30205,25.8274,16.41007L22.9499,18.80775C22.8409,18.93008,22.6843,18.99999,22.5202,18.99999C22.2031,18.99999,21.9459,18.74343,21.9459,18.426949999999998L21.9459,17L10.054079999999999,17L10.054079999999999,18.426949999999998C10.054079999999999,18.74343,9.79694,18.99999,9.47975,18.99999C9.3157,18.99999,9.15905,18.93008,9.05007,18.80775ZM11.054079999999999,18L11.054079999999999,18.426949999999998Q11.054079999999999,19.07919,10.59217,19.54005Q10.1312,19.99999,9.47975,19.99999Q8.81771,19.99999,8.36383,19.5376L5.532477,17.17831Q5.501809,17.15276,5.473276,17.12484Q5.000023,16.66179,5.000023,15.99997Q5.000023,15.33814,5.4732769999999995,14.8751Q5.501813,14.84717,5.532485,14.82162L8.36422,12.462057Q8.78159,12.038043,9.387319999999999,12.002684Q10.03737,11.964739999999999,10.5244,12.39668Q11.054079999999999,12.866442,11.054079999999999,13.573026L11.054079999999999,14L20.9459,14L20.9459,13.573026Q20.9459,12.86644,21.4756,12.396679Q21.962600000000002,11.964739999999999,22.6127,12.002684Q23.2184,12.038043,23.6358,12.462064L26.4675,14.82162Q26.4982,14.84717,26.5267,14.87509Q27,15.33814,27,15.99997Q27,16.66179,26.5267,17.12484Q26.4982,17.15276,26.4675,17.17831L23.6362,19.53759Q23.1823,19.99999,22.5202,19.99999Q21.8688,19.99999,21.4078,19.54005Q20.9459,19.07919,20.9459,18.426949999999998L20.9459,18L11.054079999999999,18Z' fill-rule='evenodd' fill='%23FFFFFF' fill-opacity='1'/></g></g></svg>"
]);
// 创建
__publicField(_CursorPicker, "CREATE", "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' fill='none' width='32' height='32' viewBox='0 0 32 32'><defs><filter id='master_svg0_3051_00276' filterUnits='objectBoundingBox' color-interpolation-filters='sRGB' x='-4' y='-3' width='24' height='24'><feFlood flood-opacity='0' result='BackgroundImageFix'/><feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0'/><feOffset dy='1' dx='0'/><feGaussianBlur stdDeviation='1'/><feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.15000000596046448 0'/><feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow'/><feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow' result='shape'/></filter></defs><g><g filter='url(%23master_svg0_3051_00276)'><path d='M15,17L15,24L17,24L17,17L24,17L24,15L17,15L17,8L15,8L15,15L8,15L8,17L15,17Z' fill-rule='evenodd' fill='%23141414' fill-opacity='1'/><path d='M15,18L15,17L8,17L8,15L15,15L15,8L17,8L17,15L24,15L24,17L17,17L17,24L15,24L15,18ZM14,18L8,18Q7.9015086,18,7.80491,17.98078Q7.708311,17.961570000000002,7.617317,17.92388Q7.526322,17.88619,7.44443,17.83147Q7.362537,17.77675,7.292893,17.70711Q7.223249,17.63746,7.16853,17.55557Q7.113812,17.47368,7.076121,17.38268Q7.03843,17.29169,7.019215,17.19509Q7,17.098489999999998,7,17L7,15Q7,14.90151,7.019215,14.80491Q7.03843,14.70831,7.076121,14.61732Q7.113812,14.52632,7.16853,14.44443Q7.223249,14.36254,7.292893,14.29289Q7.362537,14.22325,7.44443,14.16853Q7.526322,14.11381,7.617317,14.07612Q7.708311,14.03843,7.80491,14.019210000000001Q7.9015086,14,8,14L14,14L14,8Q14,7.9015086,14.019210000000001,7.80491Q14.03843,7.708311,14.07612,7.617317Q14.11381,7.526322,14.16853,7.44443Q14.22325,7.362537,14.29289,7.292893Q14.36254,7.223249,14.44443,7.16853Q14.52632,7.113812,14.61732,7.076121Q14.70831,7.03843,14.80491,7.019215Q14.90151,7,15,7L17,7Q17.098489999999998,7,17.19509,7.019215Q17.29169,7.03843,17.38268,7.076121Q17.47368,7.113812,17.55557,7.16853Q17.63746,7.223249,17.70711,7.292893Q17.77675,7.362537,17.83147,7.44443Q17.88619,7.526322,17.92388,7.617317Q17.961570000000002,7.708311,17.98078,7.80491Q18,7.9015086,18,8L18,14L24,14Q24.0985,14,24.1951,14.019210000000001Q24.2917,14.03843,24.3827,14.07612Q24.4737,14.11381,24.5556,14.16853Q24.6375,14.22325,24.7071,14.29289Q24.7767,14.36254,24.8315,14.44443Q24.8862,14.52632,24.9239,14.61732Q24.9616,14.70831,24.9808,14.80491Q25,14.90151,25,15L25,17Q25,17.098489999999998,24.9808,17.19509Q24.9616,17.29169,24.9239,17.38268Q24.8862,17.47368,24.8315,17.55557Q24.7767,17.63746,24.7071,17.70711Q24.6375,17.77675,24.5556,17.83147Q24.4737,17.88619,24.3827,17.92388Q24.2917,17.961570000000002,24.1951,17.98078Q24.0985,18,24,18L18,18L18,24Q18,24.0985,17.98078,24.1951Q17.961570000000002,24.2917,17.92388,24.3827Q17.88619,24.4737,17.83147,24.5556Q17.77675,24.6375,17.70711,24.7071Q17.63746,24.7767,17.55557,24.8315Q17.47368,24.8862,17.38268,24.9239Q17.29169,24.9616,17.19509,24.9808Q17.098489999999998,25,17,25L15,25Q14.90151,25,14.80491,24.9808Q14.70831,24.9616,14.61732,24.9239Q14.52632,24.8862,14.44443,24.8315Q14.36254,24.7767,14.29289,24.7071Q14.22325,24.6375,14.16853,24.5556Q14.11381,24.4737,14.07612,24.3827Q14.03843,24.2917,14.019210000000001,24.1951Q14,24.0985,14,24L14,18Z' fill-rule='evenodd' fill='%23FFF' /></g></g></svg>");
// 扩展
__publicField(_CursorPicker, "EXTEND", "data:image/svg+xml,<svg width='32' height='32' viewBox='0 0 32 32' fill='none' xmlns='http://www.w3.org/2000/svg'><g filter='url(%23filter0_d_228_7)'><path d='M20.9098 11.0302L15.8939 6L11.2424 11.1643L14.5819 11.1731L14.6343 14.9508C13.4995 14.9443 12.3397 14.9437 11.0993 14.962L11.0993 11.0518L6 15.9975L11.0993 20.7201L11.1544 17.3811H14.668L14.7215 21.2374L11.3827 21.2837L16.1712 25.9981L21.0501 21.1496L17.1403 21.2038C17.1018 19.8585 17.0869 18.6079 17.0779 17.3811H21.2196V20.7201L26 15.9975L21.2196 11.0518V14.962C19.7518 14.9836 18.3969 14.9788 17.0628 14.9691C17.0539 13.7224 17.0391 12.4523 17 11.0844L20.9098 11.0302Z' fill='black'/><path d='M15.9087 6.58129L19.9592 10.6433L16.9944 10.6845L16.5885 10.6901L16.6001 11.0959C16.6392 12.4596 16.6539 13.7264 16.6629 14.9719L16.6657 15.3662L17.0599 15.3691C18.3949 15.3788 19.7533 15.3836 21.2255 15.3619L21.6196 15.3561V14.962V12.0412L25.4374 15.991L21.6196 19.7627V17.3811V16.9811H21.2196H17.0779H16.6749L16.6779 17.384C16.6869 18.612 16.7018 19.8659 16.7405 21.2153L16.7517 21.6092L17.1459 21.6038L20.0664 21.5633L16.1699 25.4355L12.3456 21.6703L14.727 21.6373L15.127 21.6318L15.1214 21.2318L15.0679 17.3755L15.0625 16.9811H14.668H11.1544H10.761L10.7545 17.3745L10.7141 19.8182L6.58144 15.9908L10.6993 11.997L10.6993 14.962V15.3679L11.1052 15.3619C12.3418 15.3437 13.4986 15.3443 14.632 15.3508L15.0399 15.3531L15.0342 14.9452L14.9818 11.1676L14.9764 10.7742L14.5829 10.7731L12.1389 10.7666L15.9087 6.58129Z' stroke='white' stroke-width='0.8'/></g><defs><filter id='filter0_d_228_7' x='2' y='2' width='28' height='27.9981' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'><feFlood flood-opacity='0' result='BackgroundImageFix'/><feColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/><feOffset/><feGaussianBlur stdDeviation='2'/><feComposite in2='hardAlpha' operator='out'/><feColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0'/><feBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_228_7'/><feBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_228_7' result='shape'/></filter></defs></svg>");
// 评论
__publicField(_CursorPicker, "COMMENT", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABACAYAAABFqxrgAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAP/SURBVHgB7ZnPS1RRFMfPmxl1zPyRYUlaTIsIhGDCNq2sCFpUIITrBvdKrluM0jp04TJQ/wTXLppWLiQcSSwisEAhEFEbzRmd8fX9vnlXnmaINe/dN3E/cHj3/XDuOeeee+69RxGDWFIl2LZ9D5ckpMe9Jjyvs5BNyDQkY1lWVv4naDzkrX025iEpqXZgRMJr/MbGhj02NmanUik7kUjYLS0tNj+jJJNJu7e3156cnLSXl5e9zuBNQqoRKP6cdivjh4eHjxh9mtBRHmfwd15INQGF00p7jvxZjPcKo4WR4SEt1QBHTGnM0Ze/MP648HcUxWIxJWFmd3f3upoClXKA/O6IDfYjIcU6ODj4Si0nJiYq6gAlnFoE/WRwH5Gwsbe31++kciQzzmXxwQnMLUyyBNHwQEKGVSqVFqgcs7r44AA5Ni2QG95JmKJhbW3tjooC8dEBciwaNjc3HyoddHvDqq+vv89GJpMRv4HhMjU15bRjsdhtce3X6oTu7u5YXV3dU7anp6clCLLZ8rGipqamR0IyJeJIih8Yntz6is/TgcLES5CHvnV2dtaL5kMkOz+vFnAJwAHi5gVPn+zf0hYOZR0kKgHDvKCAQ2I4dutzwsjICCNB65xkFIhuJZqamgKfj8g9zjWfz3/c2tpy2jHRiBqJIEFidK5IjLnm5mYZGhoK4R7aZ1B8ca4rKysziIQD0UlfXx+TYmvQq4MqtmDT9KStre286FwisY+PICcE6gSeTcj29vaneDx+LQz7hEAjgZskFQWzs7Mv8ewypEZ0wkhAYroQlBNUqQ2rwirub7a2tjZRB9FMYNMhnU47fezv7+cGBgYe49mVrq6uWtH9fxd3FHx3gnIAmZube41nNyDNbmLWC5XwMxJ4RhgdHT10wMLCwpva2tpbeHdJdOcCD75EAo3n6KviCafAzMzMK7xLonbRies5CUtVqVLTgUYz83P5YzFVGU/W19fn+/v7n6F2wL3yVXdfoH8aeDiyRFYSGj8+Pj6I37/rToEOCB1wYgToPDtwJC0UVVahaIf8A1j2viMCvoDs4uLi58HBwfcopuZRtdopFAo8O/+AFCAnbpO1OQHTQRC+JSj6CLctqPlFoXhZqViMFWHLbYt6fgzHie6V8KMSQn8vGo3u4G9+NjQ05OCEvPvuj+cEnesk+27A9vUiRrIR0RBBVBz5AAZZSGyHxuIbUd+4bfWshEf7kAIML8Cxu+3t7fmlpaUipwfqJvZpiuiCfTMvxKW8ZEUaGxsll8t5R/iIfu57b1sZRyeo0S669yp5hpvyouAYGnFXi0Nx76PetrvBcdre7+1yXcIrBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBoJ1fvWrb7M26VTYAAAAASUVORK5CYII=");
// 动态光标类型
__publicField(_CursorPicker, "DYNAMIC", [
    "rotate",
    "scale"
    /* Scale */
]);
__publicField(_CursorPicker, "PEN", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJESURBVHgB7Zm9jcJAFIRHuojMJTi9jJBwSyC87NwBdIBLcAe4A64D3AEhISVAB3s7sGuWHxvzI7Rr3ieNZARYmrdv3voHEARBEARBEARBEARBEARBEARBEIRXMzTaWi2MMqMUH8TGSF/R0miKQ4F6DVe+Nq6UulYMFmluNMab+ML7+Ia3ykmSYL1eYzQaYTAYYLfbUYn9zY9Rbo8HRjurqFFGOk3TvXg8HA71drvVjtVqpYuiaOqOlVFhzxMlXN19DGi0qQiOzWaj5/O5Ho/H2nRLW1QSRERptF9lGrxVBJ/lcqmzLKv/g8tBmiGCXUXBDkC3yvcUoUNU2GEpAqaOgTP7aBEc/D2j4hWjQOCUsDHw8/5MEQgjgmMXBI2CF4NXFsEblgoBcxGDVxVhOp3GG4OmIlD8zI7hd21EH4NrRfDFFucO0Eb0MXA07Pf7a4E2ehEDgut3jo1d4+hNDJh9PNABpBcxWCwWF+YZi1uDkPQmBmxndgi7gSvfxbz7H/oQg2fAsXN+ETA3d4NHYLfgND5BF6FESwweNc9BOJlMoiiCwoti4Jt3F0yz2cyfB0E+eK1j0HXIdTXv8HaFPwRKCbvN3TPtu5gnPB8C3xVSowpnV3xlWT5tnnDAIpJtMcWhG+p3CG1d0cU84RMje74KkcC5kOHsbRKfEFdVdZd5fuddGmeIEAU7I+DdFuN+8zkiJ8VZV7TdGPXN/Dk5bBHyPP84844cXhE46SneRX6CeUeOhgcn+ADzDoXTawgeZxAEQejAP1zPK4aP9mgsAAAAAElFTkSuQmCC");
let CursorPicker = _CursorPicker;
const _Cursor = class _Cursor extends U {
    constructor() {
        super();
        __publicField(this, "m_current_cursor_type", "");
        __publicField(this, "m_styler");
        __publicField(this, "m_freeze", false);
        __publicField(this, "m_auto", "");
        __publicField(this, "m_stash", "");
        this.m_styler = new CursorPicker();
    }
    init() {
        const auto = this.m_styler.getClass(CursorType.Auto, 0);
        if (!auto) {
            return;
        }
        this.m_auto = auto;
        this.notify(_Cursor.CHANGE_CURSOR, auto);
    }
    get type() {
        return this.m_current_cursor_type;
    }
    get is_freeze() {
        return this.m_freeze;
    }
    cursor_freeze(val) {
        this.m_freeze = val;
    }
    setType(type, rotate) {
        if (this.m_freeze) {
            return;
        }
        let res = this.m_styler.getClass(type, rotate) || this.m_auto;
        this.m_current_cursor_type = res;
        this.notify(_Cursor.CHANGE_CURSOR, res);
    }
    setTypeForce(type, deg) {
        let res = this.m_styler.getClass(type, deg) || this.m_auto;
        this.m_current_cursor_type = res;
        this.notify(_Cursor.CHANGE_CURSOR, res);
    }
    stash() {
        this.m_stash = this.m_current_cursor_type;
    }
    rollback() {
        if (this.m_stash) {
            this.m_current_cursor_type = this.m_stash;
            this.notify(_Cursor.CHANGE_CURSOR, this.m_current_cursor_type);
        } else {
            this.reset();
        }
    }
    reset() {
        if (this.m_freeze) {
            return;
        }
        this.m_current_cursor_type = this.m_auto;
        this.notify(_Cursor.CHANGE_CURSOR, this.m_auto);
    }
    resetForce() {
        this.m_current_cursor_type = this.m_auto;
        this.notify(_Cursor.CHANGE_CURSOR, this.m_auto);
    }
    remove() {
        this.m_styler.remove();
    }
};
__publicField(_Cursor, "CHANGE_CURSOR", 1);
__publicField(_Cursor, "RESET", 2);
let Cursor = _Cursor;
const _Assist = class _Assist extends U {
    constructor(context) {
        super();
        __publicField(this, "m_context");
        __publicField(this, "m_stickness", 5);
        __publicField(this, "m_collect_target");
        __publicField(this, "m_shape_inner", []);
        __publicField(this, "m_pg_inner", /* @__PURE__ */ new Map());
        __publicField(this, "m_x_axis", /* @__PURE__ */ new Map());
        __publicField(this, "m_y_axis", /* @__PURE__ */ new Map());
        __publicField(this, "m_except", /* @__PURE__ */ new Map());
        __publicField(this, "m_nodes_x", []);
        __publicField(this, "m_nodes_y", []);
        __publicField(this, "m_space_adsorb_x", []);
        __publicField(this, "m_space_adsorb_y", []);
        __publicField(this, "multi_line_x", []);
        __publicField(this, "multi_line_y", []);
        __publicField(this, "highlight_guide_x", []);
        __publicField(this, "highlight_guide_y", []);
        __publicField(this, "m_nodes_x2", []);
        __publicField(this, "m_nodes_y2", []);
        __publicField(this, "m_fixed_target");
        __publicField(this, "m_guides_x", []);
        __publicField(this, "m_guides_y", []);
        this.m_context = context;
    }
    setSpaceAdsorbX(xs2) {
        this.m_space_adsorb_x = xs2;
    }
    setSpaceAdsorbY(ys2) {
        this.m_space_adsorb_y = ys2;
    }
    setNodesX2(xys) {
        this.m_nodes_x2 = xys;
    }
    get nodesX2() {
        return this.m_nodes_x2;
    }
    setNodesY2(xys) {
        this.m_nodes_y2 = xys;
    }
    get nodesY2() {
        return this.m_nodes_y2;
    }
    get except() {
        return this.m_except;
    }
    get stickness() {
        return this.m_stickness;
    }
    set_stickness(v2) {
        this.m_stickness = v2;
    }
    get xAxis() {
        return this.m_x_axis;
    }
    get yAxis() {
        return this.m_y_axis;
    }
    get nodes_x() {
        return this.m_nodes_x;
    }
    get nodes_y() {
        return this.m_nodes_y;
    }
    clear() {
        this.m_shape_inner.length = 0;
        this.m_pg_inner.clear();
        this.m_x_axis.clear();
        this.m_y_axis.clear();
        this.m_nodes_x2.length = 0;
        this.m_nodes_y2.length = 0;
        this.m_guides_x.length = 0;
        this.m_guides_y.length = 0;
    }
    get fixedTarget() {
        return this.m_fixed_target;
    }
    set_collect_target(shapes, collect_immediate = false) {
        const page = this.m_context.selection.selectedPage;
        if (!shapes.length) {
            this.m_collect_target = page;
        }
        const parents = /* @__PURE__ */ new Map();
        for (let i = 0; i < shapes.length; i++) {
            const parent = shapes[i].parent;
            if (!parent) continue;
            parents.set(parent.id, parent);
        }
        if (parents.has(page.id)) {
            this.m_collect_target = page;
        } else {
            const chains = /* @__PURE__ */ new Map();
            let longest = 0;
            let longestChains = /* @__PURE__ */ new Set([page]);
            parents.forEach((p2) => {
                const id = p2.id;
                const __set = /* @__PURE__ */ new Set();
                let __p = p2;
                let layoutCount = 0;
                while (__p) {
                    __set.add(__p);
                    __p = __p.parent;
                    layoutCount++;
                }
                if (layoutCount > longest) {
                    longest = layoutCount;
                    longestChains = __set;
                }
                chains.set(id, __set);
            });
            const __longestChains = Array.from(longestChains.values());
            let env = page;
            for (let i = 0; i < __longestChains.length; i++) {
                env = __longestChains[i];
                let isCommon = true;
                chains.forEach((c2) => {
                    if (!c2.has(env)) {
                        isCommon = false;
                    }
                });
                if (isCommon) {
                    break;
                }
            }
            this.m_collect_target = env;
        }
        if (collect_immediate) {
            this.collect();
        }
    }
    set_collect_target_direct(target, needBubble, collect_immediate = false) {
        this.m_collect_target = target;
        if (needBubble) {
            this.m_collect_target = this.getFixedContainer();
        }
        if (collect_immediate) {
            this.collect();
        }
    }
    collect() {
        this.clear();
        const target = this.m_collect_target || this.m_context.selection.selectedPage;
        this.m_shape_inner = [];
        this.m_shape_inner.push(...finder(this.m_context, target, this.m_pg_inner, this.m_x_axis, this.m_y_axis));
        if (this.m_context.user.isRuleVisible) {
            this.collectGuides();
        }
    }
    collectGuides() {
        const guideTarget = this.getFixedContainer();
        this.m_fixed_target = guideTarget;
        const guides = guideTarget == null ? void 0 : guideTarget.guides;
        if (!(guides == null ? void 0 : guides.length)) {
            return;
        }
        const gxs = this.m_guides_x;
        const gys = this.m_guides_y;
        if (guideTarget.type !== Vt.Page) {
            const matrix = guideTarget.matrix2Root();
            for (let i = 0; i < guides.length; i++) {
                const { axis, offset } = guides[i];
                const assistGui = {
                    env: guideTarget,
                    offsetFix: offset,
                    offsetRoot: offset,
                    axis
                };
                if (axis === bt.X) {
                    assistGui.offsetRoot = matrix.computeCoord2(offset, 0).x;
                    gxs.push(assistGui);
                } else {
                    assistGui.offsetRoot = matrix.computeCoord2(0, offset).y;
                    gys.push(assistGui);
                }
            }
        } else {
            for (let i = 0; i < guides.length; i++) {
                const { axis, offset } = guides[i];
                const assistGui = {
                    env: guideTarget,
                    offsetFix: offset,
                    offsetRoot: offset,
                    axis
                };
                if (axis === bt.X) {
                    gxs.push(assistGui);
                } else {
                    gys.push(assistGui);
                }
            }
        }
    }
    getFixedContainer() {
        var _a2;
        const page = this.m_context.selection.selectedPage;
        let target = this.m_collect_target || page;
        if (target.type === Vt.Page) {
            return page;
        } else {
            while (target) {
                if (target.type === Vt.Page || target.isContainer && ((_a2 = target.parent) == null ? void 0 : _a2.type) === Vt.Page && !((target.rotation || 0) % 180)) {
                    break;
                }
                target = target.parent;
            }
        }
        return target;
    }
    set_trans_target(shapes) {
        this.collect();
        this.m_except.clear();
        if (shapes.length === 1) {
            get_tree(shapes[0], this.m_except);
        } else if (shapes.length > 1) {
            for (let i = 0, len = shapes.length; i < len; i++) {
                get_tree(shapes[i], this.m_except);
            }
        }
    }
    point_match(point) {
        if (!this.m_except.size) return;
        this.m_nodes_x = [];
        this.m_nodes_y = [];
        const target = { x: 0, y: 0, sticked_by_x: false, sticked_by_y: false };
        const pre_target1 = { x: 0, sy: 0, delta: void 0 };
        const pre_target2 = { y: 0, sx: 0, delta: void 0 };
        for (let i = 0, len = this.m_shape_inner.length; i < len; i++) {
            const cs2 = this.m_shape_inner[i];
            if (this.m_except.get(cs2.id)) continue;
            const c_pg = this.m_pg_inner.get(cs2.id);
            if (!c_pg) continue;
            modify_pt_x4p(pre_target1, point, c_pg.apexX, this.m_stickness);
            modify_pt_y4p(pre_target2, point, c_pg.apexY, this.m_stickness);
        }
        if (pre_target1.delta !== void 0) {
            target.x = pre_target1.x;
            target.sticked_by_x = true;
            this.m_nodes_x = (this.m_x_axis.get(target.x) || []).concat([{
                p: { x: target.x, y: pre_target1.sy },
                id: "ex"
            }]);
        }
        if (pre_target2.delta !== void 0) {
            target.y = pre_target2.y;
            target.sticked_by_y = true;
            this.m_nodes_y = (this.m_y_axis.get(target.y) || []).concat([{
                p: { x: pre_target2.sx, y: target.y },
                id: "ex"
            }]);
        }
        this.notify(_Assist.UPDATE_ASSIST);
        return target;
    }
    alignX(point, self2, toGuide = true) {
        var _a2, _b;
        const hgx = this.highlight_guide_x;
        hgx.length = 0;
        this.m_nodes_x = [];
        const target = { x: 0, sticked_by_x: false };
        const pre_target = { x: 0, sy: 0, delta: void 0 };
        for (let i = 0; i < this.m_shape_inner.length; i++) {
            const shape2 = this.m_shape_inner[i];
            if (this.m_except.get(shape2.id)) {
                continue;
            }
            const c_pg = this.m_pg_inner.get(shape2.id);
            if (!c_pg) {
                continue;
            }
            modify_pt_x4p(pre_target, point, c_pg.apexX, this.m_stickness);
        }
        let sparkX = false;
        if (toGuide) {
            if (this.m_guides_x.length) {
                const gx = this.m_guides_x.map((g2) => g2.offsetRoot);
                sparkX = modify_pt_x4p(pre_target, point, gx, this.m_stickness);
            }
        }
        if (pre_target.delta !== void 0) {
            target.x = pre_target.x;
            target.sticked_by_x = true;
            const _self = [];
            for (let i = 0; i < self2.length; i++) {
                _self.push({ id: "self", p: { x: target.x, y: self2[i].y } });
            }
            this.m_nodes_x = (this.m_x_axis.get(target.x) || []).concat(_self);
            const fixed2 = this.fixedTarget;
            if (sparkX && fixed2) {
                if (fixed2.type === Vt.Page) {
                    const matrix = this.m_context.workspace.matrix;
                    const guides_x = this.m_guides_x;
                    const height = this.m_context.workspace.root.height;
                    for (let i = 0; i < guides_x.length; i++) {
                        let offset = guides_x[i].offsetRoot;
                        if (offset !== ((_a2 = _self[0]) == null ? void 0 : _a2.p.x)) {
                            continue;
                        }
                        offset = matrix.computeCoord2(offset, 0).x;
                        hgx.push(`M${offset} 0 L${offset} ${height}`);
                    }
                } else {
                    const guides_x = this.m_guides_x;
                    const height = fixed2.frame.height;
                    const matrix = fixed2.matrix2Root();
                    matrix.multiAtLeft(this.m_context.workspace.matrix);
                    for (let i = 0; i < guides_x.length; i++) {
                        const g2 = guides_x[i];
                        let offset = g2.offsetRoot;
                        if (offset !== ((_b = _self[0]) == null ? void 0 : _b.p.x)) {
                            continue;
                        }
                        offset = g2.offsetFix;
                        const start2 = matrix.computeCoord2(offset, 0);
                        const end2 = matrix.computeCoord2(offset, height);
                        hgx.push(`M${start2.x} ${start2.y} L${end2.x} ${end2.y}`);
                    }
                }
            }
        }
        this.notify(_Assist.UPDATE_ASSIST);
        return target;
    }
    alignY(point, self2, toGuide = true) {
        var _a2, _b;
        const hgy = this.highlight_guide_y;
        hgy.length = 0;
        this.m_nodes_y = [];
        const target = { y: 0, sticked_by_y: false };
        const pre_target = { y: 0, sx: 0, delta: void 0 };
        for (let i = 0, len = this.m_shape_inner.length; i < len; i++) {
            const shape2 = this.m_shape_inner[i];
            if (this.m_except.get(shape2.id)) {
                continue;
            }
            const c_pg = this.m_pg_inner.get(shape2.id);
            if (!c_pg) {
                continue;
            }
            modify_pt_y4p(pre_target, point, c_pg.apexY, this.m_stickness);
        }
        let sparkY = false;
        if (toGuide) {
            if (this.m_guides_y.length) {
                const gy = this.m_guides_y.map((g2) => g2.offsetRoot);
                sparkY = modify_pt_y4p(pre_target, point, gy, this.m_stickness);
            }
        }
        if (pre_target.delta !== void 0) {
            target.y = pre_target.y;
            target.sticked_by_y = true;
            const _self = [];
            for (let i = 0; i < self2.length; i++) {
                _self.push({ id: "self", p: { x: self2[i].x, y: target.y } });
            }
            this.m_nodes_y = (this.m_y_axis.get(target.y) || []).concat(_self);
            const fixed2 = this.fixedTarget;
            if (sparkY && fixed2) {
                if (fixed2.type === Vt.Page) {
                    const matrix = this.m_context.workspace.matrix;
                    const guides_y = this.m_guides_y;
                    const width = this.m_context.workspace.root.width;
                    for (let i = 0; i < guides_y.length; i++) {
                        let offset = guides_y[i].offsetRoot;
                        if (offset !== ((_a2 = _self[0]) == null ? void 0 : _a2.p.y)) {
                            continue;
                        }
                        offset = matrix.computeCoord2(0, offset).y;
                        hgy.push(`M0 ${offset} L${width} ${offset}`);
                    }
                } else {
                    const guides_y = this.m_guides_y;
                    const width = fixed2.frame.width;
                    const matrix = fixed2.matrix2Root();
                    matrix.multiAtLeft(this.m_context.workspace.matrix);
                    for (let i = 0; i < guides_y.length; i++) {
                        const g2 = guides_y[i];
                        let offset = g2.offsetRoot;
                        if (offset !== ((_b = _self[0]) == null ? void 0 : _b.p.y)) {
                            continue;
                        }
                        offset = g2.offsetFix;
                        const start2 = matrix.computeCoord2(0, offset);
                        const end2 = matrix.computeCoord2(width, offset);
                        hgy.push(`M${start2.x} ${start2.y} L${end2.x} ${end2.y}`);
                    }
                }
            }
        }
        this.notify(_Assist.UPDATE_ASSIST);
        return target;
    }
    alignXY(point) {
        if (!this.m_except.size) {
            return;
        }
        this.m_nodes_x = [];
        this.m_nodes_y = [];
        const hgx = this.highlight_guide_x;
        const hgy = this.highlight_guide_y;
        hgx.length = 0;
        hgy.length = 0;
        const target = { x: 0, y: 0, sticked_by_x: false, sticked_by_y: false };
        const pre_target1 = { x: 0, sy: 0, delta: void 0 };
        const pre_target2 = { y: 0, sx: 0, delta: void 0 };
        for (let i = 0, len = this.m_shape_inner.length; i < len; i++) {
            const shape2 = this.m_shape_inner[i];
            if (this.m_except.get(shape2.id)) {
                continue;
            }
            const c_pg = this.m_pg_inner.get(shape2.id);
            if (!c_pg) {
                continue;
            }
            modify_pt_x4p(pre_target1, point, c_pg.apexX, this.m_stickness);
            modify_pt_y4p(pre_target2, point, c_pg.apexY, this.m_stickness);
        }
        let sparkX = false;
        let sparkY = false;
        if (this.m_guides_x.length) {
            const gx = this.m_guides_x.map((g2) => g2.offsetRoot);
            sparkX = modify_pt_x4p(pre_target1, point, gx, this.m_stickness);
        }
        if (this.m_guides_y.length) {
            const gy = this.m_guides_y.map((g2) => g2.offsetRoot);
            sparkY = modify_pt_y4p(pre_target2, point, gy, this.m_stickness);
        }
        const _self = { id: "self", p: { x: point.x, y: point.y } };
        if (pre_target1.delta !== void 0) {
            target.x = pre_target1.x;
            target.sticked_by_x = true;
            _self.p.x = target.x;
            this.m_nodes_x = (this.m_x_axis.get(target.x) || []).concat([_self]);
        }
        if (pre_target2.delta !== void 0) {
            target.y = pre_target2.y;
            target.sticked_by_y = true;
            _self.p.y = target.y;
            this.m_nodes_y = (this.m_y_axis.get(target.y) || []).concat([_self]);
        }
        const fixed2 = this.fixedTarget;
        if (pre_target1.delta !== void 0 && sparkX && fixed2) {
            if (fixed2.type === Vt.Page) {
                const matrix = this.m_context.workspace.matrix;
                const guides_x = this.m_guides_x;
                const height = this.m_context.workspace.root.height;
                for (let i = 0; i < guides_x.length; i++) {
                    let offset = guides_x[i].offsetRoot;
                    if (offset !== _self.p.x) {
                        continue;
                    }
                    offset = matrix.computeCoord2(offset, 0).x;
                    hgx.push(`M${offset} 0 L${offset} ${height}`);
                }
            } else {
                const guides_x = this.m_guides_x;
                const height = fixed2.frame.height;
                const matrix = fixed2.matrix2Root();
                matrix.multiAtLeft(this.m_context.workspace.matrix);
                for (let i = 0; i < guides_x.length; i++) {
                    const g2 = guides_x[i];
                    let offset = g2.offsetRoot;
                    if (offset !== _self.p.x) {
                        continue;
                    }
                    offset = g2.offsetFix;
                    const start2 = matrix.computeCoord2(offset, 0);
                    const end2 = matrix.computeCoord2(offset, height);
                    hgx.push(`M${start2.x} ${start2.y} L${end2.x} ${end2.y}`);
                }
            }
        }
        if (pre_target2.delta !== void 0 && sparkY && fixed2) {
            if (fixed2.type === Vt.Page) {
                const matrix = this.m_context.workspace.matrix;
                const guides_y = this.m_guides_y;
                const width = this.m_context.workspace.root.width;
                for (let i = 0; i < guides_y.length; i++) {
                    let offset = guides_y[i].offsetRoot;
                    if (offset !== _self.p.y) {
                        continue;
                    }
                    offset = matrix.computeCoord2(0, offset).y;
                    hgy.push(`M0 ${offset} L${width} ${offset}`);
                }
            } else {
                const guides_y = this.m_guides_y;
                const width = fixed2.frame.width;
                const matrix = fixed2.matrix2Root();
                matrix.multiAtLeft(this.m_context.workspace.matrix);
                for (let i = 0; i < guides_y.length; i++) {
                    const g2 = guides_y[i];
                    let offset = g2.offsetRoot;
                    if (offset !== _self.p.y) {
                        continue;
                    }
                    offset = g2.offsetFix;
                    const start2 = matrix.computeCoord2(0, offset);
                    const end2 = matrix.computeCoord2(width, offset);
                    hgy.push(`M${start2.x} ${start2.y} L${end2.x} ${end2.y}`);
                }
            }
        }
        this.notify(_Assist.UPDATE_ASSIST);
        return target;
    }
    alignXY2(point) {
        this.m_nodes_x = [];
        this.m_nodes_y = [];
        const target = { x: 0, y: 0, sticked_by_x: false, sticked_by_y: false };
        const pre_target1 = { x: 0, sy: 0, delta: void 0 };
        const pre_target2 = { y: 0, sx: 0, delta: void 0 };
        for (let i = 0, len = this.m_shape_inner.length; i < len; i++) {
            const shape2 = this.m_shape_inner[i];
            if (this.m_except.get(shape2.id)) {
                continue;
            }
            const c_pg = this.m_pg_inner.get(shape2.id);
            if (!c_pg) {
                continue;
            }
            modify_pt_x4p(pre_target1, point, c_pg.apexX, this.m_stickness);
            modify_pt_y4p(pre_target2, point, c_pg.apexY, this.m_stickness);
        }
        const _self = { id: "self", p: { x: point.x, y: point.y } };
        if (pre_target1.delta !== void 0) {
            target.x = pre_target1.x;
            target.sticked_by_x = true;
            _self.p.x = target.x;
            this.m_nodes_x = (this.m_x_axis.get(target.x) || []).concat([_self]);
        }
        if (pre_target2.delta !== void 0) {
            target.y = pre_target2.y;
            target.sticked_by_y = true;
            _self.p.y = target.y;
            this.m_nodes_y = (this.m_y_axis.get(target.y) || []).concat([_self]);
        }
        return target;
    }
    alignPoints(livingXs, livingYs) {
        if (!this.m_except.size) {
            return;
        }
        this.multi_line_x = [];
        this.multi_line_y = [];
        const assistResult = {
            dx: 0,
            dy: 0,
            sticked_by_x: false,
            sticked_by_y: false,
            targetX: 0,
            targetY: 0,
            sparkX: false,
            sparkY: false
        };
        let targetX = Infinity;
        let targetY = Infinity;
        let dx = Infinity;
        let dy = Infinity;
        for (let i = 0; i < this.m_shape_inner.length; i++) {
            const shape2 = this.m_shape_inner[i];
            if (this.m_except.get(shape2.id)) {
                continue;
            }
            const pointsGroup = this.m_pg_inner.get(shape2.id);
            if (!pointsGroup) {
                continue;
            }
            const rx = alignXFromPointGroup(dx, pointsGroup.apexX, livingXs);
            dx = rx.dx;
            targetX = rx.targetX;
            const ry = alignYFromPointGroup(dy, pointsGroup.apexY, livingYs);
            dy = ry.dy;
            targetY = ry.targetY;
        }
        if (this.m_guides_x.length) {
            const gx = this.m_guides_x.map((g2) => g2.offsetRoot);
            const rx = alignXFromPointGroup(dx, gx, livingXs);
            dx = rx.dx;
            targetX = rx.targetX;
            assistResult.sparkX = rx.spark;
        }
        if (this.m_guides_y.length) {
            const gy = this.m_guides_y.map((g2) => g2.offsetRoot);
            const ry = alignYFromPointGroup(dy, gy, livingYs);
            dy = ry.dy;
            targetY = ry.targetY;
            assistResult.sparkY = ry.spark;
        }
        if (this.m_space_adsorb_x.length) {
            const rx = alignXFromSpacePoint(dx, this.m_space_adsorb_x, livingXs);
            dx = rx.dx;
            targetX = rx.targetX;
            assistResult.sparkX = rx.spark;
        }
        if (this.m_space_adsorb_y.length) {
            const ry = alignYFromSpacePoint(dy, this.m_space_adsorb_y, livingYs);
            dy = ry.dy;
            targetY = ry.targetY;
            assistResult.sparkY = ry.spark;
        }
        if (Math.abs(dx) < this.stickness) {
            assistResult.dx = dx;
            assistResult.sticked_by_x = true;
            assistResult.targetX = targetX;
        }
        if (Math.abs(dy) < this.stickness) {
            assistResult.dy = dy;
            assistResult.sticked_by_y = true;
            assistResult.targetY = targetY;
        }
        return assistResult;
    }
    reset() {
        this.m_nodes_x = [];
        this.m_nodes_y = [];
        this.m_nodes_x2 = [];
        this.m_nodes_y2 = [];
        this.multi_line_x = [];
        this.multi_line_y = [];
        this.m_except.clear();
        this.notify(_Assist.CLEAR);
    }
    // 水平相交的图形
    horIntersect(top, bottom, p_id) {
        var _a2;
        let result = [];
        const shapes = this.m_context.selection.selectedShapes.map((s) => s.id);
        const matrix = this.m_context.workspace.matrix;
        for (let i = 0; i < this.m_shape_inner.length; i++) {
            const inner_shape = this.m_shape_inner[i];
            const cur_p_id = ((_a2 = inner_shape.parent) == null ? void 0 : _a2.id) || "";
            if (shapes.includes(inner_shape.id) || cur_p_id !== p_id) continue;
            const points = [];
            const m2 = inner_shape.matrix2Root();
            m2.multiAtLeft(matrix);
            const f2 = inner_shape.frame;
            const ps2 = [{ x: 0, y: 0 }, { x: f2.width, y: 0 }, { x: f2.width, y: f2.height }, { x: 0, y: f2.height }].map((p2) => m2.computeCoord(p2.x, p2.y));
            points.push(...ps2);
            const b2 = XYsBounding(points);
            if (top <= b2.bottom && bottom >= b2.top) {
                result.push(inner_shape);
            }
        }
        return result;
    }
    // 垂直相交的图形
    verIntersect(left, right, p_id) {
        var _a2;
        let result = [];
        const shapes = this.m_context.selection.selectedShapes.map((s) => s.id);
        const matrix = this.m_context.workspace.matrix;
        for (let i = 0; i < this.m_shape_inner.length; i++) {
            const inner_shape = this.m_shape_inner[i];
            const cur_p_id = ((_a2 = inner_shape.parent) == null ? void 0 : _a2.id) || "";
            if (shapes.includes(inner_shape.id) || cur_p_id !== p_id) continue;
            const points = [];
            const m2 = inner_shape.matrix2Root();
            m2.multiAtLeft(matrix);
            const f2 = inner_shape.frame;
            const ps2 = [{ x: 0, y: 0 }, { x: f2.width, y: 0 }, { x: f2.width, y: f2.height }, { x: 0, y: f2.height }].map((p2) => m2.computeCoord(p2.x, p2.y));
            points.push(...ps2);
            const b2 = XYsBounding(points);
            if (left <= b2.right && right >= b2.left) {
                result.push(inner_shape);
            }
        }
        return result;
    }
};
__publicField(_Assist, "UPDATE_ASSIST", 1);
__publicField(_Assist, "CLEAR", 3);
__publicField(_Assist, "UPDATE_ASSIST_PATH", 4);
__publicField(_Assist, "MULTI_LINE_ASSIST", 7);
let Assist = _Assist;
class TeamWork extends U {
    // private userSelectionList: DocSelectionData[] = []
    constructor() {
        super();
    }
    // get getUserSelection() {
    //     return this.userSelectionList;
    // }
    // userSelectionUpdate(data: DocSelectionData, index: number) {
    //     if(index != -1) {
    //         this.userSelectionList[index] = data
    //     } else {
    //         this.userSelectionList.push(data)
    //     }
    //     this.notify(TeamWork.CHANGE_USER_STATE)
    // }
    // userSelectionExit(index: number) {
    //     if(index >= 0) {
    //         this.userSelectionList.splice(index, 1)
    //     }
    //     this.notify(TeamWork.CHANGE_USER_STATE)
    // }
}
__publicField(TeamWork, "CHANGE_USER_STATE", 1);
const xmlns = "http://www.w3.org/2000/svg";
const xlink = "http://www.w3.org/1999/xlink";
const htmlelement = {
    "div": 1,
    "canvas": 1
};
function createElement(tag) {
    if (htmlelement[tag]) return document.createElement(tag);
    return document.createElementNS(xmlns, tag);
}
function setAttribute(el2, key, value) {
    if (typeof value === "object") {
        const attr2 = value;
        let style = "";
        for (let b2 in attr2) {
            style += b2 + ":" + attr2[b2] + ";";
        }
        value = style;
    }
    if (typeof value === "number") value = String(value);
    if (key === "xlink:href" || key === "href") {
        el2.setAttributeNS(xlink, key, value);
    } else {
        el2.setAttribute(key, value);
    }
}
function batchSetAttribute(el2, attrs, oldattrs = {}) {
    const tkeys = Object.keys(attrs);
    const okeys = Object.keys(oldattrs);
    for (let i = 0; i < tkeys.length; i++) {
        const k = tkeys[i];
        const oval = oldattrs[k];
        const tval = attrs[k];
        if (oval !== tval) {
            setAttribute(el2, k, tval);
        }
    }
    for (let i = 0; i < okeys.length; i++) {
        const key = okeys[i];
        if (tkeys.indexOf(key) < 0) {
            el2.removeAttribute(key);
        }
    }
}
const _escapeChars = {};
_escapeChars["<"] = "&lt;";
_escapeChars[">"] = "&gt;";
_escapeChars["&"] = "&amp;";
function escapeWebChar(text) {
    const ret = [];
    let i = 0, j2 = 0, len = text.length;
    for (; i < len; ++i) {
        const e = _escapeChars[text[i]];
        if (e) {
            if (i > j2) ret.push(text.substring(j2, i));
            ret.push(e);
            j2 = i + 1;
        }
    }
    if (ret.length > 0) {
        if (i > j2) ret.push(text.substring(j2, i));
        return ret.join("");
    }
    return text;
}
function inner_elpatch(tar, old) {
    let _old = old;
    const _tar = tar;
    if (_tar === _old && _tar.el) return;
    if (_tar.eltag.length === 0) {
        _tar.el = void 0;
        return;
    }
    if (!_tar.el) {
        if (_old && _old.el && _old.eltag === _tar.eltag) {
            _tar.el = _old.el;
        } else {
            _tar.el = createElement(_tar.eltag);
            if (!_tar.el) throw new Error("can not create element: " + _tar.eltag);
            _old = void 0;
        }
    } else if (_tar.el.tagName !== _tar.eltag) {
        const el2 = createElement(_tar.eltag);
        if (!el2) throw new Error("can not create element: " + _tar.eltag);
        _tar.el = el2;
        _old = void 0;
    }
    batchSetAttribute(_tar.el, _tar.elattr, _old == null ? void 0 : _old.elattr);
    if (!Array.isArray(_tar.elchilds)) {
        if (!_old || _old.elchilds !== _tar.elchilds) {
            _tar.el.innerHTML = escapeWebChar(_tar.elchilds);
        }
        return;
    }
    const getResue = (tchild, _old2, i) => {
        if (!Array.isArray(_old2.elchilds)) return void 0;
        const oldchild = _old2.elchilds[i];
        if (!oldchild || oldchild.isViewNode) return void 0;
        return oldchild.eltag === tchild.eltag ? oldchild : void 0;
    };
    let idx = 0;
    for (let i = 0; i < _tar.elchilds.length; i++) {
        const tchild = _tar.elchilds[i];
        if (!tchild.isViewNode) {
            const ochild = _old && getResue(tchild, _old, i);
            inner_elpatch(tchild, ochild);
        }
        if (!tchild.el) {
            continue;
        }
        const childNodes2 = _tar.el.childNodes;
        if (childNodes2[idx] === tchild.el) ;
        else if (childNodes2[idx]) {
            _tar.el.insertBefore(tchild.el, childNodes2[idx]);
        } else {
            _tar.el.appendChild(tchild.el);
        }
        ++idx;
    }
    const childNodes = _tar.el.childNodes;
    if (childNodes.length > idx) {
        let count = childNodes.length - idx;
        while (count--) _tar.el.removeChild(childNodes[childNodes.length - 1]);
    }
}
function elpatch(tar, old) {
    var _a2, _b;
    inner_elpatch(tar, old);
    const _old = old;
    const _tar = tar;
    if (!((_a2 = _tar.el) == null ? void 0 : _a2.parentNode) && ((_b = _old == null ? void 0 : _old.el) == null ? void 0 : _b.parentNode)) {
        const newel = _tar.el;
        const oldel = _old == null ? void 0 : _old.el;
        const p2 = oldel == null ? void 0 : oldel.parentNode;
        if (newel === oldel) ;
        else if (newel) {
            p2.replaceChild(newel, oldel);
        } else {
            p2.removeChild(oldel);
        }
    }
}
const MAX_NODE_SUPPORT$1 = 50;
class ArtboradDom extends Hh {
    constructor() {
        super(...arguments);
        __publicField(this, "saveel");
        // 绘制优化，不可见的节点暂存不显示
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
        __publicField(this, "m_childs_changed", false);
        __publicField(this, "m_image_version", -1);
        __publicField(this, "imageel");
        __publicField(this, "m_save_image_props");
    }
    // 检查显示区域
    // 1. 太小时显示成image
    // 2.
    onChildChange(...args) {
        super.onChildChange(...args);
        this.m_childs_changed = true;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
    dropNode() {
        if (this.saveel) return;
        if (!this.eltag) return;
        this.saveel = createElement(this.eltag);
        const saveel = this.el;
        this.el = this.saveel;
        this.saveel = saveel;
        if (saveel && saveel.parentNode) {
            saveel.parentNode.replaceChild(this.el, saveel);
        }
    }
    appendNode() {
        if (!this.saveel) return;
        const saveel = this.el;
        this.el = this.saveel;
        this.saveel = void 0;
        if (saveel && saveel.parentNode && this.el) {
            saveel.parentNode.replaceChild(this.el, saveel);
        }
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            if (this.saveel) {
                const saveel = this.el;
                this.el = this.saveel;
                this.saveel = saveel;
                elpatch(this, this.m_save_render);
                this.saveel = this.el;
                this.el = saveel;
            } else {
                elpatch(this, this.m_save_render);
            }
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    switchIntoImage(force) {
        if (this.nodeCount < MAX_NODE_SUPPORT$1) {
            return false;
        }
        if (!this.el) {
            return false;
        }
        if (!(this.m_image_version !== this.m_save_version || this.m_childs_changed || force)) {
            return false;
        }
        const svgnode = this._svgnode;
        if (!svgnode || !svgnode.el || svgnode.eltag !== "svg") {
            return false;
        }
        if (!this.imageel) this.imageel = createElement("image");
        const imageel = this.imageel;
        if (this.m_image_version !== this.m_save_version || this.m_childs_changed) {
            const frame2 = this.frame;
            const svg = svgnode.el.outerHTML.replaceAll("#", "%23");
            const href = "data:image/svg+xml," + svg;
            setAttribute(imageel, "href", href);
            const props = {};
            props.x = 0;
            props.y = 0;
            props.width = frame2.width;
            props.height = frame2.height;
            props.filter = svgnode.elattr.filter;
            batchSetAttribute(imageel, props, this.m_save_image_props);
            this.m_save_image_props = props;
            this.m_image_version = this.m_save_version;
            this.m_childs_changed = false;
        }
        if (svgnode.el && svgnode.el.parentNode) {
            svgnode.el.parentNode.replaceChild(imageel, svgnode.el);
        }
        return true;
    }
    switchOutImage(force) {
        if (this.imageel && this.imageel.parentNode && (this.m_childs_changed || force)) {
            const svgnode = this._svgnode;
            if (!svgnode || !svgnode.el || svgnode.eltag !== "svg") {
                return;
            }
            if (svgnode.el) this.imageel.parentNode.replaceChild(svgnode.el, this.imageel);
            else this.imageel.parentNode.removeChild(this.imageel);
        }
    }
}
class GroupShapeDom extends Dh {
    constructor() {
        super(...arguments);
        __publicField(this, "saveel");
        // 绘制优化，不可见的节点暂存不显示
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    dropNode() {
        if (this.saveel) return;
        if (!this.eltag) return;
        this.saveel = createElement(this.eltag);
        const saveel = this.el;
        this.el = this.saveel;
        this.saveel = saveel;
        if (saveel && saveel.parentNode) {
            saveel.parentNode.replaceChild(this.el, saveel);
        }
    }
    appendNode() {
        if (!this.saveel) return;
        const saveel = this.el;
        this.el = this.saveel;
        this.saveel = void 0;
        if (saveel && saveel.parentNode && this.el) {
            saveel.parentNode.replaceChild(this.el, saveel);
        }
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            if (this.saveel) {
                const saveel = this.el;
                this.el = this.saveel;
                this.saveel = saveel;
                elpatch(this, this.m_save_render);
                this.saveel = this.el;
                this.el = saveel;
            } else {
                elpatch(this, this.m_save_render);
            }
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
const MAX_NODE_SUPPORT = 2e3;
function intersect_range(lx0, lx1, rx0, rx1) {
    return lx0 < rx1 && lx1 > rx0;
}
function intersect_rect(lhs, rhs) {
    return intersect_range(lhs.x, lhs.x + lhs.width, rhs.x, rhs.x + rhs.width) && intersect_range(lhs.y, lhs.y + lhs.height, rhs.y, rhs.y + rhs.height);
}
class PageDom extends Ac {
    constructor(ctx, props) {
        super(ctx, props);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
        // 在缩放、移动内容、可见窗口大小改变时，增加删除节点
        __publicField(this, "m_client_visible_rect");
        __publicField(this, "m_client_drop_rect");
        __publicField(this, "m_has_image", false);
        __publicField(this, "m_last_focusid");
        __publicField(this, "m_first_bind", false);
        this.onRenderIdle = this.onRenderIdle.bind(this);
        this.onBeforeRender = this.onBeforeRender.bind(this);
        ctx.setBeforeRenderCallback(this.onBeforeRender);
        ctx.setIdleCallback(this.onRenderIdle);
    }
    bind(node) {
        if (this.el) throw new Error("already binded");
        this.el = node;
        this.m_first_bind = true;
    }
    unbind() {
        this.m_save_version = -1;
        this.m_save_render.reset("");
        this.el = void 0;
    }
    // protected checkAndResetDirty(): boolean {
    //     if (super.checkAndResetDirty()) return true;
    //     return this.m_save_version < 0;
    // }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    // 可见区域+20%绘制
    // 可见区域+50%以外drop
    optimizeClientVisibleNodes(visibleRect) {
        const extend2 = Math.round(Math.max(100, Math.max(visibleRect.width, visibleRect.height) * 0.4));
        const dropextend = Math.round(Math.max(500, Math.max(visibleRect.width, visibleRect.height) * 1));
        if (!this.m_client_visible_rect || !this.m_client_drop_rect) {
            this.m_client_visible_rect = { x: 0, y: 0, width: 0, height: 0 };
            this.m_client_drop_rect = { x: 0, y: 0, width: 0, height: 0 };
        }
        this.m_client_visible_rect.x = visibleRect.x - extend2;
        this.m_client_visible_rect.y = visibleRect.y - extend2;
        this.m_client_visible_rect.width = visibleRect.width + extend2 * 2;
        this.m_client_visible_rect.height = visibleRect.height + extend2 * 2;
        this.m_client_drop_rect.x = visibleRect.x - dropextend;
        this.m_client_drop_rect.y = visibleRect.y - dropextend;
        this.m_client_drop_rect.width = visibleRect.width + dropextend * 2;
        this.m_client_drop_rect.height = visibleRect.height + dropextend * 2;
        for (let i = 0, len = this.m_children.length; i < len; i++) {
            const c2 = this.m_children[i];
            if (c2 instanceof ArtboradDom || c2 instanceof GroupShapeDom) {
                if (!intersect_rect(c2._p_visibleFrame, this.m_client_drop_rect)) c2.dropNode();
                else if (intersect_rect(c2._p_visibleFrame, this.m_client_visible_rect)) c2.appendNode();
            }
        }
    }
    onBeforeRender() {
        if (!this.m_has_image) {
            return;
        }
        if (this.nodeCount < MAX_NODE_SUPPORT / 2) {
            for (let i = 0, len = this.m_children.length; i < len; i++) {
                const c2 = this.m_children[i];
                if (c2 instanceof ArtboradDom) {
                    c2.switchOutImage(true);
                }
            }
            this.m_has_image = false;
        } else {
            const ctx = this.m_ctx;
            const focusid = ctx.getFocusLevel1Id();
            for (let i = 0, len = this.m_children.length; i < len; i++) {
                const c2 = this.m_children[i];
                if (c2 instanceof ArtboradDom && c2.id === focusid) {
                    c2.switchOutImage(false);
                }
            }
        }
    }
    onRenderIdle() {
        if (this.nodeCount < MAX_NODE_SUPPORT) {
            this.emit("renderidle");
            return false;
        }
        this.m_has_image = true;
        const ctx = this.m_ctx;
        const focusid = ctx.getFocusLevel1Id() ?? this.m_last_focusid;
        if (focusid) this.m_last_focusid = focusid;
        const frame_time = 40;
        const startTime = Date.now();
        const force = this.m_first_bind;
        this.m_first_bind = false;
        for (let i = 0, len = this.m_children.length; i < len; i++) {
            const c2 = this.m_children[i];
            if (c2 instanceof ArtboradDom && c2.id !== focusid && c2.switchIntoImage(force)) {
                const endTime = Date.now();
                if (endTime - startTime > frame_time) {
                    return true;
                }
            }
        }
        this.emit("renderidle");
        return false;
    }
}
class ContactLineDom extends qh {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class LineDom extends ec {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class PathShapeDom extends Kh {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class PathShapeDom2 extends ic {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class SymbolDom extends sc {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class SymbolRefDom extends nc {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
const IMAGE_DEFAULT = "data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ic3ZnIiB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHZpZXdCb3g9IjAgMCAxOCAxOCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cGF0aA0KICAgICAgICBkPSJNMTIuNSAxMGMxLjM4IDAgMi41LTEuMTIgMi41LTIuNUMxNSA2LjEyIDEzLjg4IDUgMTIuNSA1IDExLjEyIDUgMTAgNi4xMiAxMCA3LjVjMCAxLjM4IDEuMTIgMi41IDIuNSAyLjV6TTE0IDcuNWMwIC44MjgtLjY3MiAxLjUtMS41IDEuNS0uODI4IDAtMS41LS42NzItMS41LTEuNSAwLS44MjguNjcyLTEuNSAxLjUtMS41LjgyOCAwIDEuNS42NzIgMS41IDEuNXpNMTcgMUgxdjE2aDE2VjF6bS0xIDF2MTRoLTEuMjkzTDYgNy4yOTNsLTQgNFYyaDE0ek0yIDE2di0zLjI5M2w0LTRMMTMuMjkzIDE2SDJ6Ig0KICAgICAgICBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iMSIgZmlsbD0iZ3JleSIgc3Ryb2tlPSJub25lIj4NCiAgICA8L3BhdGg+DQo8L3N2Zz4=";
class TableCellDom extends Cc {
    constructor(ctx, props) {
        super(ctx, props, IMAGE_DEFAULT);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class TableDom extends Tc {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class TextShapeDom extends Ic {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class CutoutShapeDom extends kc {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class RectShapeDom extends Qh {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class BoolShapeDom extends fl {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class StarShapeDom extends ml {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
class PolygonShapeDom extends gl {
    constructor() {
        super(...arguments);
        __publicField(this, "el");
        // 不要改名，patch用到
        __publicField(this, "m_save_version", -1);
        __publicField(this, "m_save_render", za.make(""));
    }
    render() {
        const version2 = super.render();
        if (version2 !== this.m_save_version || !this.el) {
            elpatch(this, this.m_save_render);
            this.m_save_version = version2;
            this.m_save_render.reset(this.eltag, this.elattr, this.elchilds);
            this.m_save_render.el = this.el;
        }
        return version2;
    }
    checkAndResetDirty() {
        if (super.checkAndResetDirty()) return true;
        return !this.el;
    }
}
function initComsMap(comsMap) {
    comsMap.set(Vt.Artboard, ArtboradDom);
    comsMap.set(Vt.Group, GroupShapeDom);
    comsMap.set(Vt.Image, RectShapeDom);
    comsMap.set(Vt.BoolShape, BoolShapeDom);
    comsMap.set(Vt.Path, PathShapeDom);
    comsMap.set(Vt.Path2, PathShapeDom2);
    comsMap.set(Vt.Oval, PathShapeDom);
    comsMap.set(Vt.Text, TextShapeDom);
    comsMap.set(Vt.Symbol, SymbolDom);
    comsMap.set(Vt.SymbolUnion, SymbolDom);
    comsMap.set(Vt.SymbolRef, SymbolRefDom);
    comsMap.set(Vt.Line, LineDom);
    comsMap.set(Vt.Table, TableDom);
    comsMap.set(Vt.Contact, ContactLineDom);
    comsMap.set(Vt.TableCell, TableCellDom);
    comsMap.set(Vt.Cutout, CutoutShapeDom);
    comsMap.set(Vt.Rectangle, RectShapeDom);
    comsMap.set(Vt.Star, StarShapeDom);
    comsMap.set(Vt.Polygon, PolygonShapeDom);
}
class DomCtx extends Rc {
    constructor() {
        super(...arguments);
        __publicField(this, "idleCallback");
        __publicField(this, "beforeRender");
        __publicField(this, "level1Id");
    }
    getFocusShape() {
        return this.focusshape;
    }
    getFocusLevel1Id() {
        return this.level1Id;
    }
    updateFocusShape(shape2) {
        this.focusshape = shape2;
        this.level1Id = void 0;
        if (shape2) {
            let p2 = shape2.parent;
            while (p2) {
                this.level1Id = shape2.id;
                shape2 = p2;
                p2 = shape2.parent;
            }
        }
    }
    setBeforeRenderCallback(cb) {
        this.beforeRender = cb;
    }
    setIdleCallback(cb) {
        this.idleCallback = cb;
    }
    onIdle() {
        var _a2;
        const ret = super.onIdle();
        return ((_a2 = this.idleCallback) == null ? void 0 : _a2.call(this)) ?? ret;
    }
    aloop() {
        if (this.beforeRender) this.beforeRender();
        return super.aloop();
    }
}
const _PdMedia = class _PdMedia extends U {
    constructor(context) {
        super();
        __publicField(this, "m_last_time", 0);
        __publicField(this, "m_re_upload", /* @__PURE__ */ new Map());
        __publicField(this, "m_context");
        this.m_context = context;
    }
    show_tips() {
        const now = Date.now();
        if (now - this.m_last_time > 6e4) {
            this.notify(_PdMedia.SHOW_TIPS);
            this.m_last_time = now;
        }
    }
    re_upload(ref2, buff) {
        if ((this.m_re_upload.get(ref2) || 0) > 0) {
            return;
        }
        const ov = this.m_re_upload.get(ref2);
        this.m_re_upload.set(ref2, ov ? ov + 1 : 1);
        const timer = setTimeout(() => {
            var _a2;
            const __buff = new Uint8Array(buff);
            (_a2 = this.m_context.net) == null ? void 0 : _a2.upload(ref2, __buff.buffer);
            clearTimeout(timer);
        }, 6e4);
    }
};
// private m_stack:
__publicField(_PdMedia, "SHOW_TIPS");
let PdMedia = _PdMedia;
const _User = class _User extends U {
    constructor() {
        super();
        __publicField(this, "m_username", "");
        __publicField(this, "m_pixel_alignment", true);
        __publicField(this, "m_pixel_grid", true);
        __publicField(this, "m_rule", true);
    }
    get userName() {
        return this.m_username;
    }
    get isPixelAlignMent() {
        return this.m_pixel_alignment;
    }
    get isPixelGrid() {
        return this.m_pixel_grid;
    }
    get isRuleVisible() {
        return this.m_rule;
    }
    modifyPixelAlignment(v2) {
        const conf = JSON.parse(localStorage.getItem("userConfig") || this.initConfig);
        conf.pixelAlignment = v2;
        this.m_pixel_alignment = v2;
        localStorage.setItem("userConfig", JSON.stringify(conf));
    }
    modifyPixelGrid(v2) {
        const conf = JSON.parse(localStorage.getItem("userConfig") || this.initConfig);
        conf.pixelGrid = v2;
        this.m_pixel_grid = v2;
        this.notify(_User.GRID_STATUS_CHANGE);
        localStorage.setItem("userConfig", JSON.stringify(conf));
    }
    modifyRuleVisible(v2) {
        const conf = JSON.parse(localStorage.getItem("userConfig") || this.initConfig);
        conf.rule = v2;
        this.m_rule = v2;
        this.notify(_User.RULE_STATUS_CHANGE);
        localStorage.setItem("userConfig", JSON.stringify(conf));
    }
    get initConfig() {
        const conf = _User.CONF;
        return JSON.stringify(conf);
    }
    updateUserConfig() {
        let conf = JSON.parse(localStorage.getItem("userConfig"));
        if (!conf) {
            conf = _User.CONF;
        }
        if (Object.keys(conf).length !== Object.keys(_User.CONF).length) {
            const __temp = JSON.parse(JSON.stringify(conf));
            conf = _User.CONF;
            conf.pixelAlignment = __temp.pixelAlignment || true;
            conf.pixelGrid = __temp.pixelGrid || true;
            conf.rule = __temp.rule || true;
        }
        this.m_pixel_alignment = conf.pixelAlignment;
        this.m_pixel_grid = conf.pixelGrid;
        this.m_rule = conf.rule;
        localStorage.setItem("userConfig", JSON.stringify(conf));
    }
};
__publicField(_User, "GRID_STATUS_CHANGE", 1);
__publicField(_User, "RULE_STATUS_CHANGE", 2);
__publicField(_User, "CONF", {
    pixelAlignment: true,
    pixelGrid: true,
    rule: true
});
let User = _User;
const _Component = class _Component extends U {
    constructor(context) {
        super();
        __publicField(this, "m_context");
        __publicField(this, "m_bridge", false);
        __publicField(this, "m_wonder");
        __publicField(this, "m_into_view_after_mounted");
        this.m_context = context;
    }
    get bridge() {
        return this.m_bridge;
    }
    set_brige_status(status) {
        this.m_bridge = status;
        this.notify(_Component.BRIDGE_CHANGE);
    }
    get wonder() {
        return this.m_wonder;
    }
    register_wonder(shape2) {
        this.m_wonder = shape2;
        this.notify(_Component.WONDER_CHANGE);
    }
    logout_wonder() {
        this.m_wonder = void 0;
        this.notify(_Component.WONDER_CHANGE);
    }
    get into_view_target() {
        return this.m_into_view_after_mounted;
    }
    set_scroll_target(id) {
        this.m_into_view_after_mounted = id;
    }
    is_need_into_view(id) {
        if (!this.m_into_view_after_mounted) return false;
        return id === this.m_into_view_after_mounted;
    }
    compMenuMount(shape2, e) {
        this.notify(_Component.COMP_MENU, shape2, e);
    }
};
__publicField(_Component, "BRIDGE_CHANGE", 1);
__publicField(_Component, "WONDER_CHANGE", 2);
__publicField(_Component, "CARD_TYPE_CHANGE", 5);
__publicField(_Component, "COMP_MENU", 6);
__publicField(_Component, "SELECTED_VAL", 7);
let Component = _Component;
class TransformHandler {
    constructor(context, event) {
        __publicField(this, "context");
        __publicField(this, "workspace");
        __publicField(this, "page");
        __publicField(this, "shiftStatus", false);
        __publicField(this, "altStatus", false);
        __publicField(this, "alignPixel");
        __publicField(this, "asyncApiCaller");
        __publicField(this, "__keydown", this.keydown.bind(this));
        __publicField(this, "__keyup", this.keyup.bind(this));
        this.context = context;
        this.workspace = context.workspace;
        this.page = context.selection.selectedPage;
        if (event) {
            this.shiftStatus = event.shiftKey;
            this.altStatus = event.altKey;
        }
        this.alignPixel = context.user.isPixelAlignMent;
        this.beforeTransform();
        document.addEventListener("keydown", this.__keydown);
        document.addEventListener("keyup", this.__keyup);
    }
    beforeTransform() {
        this.context.menu.menuMount();
        this.context.cursor.cursor_freeze(true);
        this.workspace.setCtrl("controller");
    }
    keydown(event) {
    }
    keyup(event) {
    }
    fulfil() {
        var _a2;
        const context = this.context;
        (_a2 = this.asyncApiCaller) == null ? void 0 : _a2.commit();
        context.assist.reset();
        this.workspace.setCtrl("page");
        context.cursor.cursor_freeze(false);
        document.removeEventListener("keydown", this.__keydown);
        document.removeEventListener("keyup", this.__keyup);
    }
    updateCtrlView(rule) {
        this.context.nextTick(this.context.selection.selectedPage, () => {
            this.workspace.notify(WorkSpace.SELECTION_VIEW_UPDATE);
            if (rule) {
                this.context.tool.notify(Tool.RULE_RENDER);
            }
        });
    }
}
function point2line(point, start2, end2) {
    const px = point.x;
    const py = point.y;
    const x1 = start2.x;
    const y1 = start2.y;
    const x2 = end2.x;
    const y2 = end2.y;
    const lengthSquared = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (!lengthSquared) {
        return {
            point: { x: x1, y: y1 },
            distance: Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1))
        };
    }
    let t4 = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lengthSquared;
    if (t4 >= 1 || t4 <= 0) {
        return;
    }
    const x3 = x1 + t4 * (x2 - x1);
    const y3 = y1 + t4 * (y2 - y1);
    const distance = Math.sqrt((px - x3) * (px - x3) + (py - y3) * (py - y3));
    return { point: { x: x3, y: y3 }, distance };
}
function cubicBezier(t4, start2, c1, c2, end2) {
    const x2 = Math.pow(1 - t4, 3) * start2.x + 3 * Math.pow(1 - t4, 2) * t4 * c1.x + 3 * (1 - t4) * Math.pow(t4, 2) * c2.x + Math.pow(t4, 3) * end2.x;
    const y2 = Math.pow(1 - t4, 3) * start2.y + 3 * Math.pow(1 - t4, 2) * t4 * c1.y + 3 * (1 - t4) * Math.pow(t4, 2) * c2.y + Math.pow(t4, 3) * end2.y;
    return { x: x2, y: y2 };
}
function cubicBezierDerivative(t4, start2, c1, c2, end2) {
    const x2 = 3 * Math.pow(1 - t4, 2) * (c1.x - start2.x) + 6 * (1 - t4) * t4 * (c2.x - c1.x) + 3 * Math.pow(t4, 2) * (end2.x - c2.x);
    const y2 = 3 * Math.pow(1 - t4, 2) * (c1.y - start2.y) + 6 * (1 - t4) * t4 * (c2.y - c1.y) + 3 * Math.pow(t4, 2) * (end2.y - c2.y);
    return { x: x2, y: y2 };
}
function point2curve3rd(point, start2, c1, c2, end2) {
    const epsilon = 1e-6;
    let t4 = 0.5;
    let i = 0;
    while (i < 50) {
        const _xy = cubicBezier(t4, start2, c1, c2, end2);
        const _der = cubicBezierDerivative(t4, start2, c1, c2, end2);
        const dxToPoint = _xy.x - point.x;
        const dyToPoint = _xy.y - point.y;
        const derivativeDotProduct = dxToPoint * _der.x + dyToPoint * _der.y;
        if (Math.abs(derivativeDotProduct) < epsilon) {
            break;
        }
        t4 -= derivativeDotProduct / (_der.x * _der.x + _der.y * _der.y);
        i++;
    }
    if (t4 < 0 || t4 > 1) {
        return;
    }
    const xy = cubicBezier(t4, start2, c1, c2, end2);
    const distance = Math.sqrt((point.x - xy.x) ** 2 + (point.y - xy.y) ** 2);
    return { distance, point: xy };
}
const _PathEditor = class _PathEditor extends TransformHandler {
    constructor(context, event, needBuildMap = "", flattenPoint = false) {
        super(context, event);
        // 建立完整的图层地图
        __publicField(this, "shape");
        __publicField(this, "path");
        __publicField(this, "fixedPoint", { x: 0, y: 0 });
        __publicField(this, "livingPoint", { x: 0, y: 0 });
        __publicField(this, "baseData", /* @__PURE__ */ new Map());
        __publicField(this, "baseMatrix", new o());
        __publicField(this, "baseMatrixInverse", new o());
        __publicField(this, "handleInfo");
        __publicField(this, "isInitMatrix", false);
        __publicField(this, "actionType", "handle");
        __publicField(this, "mapX", /* @__PURE__ */ new Map());
        __publicField(this, "mapY", /* @__PURE__ */ new Map());
        __publicField(this, "uniquePosition", /* @__PURE__ */ new Set());
        __publicField(this, "selected");
        __publicField(this, "fullPosition", /* @__PURE__ */ new Set());
        __publicField(this, "fixedSegments", /* @__PURE__ */ new Set());
        __publicField(this, "initFixedSegments", false);
        // handle折断之前的CurveMode；
        __publicField(this, "curveModeBefore");
        this.path = context.path;
        if (event) {
            this.fixedPoint = this.workspace.getRootXY(event);
            this.livingPoint = { ...this.fixedPoint };
        }
        this.shape = this.context.selection.selectedShapes[0];
        this.workspace.setSelectionViewUpdater(false);
        if (needBuildMap) {
            this.buildMap(needBuildMap);
        }
        if (flattenPoint) {
            this.getUniquePosition();
        }
    }
    buildMap(buildType) {
        this.init();
        const shape2 = this.shape;
        if (!shape2) {
            return;
        }
        const clientMatrix = new o(this.baseMatrix);
        clientMatrix.multiAtLeft(this.context.workspace.matrix);
        const activeTarget = /* @__PURE__ */ new Set();
        if (buildType === _PathEditor.BORDER_MAP) {
            this.path.syntheticPoints.forEach((points, segmentIndex) => {
                if (!points.length) return;
                points.forEach((index2) => {
                    var _a2;
                    const point = (_a2 = shape2 == null ? void 0 : shape2.segments[segmentIndex]) == null ? void 0 : _a2.points[index2];
                    if (!point) return;
                    activeTarget.add(point.id);
                });
            });
        }
        const segments = shape2.segments;
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            if (!segment) continue;
            const points = segment.points;
            for (let j2 = 0; j2 < points.length; j2++) {
                const point = points[j2];
                if (!point) continue;
                if (buildType === _PathEditor.BORDER_MAP && activeTarget.has(point.id)) continue;
                const xy = clientMatrix.computeCoord3(point);
                const xKey = Number(xy.x.toFixed(2));
                let xContainer = this.mapX.get(xKey);
                if (!xContainer) {
                    xContainer = [xy];
                    this.mapX.set(xKey, xContainer);
                } else {
                    xContainer.push(xy);
                }
                const yKey = Number(xy.y.toFixed(2));
                let yContainer = this.mapY.get(yKey);
                if (!yContainer) {
                    yContainer = [xy];
                    this.mapY.set(yKey, yContainer);
                } else {
                    yContainer.push(xy);
                }
            }
        }
    }
    init() {
        this.shape = this.context.selection.selectedShapes[0];
        if (!this.shape || !(this.shape instanceof Kh)) {
            return;
        }
        const m2 = this.shape.matrix2Root();
        const frame2 = this.shape.frame;
        m2.preScale(frame2.width, frame2.height);
        this.baseMatrix = m2;
        this.baseMatrixInverse = new o(m2.inverse);
        this.getBaseData();
        this.isInitMatrix = true;
    }
    getBaseData() {
        this.baseData.clear();
        const selected = this.path.syntheticPoints;
        if (this.shape.pathType === Ve.Editable) {
            let wrongSelection = false;
            selected.forEach((indexes, segment) => {
                var _a2, _b;
                const points = (_b = (_a2 = this.shape) == null ? void 0 : _a2.segments[segment]) == null ? void 0 : _b.points;
                if (!(points == null ? void 0 : points.length)) {
                    wrongSelection = true;
                    return;
                }
                this.__getData(points, indexes);
            });
            if (wrongSelection || !this.baseData.size) {
                this.path.reset();
            }
        }
    }
    __getData(points, indexes) {
        if (!indexes) {
            return;
        }
        for (let i = 0; i < indexes.length; i++) {
            const index2 = indexes[i];
            const point = points[index2];
            if (!point) {
                continue;
            }
            this.baseData.set(point.id, {
                x: point.x,
                y: point.y,
                fromX: point.fromX,
                fromY: point.fromY,
                toX: point.toX,
                toY: point.toY
            });
        }
    }
    getUniquePosition() {
        const selected = this.selected || this.path.syntheticPoints;
        if (!this.selected) {
            this.selected = selected;
        }
        const shape2 = this.shape;
        const __xy_string = /* @__PURE__ */ new Set();
        selected.forEach((indexes, segmentIndex) => {
            var _a2;
            const points = (_a2 = shape2.segments[segmentIndex]) == null ? void 0 : _a2.points;
            if (!points) return;
            for (let i = 0; i < indexes.length; i++) {
                const point = points[indexes[i]];
                if (!point) continue;
                this.fullPosition.add(point.id);
                const __xyStr = `${point.x}?${point.y}`;
                if (!__xy_string.has(__xyStr)) {
                    this.uniquePosition.add(point.id);
                    __xy_string.add(__xyStr);
                }
            }
        });
    }
    modifyDelta(dx, dy) {
        const points = [];
        const baseData = this.baseData;
        const clientMatrix = new o(this.baseMatrix);
        clientMatrix.multiAtLeft(this.context.workspace.matrix);
        this.uniquePosition.forEach((id) => {
            const base = baseData.get(id);
            if (!base) return;
            points.push(clientMatrix.computeCoord2(base.x + dx, base.y + dy));
        });
        const modified = this.modifyByPoints(points);
        if (modified) {
            let fulfil = false;
            const __xy = clientMatrix.inverseCoord(points[0]);
            this.uniquePosition.forEach((id) => {
                if (fulfil) return;
                const base = baseData.get(id);
                if (!base) return;
                fulfil = true;
                dx = __xy.x - base.x;
                dy = __xy.y - base.y;
            });
            return { dx, dy };
        }
        const modified2 = this.modifyBySegment(points);
        if (modified2) {
            let fulfil = false;
            const __xy = clientMatrix.inverseCoord(points[0]);
            this.uniquePosition.forEach((id) => {
                if (fulfil) return;
                const base = baseData.get(id);
                if (!base) return;
                fulfil = true;
                dx = __xy.x - base.x;
                dy = __xy.y - base.y;
            });
        }
        return { dx, dy };
    }
    modifyByPoints(activePoints) {
        let delX = Infinity;
        let delY = Infinity;
        let DX = 0;
        let DY = 0;
        let TX = 0;
        let TY = 0;
        const xs2 = Array.from(this.mapX.keys());
        const ys2 = Array.from(this.mapY.keys());
        const aLen = activePoints.length;
        for (let i = 0; i < aLen; i++) {
            const { x: x2, y: y2 } = activePoints[i];
            for (let j2 = 0; j2 < xs2.length; j2++) {
                const dx = xs2[j2] - x2;
                const __dx = Math.abs(dx);
                if (__dx < delX) {
                    delX = __dx;
                    DX = dx;
                    TX = xs2[j2];
                }
            }
            for (let k = 0; k < ys2.length; k++) {
                const dy = ys2[k] - y2;
                const __dy = Math.abs(dy);
                if (__dy < delY) {
                    delY = __dy;
                    DY = dy;
                    TY = ys2[k];
                }
            }
        }
        let modified = false;
        const assist = this.context.assist;
        if (delX < _PathEditor.DELTA) {
            const ap = [];
            for (let i = 0; i < aLen; i++) {
                const __ap = activePoints[i];
                __ap.x += DX;
                if (Number(__ap.x.toFixed(2)) === TX) {
                    ap.push(__ap);
                }
            }
            assist.setNodesX2([...this.mapX.get(TX) || [], ...ap]);
            modified = true;
        } else {
            assist.setNodesX2([]);
        }
        if (delY < _PathEditor.DELTA) {
            const ap = [];
            for (let i = 0; i < aLen; i++) {
                const __ap = activePoints[i];
                __ap.y += DY;
                if (Number(__ap.y.toFixed(2)) === TY) {
                    ap.push(__ap);
                }
            }
            assist.setNodesY2([...this.mapY.get(TY) || [], ...ap]);
            modified = true;
        } else {
            assist.setNodesY2([]);
        }
        if (modified) {
            assist.notify(Assist.UPDATE_ASSIST_PATH);
        } else {
            assist.notify(Assist.CLEAR);
        }
        return modified;
    }
    __initFS() {
        var _a2;
        const segments = (_a2 = this.shape) == null ? void 0 : _a2.segments;
        if (!segments) {
            return;
        }
        const full = this.fullPosition;
        const fixed2 = this.fixedSegments;
        const clientMatrix = new o(this.baseMatrix);
        clientMatrix.multiAtLeft(this.context.workspace.matrix);
        for (let segmentIndex = 0; segmentIndex < segments.length; segmentIndex++) {
            const segment = segments[segmentIndex];
            const points = segment == null ? void 0 : segment.points;
            const len = points == null ? void 0 : points.length;
            if (!len) continue;
            for (let i = 0; i < len; i++) {
                const point = points[i];
                let nextPoint;
                if (i === len - 1) {
                    if (!segment.isClosed) break;
                    nextPoint = points[0];
                } else {
                    nextPoint = points[i + 1];
                }
                if (!nextPoint || !point) continue;
                if (full.has(point.id) || full.has(nextPoint.id)) continue;
                if (point.hasFrom || nextPoint.hasTo) {
                    const seg = {
                        start: { x: point.x, y: point.y },
                        c1: { x: point.fromX || point.x || 0, y: point.fromY || point.y || 0 },
                        c2: { x: nextPoint.toX || nextPoint.x || 0, y: nextPoint.toY || nextPoint.y || 0 },
                        end: { x: nextPoint.x, y: nextPoint.y }
                    };
                    seg.start = clientMatrix.computeCoord3(seg.start);
                    seg.c1 = clientMatrix.computeCoord3(seg.c1);
                    seg.c2 = clientMatrix.computeCoord3(seg.c2);
                    seg.end = clientMatrix.computeCoord3(seg.end);
                    fixed2.add({ type: "3rd", seg });
                } else {
                    const seg = {
                        start: { x: point.x, y: point.y },
                        end: { x: nextPoint.x, y: nextPoint.y }
                    };
                    seg.start = clientMatrix.computeCoord3(seg.start);
                    seg.end = clientMatrix.computeCoord3(seg.end);
                    fixed2.add({ type: "line", seg });
                }
            }
        }
        this.initFixedSegments = true;
    }
    modifyBySegment(activePoints) {
        if (!this.initFixedSegments) {
            this.__initFS();
        }
        if (!this.initFixedSegments) {
            return;
        }
        let distance = Infinity;
        let dx = 0;
        let dy = 0;
        for (let i = 0; i < activePoints.length; i++) {
            const point = activePoints[i];
            this.fixedSegments.forEach((segment) => {
                let d2;
                if (segment.type === "line") {
                    const seg = segment.seg;
                    d2 = point2line(point, seg.start, seg.end);
                } else {
                    const seg = segment.seg;
                    d2 = point2curve3rd(point, seg.start, seg.c1, seg.c2, seg.end);
                }
                if (d2 === void 0) return;
                const D2 = Math.abs(d2.distance);
                if (D2 < distance) {
                    const targetPoint = d2.point;
                    dx = targetPoint.x - point.x;
                    dy = targetPoint.y - point.y;
                    distance = D2;
                }
            });
        }
        let modified = false;
        if (distance < _PathEditor.DELTA) {
            activePoints[0].x += dx;
            activePoints[0].y += dy;
            modified = true;
        }
        return modified;
    }
    __execute() {
        const __fixed = this.baseMatrixInverse.computeCoord3(this.fixedPoint);
        const __living = this.baseMatrixInverse.computeCoord3(this.livingPoint);
        let dx = __living.x - __fixed.x;
        let dy = __living.y - __fixed.y;
        if (this.shiftStatus) {
            if (Math.abs(dx) > Math.abs(dy)) {
                dy = 0;
            } else {
                dx = 0;
            }
        }
        const modified = this.modifyDelta(dx, dy);
        dx = modified.dx;
        dy = modified.dy;
        const selected = this.selected || this.path.syntheticPoints;
        if (!this.selected) {
            this.selected = selected;
        }
        const units = /* @__PURE__ */ new Map();
        if (this.shape.pathType === Ve.Editable) {
            selected.forEach((indexes, segment) => {
                const points = this.shape.segments[segment].points;
                this.__gen(units, points, segment, indexes, dx, dy);
            });
        }
        this.asyncApiCaller.execute(this.shape, units);
        this.updateCtrlView(0);
    }
    __gen(actions, points, segment, indexes, dx, dy) {
        const __units = [];
        for (let i = 0; i < indexes.length; i++) {
            const index2 = indexes[i];
            const point = points[index2];
            if (!point) continue;
            const base = this.baseData.get(point.id);
            if (!base) {
                continue;
            }
            __units.push({
                index: index2,
                x: base.x + dx,
                y: base.y + dy,
                fromX: (base.fromX || 0) + dx,
                fromY: (base.fromY || 0) + dy,
                toX: (base.toX || 0) + dx,
                toY: (base.toY || 0) + dy
            });
        }
        actions.set(segment, __units);
    }
    passiveExecute() {
        if (!this.asyncApiCaller) {
            return;
        }
        if (this.actionType === "point") {
            this.__execute();
        } else {
            if (this.altStatus) {
                this.breakOff();
            } else {
                this.recovery();
            }
        }
    }
    // 拖动之后通过键盘事件控制折断状态
    breakOff() {
        var _a2, _b;
        if (!this.isInitMatrix) {
            this.init();
        }
        if (!this.handleInfo) {
            return;
        }
        const { index: index2, segment } = this.handleInfo;
        const point = (_b = (_a2 = this.shape) == null ? void 0 : _a2.segments[segment]) == null ? void 0 : _b.points[index2];
        if (!point) {
            return;
        }
        if (point.mode === ft.Disconnected) {
            return;
        }
        this.curveModeBefore = point.mode;
        this.asyncApiCaller.breakOffHandle(this.shape, segment, index2);
        this.updateCtrlView(0);
    }
    recovery() {
        var _a2, _b;
        if (!this.curveModeBefore) {
            return;
        }
        if (!this.handleInfo) {
            return;
        }
        if (!this.isInitMatrix) {
            this.init();
        }
        const { index: index2, segment, side } = this.handleInfo;
        const point = (_b = (_a2 = this.shape) == null ? void 0 : _a2.segments[segment]) == null ? void 0 : _b.points[index2];
        if (!point) {
            return;
        }
        if (point.mode !== ft.Disconnected) {
            return;
        }
        this.asyncApiCaller.recoveryHandle(this.shape, segment, index2, this.curveModeBefore, side);
        this.curveModeBefore = void 0;
        this.updateCtrlView(0);
    }
    keydown(event) {
        if (event.repeat) {
            return;
        }
        if (event.altKey) {
            this.altStatus = true;
            this.passiveExecute();
        }
        if (event.shiftKey) {
            this.shiftStatus = true;
            this.passiveExecute();
        }
    }
    keyup(event) {
        if (event.code === "AltLeft") {
            this.altStatus = false;
            this.passiveExecute();
        }
        if (event.code === "ShiftLeft") {
            this.shiftStatus = false;
            this.passiveExecute();
        }
    }
    createApiCaller(segment = -1, index2 = -1, needStore = false) {
        this.asyncApiCaller = new $g(this.context.coopRepo, this.context.data, this.page, needStore);
        let addRes = false;
        if (index2 > -1 && segment > -1) {
            addRes = this.asyncApiCaller.addPoint(this.shape, segment, index2);
            if (addRes) {
                this.path.select_point(segment, index2);
                this.buildMap(_PathEditor.BORDER_MAP);
                this.getUniquePosition();
            }
        }
        this.path.editing(true);
        return addRes;
    }
    addPointForPen(segment, index2, down, point) {
        if (!this.asyncApiCaller || !this.shape) {
            return false;
        }
        if (!this.isInitMatrix) {
            this.init();
        }
        let xy;
        if (point) {
            xy = { x: point.x, y: point.y };
        } else {
            const m2 = new o(this.baseMatrix);
            m2.multiAtLeft(this.context.workspace.matrix);
            const inverse = new o(m2.inverse);
            xy = inverse.computeCoord3(down);
        }
        let addRes = false;
        if (index2 > -1 && segment > -1) {
            const __segment = this.shape.segments[segment];
            if (!__segment) {
                return this.addSegmentForPen(down);
            }
            index2 = __segment.points.length;
            addRes = this.asyncApiCaller.addPointForPen(this.shape, segment, index2, xy);
            if (addRes) {
                this.path.select_point(segment, index2);
                const point2 = this.shape.segments[segment].points[index2];
                this.context.path.setLastPoint({ point: point2, index: index2, segment });
                this.path.editing(true);
                this.updateCtrlView(0);
            }
        }
        return addRes;
    }
    addSegmentForPen(down, point) {
        if (!this.asyncApiCaller || !this.shape) {
            return false;
        }
        if (!this.isInitMatrix) {
            this.init();
        }
        let xy;
        if (point) {
            xy = point;
        } else {
            const m2 = new o(this.baseMatrix);
            m2.multiAtLeft(this.context.workspace.matrix);
            const inverse = new o(m2.inverse);
            xy = inverse.computeCoord3(down);
        }
        let addRes = false;
        addRes = this.asyncApiCaller.addSegmentForPen(this.shape, xy);
        if (addRes) {
            const segment = this.shape.segments.length - 1;
            const point2 = this.shape.segments[segment].points[0];
            this.path.select_point(segment, 0);
            this.context.path.setLastPoint({ point: point2, index: 0, segment });
        }
        this.path.editing(true);
        return addRes;
    }
    createVec() {
        var _a2;
        const env = this.context.selection.getClosestContainer(this.livingPoint);
        const frame2 = new _e(0, 0, 1, 1);
        const m2 = new o(env.matrix2Root().inverse);
        const __xy = m2.computeCoord3(this.livingPoint);
        frame2.x = __xy.x;
        frame2.y = __xy.y;
        let count = 1;
        this.context.selection.selectedPage.shapes.forEach((s) => {
            if (s.type === Vt.Path) count++;
        });
        const name = `${this.context.workspace.t("shape.path")} ${count}`;
        const previousPathStyle = ((_a2 = this.path.previousPathStyle) == null ? void 0 : _a2.borders.length) ? this.path.previousPathStyle : void 0;
        const _vec = this.asyncApiCaller.createVec(name, frame2, env, previousPathStyle);
        if (_vec) {
            this.path.setPreviousPathId(_vec.id);
        }
        this.updateCtrlView(0);
        return _vec;
    }
    execute(event) {
        if (!this.isInitMatrix) {
            this.init();
        }
        this.livingPoint = this.workspace.getRootXY(event);
        this.__execute();
        this.actionType = "point";
    }
    execute4handlePre(index2, segmentIndex) {
        if (!this.isInitMatrix) {
            this.init();
        }
        this.buildMap(_PathEditor.FULL_MAP);
        const order = this.altStatus ? 2 : 3;
        this.asyncApiCaller.preCurve(order, this.shape, index2, segmentIndex);
        this.actionType = "handle";
    }
    execute4handlePreForPen(index2, segment = -1) {
        if (!this.isInitMatrix) {
            this.init();
        }
        this.buildMap(_PathEditor.FULL_MAP);
        if (!this.handleInfo) {
            this.handleInfo = { index: index2, segment, side: "from" };
        }
        const lowOrder = this.altStatus;
        this.asyncApiCaller.preCurve2(lowOrder ? 2 : 3, this.shape, index2, segment);
        this.actionType = "penHandle";
    }
    execute4handle(index2, side, from, to2, segment = -1) {
        var _a2, _b;
        if (!this.isInitMatrix) {
            this.init();
        }
        if (!this.handleInfo) {
            this.handleInfo = { index: index2, segment, side };
        }
        const point = (_b = (_a2 = this.shape) == null ? void 0 : _a2.segments[segment]) == null ? void 0 : _b.points[index2];
        if (!point) {
            return;
        }
        const caller = this.asyncApiCaller;
        if (this.altStatus && point.mode !== ft.Disconnected) {
            this.curveModeBefore = point.mode;
            caller.breakOffHandle(this.shape, segment, index2);
        }
        const m2 = new o(this.baseMatrix);
        m2.multiAtLeft(this.context.workspace.matrix);
        const xs2 = Array.from(this.mapX.keys());
        const ys2 = Array.from(this.mapY.keys());
        const isFrom = side === "from";
        const activePoint = isFrom ? m2.computeCoord3(from) : m2.computeCoord3(to2);
        let deltaX = Infinity;
        let dx = 0;
        let TX = 0;
        let deltaY = Infinity;
        let dy = 0;
        let TY = 0;
        for (let i = 0; i < xs2.length; i++) {
            const __x = xs2[i];
            const __d = __x - activePoint.x;
            const D2 = Math.abs(__d);
            if (D2 < deltaX) {
                deltaX = D2;
                dx = __d;
                TX = __x;
            }
        }
        for (let i = 0; i < ys2.length; i++) {
            const __y = ys2[i];
            const __d = __y - activePoint.y;
            const D2 = Math.abs(__d);
            if (D2 < deltaY) {
                deltaY = D2;
                dy = __d;
                TY = __y;
            }
        }
        const assist = this.context.assist;
        let modified = false;
        if (deltaX < _PathEditor.DELTA) {
            activePoint.x += dx;
            const xNodes = [...this.mapX.get(TX) || []];
            xNodes.push(activePoint);
            modified = true;
            assist.setNodesX2(xNodes);
        } else {
            assist.setNodesX2([]);
        }
        if (deltaY < _PathEditor.DELTA) {
            activePoint.y += dy;
            const yNodes = [...this.mapY.get(TY) || []];
            yNodes.push(activePoint);
            modified = true;
            assist.setNodesY2(yNodes);
        } else {
            assist.setNodesY2([]);
        }
        if (modified) {
            const mInverse = new o(m2.inverse);
            const mode = point.mode;
            if (isFrom) {
                from = mInverse.computeCoord3(activePoint);
                if (mode === ft.Asymmetric) {
                    to2.x = point.toX || 0;
                    to2.y = point.toY || 0;
                    const l2 = Math.hypot(to2.x - point.x, to2.y - point.y);
                    const __angle = Math.atan2(from.x - point.x, from.y - point.y);
                    const _l_x = Math.abs(Math.sin(__angle) * l2);
                    const _l_y = Math.abs(Math.cos(__angle) * l2);
                    const _delta_x = from.x - point.x;
                    const _delta_y = from.y - point.y;
                    to2.x = point.x - _delta_x / Math.abs(_delta_x) * _l_x;
                    to2.y = point.y - _delta_y / Math.abs(_delta_y) * _l_y;
                } else if (mode === ft.Mirrored) {
                    to2.x = 2 * point.x - from.x;
                    to2.y = 2 * point.y - from.y;
                }
            } else {
                to2 = mInverse.computeCoord3(activePoint);
                if (mode === ft.Asymmetric) {
                    from.x = point.fromX || 0;
                    from.y = point.fromY || 0;
                    const l2 = Math.hypot(from.x - point.x, from.y - point.y);
                    const __angle = Math.atan2(to2.x - point.x, to2.y - point.y);
                    const _l_x = Math.abs(Math.sin(__angle) * l2);
                    const _l_y = Math.abs(Math.cos(__angle) * l2);
                    const _delta_x = to2.x - point.x;
                    const _delta_y = to2.y - point.y;
                    from.x = point.x - _delta_x / Math.abs(_delta_x) * _l_x;
                    from.y = point.y - _delta_y / Math.abs(_delta_y) * _l_y;
                } else if (mode === ft.Mirrored) {
                    from.x = 2 * point.x - to2.x;
                    from.y = 2 * point.y - to2.y;
                }
            }
            assist.notify(Assist.UPDATE_ASSIST_PATH);
        } else {
            assist.notify(Assist.CLEAR);
        }
        caller.execute4handle(this.shape, index2, side, from, to2, segment);
        this.updateCtrlView(0);
    }
    closeSegmentAt(segmentIndex) {
        if (!this.isInitMatrix) {
            this.init();
        }
        const segment = this.shape.segments[segmentIndex];
        if (!segment) {
            return false;
        }
        if (!this.asyncApiCaller) {
            this.createApiCaller();
        }
        const caller = this.asyncApiCaller;
        const res = caller.closeSegmentAt(this.shape, segmentIndex);
        if (res) {
            this.path.select_point(segmentIndex, 0);
            this.path.setContactStatus(false);
        }
        return res;
    }
    cancelContactStatus() {
        this.path.setContactStatus(false);
    }
    mergeSegment(segmentIndex, toSegmentIndex, at2) {
        if (!this.isInitMatrix) {
            this.init();
        }
        const segment = this.shape.segments[segmentIndex];
        if (!segment) {
            return false;
        }
        if (!this.asyncApiCaller) {
            this.createApiCaller();
        }
        const caller = this.asyncApiCaller;
        const res = caller.mergeSegment(this.shape, segmentIndex, toSegmentIndex, at2);
        if (res) {
            this.path.select_point(res.segment, res.activeIndex);
            this.path.setContactStatus(false);
        }
    }
    reverseSegment(segmentIndex) {
        if (!this.isInitMatrix) {
            this.init();
        }
        const segment = this.shape.segments[segmentIndex];
        if (!segment) {
            return false;
        }
        if (!this.asyncApiCaller) {
            this.createApiCaller();
        }
        const caller = this.asyncApiCaller;
        const res = caller.reversePointsAt(this.shape, segmentIndex);
        if (res) {
            this.path.select_point(res.segment, res.activeIndex);
            this.path.setContactStatus(true);
            return res;
        }
        return false;
    }
    fulfil() {
        this.workspace.setSelectionViewUpdater(true);
        this.path.editing(false);
        super.fulfil();
    }
    // 以下是自闭合函数，函数内执行fulfil
    clip(segmentIndex, index2) {
        try {
            if (!this.isInitMatrix) {
                this.init();
            }
            if (!this.asyncApiCaller) {
                this.createApiCaller();
            }
            if (!this.asyncApiCaller || !this.isInitMatrix) {
                return;
            }
            this.asyncApiCaller.clip(this.shape, segmentIndex, index2);
        } finally {
            this.fulfil();
        }
    }
    sortSegment() {
        try {
            if (this.context.coopRepo.isInTransact()) {
                return;
            }
            if (!this.isInitMatrix) {
                this.init();
            }
            if (!this.asyncApiCaller) {
                this.createApiCaller();
            }
            if (!this.asyncApiCaller || !this.isInitMatrix) {
                return;
            }
            this.asyncApiCaller.sortSegment(this.shape);
        } finally {
            this.fulfil();
        }
    }
    modifyClosedStatus(val) {
        try {
            if (!this.isInitMatrix) {
                this.init();
            }
            if (!this.asyncApiCaller) {
                this.createApiCaller();
            }
            if (!this.asyncApiCaller || !this.isInitMatrix) {
                return;
            }
            this.asyncApiCaller.modifyClosedStatus(this.shape, val);
        } finally {
            this.fulfil();
        }
    }
};
__publicField(_PathEditor, "DELTA", 5);
__publicField(_PathEditor, "BORDER_MAP", "border-map");
// 建立动作点之外的点形成的地图
__publicField(_PathEditor, "FULL_MAP", "full-map");
let PathEditor = _PathEditor;
const _Path = class _Path extends U {
    constructor(context) {
        super();
        __publicField(this, "m_context");
        __publicField(this, "selected_points", /* @__PURE__ */ new Map());
        __publicField(this, "selected_sides", /* @__PURE__ */ new Map());
        __publicField(this, "is_selecting", false);
        __publicField(this, "is_editing", false);
        __publicField(this, "m_segments", []);
        __publicField(this, "m_bridging_events");
        __publicField(this, "contacting", false);
        __publicField(this, "m_last_mouseevent");
        __publicField(this, "bridgeParams");
        __publicField(this, "m_last_point");
        __publicField(this, "previous_path_id", "");
        this.m_context = context;
    }
    saveEvent(e) {
        this.m_last_mouseevent = e;
    }
    get lastEvent() {
        return this.m_last_mouseevent;
    }
    get selectedPoints() {
        return this.selected_points;
    }
    get selectedPointsLength() {
        return Array.from(this.selected_points.values()).flat().length;
    }
    get syntheticPoints() {
        const pathShape = this.m_context.selection.selectedShapes[0];
        const pathType = pathShape == null ? void 0 : pathShape.pathType;
        const result = /* @__PURE__ */ new Map();
        this.selected_points.forEach((indexes, segment) => {
            result.set(segment, new Set(indexes));
        });
        if (!pathType) {
            return this.selected_points;
        }
        if (!this.selected_sides.size) {
            return this.selected_points;
        }
        this.selected_sides.forEach((indexes, segment) => {
            var _a2, _b;
            let points = result.get(segment);
            if (!points) {
                points = /* @__PURE__ */ new Set();
                result.set(segment, points);
            }
            let max = 0;
            if (pathType === Ve.Editable) {
                max = ((_b = (_a2 = pathShape.segments[segment]) == null ? void 0 : _a2.points) == null ? void 0 : _b.length) - 1;
            }
            if (max > -1) {
                for (let i = 0, l2 = indexes.length; i < l2; i++) {
                    const index2 = indexes[i];
                    const anther = index2 === max ? 0 : index2 + 1;
                    points.add(index2);
                    points.add(anther);
                }
            }
        });
        const __result = /* @__PURE__ */ new Map();
        result.forEach((indexes, segment) => {
            __result.set(segment, Array.from(indexes.values()));
        });
        return __result;
    }
    is_selected(segment, index2) {
        const points = this.selected_points.get(segment);
        return !!(points == null ? void 0 : points.length) && points.findIndex((i) => i === index2) > -1;
    }
    select_point(segmentIndex, index2, deep = false) {
        var _a2;
        this._reset();
        if (deep) {
            const pathShape = this.m_context.selection.pathshape;
            if (!pathShape) {
                return;
            }
            const point = (_a2 = pathShape == null ? void 0 : pathShape.segments[segmentIndex]) == null ? void 0 : _a2.points[index2];
            if (!point) {
                return;
            }
            const frame2 = pathShape.frame;
            const m2 = pathShape.matrix2Root();
            m2.preScale(frame2.width, frame2.height);
            m2.multiAtLeft(this.m_context.workspace.matrix);
            const { x: x2, y: y2 } = m2.computeCoord3(point);
            const segments = pathShape.segments;
            const resultPoints = /* @__PURE__ */ new Map();
            for (let i = 0; i < segments.length; i++) {
                const points = segments[i].points;
                let container = resultPoints.get(i);
                if (!container) {
                    container = [];
                    resultPoints.set(i, container);
                }
                for (let j2 = 0; j2 < points.length; j2++) {
                    const __point = m2.computeCoord3(points[j2]);
                    if (Math.abs(__point.x - x2) <= 0.01 && Math.abs(__point.y - y2) <= 0.01) {
                        container.push(j2);
                    }
                }
            }
            resultPoints.forEach((points, segmentIndex2) => {
                if (!points.length) {
                    return;
                }
                this.selected_points.set(segmentIndex2, points);
            });
        } else {
            this.selected_points.set(segmentIndex, [index2]);
        }
        this.notify(_Path.SELECTION_CHANGE);
    }
    select_points(segment, indexes) {
        this._reset();
        this.selected_points.set(segment, [...indexes]);
        this.notify(_Path.SELECTION_CHANGE);
    }
    adjust_points(segment, index2) {
        const points = this.selected_points.get(segment);
        if (!(points == null ? void 0 : points.length)) {
            this.selected_points.set(segment, [index2]);
        } else {
            let al2 = -1;
            for (let i = points.length - 1; i > -1; i--) {
                if (points[i] === index2) {
                    al2 = i;
                    break;
                }
            }
            if (al2 > -1) {
                points.splice(al2, 1);
            } else {
                points.push(index2);
            }
        }
        this.notify(_Path.SELECTION_CHANGE);
    }
    is_selected_segs(segment, index2) {
        const sides = this.selected_sides.get(segment);
        return !!(sides == null ? void 0 : sides.length) && sides.findIndex((i) => i === index2) > -1;
    }
    get selectedSides() {
        return this.selected_sides;
    }
    get selectedSidesLength() {
        return Array.from(this.selected_sides.values()).flat().length;
    }
    select_side(segment, index2) {
        this._reset();
        this.selected_sides.set(segment, [index2]);
        this.notify(_Path.SELECTION_CHANGE);
    }
    select_sides(segment, indexes) {
        this._reset();
        this.selected_sides.set(segment, [...indexes]);
        this.notify(_Path.SELECTION_CHANGE);
    }
    adjust_sides(segment, index2) {
        const sides = this.selected_sides.get(segment);
        if (!(sides == null ? void 0 : sides.length)) {
            this.selected_sides.set(segment, [index2]);
        } else {
            let al2 = -1;
            for (let i = sides.length - 1; i > -1; i--) {
                if (sides[i] === index2) {
                    al2 = i;
                    break;
                }
            }
            if (al2 > 0) {
                sides.splice(al2, 1);
            } else {
                sides.push(index2);
            }
        }
        this.notify(_Path.SELECTION_CHANGE);
    }
    select(indexes1, indexes2) {
        this._reset();
        indexes1.forEach((v2, k) => {
            this.selected_points.set(k, Array.from(v2.values()));
        });
        indexes2.forEach((v2, k) => {
            this.selected_sides.set(k, Array.from(v2.values()));
        });
        this.notify(_Path.SELECTION_CHANGE);
    }
    _reset() {
        this.selected_points.clear();
        this.selected_sides.clear();
    }
    reset() {
        const need_notify = this.selected_points.size || this.selected_sides.size;
        this.selected_points.clear();
        this.selected_sides.clear();
        if (need_notify) {
            this.notify(_Path.SELECTION_CHANGE);
        }
    }
    get matrix_unit_to_root() {
        const path_shape = this.m_context.selection.pathshape;
        if (!path_shape) return new o();
        const f2 = path_shape.frame;
        const m2 = new o(path_shape.matrix2Root());
        m2.multiAtLeft(this.m_context.workspace.matrix);
        m2.preScale(f2.width, f2.height);
        return m2;
    }
    clear_highlight() {
        this.notify(_Path.CLEAR_HIGH_LIGHT);
    }
    selecting(_val) {
        this.is_selecting = _val;
    }
    editing(_val) {
        this.is_editing = _val;
    }
    get no_hover() {
        return this.is_selecting || this.is_editing;
    }
    get no_add() {
        const action = this.m_context.tool.action;
        return this.no_hover || [Action.Curve, Action.PathClip].includes(action);
    }
    set_segments(segments) {
        this.m_segments = segments;
    }
    get segments() {
        return this.m_segments;
    }
    bridging(event) {
        this.m_bridging_events = event;
        this.notify(_Path.BRIDGING);
    }
    bridging_completed() {
        this.m_bridging_events = void 0;
        this.notify(_Path.BRIDGING_COMPLETED);
    }
    get bridging_events() {
        return this.m_bridging_events;
    }
    getCurvePoints() {
        const points = [];
        const shape2 = this.m_context.selection.pathshape;
        if (!shape2) {
            return points;
        }
        if (shape2.pathType === Ve.Editable) {
            const segments = shape2.segments;
            this.selected_points.forEach((indexes, segment) => {
                var _a2;
                const __points = (_a2 = segments[segment]) == null ? void 0 : _a2.points;
                if (!(__points == null ? void 0 : __points.length)) {
                    return;
                }
                for (let i = 0; i < indexes.length; i++) {
                    const p2 = __points[indexes[i]];
                    if (p2) {
                        points.push(p2);
                    }
                }
            });
        }
        return points;
    }
    get isSingleSelection() {
        if (this.selected_sides.size) {
            return false;
        }
        if (this.selected_points.size === 1) {
            let result = false;
            this.selected_points.forEach((s) => {
                result = s.length === 1;
            });
            return result;
        } else {
            return false;
        }
    }
    get isContacting() {
        return this.contacting;
    }
    setContactStatus(v2) {
        this.contacting = v2;
        if (!v2) {
            new PathEditor(this.m_context).sortSegment();
        }
        this.notify(_Path.CONTACT_STATUS_CHANGE);
    }
    get bridgeParam() {
        return this.bridgeParams;
    }
    setBridgeParams(p2) {
        this.bridgeParams = p2;
    }
    get lastPoint() {
        return this.m_last_point;
    }
    setLastPoint(point) {
        this.m_last_point = point;
    }
    setPreviousPathId(id) {
        this.previous_path_id = id;
    }
    get previousPathStyle() {
        const page = this.m_context.selection.selectedPage;
        const shape2 = page.getShape(this.previous_path_id);
        return shape2 == null ? void 0 : shape2.style;
    }
};
__publicField(_Path, "SELECTION_CHANGE", 1);
__publicField(_Path, "SELECTION_CHANGE_P", 2);
__publicField(_Path, "SELECTION_CHANGE_S", 3);
__publicField(_Path, "POINT_TYPE_CHANGE", 4);
__publicField(_Path, "CLEAR_HIGH_LIGHT", 5);
__publicField(_Path, "BRIDGING", 6);
__publicField(_Path, "BRIDGING_COMPLETED", 7);
__publicField(_Path, "CONTACT_STATUS_CHANGE", 8);
let Path2 = _Path;
const _ColorCtx = class _ColorCtx extends U {
    constructor() {
        super();
        __publicField(this, "m_selected_stop");
        __publicField(this, "editor_mode", false);
        __publicField(this, "m_gradient");
        __publicField(this, "m_gradient_type");
        __publicField(this, "m_locat");
        __publicField(this, "m_image_scale_mode");
        __publicField(this, "m_image_scale");
        __publicField(this, "m_image_origin_frame");
        __publicField(this, "m_color_index", -1);
    }
    select_stop(id) {
        this.m_selected_stop = id;
        this.notify(_ColorCtx.CHANGE_STOP);
    }
    get selected_stop() {
        return this.m_selected_stop;
    }
    switch_editor_mode(val, gradient) {
        this.editor_mode = val && !!gradient;
        this.m_gradient = gradient;
        this.notify(_ColorCtx.COLOR_EDITOR);
    }
    set_gradient_type(type) {
        this.m_gradient_type = type;
        this.notify(_ColorCtx.CHANGE_GRADIENT_TYPE);
    }
    get gradient_type() {
        return this.m_gradient_type;
    }
    get mode() {
        return this.editor_mode;
    }
    get gradient() {
        return this.m_gradient;
    }
    gradinet_locat(locat) {
        this.m_locat = locat;
    }
    get locat() {
        return this.m_locat;
    }
    clear_locat() {
        this.m_locat = void 0;
    }
    setImageScaleMode(mode) {
        this.m_image_scale_mode = mode;
        this.notify(_ColorCtx.CHANGE_IMAGE_MODE);
    }
    get imageScaleMode() {
        return this.m_image_scale_mode;
    }
    setImageScale(scale) {
        this.m_image_scale = scale;
        this.notify(_ColorCtx.TILE_CHANGE);
    }
    get imageScale() {
        return this.m_image_scale;
    }
    setImageOriginFrame(frame2) {
        this.m_image_origin_frame = frame2;
        this.notify(_ColorCtx.IMAGE_ORIGIN_CHANGE);
    }
    get imageOriginFrame() {
        return this.m_image_origin_frame;
    }
    setColorIndex(index2) {
        this.m_color_index = index2;
    }
    get colorIndex() {
        return this.m_color_index;
    }
};
__publicField(_ColorCtx, "CHANGE_STOP", 1);
__publicField(_ColorCtx, "COLOR_EDITOR", 2);
__publicField(_ColorCtx, "STOP_DELETE", 3);
__publicField(_ColorCtx, "CHANGE_GRADIENT_TYPE", 4);
__publicField(_ColorCtx, "GRADIENT_UPDATE", 5);
__publicField(_ColorCtx, "TILE_CHANGE", 6);
__publicField(_ColorCtx, "CHANGE_IMAGE_MODE", 7);
__publicField(_ColorCtx, "IMAGE_ORIGIN_CHANGE", 8);
__publicField(_ColorCtx, "HIDDEN_SELECTED", 9);
let ColorCtx = _ColorCtx;
function startLoadTask(data, taskMgr) {
    const pagelist = data.pagesList.slice(0);
    const pageloadTask = new class {
        // page auto loader
        isValid() {
            return !this.isDone();
        }
        isDone() {
            return pagelist.length <= 0;
        }
        async run() {
            let id;
            while (pagelist.length > 0) {
                const i = pagelist[0];
                if (data.pagesMgr.getSync(i.id)) {
                    pagelist.splice(0, 1);
                } else {
                    id = i.id;
                    break;
                }
            }
            if (id) {
                await data.pagesMgr.get(id);
                pagelist.splice(0, 1);
            }
        }
    }();
    taskMgr.add(pageloadTask, Em.normal);
    taskMgr.startLoop();
}
class Attribute extends U {
    constructor() {
        super();
        __publicField(this, "m_default_image", "data:image/svg+xml;base64,PHN2ZyBkYXRhLXYtM2YyZGNlYTM9IiIgZGF0YS12LTJkNjBmMTNlPSIiIHdpZHRoPSI4MDAiIGhlaWdodD0iODAwIiB2aWV3Qm94PSIwIDAgNDAwIDQwMCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczp4aHRtbD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pbllNaW4gbWVldCIgb3ZlcmZsb3c9InZpc2libGUiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsiPjxnPjxnPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDIxNiwyMTYsMjE2KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjE2LDIxNiwyMTYpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwyMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDIxNiwyMTYsMjE2KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwzMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMzAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwyMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMjAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMCwwLDApIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDIwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwxMDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigyMTYsMjE2LDIxNikiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzAwLDEwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjE2LDIxNiwyMTYpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAwLDApIj48cGF0aCBkPSJNIDAgMCBMIDEwMCAwIEwgMTAwIDEwMCBMIDAgMTAwIEwgMCAwIFoiIGZpbGw9InJnYigwLDAsMCkiIGZpbGwtb3BhY2l0eT0iMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMDAsMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMzAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDMwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMjAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMCwwLDApIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDIwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDI1NSwyNTUsMjU1KSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMTAwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLDEwMCkiPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnPjxwYXRoIGQ9Ik0gMCAwIEwgMTAwIDAgTCAxMDAgMTAwIEwgMCAxMDAgTCAwIDAgWiIgZmlsbD0icmdiKDAsMCwwKSIgZmlsbC1vcGFjaXR5PSIxIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMCwwKSI+PHBhdGggZD0iTSAwIDAgTCAxMDAgMCBMIDEwMCAxMDAgTCAwIDEwMCBMIDAgMCBaIiBmaWxsPSJyZ2IoMjU1LDI1NSwyNTUpIiBmaWxsLW9wYWNpdHk9IjEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L2c+PC9nPjwvc3ZnPg==");
    }
    get defaultImage() {
        return this.m_default_image;
    }
}
__publicField(Attribute, "HOR_HILP", 1);
__publicField(Attribute, "VER_HILP", 2);
__publicField(Attribute, "ADD_SIZE_CHANGE", 3);
__publicField(Attribute, "MINUS_SIZE_CHANGE", 4);
__publicField(Attribute, "FRAME_CHANGE", 5);
__publicField(Attribute, "SELECTION_HIDDEN", 15);
class PluginsMgr {
    constructor() {
        __publicField(this, "_plugins", /* @__PURE__ */ new Map());
    }
    regist(...plugins) {
        plugins.forEach((p2) => {
            let arr = this._plugins.get(p2.locate);
            if (!arr) {
                arr = [];
                this._plugins.set(p2.locate, arr);
            }
            arr.push(p2);
        });
    }
    search(locate) {
        const arr = this._plugins.get(locate);
        return arr || [];
    }
    search2(locate) {
        const begin = [];
        const end2 = [];
        this.search(locate).forEach((p2) => {
            if (p2.align === "begin") begin.push(p2);
            else end2.push(p2);
        });
        return { begin, end: end2 };
    }
}
const events = {
    context_readonly_change: "context_readonly_change"
    // export const context_state_change = 'context_state_change'
};
class EscStack {
    constructor() {
        __publicField(this, "m_stack_map", /* @__PURE__ */ new Map());
    }
    // constructor() {
    //     super();
    // }
    save(key, call) {
        if (this.m_stack_map.has(key)) {
            this.m_stack_map.delete(key);
        }
        this.m_stack_map.set(key, { key, task: call });
    }
    remove(key) {
        this.m_stack_map.delete(key);
    }
    has(key) {
        return this.m_stack_map.has(key);
    }
    execute() {
        const queue2 = Array.from(this.m_stack_map.values());
        for (let i = queue2.length - 1; i > -1; i--) {
            const item = queue2[i];
            this.m_stack_map.delete(item.key);
            if (typeof item.task !== "function") continue;
            if (item.task()) break;
        }
    }
    clear() {
        var _a2;
        const queue2 = Array.from(this.m_stack_map.values());
        while (queue2.length) {
            const f2 = (_a2 = queue2.pop()) == null ? void 0 : _a2.task;
            if (typeof f2 !== "function") continue;
            f2();
        }
        this.m_stack_map.clear();
    }
}
function getFrameList(page) {
    if (!page.childs.length) page.m_ctx.layoutAll();
    return page.childs.filter((item) => item.type === Vt.Artboard || item.type === Vt.Symbol || item.type === Vt.SymbolRef);
}
function finderShape(matrix, scout2, scope, hot) {
    let result = void 0;
    for (let i = scope.length - 1; i > -1; i--) {
        const item = scope[i];
        if (!item.isVisible) {
            continue;
        }
        const path = item.getPath().clone();
        const m2 = getPreviewMatrix(item);
        m2.multiAtLeft(matrix.clone());
        path.transform(m2);
        if (!scout2.isPointInShapeForPreview(item, hot, path.toString(), matrix)) {
            continue;
        }
        if (item.type === Vt.Table) {
            return item;
        }
        const children = item.type === Vt.SymbolRef ? item.naviChilds || [] : item.childs || [];
        if (!children.length) {
            return item;
        } else {
            result = finderShape(matrix, scout2, children, hot);
            const background = item.type === Vt.Artboard || item.type == Vt.Symbol || item.type === Vt.SymbolUnion || item.type === Vt.SymbolRef;
            if (!result && background) {
                return item;
            }
        }
        if (result) {
            return result;
        }
    }
}
function getScrollShape(shape2) {
    let s;
    if (!shape2) return;
    if (shape2.scrollDirection && shape2.scrollDirection !== Nt.NONE) {
        return s = shape2;
    }
    let p2 = shape2.parent;
    while (p2 && p2.type !== Vt.Page) {
        if (p2.scrollDirection && p2.scrollDirection !== Nt.NONE) {
            s = p2;
            break;
        } else {
            p2 = p2.parent;
        }
    }
    return s;
}
function getPreviewMatrix(shape2) {
    const m2 = shape2.matrix2Parent();
    let p2 = shape2.parent;
    while (p2 && p2.type !== Vt.Page) {
        const offset = p2.innerTransform;
        offset && m2.multiAtLeft(offset.toMatrix());
        m2.multiAtLeft(p2.matrix2Parent());
        p2 = p2.parent;
    }
    return m2;
}
function selectShapes(context, shapes) {
    const hoveredShape = shapes;
    const selection = context.selection;
    if (hoveredShape) {
        context.preview.saveLastHoverShape(hoveredShape);
        selection.hoverShape(hoveredShape);
    } else {
        selection.unHoverShape();
    }
}
function eventPriority(shape2) {
    const protoActions = shape2.prototypeInterActions;
    let eventTypeIndex = {
        click: -1,
        dblclick: -1,
        mousedown: -1,
        mouseup: -1,
        mouseenter: -1,
        hover: -1
    };
    if (!protoActions) return eventTypeIndex;
    for (let i = 0; i < protoActions.length; i++) {
        const protoAction = protoActions[i];
        const type = protoAction.event.interactionType;
        if (type === Ot.ONCLICK) {
            eventTypeIndex.click = i;
        }
        if (type === Ot.DBCLICK) {
            eventTypeIndex.dblclick = i;
        }
        if (type === Ot.MOUSEDOWN) {
            eventTypeIndex.mousedown = i;
        }
        if (type === Ot.MOUSEUP) {
            eventTypeIndex.mouseup = i;
        }
        if (type === Ot.MOUSEENTER) {
            eventTypeIndex.mouseenter = i;
        }
        if (type === Ot.HOVER) {
            eventTypeIndex.hover = i;
        }
    }
    return eventTypeIndex;
}
const viewBox = (m2, shape2) => {
    const cur_frame = shape2.frame;
    const matrix = getPreviewMatrix(shape2);
    matrix.multiAtLeft(m2.clone());
    const points = [
        matrix.computeCoord2(0, 0),
        matrix.computeCoord2(cur_frame.width, 0),
        matrix.computeCoord2(cur_frame.width, cur_frame.height),
        matrix.computeCoord2(0, cur_frame.height)
    ];
    const box = XYsBounding(points);
    return box;
};
const getAtrboardInnerOffset = (atrboard) => {
    const size2 = atrboard.size;
    let offsetT = 0;
    let offsetL = 0;
    let offsetR = size2.width;
    let offsetB = size2.height;
    for (let i = 0; i < atrboard.childs.length; i++) {
        const child = atrboard.childs[i];
        const frame2 = child._p_frame;
        const right = frame2.x + frame2.width;
        const bottom = frame2.y + frame2.height;
        if (frame2.x < offsetL) offsetL = frame2.x;
        if (frame2.y < offsetT) offsetT = frame2.y;
        if (right > offsetR) offsetR = right;
        if (bottom > offsetB) offsetB = bottom;
    }
    return { top: -offsetT, right: size2.width - offsetR, bottom: size2.height - offsetB, left: -offsetL };
};
const scrollAtrboard = (atrboard, trans) => {
    const offset = getAtrboardInnerOffset(atrboard);
    const transform2 = atrboard.innerTransform || new Ii();
    const tx = transform2.translateX;
    const ty = transform2.translateY;
    let is_scrollx = false;
    let is_scrolly = false;
    if (atrboard.scrollDirection === Nt.VERTICAL) {
        if (trans.y > 0 && offset.top > ty) {
            const transy = trans.y + ty > offset.top ? offset.top - ty : trans.y;
            atrboard.innerScrollOffset(0, transy);
            is_scrolly = true;
        } else if (trans.y < 0 && offset.bottom < ty) {
            const transy = ty + trans.y < offset.bottom ? offset.bottom - ty : trans.y;
            atrboard.innerScrollOffset(0, transy);
            is_scrolly = true;
        }
    } else if (atrboard.scrollDirection === Nt.HORIZONTAL) {
        if (trans.x > 0 && offset.left > tx) {
            const transx = trans.x + tx > offset.left ? offset.left - tx : trans.x;
            atrboard.innerScrollOffset(transx, 0);
            is_scrollx = true;
        } else if (trans.x < 0 && offset.right < tx) {
            const transx = tx + trans.x < offset.right ? offset.right - tx : trans.x;
            atrboard.innerScrollOffset(transx, 0);
            is_scrollx = true;
        }
    } else if (atrboard.scrollDirection === Nt.BOTH) {
        if (trans.y > 0 && offset.top > ty) {
            const transy = trans.y + ty > offset.top ? offset.top - ty : trans.y;
            atrboard.innerScrollOffset(0, transy);
            is_scrolly = true;
        } else if (trans.y < 0 && offset.bottom < ty) {
            const transy = ty + trans.y < offset.bottom ? offset.bottom - ty : trans.y;
            atrboard.innerScrollOffset(0, transy);
            is_scrolly = true;
        }
        if (trans.x > 0 && offset.left > tx) {
            const transx = trans.x + tx > offset.left ? offset.left - tx : trans.x;
            atrboard.innerScrollOffset(transx, 0);
            is_scrollx = true;
        } else if (trans.x < 0 && offset.right < tx) {
            const transx = tx + trans.x < offset.right ? offset.right - tx : trans.x;
            atrboard.innerScrollOffset(transx, 0);
            is_scrollx = true;
        }
    }
    return { x: is_scrollx, y: is_scrolly };
};
var ScaleType = /* @__PURE__ */ ((ScaleType2) => {
    ScaleType2["Actual"] = "Actual";
    ScaleType2["FitScreen"] = "fit_screen";
    ScaleType2["FitWidth"] = "fit_width";
    ScaleType2["FillScreen"] = "fill_screen";
    return ScaleType2;
})(ScaleType || {});
const _Preview = class _Preview extends U {
    constructor(context) {
        super();
        __publicField(this, "m_context");
        __publicField(this, "m_preview_window");
        __publicField(this, "m_doc_id", "");
        __publicField(this, "m_scale", 1);
        __publicField(this, "m_navi_visible", true);
        __publicField(this, "m_menu_options", "Actual");
        __publicField(this, "m_visible_ui", true);
        __publicField(this, "m_menu_visible", false);
        __publicField(this, "m_proto_action");
        __publicField(this, "m_atrboard_scroll_offset", { x: 0, y: 0 });
        __publicField(this, "m_interaction_action", /* @__PURE__ */ new Set());
        __publicField(this, "m_supernatant_open", false);
        __publicField(this, "m_swap_action", /* @__PURE__ */ new Set());
        __publicField(this, "m_navi_shape_list", []);
        __publicField(this, "m_setTimeouts", /* @__PURE__ */ new Set());
        __publicField(this, "m_delaySetTimeouts", /* @__PURE__ */ new Map());
        __publicField(this, "m_arboard_inner_transform", /* @__PURE__ */ new Map());
        __publicField(this, "m_inner_scroll");
        __publicField(this, "m_save_last_shape");
        this.m_context = context;
    }
    setPreviewWindow(window2) {
        this.m_preview_window = window2;
    }
    get scale() {
        return this.m_scale;
    }
    setScale(scale) {
        this.m_scale = scale;
        this.notify(_Preview.MATRIX_SCALE);
    }
    get previewWindow() {
        return this.m_preview_window;
    }
    setDocInfoId(id) {
        this.m_doc_id = id;
    }
    get pageIndex() {
        const page = this.m_context.selection.selectedPage;
        const index2 = this.m_context.data.pagesList.findIndex((item) => item.id === (page == null ? void 0 : page.id));
        return index2;
    }
    get shapeIndex() {
        const page = this.m_context.selection.selectedPage;
        const shape2 = this.m_context.selection.selectedShapes[0];
        return getFrameList(page).findIndex((item) => item.id === (shape2 == null ? void 0 : shape2.id));
    }
    isSelectedShape(shape2) {
        var _a2;
        const shapeId = typeof shape2 === "string" ? shape2 : shape2.id;
        return shapeId === ((_a2 = this.m_context.selection.selectedShapes[0]) == null ? void 0 : _a2.id);
    }
    setScaleMenu(type) {
        this.m_menu_options = type;
        this.notify(_Preview.MENU_CHANGE);
    }
    get scaleType() {
        return this.m_menu_options;
    }
    showNavi(visible) {
        this.m_navi_visible = visible;
        this.notify(_Preview.NAVI_VISIBLE);
    }
    get naviState() {
        return this.m_navi_visible;
    }
    showUiVisible(visible) {
        this.m_visible_ui = visible;
        this.notify(_Preview.UI_CHANGE);
    }
    get uiState() {
        return this.m_visible_ui;
    }
    setMenuVisible(visible) {
        this.m_menu_visible = visible;
    }
    get menuVisible() {
        return this.m_menu_visible;
    }
    setFromShapeAction(info) {
        this.m_proto_action = info;
    }
    get protoAction() {
        return this.m_proto_action;
    }
    setArtboardScroll(offset, action, innerScroll) {
        this.m_atrboard_scroll_offset = offset;
        this.m_inner_scroll = innerScroll;
        this.notify(_Preview.ARTBOARD_SCROLL, action);
    }
    get artboardScrollOffset() {
        return this.m_atrboard_scroll_offset;
    }
    get innerScroll() {
        return this.m_inner_scroll;
    }
    setInteractionAction(action, back_id) {
        if (action) {
            this.m_interaction_action.add(action);
        } else {
            this.m_interaction_action.clear();
        }
        this.notify(_Preview.INTERACTION_CHANGE, back_id);
    }
    resetInteractionAction(action, back_id) {
        this.m_interaction_action.clear();
        this.m_interaction_action.add(action);
        this.notify(_Preview.INTERACTION_CHANGE, back_id);
    }
    get interactionAction() {
        return this.m_interaction_action;
    }
    deleteEndAction() {
        const actions = Array.from(this.m_interaction_action);
        const lastItem = actions.pop();
        this.m_interaction_action = new Set(actions);
        this.notify(_Preview.SUPERNATANT_CLOSR, lastItem);
    }
    get endAction() {
        const actions = Array.from(this.m_interaction_action);
        return actions[actions.length - 1];
    }
    setSupernatantIsOpen(v2) {
        this.m_supernatant_open = v2;
    }
    get supernatantIsOpen() {
        return this.m_supernatant_open;
    }
    setSwapAction(action) {
        if (action) {
            this.m_swap_action.add(action);
        } else {
            this.m_swap_action.clear();
        }
    }
    deleteSwapEndAction() {
        const actions = Array.from(this.m_swap_action);
        actions.pop();
        this.m_swap_action = new Set(actions);
    }
    get swapEndAction() {
        const actions = Array.from(this.m_swap_action);
        return actions[actions.length - 1];
    }
    setNaviShapeList(list) {
        this.m_navi_shape_list = list;
        this.notify(_Preview.FLOW_CHANGE);
    }
    get naviShapeList() {
        return this.m_navi_shape_list;
    }
    addSetTimeout(fn2) {
        this.m_setTimeouts.add(fn2);
    }
    clearSetTimeout() {
        this.m_setTimeouts.forEach((item) => {
            clearTimeout(item);
            item = null;
        });
        this.m_setTimeouts.clear();
    }
    get delaySetTimeout() {
        return this.m_delaySetTimeouts;
    }
    addDelaySetTimeout(key, value) {
        this.m_delaySetTimeouts.set(key, value);
    }
    deleteDelaySetTimeout(key) {
        const timer = this.m_delaySetTimeouts.get(key);
        if (timer) {
            clearTimeout(timer);
            this.m_delaySetTimeouts.delete(key);
        }
    }
    clearDelaySetTimeout() {
        this.m_delaySetTimeouts.forEach((v2, k) => {
            clearTimeout(v2);
            this.m_delaySetTimeouts.delete(k);
        });
        this.m_delaySetTimeouts.clear();
    }
    setInnerTransform(key, value) {
        this.m_arboard_inner_transform.set(key, value);
    }
    get innerTransform() {
        return this.m_arboard_inner_transform;
    }
    clearInnerTransform() {
        this.m_arboard_inner_transform.clear();
    }
    saveLastHoverShape(shape2) {
        this.m_save_last_shape = shape2;
    }
    get saveShape() {
        return this.m_save_last_shape;
    }
};
__publicField(_Preview, "MATRIX_SCALE", 3);
__publicField(_Preview, "MENU_CHANGE", 4);
__publicField(_Preview, "NAVI_VISIBLE", 5);
__publicField(_Preview, "UI_CHANGE", 6);
__publicField(_Preview, "MENU_VISIBLE", 7);
__publicField(_Preview, "NEXT_PAGE", 8);
__publicField(_Preview, "BEFORE_PAGE", 9);
__publicField(_Preview, "NAVI_CHANGE", 10);
__publicField(_Preview, "SCALE_CHANGE", 11);
__publicField(_Preview, "ARTBOARD_SCROLL", 12);
__publicField(_Preview, "MATRIX_CHANGE", 13);
__publicField(_Preview, "INTERACTION_CHANGE", 14);
__publicField(_Preview, "SWAP_REF_STAT", 15);
__publicField(_Preview, "FLOW_CHANGE", 16);
__publicField(_Preview, "SUPERNATANT_CLOSR", 17);
__publicField(_Preview, "SYMBOL_REF_SWITCH", 18);
let Preview = _Preview;
class RepoWraper {
    constructor(repo) {
        __publicField(this, "m_repo");
        this.m_repo = repo;
    }
    canRedo() {
        return this.m_repo.canRedo();
    }
    canUndo() {
        return this.m_repo.canUndo();
    }
    undo() {
        this.m_repo.undo();
    }
    redo() {
        this.m_repo.redo();
    }
    watch(f2) {
        throw new Error("Not implemented");
    }
    unwatch(f2) {
        throw new Error("Not implemented");
    }
    // onCommit(...args: Parameters<typeof this.m_repo.onCommit>): ReturnType<typeof this.m_repo.onCommit> {
    //     return this.m_repo.onCommit(...args)
    // }
    // onUndoRedo(...args: Parameters<typeof this.m_repo.onUndoRedo>): ReturnType<typeof this.m_repo.onUndoRedo> {
    //     return this.m_repo.onUndoRedo(...args)
    // }
}
class ToolBox {
    constructor(context) {
        __publicField(this, "_scout");
        __publicField(this, "_event", new y());
        __publicField(this, "_context");
        this._context = context;
    }
    get scout() {
        if (!this._scout) this._scout = scout(this._context);
        return this._scout;
    }
    get event() {
        return this._event;
    }
}
class Context extends U {
    constructor(data, repo, props) {
        super();
        // 用EventEmitter及storage来进行界面组件之间的数据同步及通信
        // storage的key可以用组件路径也可用uuid等唯一标识
        // eventid同上，需要个唯一前缀。
        // 做到不同功能的组件之间可以完全解耦合
        // public storage: Map<string, any> = new Map();
        __publicField(this, "m_data");
        __publicField(this, "m_editor");
        __publicField(this, "m_repo");
        __publicField(this, "m_coopRepo");
        __publicField(this, "m_taskMgr");
        __publicField(this, "m_textEditor");
        __publicField(this, "m_selection");
        __publicField(this, "m_workspace");
        __publicField(this, "m_pluginsMgr");
        __publicField(this, "m_menu");
        __publicField(this, "m_tool");
        __publicField(this, "m_navi");
        __publicField(this, "m_cursor");
        __publicField(this, "m_escstack");
        __publicField(this, "m_assist");
        __publicField(this, "m_teamwork");
        __publicField(this, "m_component");
        __publicField(this, "m_path");
        __publicField(this, "m_color");
        __publicField(this, "m_medias");
        __publicField(this, "m_user");
        __publicField(this, "m_attr");
        __publicField(this, "m_preview");
        __publicField(this, "m_vdom", /* @__PURE__ */ new Map());
        __publicField(this, "m_props");
        __publicField(this, "m_net");
        __publicField(this, "m_readonly");
        __publicField(this, "_storage", /* @__PURE__ */ new Map());
        __publicField(this, "_sessionStorage", /* @__PURE__ */ new Map());
        __publicField(this, "m_toolbox", new ToolBox(this));
        __publicField(this, "keyHandlers", {});
        window.__context = this;
        this.m_data = data;
        this.m_coopRepo = repo;
        this.m_props = props;
        this.m_repo = new RepoWraper(this.m_coopRepo);
        this.m_taskMgr = new Am();
        this.m_selection = new Selection(data, this);
        repo.setSelection(this.m_selection);
        this.m_workspace = new WorkSpace(this);
        this.m_pluginsMgr = new PluginsMgr();
        this.m_menu = new Menu(this);
        this.m_tool = new Tool(this);
        this.m_navi = new Navi();
        this.m_editor = new ym(this.m_data, this.m_coopRepo, this.m_selection);
        this.m_cursor = new Cursor();
        this.m_escstack = new EscStack();
        this.m_assist = new Assist(this);
        this.m_teamwork = new TeamWork();
        this.m_component = new Component(this);
        this.m_path = new Path2(this);
        this.m_color = new ColorCtx();
        this.m_medias = new PdMedia(this);
        this.m_user = new User();
        this.m_attr = new Attribute();
        this.m_preview = new Preview(this);
        startLoadTask(data, this.m_taskMgr);
    }
    get storage() {
        return this._storage;
    }
    get sessionStorage() {
        return this._sessionStorage;
    }
    get toolbox() {
        return this.m_toolbox;
    }
    get escstack() {
        return this.m_escstack;
    }
    get curAction() {
        return this.tool.action;
    }
    setCurAction(uuid) {
        this.tool.setAction(uuid);
    }
    registKeyHandler(keyCode, handler) {
        this.keyHandlers[keyCode] = handler;
    }
    hasPendingSyncCmd() {
        return this.m_coopRepo.hasPendingSyncCmd();
    }
    setNet(net) {
        this.m_net = net;
        this.m_coopRepo.setNet(net);
    }
    get net() {
        return this.m_net;
    }
    get editor() {
        return this.m_editor;
    }
    editor4Doc() {
        return this.editor.editor4Doc();
    }
    editor4Page(page) {
        return this.editor.editor4Page(page);
    }
    editor4Shape(shape2) {
        if (!this.selection.selectedPage) throw new Error("not selected page?");
        return this.editor.editor4Shape(this.selection.selectedPage, shape2);
    }
    // 在editor里缓存临时数据不太对，应缓存到textselection
    editor4TextShape(shape2) {
        if (!this.selection.selectedPage) throw new Error("not selected page?");
        if (this.m_textEditor && this.m_textEditor.shape.id === shape2.id && this.m_textEditor.view.parent) {
            return this.m_textEditor;
        }
        this.m_textEditor = this.editor.editor4TextShape(this.selection.selectedPage, shape2);
        return this.m_textEditor;
    }
    peekEditor4TextShape(shape2) {
        if (this.m_textEditor && this.m_textEditor.shape.id === shape2.id) {
            return this.m_textEditor;
        }
    }
    editor4Table(shape2) {
        if (!this.selection.selectedPage) throw new Error("not selected page?");
        return this.editor.editor4Table(this.selection.selectedPage, shape2);
    }
    get data() {
        return this.m_data;
    }
    get repo() {
        return this.m_repo;
    }
    get props() {
        return this.m_props;
    }
    setReadonly(readonly2) {
        this.m_readonly = readonly2;
        this.notify(events.context_readonly_change, readonly2);
    }
    get readonly() {
        return !!this.m_readonly;
    }
    get coopRepo() {
        return this.m_coopRepo;
    }
    get selection() {
        return this.m_selection;
    }
    get workspace() {
        return this.m_workspace;
    }
    get pluginsMgr() {
        return this.m_pluginsMgr;
    }
    get menu() {
        return this.m_menu;
    }
    get tool() {
        return this.m_tool;
    }
    get navi() {
        return this.m_navi;
    }
    get cursor() {
        return this.m_cursor;
    }
    get assist() {
        return this.m_assist;
    }
    get teamwork() {
        return this.m_teamwork;
    }
    get tableSelection() {
        return this.m_selection.tableSelection;
    }
    get textSelection() {
        return this.m_selection.textSelection;
    }
    get component() {
        return this.m_component;
    }
    get path() {
        return this.m_path;
    }
    get medias() {
        return this.m_medias;
    }
    get user() {
        return this.m_user;
    }
    get attr() {
        return this.m_attr;
    }
    get preview() {
        return this.m_preview;
    }
    createVDom(page) {
        const domCtx = new DomCtx();
        initComsMap(domCtx.comsMap);
        const dom = new PageDom(domCtx, { data: page });
        const ret = { dom, ctx: domCtx };
        this.m_vdom.set(page.id, ret);
        return ret;
    }
    getPageDom(page) {
        const ret = this.m_vdom.get(page.id);
        if (ret) return ret;
        page = page instanceof Ac ? page.data : page;
        return this.createVDom(page);
    }
    get arrange() {
        return this.m_arrange;
    }
    nextTick(page, cb) {
        const ctx = this.getPageDom(page.data).ctx;
        ctx.once("nextTick", cb);
    }
    get color() {
        return this.m_color;
    }
}
async function parserDocument() {
    const storage = new LCStorage();
    const repo = new st();
    const { document: document2, loader } = await wp(storage, "", "", "", repo);
    const cooprepo = new Nf(document2, repo);
    return new Context(document2, cooprepo, { source: "storage", storage });
}
async function fetchConfig() {
    const response = await fetch("/static/.config");
    const stream = response.body;
    if (!stream) throw new Error("null stream");
    const reader = stream.getReader();
    const values = [];
    let count = 0;
    while (reader) {
        const { value, done } = await reader.read();
        if (value) {
            values.push(value);
            count += value.length;
        }
        if (done) break;
    }
    if (values.length) {
        const units = new Uint8Array(count);
        let index2 = 0;
        for (const u of values) {
            units.set(u, index2);
            index2 += u.length;
        }
        return JSON.parse(new TextDecoder().decode(units));
    } else {
        throw new Error("no values");
    }
}
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
    __name: "PreviewPageCard",
    props: {
        context: {},
        shapes: {},
        data: {},
        backgroundColor: {},
        selected: { type: Boolean }
    },
    emits: ["start-loop"],
    setup(__props, { expose: __expose, emit: __emit }) {
        const props = __props;
        const emits = __emit;
        const pageSvg = ref();
        let pageDom;
        function assemble() {
            disassemble();
            let shapes = props.data;
            if (!shapes) return;
            if (shapes instanceof Vh) {
                shapes = $c(shapes);
            }
            const borders = new G();
            const fills = new G();
            const style = new is(borders, fills, new G());
            const trans = new Ii();
            const page = new qi(
                new G(),
                "assemble-page",
                "assemble-page",
                Vt.Page,
                trans,
                style,
                new G(shapes)
            );
            page.isVisible = true;
            const domCtx = new DomCtx();
            initComsMap(domCtx.comsMap);
            const dom = new PageDom(domCtx, { data: page });
            pageDom = { dom, ctx: domCtx };
            if (pageSvg.value) {
                pageDom.dom.bind(pageSvg.value);
                pageDom.dom.render();
                pageDom.ctx.loop(window.requestAnimationFrame);
                if (pageDom.dom.childs && props.selected) {
                    props.context.selection.replaceSelectShape(pageDom.dom.childs[0]);
                }
                replaceSupernatantShape(pageDom.dom.childs[0]);
                setInnerTransform(pageDom.dom.childs);
                emits("start-loop");
            }
        }
        const setInnerTransform = (shapes) => {
            if (!shapes.length) return;
            const innerTrans = props.context.preview.innerTransform;
            for (let i = 0; i < shapes.length; i++) {
                const shape2 = shapes[i];
                if (shape2 instanceof Hh) {
                    const transform2 = innerTrans.get(shape2.id) || new Ii();
                    shape2.initInnerTransform(transform2);
                }
                const children = shape2.childs || [];
                if (shape2.type === Vt.Table) {
                    continue;
                }
                setInnerTransform(children);
            }
        };
        const replaceSupernatantShape = (replace_s) => {
            if (props.selected) return;
            for (let i = 0; i < props.shapes.length; i++) {
                const shape2 = props.shapes[i];
                if (shape2.id === props.data.id) {
                    props.shapes[i] = replace_s;
                }
            }
        };
        function disassemble() {
            if (pageDom) {
                pageDom.ctx.stopLoop();
                pageDom.dom.unbind();
                if (!pageDom.dom.isDistroyed) {
                    pageDom == null ? void 0 : pageDom.dom.destory();
                }
                pageDom = void 0;
            }
        }
        watch(() => props.shapes, () => {
            assemble();
        }, { immediate: true });
        const preview_watch = (t4) => {
            if (t4 === Preview.SWAP_REF_STAT) {
                assemble();
            }
        };
        __expose({ pageSvg, repaint: assemble });
        onMounted(() => {
            props.context.preview.watch(preview_watch);
        });
        onUnmounted(() => {
            props.context.preview.unwatch(preview_watch);
        });
        return (_ctx, _cache) => {
            return openBlock(), createElementBlock("svg", {
                ref_key: "pageSvg",
                ref: pageSvg,
                style: normalizeStyle({ "background-color": _ctx.backgroundColor })
            }, null, 4);
        };
    }
});
const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};
const PageCard = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-9f4c1242"]]);
class ViewUpdater {
    constructor(context) {
        __publicField(this, "m_context");
        __publicField(this, "m_current_page");
        // 当前页
        __publicField(this, "m_current_view");
        // 当前播放对象
        __publicField(this, "m_page_card");
        // 渲染卡片
        __publicField(this, "matrix", new o());
        __publicField(this, "m_container");
        // 整个黑盒子
        __publicField(this, "m_image_map", /* @__PURE__ */ new Map());
        // todo 缓存，使列表流畅
        __publicField(this, "m_dirty_target", /* @__PURE__ */ new Map());
        __publicField(this, "m_lazy_updater");
        // 停止监听播放对象内部元素(子孙元素)变化
        __publicField(this, "m_stop_last_bubble", () => {
        });
        // 停止监听播放对象的变化
        __publicField(this, "m_stop_last", () => {
        });
        __publicField(this, "m_stop_last_on_page", () => {
        });
        // __update属于播放对象的全量绘制，消耗比较大
        __publicField(this, "update", lodashExports.debounce(this.__update, 300));
        __publicField(this, "MAX", 25600);
        __publicField(this, "MIN", 2);
        this.m_context = context;
        this.m_lazy_updater = new DirtyCleaner(context, this.m_image_map, this.m_dirty_target);
    }
    get lazyLoader() {
        return this.m_lazy_updater;
    }
    get v_matrix() {
        return this.matrix;
    }
    get pageCard() {
        return this.m_page_card;
    }
    setPageCard(card) {
        this.m_page_card = card;
    }
    get currentPage() {
        return this.m_context.selection.selectedPage;
    }
    /**
     * @description 监听播放对象的变化
     * @param args
     */
    updater(...args) {
        this.update(...args);
    }
    /**
     * @description 监听播放对象内部元素(子孙元素)变化
     */
    updaterBubble(...args) {
        this.update(...args);
    }
    /**
     * @description page的变化，有可能导致整个坐标系发生改变，此时应该让播放对象抵消这个改变，避免位移
     */
    updater4Page(...args) {
    }
    setAttri(m2) {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card || !this.m_page_card.pageSvg) {
            return;
        }
        const frame2 = shape2.frame;
        const svgEl = this.m_page_card.pageSvg;
        svgEl.setAttribute("viewBox", `0 0 ${frame2.width} ${frame2.height}`);
        svgEl.setAttribute("width", `${frame2.width}`);
        svgEl.setAttribute("height", `${frame2.height}`);
        svgEl.style["transition"] = "";
        svgEl.style["transform"] = m2.toString();
        svgEl.style.zIndex = "0";
        svgEl.style.opacity = "1";
        this.m_context.preview.setScale(this.getScale(m2));
        this.overlayBox();
        this.matrix.reset(m2);
        this.m_context.preview.notify(Preview.MATRIX_CHANGE);
    }
    getCenterMatrix() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        const page = this.m_current_page;
        if (!shape2 || !container || !this.m_page_card || !page) {
            return new o();
        }
        const transformMatrix = new o();
        const shape_root_m = shape2.matrix2Root();
        shape_root_m.trans(-page.transform.translateX, -page.transform.translateY);
        const m2 = ki(shape_root_m).clone();
        const clientTransform = ki(transformMatrix);
        m2.addTransform(clientTransform);
        const { x: x2, y: y2, width, height } = shape2.frame;
        const { col0: lt2, col1: rt2, col2: rb, col3: lb } = m2.transform([
            E.FromXY(x2, y2),
            E.FromXY(x2 + width, y2),
            E.FromXY(x2 + width, y2 + height),
            E.FromXY(x2, y2 + height)
        ]);
        const box = XYsBounding([lt2, rt2, rb, lb]);
        const root = container.getBoundingClientRect();
        const cx = (box.right + box.left) / 2;
        const cy = (box.bottom + box.top) / 2;
        const rootCX = root.width / 2;
        const rootCY = root.height / 2;
        transformMatrix.trans(rootCX - cx, rootCY - cy);
        return transformMatrix;
    }
    getBoundingBox(toClient = false) {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const frame2 = shape2._p_frame;
        const m2 = new o(shape2.matrix2Parent());
        m2.trans(-frame2.x, -frame2.y);
        if (toClient) {
            m2.multiAtLeft(this.matrix);
        }
        const points = [
            m2.computeCoord2(0, 0),
            m2.computeCoord2(frame2.width, 0),
            m2.computeCoord2(frame2.width, frame2.height),
            m2.computeCoord2(0, frame2.height)
        ];
        const box = XYsBounding(points);
        return { x: box.left, y: box.top, width: box.right - box.left, height: box.bottom - box.top };
    }
    __update(...args) {
        var _a2;
        (_a2 = this.m_page_card) == null ? void 0 : _a2.repaint();
        if (args.includes("frame") || args.includes("rotation") || args.includes("transform")) {
            this.modifyTransform();
        }
    }
    getScale(m2) {
        let __m = (m2 || this.matrix).toArray();
        __m[4] = 0;
        __m[5] = 0;
        __m = new o(__m);
        const xy = __m.computeCoord2(1, 0);
        return Math.hypot(xy.x, xy.y);
    }
    modifyTransformToFit() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const box = this.getBoundingBox();
        const boxWidth = box.width;
        const boxHeight = box.height;
        const root = container.getBoundingClientRect();
        const rootWidth = root.width;
        const rootHeight = root.height;
        const ratio_w = boxWidth / rootWidth * 1.06;
        const ratio_h = boxHeight / rootHeight * 1.12;
        const ratio = Math.max(ratio_h, ratio_w);
        const max = 256;
        const min = 0.02;
        let scale = 1 / ratio;
        if (scale < min) {
            scale = min;
        } else if (scale > max) {
            scale = max;
        }
        const matrix = this.getCenterMatrix();
        matrix.trans(-rootWidth / 2, -rootHeight / 2);
        matrix.scale(scale);
        matrix.trans(rootWidth / 2, rootHeight / 2);
        this.setAttri(matrix);
    }
    modifyTransformToFill() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const box = this.getBoundingBox();
        const boxWidth = box.width;
        const boxHeight = box.height;
        const root = container.getBoundingClientRect();
        const rootWidth = root.width;
        const rootHeight = root.height;
        const ratio_w = boxWidth / rootWidth;
        const ratio_h = boxHeight / rootHeight;
        const ratio = Math.min(ratio_h, ratio_w);
        const max = 256;
        const min = 0.02;
        let scale = 1 / ratio;
        if (scale < min) {
            scale = min;
        } else if (scale > max) {
            scale = max;
        }
        const matrix = this.getCenterMatrix();
        matrix.trans(-rootWidth / 2, -rootHeight / 2);
        matrix.scale(scale);
        matrix.trans(rootWidth / 2, rootHeight / 2);
        if (ratio_w > ratio_h) {
            matrix.trans((box.width * scale - rootWidth) / 2, 0);
        } else {
            matrix.trans(0, (box.height * scale - rootHeight) / 2);
        }
        this.setAttri(matrix);
    }
    modifyTransformToFillByWidth() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const box = this.getBoundingBox();
        const boxWidth = box.width;
        const root = container.getBoundingClientRect();
        const rootWidth = root.width;
        const rootHeight = root.height;
        const ratio = boxWidth / rootWidth;
        const max = 256;
        const min = 0.02;
        let scale = 1 / ratio;
        if (scale < min) {
            scale = min;
        } else if (scale > max) {
            scale = max;
        }
        const matrix = this.getCenterMatrix();
        matrix.trans(-rootWidth / 2, -rootHeight / 2);
        matrix.scale(scale);
        matrix.trans(rootWidth / 2, rootHeight / 2);
        this.setAttri(matrix);
    }
    modifyTransformFixPrototype() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const box = this.getBoundingBox();
        const boxWidth = box.width;
        const root = container.getBoundingClientRect();
        const rootWidth = root.width;
        const rootHeight = root.height;
        const ratio = boxWidth / rootWidth;
        const max = 256;
        const min = 0.02;
        let scale = 1 / ratio;
        if (scale < min) {
            scale = min;
        } else if (scale > max) {
            scale = max;
        }
        const matrix = this.getCenterMatrix();
        matrix.trans(-rootWidth / 2, -rootHeight / 2);
        matrix.scale(scale);
        matrix.trans(rootWidth / 2, rootHeight / 2);
        matrix.trans(0, (box.height * scale - rootHeight) / 2);
        this.setAttri(matrix);
    }
    mount(container, page, current, pageCard) {
        this.m_container = container;
        this.m_current_page = page;
        this.m_current_view = current;
        this.m_page_card = pageCard;
        if (!this.m_current_view) {
            return;
        }
        const bubble = this.updaterBubble.bind(this);
        const updater = this.updater.bind(this);
        this.m_stop_last = this.m_current_view.watch(updater);
        this.m_stop_last_bubble = this.m_current_view.data.bubblewatch(bubble);
        if (!this.m_current_page) {
            return;
        }
        this.m_stop_last_on_page = this.m_current_page.watch(this.updater4Page.bind(this));
    }
    /**
     * @description 切换播放对象
     */
    atTarget(shape2) {
        var _a2;
        if (shape2 && shape2.id === ((_a2 = this.m_current_view) == null ? void 0 : _a2.id)) {
            return;
        }
        this.m_stop_last();
        this.m_stop_last_bubble();
        this.m_current_view = shape2;
        if (!this.m_current_view) {
            return;
        }
        const bubble = this.updaterBubble.bind(this);
        const updater = this.updater.bind(this);
        this.m_stop_last = this.m_current_view.watch(updater);
        this.m_stop_last_bubble = this.m_current_view.data.bubblewatch(bubble);
    }
    /**
     * @description 切换页面
     */
    atPage(page) {
        var _a2;
        if (page && page.id === ((_a2 = this.m_current_page) == null ? void 0 : _a2.id)) {
            return;
        }
        this.m_stop_last_on_page();
        this.m_current_page = page;
        if (!this.m_current_page) {
            return;
        }
        this.m_stop_last_on_page = this.m_current_page.watch(this.updater4Page.bind(this));
    }
    /**
     * @description 修改播放对象的transform(原比例);
     */
    modifyTransform() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const matrix = this.getCenterMatrix();
        this.setAttri(matrix);
    }
    modifyTransformKeepScale() {
        const scale = this.getScale();
        if (scale === 1) {
            return this.modifyTransform();
        }
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const rootBox = container.getBoundingClientRect();
        const matrix = this.getCenterMatrix();
        const rcx = rootBox.width / 2;
        const rcy = rootBox.height / 2;
        matrix.trans(-rcx, -rcy);
        matrix.scale(scale);
        matrix.trans(rcx, rcy);
        this.setAttri(matrix);
    }
    scale(e) {
        const MAX = this.MAX;
        const MIN = this.MIN;
        let scale_delta = 1.3;
        if (Math.abs(e.deltaY) < 16 && Math.abs(e.deltaX) < 16) {
            scale_delta = 1.12;
        }
        const scale = Number((this.m_context.preview.scale * 100).toFixed(0));
        let scale_delta_ = 1 / scale_delta;
        if (scale <= MIN) {
            scale_delta_ = 1;
        } else if (scale >= MAX) {
            scale_delta = MAX / scale;
        }
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const targetBox = this.getBoundingBox();
        const rootBox = container.getBoundingClientRect();
        const rcx = rootBox.width / 2;
        const rcy = rootBox.height / 2;
        const matrix = this.matrix;
        const __s = this.m_context.preview.scale;
        const __scale = Math.sign(e.deltaY) <= 0 ? Math.min(scale_delta * __s, 256) : Math.max(scale_delta_ * __s, 0.02);
        if (targetBox.width * __s > rootBox.width && targetBox.height * __s > rootBox.height) {
            const offsetX = e.x - rootBox.x;
            const offsetY = e.y - rootBox.y;
            matrix.trans(-offsetX, -offsetY);
            matrix.scale(Math.sign(e.deltaY) <= 0 ? scale_delta : scale_delta_);
            matrix.trans(offsetX, offsetY);
        } else {
            matrix.reset(this.getCenterMatrix());
            matrix.trans(-rcx, -rcy);
            matrix.scale(__scale);
            matrix.trans(rcx, rcy);
        }
        this.setAttri(matrix);
        this.m_context.preview.setScaleMenu(void 0);
    }
    keyScale(s) {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const rootBox = container.getBoundingClientRect();
        const rcx = rootBox.width / 2;
        const rcy = rootBox.height / 2;
        const matrix = this.matrix;
        matrix.reset(this.getCenterMatrix());
        matrix.trans(-rcx, -rcy);
        matrix.scale(s > 0 ? Math.min(this.m_context.preview.scale + s, 256) : Math.max(this.m_context.preview.scale + s, 0.02));
        matrix.trans(rcx, rcy);
        this.setAttri(matrix);
        this.m_context.preview.setScaleMenu(void 0);
    }
    getBoundingOnView() {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        const page = this.m_current_page;
        if (!shape2 || !container || !this.m_page_card || !page) {
            return;
        }
        const shape_root_m = shape2.matrix2Root();
        shape_root_m.trans(-page.transform.translateX, -page.transform.translateY);
        const m2 = ki(shape_root_m).clone();
        const clientTransform = ki(this.matrix);
        m2.addTransform(clientTransform);
        const { x: x2, y: y2, width, height } = shape2.frame;
        const { col0: lt2, col1: rt2, col2: rb, col3: lb } = m2.transform([
            E.FromXY(x2, y2),
            E.FromXY(x2 + width, y2),
            E.FromXY(x2 + width, y2 + height),
            E.FromXY(x2, y2 + height)
        ]);
        const box = XYsBounding([lt2, rt2, rb, lb]);
        return box;
    }
    trans(e, scroll) {
        const MAX_STEP = 120;
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return;
        }
        const root = container.getBoundingClientRect();
        let stepx = Math.abs(e.deltaX) > MAX_STEP ? MAX_STEP * (e.deltaX / Math.abs(e.deltaX)) : e.deltaX;
        let stepy = Math.abs(e.deltaY) > MAX_STEP ? MAX_STEP * (e.deltaY / Math.abs(e.deltaY)) : e.deltaY;
        if (e.shiftKey && !is_mac() && e.deltaX < 1) {
            stepx = stepy;
            stepy = 0;
        }
        const bound = this.getBoundingOnView();
        const left = bound.left;
        const top = bound.top;
        const right = bound.right;
        const bottom = bound.bottom;
        if (left < 0) {
            if (left > stepx) stepx = left;
        }
        if (left >= 0 && stepx < 0) stepx = 0;
        if (top < 0) {
            if (top > stepy) stepy = top;
        }
        if (top >= 0 && stepy < 0) stepy = 0;
        if (right > root.width) {
            if (right - root.width < stepx) stepx = right - root.width;
        }
        if (right <= root.width && stepx > 0) stepx = 0;
        if (bottom > root.height) {
            if (bottom - root.height < stepy) stepy = bottom - root.height;
        }
        if (bottom <= root.height && stepy > 0) stepy = 0;
        if (scroll) {
            if (scroll.x) stepx = 0;
            if (scroll.y) stepy = 0;
        }
        this.matrix.trans(-stepx, -stepy);
        this.setAttri(this.matrix);
    }
    artboardInTrans(el2) {
        const shape2 = this.m_current_view;
        const container = this.m_container;
        if (!shape2 || !container || !this.m_page_card) {
            return true;
        }
        const root = container.getBoundingClientRect();
        let stepx = this.m_context.preview.artboardScrollOffset.x;
        let stepy = this.m_context.preview.artboardScrollOffset.y;
        const bound = this.getBoundingOnView();
        const left = bound.left;
        const top = bound.top;
        const right = bound.right;
        const bottom = bound.bottom;
        if (left < 0) {
            if (left > stepx) stepx = left;
        }
        if (left >= 0 && stepx < 0) stepx = 0;
        if (top < 0) {
            if (top > stepy) stepy = top;
        }
        if (top >= 0 && stepy < 0) stepy = 0;
        if (right > root.width) {
            if (right - root.width < stepx) stepx = right - root.width;
        }
        if (right <= root.width && stepx > 0) stepx = 0;
        if (bottom > root.height) {
            if (bottom - root.height < stepy) stepy = bottom - root.height;
        }
        if (bottom <= root.height && stepy > 0) stepy = 0;
        this.matrix.trans(-stepx, -stepy);
        el2.style["transform"] = this.matrix.toString();
        if (stepx === stepy && stepx === 0) {
            return true;
        }
    }
    overlayBox(s) {
        const shape2 = s || this.m_current_view;
        if (!shape2) {
            return;
        }
        const over_el = document.querySelector(".preview_overlay");
        if (over_el) {
            const frame2 = shape2.frame;
            const _m2 = getPreviewMatrix(shape2);
            const matrix = new o(this.v_matrix.clone());
            _m2.multiAtLeft(matrix);
            const points = [[0, 0], [frame2.width, 0], [frame2.width, frame2.height], [0, frame2.height]].map((p2) => _m2.computeCoord(p2[0], p2[1]));
            const box = XYsBounding(points);
            over_el.style.clipPath = `polygon(
                0 0, 
                100% 0, 
                100% 100%, 
                0 100%, 
                0 ${box.top}px, 
                ${box.left}px ${box.top}px, 
                ${box.left}px ${box.bottom}px, 
                ${box.right}px ${box.bottom}px, 
                ${box.right}px ${box.top}px, 
                100% ${box.top}px, 
                0 ${box.top}px
            )`;
        }
    }
    updateViewBox(context, shape2, type, box) {
        var _a2;
        const cur_shape = context.selection.selectedShapes[0];
        if (!cur_shape) return;
        const cur_frame = cur_shape._p_frame;
        const m2 = new o();
        m2.reset(this.v_matrix);
        if (type === Lt.OVERLAY || type === Lt.SWAP || type === Lt.NAVIGATE) {
            let s = shape2;
            const frame2 = shape2._p_frame;
            viewBox(this.v_matrix, shape2);
            if (type === Lt.SWAP) {
                const before_action = context.preview.swapEndAction;
                if (!before_action) return;
                s = this.getCurLayerShape(context, before_action.targetNodeID);
            }
            if (!s) return;
            const scale = this.v_matrix.m00;
            const { left, right, top, bottom } = s.overlayPosition ? s.overlayPosition.margin : { left: 0, right: 0, top: 0, bottom: 0 };
            m2.trans((cur_frame.x - frame2.x) * scale, (cur_frame.y - frame2.y) * scale);
            if (((_a2 = s.overlayPosition) == null ? void 0 : _a2.position) === kt.CENTER || !s.overlayPosition) {
                const c_x = frame2.width * scale / 2;
                const c_y = frame2.height * scale / 2;
                const v_center = { x: (box.left + box.right) / 2, y: (box.top + box.bottom) / 2 };
                m2.trans(v_center.x - (box.left + c_x), v_center.y - (box.top + c_y));
            } else if (s.overlayPosition.position === kt.TOPCENTER) {
                const c_x = frame2.width * scale / 2;
                const v_centerx = (box.left + box.right) / 2;
                m2.trans(v_centerx - (box.left + c_x), top);
            } else if (s.overlayPosition.position === kt.TOPRIGHT) {
                const r = frame2.width * scale + box.left;
                m2.trans(box.right - r - right, top);
            } else if (s.overlayPosition.position === kt.CENTERLEFT) {
                const c_y = frame2.height * scale / 2;
                const v_centery = (box.top + box.bottom) / 2;
                m2.trans(left, v_centery - (box.top + c_y));
            } else if (s.overlayPosition.position === kt.CENTERRIGHT) {
                const c_y = frame2.height * scale / 2;
                const v_centery = (box.top + box.bottom) / 2;
                const r = frame2.width * scale + box.left;
                m2.trans(box.right - r - right, v_centery - (box.top + c_y));
            } else if (s.overlayPosition.position === kt.BOTTOMCENTER) {
                const c_x = frame2.width * scale / 2;
                const v_centerx = (box.left + box.right) / 2;
                const b2 = frame2.height * scale + box.top;
                m2.trans(v_centerx - (box.left + c_x), box.bottom - b2 - bottom);
            } else if (s.overlayPosition.position === kt.BOTTOMLEFT) {
                const b2 = frame2.height * scale + box.top;
                m2.trans(left, box.bottom - b2 - bottom);
            } else if (s.overlayPosition.position === kt.BOTTOMRIGHT) {
                const r = frame2.width * scale + box.left;
                const b2 = frame2.height * scale + box.top;
                m2.trans(box.right - r - right, box.bottom - b2 - bottom);
            } else {
                m2.trans(left, top);
            }
        }
        return m2;
    }
    readyPosition(matrix, shape2, type) {
        const m2 = new o(matrix.clone());
        if (!type) return m2;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape || !shape2) return m2;
        const box = viewBox(this.v_matrix, select_shape);
        const cur_box = viewBox(matrix, shape2);
        const animate_type = type.split("_");
        const direction = animate_type.at(-1);
        if (animate_type.includes("FROM")) {
            if (direction === "RIGHT") {
                const trans = box.right - cur_box.left;
                m2.trans(-trans, 0);
            } else if (direction === "LEFT") {
                const trans = cur_box.right - box.left;
                m2.trans(trans, 0);
            } else if (direction === "TOP") {
                const trans = box.bottom - cur_box.top;
                m2.trans(0, -trans);
            } else if (direction === "BOTTOM") {
                const trans = cur_box.bottom - box.top;
                m2.trans(0, trans);
            }
        } else if (animate_type.includes("SLIDE") && animate_type.includes("OUT")) {
            const w2 = (box.right - box.left) * 0.2;
            const h2 = (box.bottom - box.top) * 0.2;
            if (direction === "RIGHT") {
                const trans = box.right - cur_box.right - w2;
                m2.trans(trans, 0);
            } else if (direction === "LEFT") {
                const trans = cur_box.left - box.left + w2;
                m2.trans(trans, 0);
            } else if (direction === "TOP") {
                const trans = box.bottom - cur_box.bottom - h2;
                m2.trans(0, trans);
            } else if (direction === "BOTTOM") {
                const trans = cur_box.top - box.top + h2;
                m2.trans(0, trans);
            }
        }
        return m2;
    }
    backReadyPosition(matrix, shape2, type) {
        const m2 = new o(matrix.clone());
        if (!type) return m2;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape || !shape2) return m2;
        const box = viewBox(this.v_matrix, select_shape);
        const cur_box = viewBox(matrix, shape2);
        const animate_type = type.split("_");
        const direction = animate_type.at(-1);
        if (animate_type.includes("SLIDE") && animate_type.includes("FROM")) {
            const w2 = (box.right - box.left) * 0.2;
            const h2 = (box.bottom - box.top) * 0.2;
            if (direction === "RIGHT") {
                const trans = box.left - cur_box.left + w2;
                m2.trans(trans, 0);
            } else if (direction === "LEFT") {
                const trans = box.right - cur_box.right - w2;
                m2.trans(trans, 0);
            } else if (direction === "TOP") {
                const trans = box.top - cur_box.top + h2;
                m2.trans(0, trans);
            } else if (direction === "BOTTOM") {
                const trans = cur_box.bottom - box.bottom - h2;
                m2.trans(0, trans);
            }
        } else if (animate_type.includes("OUT") || animate_type.includes("PUSH")) {
            if (direction === "RIGHT") {
                const trans = cur_box.right - box.left;
                m2.trans(trans, 0);
            } else if (direction === "LEFT") {
                const trans = box.right - cur_box.left;
                m2.trans(-trans, 0);
            } else if (direction === "TOP") {
                const trans = cur_box.bottom - box.top;
                m2.trans(0, trans);
            } else if (direction === "BOTTOM") {
                const trans = box.bottom - cur_box.top;
                m2.trans(0, -trans);
            }
        }
        return m2;
    }
    getCurLayerShape(context, id) {
        const page = context.selection.selectedPage;
        const shapes = getFrameList(page);
        return shapes.find((item) => item.id === id);
    }
    // 容器内滚动
    scrollAnimate(el2, action) {
        const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
        const time = action.transitionDuration ?? 0.3;
        el2.style["transition"] = `all ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
    }
    // 淡入淡出动画
    dissolveAnimate(action, els, value) {
        if (action.transitionType !== Pt.DISSOLVE || !els) return;
        const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
        const time = action.transitionDuration ?? 0.3;
        els[els.length - 1].style["transition"] = `opacity ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        els[els.length - 1].style.opacity = `${value}`;
    }
    // 移入动画
    shiftInAnimate(action, els) {
        if (!els) return;
        if (action.transitionType === Pt.MOVEFROMLEFT || action.transitionType === Pt.MOVEFROMRIGHT || action.transitionType === Pt.MOVEFROMTOP || action.transitionType === Pt.MOVEFROMBOTTOM) {
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        }
    }
    // pageSvg移出动作
    slideAndshiftOutAnimate(action) {
        var _a2, _b;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("OUT")) {
            const pageSvg = (_b = this.pageCard) == null ? void 0 : _b.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            pageSvg.style.zIndex = "9";
            this.outAction(action);
        }
    }
    // 滑入 推入动画
    pushAndslideInAnimate(action, els) {
        var _a2;
        if (!els) return;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && (animateType.includes("SLIDE") && animateType.includes("OUT"))) {
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = (action.transitionDuration ?? 0.3) - 0.05;
            els[els.length - 1].style["transition"] = `transform ${time > 0 ? time : 1e-3}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        } else if (animateType && (animateType.includes("SLIDE") || animateType.includes("PUSH"))) {
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        }
    }
    // 滑入动画
    pageSvgSlideAnimate(action) {
        var _a2;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape) return;
        const box = viewBox(this.v_matrix, select_shape);
        const m2 = new o(this.v_matrix.clone());
        if (action.transitionType === Pt.SLIDEFROMBOTTOM || action.transitionType === Pt.SLIDEFROMLEFT || action.transitionType === Pt.SLIDEFROMRIGHT || action.transitionType === Pt.SLIDEFROMTOP) {
            const pageSvg = (_a2 = this.pageCard) == null ? void 0 : _a2.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            const animate_type = action.transitionType.split("_");
            const direction = animate_type.at(-1);
            const w2 = (box.right - box.left) * 0.3;
            const h2 = (box.bottom - box.top) * 0.3;
            if (direction === "RIGHT") {
                m2.trans(w2, 0);
            } else if (direction === "LEFT") {
                m2.trans(-w2, 0);
            } else if (direction === "TOP") {
                m2.trans(0, h2);
            } else if (direction === "BOTTOM") {
                m2.trans(0, -h2);
            }
            pageSvg.style["transform"] = m2.toString();
        }
    }
    // pageSvg推出动画
    pageSvgPushAnimate(action) {
        var _a2, _b, _c2;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape) return;
        const box = viewBox(this.v_matrix, select_shape);
        const m2 = new o(this.v_matrix.clone());
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("PUSH")) {
            const pageSvg = (_b = this.pageCard) == null ? void 0 : _b.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            const direction = animateType.at(-1);
            const w2 = box.right - box.left;
            const h2 = box.bottom - box.top;
            if (direction === "RIGHT") {
                m2.trans(w2, 0);
            } else if (direction === "LEFT") {
                m2.trans(-w2, 0);
            } else if (direction === "TOP") {
                m2.trans(0, h2);
            } else if (direction === "BOTTOM") {
                m2.trans(0, -h2);
            }
            const svgEl = (_c2 = this.m_page_card) == null ? void 0 : _c2.pageSvg;
            svgEl.style["transform"] = m2.toString();
        }
    }
    // 移除动画效果
    removeAnimate(el2, isTrans) {
        if (el2) {
            el2.addEventListener("transitionend", function() {
                this.style["transition"] = "";
            });
        }
        if (isTrans) {
            el2.style["transition"] = "";
        }
    }
    // 移出动作
    outAction(action) {
        var _a2, _b;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape) return;
        const box = viewBox(this.v_matrix, select_shape);
        const animate_type = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (!animate_type) return;
        const m2 = new o(this.v_matrix.clone());
        const direction = animate_type.at(-1);
        if (animate_type.includes("OUT")) {
            const transx = box.right - box.left;
            const transy = box.bottom - box.top;
            if (direction === "RIGHT") {
                m2.trans(transx, 0);
            } else if (direction === "LEFT") {
                m2.trans(-transx, 0);
            } else if (direction === "TOP") {
                m2.trans(0, transy);
            } else if (direction === "BOTTOM") {
                m2.trans(0, -transy);
            }
        }
        const svgEl = (_b = this.m_page_card) == null ? void 0 : _b.pageSvg;
        svgEl.style["transform"] = m2.toString();
    }
    backSlideInAnimate(action, els) {
        var _a2, _b;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape) return;
        if (animateType && animateType.includes("SLIDE") && animateType.includes("FROM")) {
            const box = viewBox(this.v_matrix, select_shape);
            const m2 = new o(this.v_matrix.clone());
            const direction = animateType.at(-1);
            const w2 = box.right - box.left;
            const h2 = box.bottom - box.top;
            if (direction === "RIGHT") {
                m2.trans(-w2, 0);
            } else if (direction === "LEFT") {
                m2.trans(w2, 0);
            } else if (direction === "TOP") {
                m2.trans(0, -h2);
            } else if (direction === "BOTTOM") {
                m2.trans(0, h2);
            }
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            const svgEl = (_b = this.m_page_card) == null ? void 0 : _b.pageSvg;
            svgEl.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            svgEl.style.zIndex = "9";
            svgEl.style["transform"] = m2.toString();
        }
    }
    backSlideOutAnimate(action, els) {
        var _a2, _b, _c2;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("OUT") && animateType.includes("SLIDE")) {
            const select_shape = this.m_context.selection.selectedShapes[0];
            if (!select_shape) return;
            const box = viewBox(this.v_matrix, select_shape);
            const pageSvg = (_b = this.pageCard) == null ? void 0 : _b.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            const m2 = new o(this.v_matrix.clone());
            const direction = animateType.at(-1);
            const w2 = (box.right - box.left) * 0.3;
            const h2 = (box.bottom - box.top) * 0.3;
            if (direction === "RIGHT") {
                m2.trans(-w2, 0);
            } else if (direction === "LEFT") {
                m2.trans(w2, 0);
            } else if (direction === "TOP") {
                m2.trans(0, -h2);
            } else if (direction === "BOTTOM") {
                m2.trans(0, h2);
            }
            const svgEl = (_c2 = this.m_page_card) == null ? void 0 : _c2.pageSvg;
            svgEl.style["transform"] = m2.toString();
        }
    }
    backDissolveAnimate(action, els) {
        var _a2;
        if (action.transitionType !== Pt.DISSOLVE) return;
        const svgEl = (_a2 = this.m_page_card) == null ? void 0 : _a2.pageSvg;
        const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
        const time = action.transitionDuration ?? 0.3;
        svgEl.style["transition"] = `opacity ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        svgEl.style.zIndex = "9";
        svgEl.style.opacity = "0";
        if (els.length > 1) {
            for (let i = 0; i < els.length - 1; i++) {
                const el2 = els[i];
                el2.style["transition"] = `opacity ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
                el2.style.zIndex = "9";
                el2.style.opacity = `0`;
            }
        }
    }
    backOutAction(action) {
        var _a2, _b;
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!select_shape) return;
        const box = viewBox(this.v_matrix, select_shape);
        const animate_type = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (!animate_type) return;
        const m2 = new o(this.v_matrix.clone());
        const direction = animate_type.at(-1);
        const w2 = box.right - box.left;
        const h2 = box.bottom - box.top;
        if (direction === "RIGHT") {
            m2.trans(-w2, 0);
        } else if (direction === "LEFT") {
            m2.trans(w2, 0);
        } else if (direction === "TOP") {
            m2.trans(0, -h2);
        } else if (direction === "BOTTOM") {
            m2.trans(0, h2);
        }
        const svgEl = (_b = this.m_page_card) == null ? void 0 : _b.pageSvg;
        svgEl.style["transform"] = m2.toString();
    }
    backShiftInAnimate(action) {
        var _a2, _b;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && (animateType.includes("MOVE") && animateType.includes("FROM"))) {
            const pageSvg = (_b = this.pageCard) == null ? void 0 : _b.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            pageSvg.style.zIndex = "9";
            this.backOutAction(action);
        }
    }
    backShiftOutAnimate(action, els) {
        var _a2;
        if (!els) return;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("MOVE") && animateType.includes("OUT")) {
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        }
    }
    backPushInAnimate(action, els) {
        var _a2;
        if (!els) return;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("PUSH")) {
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            els[els.length - 1].style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
        }
    }
    backPushAnimate(action) {
        var _a2, _b;
        const animateType = (_a2 = action.transitionType) == null ? void 0 : _a2.split("_");
        if (animateType && animateType.includes("PUSH")) {
            const pageSvg = (_b = this.pageCard) == null ? void 0 : _b.pageSvg;
            if (!pageSvg) return;
            const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
            const time = action.transitionDuration ?? 0.3;
            pageSvg.style["transition"] = `transform ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
            this.backOutAction(action);
        }
    }
    getHotZone(e, matrix, shape2) {
        const view = this.m_container;
        const boxs = /* @__PURE__ */ new Set();
        if (!view) return;
        this.hotZoneBox(e, matrix, shape2, boxs);
        const hover_shape = this.m_context.selection.hoveredShape;
        if (hover_shape) return;
        const hotBoxs = Array.from(boxs);
        for (let i = 0; i < hotBoxs.length; i++) {
            const box = hotBoxs[i];
            const style = toStyle({
                position: "absolute",
                top: box.top + "px",
                left: box.left + "px",
                width: box.right - box.left + "px",
                height: box.bottom - box.top + "px",
                "background-color": "rgba(255, 0, 0, 0.3)",
                "z-index": "999",
                opacity: "1",
                transition: "opacity 0.3s cubic-bezier(0, 0, 1, 1) 0s"
            });
            const el2 = document.createElement("div");
            el2.setAttribute("style", style);
            view.appendChild(el2);
            setTimeout(() => {
                el2.style.opacity = "0";
            }, 0);
            setTimeout(() => {
                view.removeChild(el2);
            }, 300);
        }
    }
    hotZoneBox(e, matrix, shape2, boxs) {
        const view = this.m_container;
        const viewbox = view.getBoundingClientRect();
        const downX = e.clientX - viewbox.x;
        const downY = e.clientY - viewbox.y;
        if (shape2.prototypeInterActions && shape2.prototypeInterActions.length) {
            const box = viewBox(matrix, shape2);
            if (downX < box.left || downX > box.right || downY < box.top || downY > box.bottom) {
                boxs.add(box);
            }
        } else {
            const children = shape2.childs;
            if (children.length) {
                for (let i = 0; i < children.length; i++) {
                    const c2 = children[i];
                    this.hotZoneBox(e, matrix, c2, boxs);
                }
            }
        }
    }
    artboardInnerScroll(action, el2, shape2) {
        const is_inner = this.m_context.preview.innerScroll;
        if (!is_inner) {
            if (el2 && action.transitionType === Pt.SCROLLANIMATE) {
                this.scrollAnimate(el2, action);
            }
            const isTrans = this.artboardInTrans(el2);
            const time = action.transitionDuration ?? 0.3;
            const timer = setTimeout(() => {
                this.removeAnimate(el2, isTrans);
            }, time * 1e3);
            this.m_context.preview.addSetTimeout(timer);
        } else {
            const inner_shape = this.getScrollArtboard(shape2, is_inner.id);
            if (action.transitionType === Pt.SCROLLANIMATE) {
                const el22 = document.getElementById(`${inner_shape.id}`);
                if (el22) {
                    this.scrollAnimate(el22, action);
                    const time = action.transitionDuration ?? 0.3;
                    setTimeout(() => {
                        el22.style["transition"] = "";
                    }, time * 1e3);
                }
            }
            const trans = inner_shape.innerTransform;
            let stepx = this.m_context.preview.artboardScrollOffset.x - ((trans == null ? void 0 : trans.translateX) || 0);
            let stepy = this.m_context.preview.artboardScrollOffset.y - ((trans == null ? void 0 : trans.translateY) || 0);
            scrollAtrboard(inner_shape, { x: stepx, y: stepy });
        }
    }
    getScrollArtboard(shape2, scrollId) {
        if (shape2.id === scrollId) {
            return shape2;
        }
        const children = shape2.childs || [];
        if (!children.length) {
            return;
        } else {
            for (let i = 0; i < children.length; i++) {
                const item = children[i];
                const result = this.getScrollArtboard(item, scrollId);
                if (result) {
                    return result;
                }
            }
        }
        return;
    }
}
class DirtyCleaner {
    constructor(context, store, dirty) {
        __publicField(this, "m_image_map");
        // todo 缓存，使列表流畅
        __publicField(this, "m_dirty_target");
        __publicField(this, "m_context");
        __publicField(this, "timer", null);
        __publicField(this, "m_current_creating", "");
        __publicField(this, "m_loop", false);
        this.m_context = context;
        this.m_image_map = store;
        this.m_dirty_target = dirty;
    }
    changePage(targets) {
        let needInit = false;
        for (let i = 0; i < targets.length; i++) {
            const t4 = targets[i];
            if (!this.m_image_map.has(t4.id)) {
                needInit = true;
                this.m_dirty_target.set(t4.id, t4);
            }
        }
        if (needInit) {
            clearTimeout(this.timer);
            this.timer = null;
            this.initStore();
        }
    }
    initStore() {
        const dirty = Array.from(this.m_dirty_target.keys());
        const cd = dirty.pop();
        if (!cd) {
            console.log("finish init");
            this.m_loop = false;
            return;
        }
        const target = this.m_dirty_target.get(cd);
        if (!target) {
            return;
        }
        this.m_dirty_target.delete(this.m_current_creating);
        this.m_current_creating = cd;
        console.log("_target_", target.name, target);
        this.m_context.menu.notify(Menu.WRITE_MEDIA_LAZY, target);
        this.m_loop = true;
    }
    dataLoad(b64) {
        if (!this.m_current_creating) {
            this.m_loop = false;
            return;
        }
        console.log("__dataLoad__", this.m_current_creating);
        this.m_image_map.set(this.m_current_creating, b64);
        const last = this.m_current_creating;
        if (this.m_loop) {
            this.initStore();
        } else {
            this.lazyAfter5s();
        }
        return last;
    }
    lazyAfter5s() {
        const __lazy = this.lazyLong.bind(this);
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
            __lazy();
            clearTimeout(this.timer);
            this.timer = null;
        }, 5e3);
    }
    lazyLong() {
        const dirty = Array.from(this.m_dirty_target.keys());
        const cd = dirty.pop();
        if (!cd) {
            this.lazyAfter5s();
            console.log("no dirty");
            return;
        }
        const target = this.m_dirty_target.get(cd);
        if (!target) {
            this.lazyAfter5s();
            return;
        }
        this.m_dirty_target.delete(this.m_current_creating);
        this.m_current_creating = cd;
        this.m_context.menu.notify(Menu.WRITE_MEDIA_LAZY, target);
    }
    uninstall() {
        this.m_current_creating = "";
        clearTimeout(this.timer);
        this.timer = null;
    }
}
let current_state = 1;
let reset_state_timer = null;
function reset_state() {
    current_state = 1;
    clearTimeout(reset_state_timer);
    reset_state_timer = null;
}
function reset_timer() {
    clearTimeout(reset_state_timer);
    reset_state_timer = null;
}
function dbl_action() {
    reset_state_timer && reset_timer();
    reset_state_timer = setTimeout(() => {
        reset_state();
    }, 300);
    return current_state++ === 2;
}
class ProtoAction {
    constructor(context) {
        __publicField(this, "m_context");
        __publicField(this, "m_shapes", []);
        this.m_context = context;
    }
    executeActionx(action, matrix, id) {
        const page = this.m_context.selection.selectedPage;
        this.m_shapes = getFrameList(page);
        if (action.connectionType === Ft.INTERNALNODE && action.navigationType === Lt.NAVIGATE) {
            this.actionSkipPage(action);
        } else if (action.connectionType === Ft.URL) {
            if (action.connectionURL) {
                this.openUrl(action.connectionURL);
            }
        } else if (action.connectionType === Ft.BACK) {
            this.actionBackPage();
        } else if (action.connectionType === Ft.INTERNALNODE && action.navigationType === Lt.SCROLLTO) {
            this.artboardInScroll(action, matrix);
        } else if (action.navigationType === Lt.OVERLAY) {
            this.openDialog(action, matrix);
        } else if (action.connectionType === Ft.CLOSE) {
            this.closeDialog();
        } else if (action.navigationType === Lt.SWAP) {
            this.replaceDialog(action, matrix);
        } else if (action.navigationType === Lt.SWAPSTATE) {
            this.symbolStateSwitch(action);
        }
        if (id) this.m_context.preview.deleteDelaySetTimeout(id);
    }
    // 跳转页面
    actionSkipPage(action) {
        const shapeId = action.targetNodeID;
        if (!shapeId) return;
        const shape2 = this.m_shapes.find((item) => item.id === shapeId);
        const select_shape = this.m_context.selection.selectedShapes[0];
        if (!shape2 || !select_shape) return;
        this.m_context.preview.setFromShapeAction({ id: select_shape.id, action });
        if (!action.transitionType) return;
        const type = action.transitionType.split("_");
        const time = action.transitionDuration ?? 0.3;
        if (action.transitionType === Pt.INSTANTTRANSITION) {
            this.m_context.selection.selectShape(shape2);
        } else if (type.includes("DISSOLVE") || type.includes("MOVE") && type.includes("FROM")) {
            this.m_context.preview.setInteractionAction(action);
            const timer = setTimeout(() => {
                this.m_context.selection.selectShape(shape2);
            }, time * 1e3);
            this.m_context.preview.addSetTimeout(timer);
        } else if (type.includes("SLIDE") || type.includes("PUSH") || type.includes("OUT")) {
            this.m_context.preview.resetInteractionAction(action);
            const timer = setTimeout(() => {
                this.m_context.selection.selectShape(shape2);
            }, time * 1e3);
            this.m_context.preview.addSetTimeout(timer);
        }
    }
    // 返回上一级
    actionBackPage() {
        const action = this.m_context.preview.protoAction;
        if (action) {
            const shape2 = this.m_shapes.find((item) => item.id === action.id);
            if (!action.action.transitionType || !shape2) return;
            const type = action.action.transitionType.split("_");
            const time = action.action.transitionDuration ?? 0.3;
            if (action.action.transitionType === Pt.INSTANTTRANSITION) {
                this.m_context.selection.selectShape(shape2);
            } else if (type.includes("DISSOLVE")) {
                this.m_context.preview.setInteractionAction(action.action, shape2 == null ? void 0 : shape2.id);
                const timer = setTimeout(() => {
                    this.m_context.selection.selectShape(shape2);
                }, time * 1e3);
                this.m_context.preview.addSetTimeout(timer);
            } else {
                this.m_context.preview.resetInteractionAction(action.action, shape2 == null ? void 0 : shape2.id);
                const timer = setTimeout(() => {
                    this.m_context.selection.selectShape(shape2);
                }, time * 1e3);
                this.m_context.preview.addSetTimeout(timer);
            }
        }
    }
    // 容器内滚动
    artboardInScroll(action, matrix) {
        var _a2, _b, _c2, _d2;
        const page = this.m_context.selection.selectedPage;
        if (!page || !action.targetNodeID) return;
        const target_shape = page.getShape(action.targetNodeID);
        if (!target_shape) return;
        const scroll_shape = this.scrollParent(target_shape);
        if (scroll_shape) {
            if (scroll_shape.parent.type === Vt.Page && scroll_shape.scrollDirection === Nt.NONE) {
                const box = viewBox(matrix, scroll_shape);
                const offsetx = box.left - (((_a2 = action.extraScrollOffset) == null ? void 0 : _a2.x) || 0);
                const offsety = box.top - (((_b = action.extraScrollOffset) == null ? void 0 : _b.y) || 0);
                this.m_context.preview.setArtboardScroll({ x: offsetx, y: offsety }, action);
            } else {
                const frame2 = target_shape._p_frame;
                const offsetx = -frame2.x + (((_c2 = action.extraScrollOffset) == null ? void 0 : _c2.x) || 0);
                const offsety = -frame2.y + (((_d2 = action.extraScrollOffset) == null ? void 0 : _d2.y) || 0);
                this.m_context.preview.setArtboardScroll({ x: offsetx, y: offsety }, action, scroll_shape);
            }
        }
    }
    scrollParent(shape2) {
        let p2 = shape2.parent;
        while (p2 && p2.type !== Vt.Artboard && p2.type !== Vt.Page) {
            p2 = p2.parent;
        }
        return p2;
    }
    // 打开链接
    openUrl(str) {
        const url = getFullURL(str);
        let a2 = document.createElement("a");
        const id = "new_a";
        a2.setAttribute("href", url);
        a2.setAttribute("target", "_blank");
        a2.setAttribute("id", id);
        if (!document.getElementById(id)) {
            document.body.appendChild(a2);
        }
        a2.click();
        document.body.removeChild(a2);
    }
    // 组件状态替换
    symbolStateSwitch(action, id, shape2) {
        const down_shape = shape2 || this.m_context.selection.hoveredShape;
        if (!action.targetNodeID) return;
        const time = action.transitionDuration ?? 0.3;
        const maprefIdArray = this.getMapRefIdLS(rc);
        maprefIdArray.set(down_shape.id, action.targetNodeID);
        this.saveMapRefIdLS(maprefIdArray, rc);
        if (action.transitionType === Pt.INSTANTTRANSITION) {
            this.m_context.preview.notify(Preview.SWAP_REF_STAT);
            this.m_context.preview.notify(Preview.SYMBOL_REF_SWITCH);
        } else {
            this.m_context.preview.notify(Preview.SYMBOL_REF_SWITCH, action, shape2);
            const timer = setTimeout(() => {
                this.m_context.preview.notify(Preview.SWAP_REF_STAT);
                this.m_context.preview.notify(Preview.SYMBOL_REF_SWITCH);
            }, time * 1e3);
            this.m_context.preview.addSetTimeout(timer);
        }
        if (id) this.m_context.preview.deleteDelaySetTimeout(id);
    }
    // 打开浮层
    openDialog(action, matrix) {
        this.m_context.preview.setInteractionAction(action);
        delayAction(this.m_context, matrix);
    }
    // 关闭浮层
    closeDialog() {
        const endAction = this.m_context.preview.endAction;
        if (!endAction) return;
        if (endAction.navigationType === Lt.SWAP) {
            this.m_context.preview.deleteSwapEndAction();
        }
        this.m_context.preview.deleteEndAction();
    }
    // 替换浮层
    replaceDialog(action, matrix) {
        const end_action = this.m_context.preview.endAction;
        this.m_context.preview.setSwapAction(end_action);
        this.closeDialog();
        this.openDialog(action, matrix);
    }
    getMapRefIdLS(key) {
        let jsonString = sessionStorage.getItem(key);
        if (jsonString) {
            let refIdArray = JSON.parse(jsonString);
            return new Map(refIdArray);
        }
        return /* @__PURE__ */ new Map();
    }
    saveMapRefIdLS(map, key) {
        let refIdArray = Array.from(map.entries());
        let jsonString = JSON.stringify(refIdArray);
        sessionStorage.setItem(key, jsonString);
    }
}
function getFullURL(str) {
    const pattern2 = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
    if (!pattern2.test(str)) {
        return str;
    }
    if (!/^https?:\/\//i.test(str)) {
        str = "http://" + str;
    }
    return str;
}
const delayAction = (context, matrix) => {
    let shape2 = context.selection.selectedShapes[0];
    const page = context.selection.selectedPage;
    const shapes = getFrameList(page);
    const action = context.preview.endAction;
    if (action) {
        const s = shapes.find((item) => item.id === action.targetNodeID);
        if (s) {
            shape2 = s;
        }
    }
    if (!shape2) return;
    const protoActionFn = new ProtoAction(context);
    executeDelayActionShape(context, shape2, protoActionFn, matrix);
};
function executeDelayActionShape(context, shape2, protoActionFn, matrix) {
    const actions = shape2.prototypeInterActions;
    if (actions == null ? void 0 : actions.length) {
        for (let i = 0; i < actions.length; i++) {
            const action = actions[i];
            if (action.event.interactionType === Ot.AFTERTIMEOUT) {
                const time = action.event.transitionTimeout || 0.8;
                const timers = context.preview.delaySetTimeout;
                if (!timers.has(action.id)) {
                    const timer = setTimeout(() => {
                        if (action.actions.navigationType === Lt.SWAPSTATE) {
                            protoActionFn.symbolStateSwitch(action.actions, action.id, shape2);
                        } else {
                            protoActionFn.executeActionx(action.actions, matrix, action.id);
                        }
                    }, time * 1e3);
                    context.preview.addDelaySetTimeout(action.id, timer);
                }
            }
        }
    }
    if (shape2.type === Vt.Table) {
        return;
    }
    const children = shape2.childs || [];
    if (!children.length) {
        return;
    } else {
        for (let i = 0; i < children.length; i++) {
            const item = children[i];
            executeDelayActionShape(context, item, protoActionFn, matrix);
        }
    }
}
const _hoisted_1$3 = ["width", "height", "viewBox"];
const _hoisted_2$1 = ["d", "stroke-width"];
const _hoisted_3 = ["d", "fill"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
    __name: "ControlsView",
    props: {
        context: {},
        matrix: {}
    },
    emits: ["updateSearch"],
    setup(__props, { emit: __emit }) {
        const emit2 = __emit;
        const props = __props;
        const tracing_class = reactive({ thick_stroke: false, hollow_fill: false });
        const tracingFrame = ref({ path: "", viewBox: "", height: 0, width: 0 });
        const tracing = ref(false);
        let downXY = { x: 0, y: 0 };
        let isDragging = false;
        const saveShape = ref();
        let protoActionFn = void 0;
        let eventTypeIndex = {
            click: -1,
            dblclick: -1,
            mousedown: -1,
            mouseup: -1,
            mouseenter: -1,
            hover: -1
        };
        let eventTypeZIndex = {
            click: false,
            dblclick: false,
            mousedown: false,
            mouseup: false,
            mouseenter: false,
            hover: false
        };
        function pathMousedown(e) {
            emit2("updateSearch", e);
            const selection = props.context.selection;
            if (props.context.workspace.isPageDragging) {
                return;
            }
            if (props.context.preview.menuVisible) {
                props.context.preview.notify(Preview.MENU_VISIBLE);
            }
            const hoveredShape = selection.hoveredShape;
            if (!hoveredShape) {
                return;
            }
            if (!protoActionFn) {
                protoActionFn = new ProtoAction(props.context);
            }
            downXY = { x: e.x, y: e.y };
            eventTypeZIndex.dblclick = false;
            eventTypeZIndex.mousedown = false;
            if (e.button === 0) {
                const protoActions = hoveredShape.prototypeInterActions;
                if (!protoActions) return;
                if (dbl_action()) {
                    if (!eventTypeZIndex.dblclick && eventTypeIndex.click === -1 && eventTypeIndex.mousedown === -1 && eventTypeIndex.mouseup === -1) {
                        for (let i = protoActions.length - 1; i > -1; i--) {
                            const protoAction = protoActions[i];
                            const type = protoAction.event.interactionType;
                            if (type === Ot.DBCLICK) {
                                console.log("双击事件");
                                e.stopPropagation();
                                eventTypeZIndex.dblclick = true;
                                protoActionFn.executeActionx(protoAction.actions, props.matrix);
                                break;
                            }
                        }
                    }
                    return;
                }
                if (!eventTypeZIndex.mousedown) {
                    for (let i = protoActions.length - 1; i > -1; i--) {
                        const protoAction = protoActions[i];
                        const type = protoAction.event.interactionType;
                        if (type === Ot.MOUSEDOWN) {
                            console.log("按下鼠标");
                            e.stopPropagation();
                            eventTypeZIndex.mousedown = true;
                            protoActionFn.executeActionx(protoAction.actions, props.matrix);
                            break;
                        }
                    }
                }
            }
            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        }
        const onMouseMove = (e) => {
            if (isDragging) ;
            else if (Math.hypot(e.x - downXY.x, e.y - downXY.y) > 3) {
                e.stopPropagation();
                isDragging = true;
            }
        };
        const onMouseUp = (e) => {
            e.stopPropagation();
            emit2("updateSearch", e);
            const hoveredShape = props.context.selection.hoveredShape;
            if (!hoveredShape) return;
            const protoActions = hoveredShape.prototypeInterActions;
            if (!protoActions) return;
            if (!protoActionFn) {
                protoActionFn = new ProtoAction(props.context);
            }
            eventTypeZIndex.click = false;
            eventTypeZIndex.mouseup = false;
            for (let i = protoActions.length - 1; i > -1; i--) {
                const protoAction = protoActions[i];
                const type = protoAction.event.interactionType;
                if (!eventTypeZIndex.mouseup && type === Ot.MOUSEUP) {
                    if (!isDragging && e.button === 0) {
                        console.log("松开鼠标");
                        eventTypeZIndex.mouseup = true;
                        protoActionFn.executeActionx(protoAction.actions, props.matrix);
                    }
                }
                if (!(Math.hypot(e.x - downXY.x, e.y - downXY.y) > 3)) {
                    if (!eventTypeZIndex.click && type === Ot.ONCLICK && eventTypeIndex.mousedown === -1 && eventTypeIndex.mouseup === -1) {
                        if (!isDragging && e.button === 0) {
                            console.log("单击事件");
                            eventTypeZIndex.click = true;
                            protoActionFn.executeActionx(protoAction.actions, props.matrix);
                        }
                    }
                }
                if (type === Ot.RIGHTCLICK) {
                    if (!isDragging && e.button === 2) {
                        console.log("右击事件");
                        protoActionFn.executeActionx(protoAction.actions, props.matrix);
                    }
                }
                if (isDragging) {
                    if (type === Ot.DRAG) {
                        console.log("拖拽事件");
                        protoActionFn.executeActionx(protoAction.actions, props.matrix);
                    }
                }
            }
            if (isDragging) {
                isDragging = false;
            }
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
        };
        const onMouseenter = () => {
            if (props.context.workspace.isPageDragging) {
                return;
            }
            eventTypeZIndex.hover = false;
            eventTypeZIndex.mouseenter = false;
            const hoveredShape = props.context.selection.hoveredShape;
            protoActionFn = new ProtoAction(props.context);
            if (hoveredShape) {
                const protoActions = hoveredShape.prototypeInterActions;
                console.log("__protoActions__", protoActions);
                if (!protoActions) return;
                eventTypeIndex = eventPriority(hoveredShape);
                for (let i = protoActions.length - 1; i > -1; i--) {
                    const protoAction = protoActions[i];
                    const type = protoAction.event.interactionType;
                    if (type === Ot.HOVER || type === Ot.MOUSEENTER) {
                        if (!eventTypeZIndex.hover && type === Ot.HOVER && eventTypeIndex.mouseenter === -1) {
                            console.log("鼠标悬停");
                            eventTypeZIndex.hover = true;
                            protoActionFn.executeActionx(protoAction.actions, props.matrix);
                            if (protoAction.actions.transitionType === Pt.INSTANTTRANSITION) {
                                emit2("updateSearch");
                            } else {
                                const time = protoAction.actions.transitionDuration ?? 0.3;
                                const timer = setTimeout(() => {
                                    emit2("updateSearch");
                                }, time * 1e3);
                                props.context.preview.addSetTimeout(timer);
                            }
                        } else if (!eventTypeZIndex.mouseenter && type === Ot.MOUSEENTER) {
                            console.log("hoveredShape: 移入");
                            eventTypeZIndex.mouseenter = true;
                            protoActionFn.executeActionx(protoAction.actions, props.matrix);
                            if (protoAction.actions.transitionType === Pt.INSTANTTRANSITION) {
                                emit2("updateSearch");
                            } else {
                                const time = protoAction.actions.transitionDuration ?? 0.3;
                                const timer = setTimeout(() => {
                                    emit2("updateSearch");
                                }, time * 1e3);
                                props.context.preview.addSetTimeout(timer);
                            }
                        }
                    }
                }
                if (saveShape.value) {
                    moveOutAction();
                }
                saveShape.value = hoveredShape;
            } else {
                if (!saveShape.value) return;
                moveOutAction();
                saveShape.value = void 0;
            }
        };
        const moveOutAction = () => {
            const shape2 = props.context.preview.saveShape;
            if (!shape2) return;
            const protoActions = shape2.prototypeInterActions;
            if (!protoActions) return;
            for (let i = 0; i < protoActions.length; i++) {
                const protoAction = protoActions[i];
                const type = protoAction.event.interactionType;
                if (type === Ot.MOUSELEAVE && protoActionFn) {
                    console.log("saveShape.value: 移出");
                    if (protoAction.actions.navigationType === Lt.SWAPSTATE) {
                        protoActionFn.symbolStateSwitch(protoAction.actions, protoAction.id, shape2);
                    } else {
                        protoActionFn.executeActionx(protoAction.actions, props.matrix);
                    }
                    break;
                }
            }
        };
        function createShapeTracing() {
            const hoveredShape = props.context.selection.hoveredShape;
            tracing.value = false;
            if (!hoveredShape) {
                return;
            }
            const path = hoveredShape.getPath().clone();
            const m2 = getPreviewMatrix(hoveredShape);
            m2.multiAtLeft(props.matrix.clone());
            path.transform(m2);
            tracingFrame.value = { height: 10, width: 10, viewBox: `${0} ${0} ${10} ${10}`, path: path.toString() };
            tracing.value = true;
            modify_tracing_class(hoveredShape);
        }
        function modify_tracing_class(shape2) {
            tracing_class.thick_stroke = false;
            tracing_class.hollow_fill = false;
            if (shape2 instanceof Kh && !shape2.isClosed) {
                tracing_class.hollow_fill = true;
                tracing_class.thick_stroke = true;
            }
            if (shape2.getFills().length) {
                tracing_class.hollow_fill = false;
            }
        }
        const selected_watcher = (t4) => {
            if (t4 === Selection.CHANGE_SHAPE_HOVER) {
                onMouseenter();
                createShapeTracing();
            } else if (t4 === Selection.CHANGE_SHAPE) {
                props.context.preview.clearSetTimeout();
                props.context.preview.clearDelaySetTimeout();
                props.context.preview.setInteractionAction(void 0);
                props.context.preview.setSwapAction(void 0);
                sessionStorage.removeItem(rc);
                delayAction(props.context, props.matrix);
            } else if (t4 === Selection.PREVIEW_HOVER_CHANGE) {
                createShapeTracing();
            }
        };
        const preview_watcher = (t4) => {
            if (t4 === Preview.MATRIX_CHANGE) {
                createShapeTracing();
            } else if (t4 === Preview.SWAP_REF_STAT) {
                delayAction(props.context, props.matrix);
            }
        };
        onMounted(() => {
            props.context.selection.watch(selected_watcher);
            props.context.preview.watch(preview_watcher);
        });
        onUnmounted(() => {
            props.context.selection.unwatch(selected_watcher);
            props.context.preview.unwatch(preview_watcher);
        });
        return (_ctx, _cache) => {
            return tracing.value ? (openBlock(), createElementBlock("svg", {
                key: 0,
                version: "1.1",
                xmlns: "http://www.w3.org/2000/svg",
                "xmlns:xlink": "http://www.w3.org/1999/xlink",
                "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
                preserveAspectRatio: "xMinYMin meet",
                overflow: "visible",
                width: tracingFrame.value.width,
                height: tracingFrame.value.height,
                viewBox: tracingFrame.value.viewBox,
                style: { "position": "absolute", "top": "0", "left": "0" }
            }, [
                createBaseVNode("path", {
                    d: tracingFrame.value.path,
                    fill: "none",
                    stroke: "transparent",
                    "stroke-width": _ctx.context.selection.hoverStroke,
                    onMousedown: _cache[0] || (_cache[0] = (e) => pathMousedown(e))
                }, null, 40, _hoisted_2$1),
                createBaseVNode("path", {
                    d: tracingFrame.value.path,
                    fill: tracing_class.hollow_fill ? "none" : "transparent",
                    stroke: "transparent",
                    "stroke-width": "1.5",
                    onMousedown: _cache[1] || (_cache[1] = (e) => pathMousedown(e))
                }, null, 40, _hoisted_3)
            ], 8, _hoisted_1$3)) : createCommentVNode("", true);
        };
    }
});
const _hoisted_1$2 = {
    key: 1,
    class: "overlay"
};
const _hoisted_2 = {
    key: 2,
    class: "preview_overlay"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "PreviewContent",
    props: {
        context: {},
        page: {}
    },
    setup(__props) {
        const props = __props;
        const preview2 = ref();
        let cur_shape = reactive([]);
        const listLength = ref(0);
        const curPage = ref(0);
        const pageCard = ref();
        const viewBoxDialog = ref();
        const spacePressed = ref(false);
        let target_shapes = reactive([]);
        const isSuperposed = ref(false);
        const end_matrix = ref(new o());
        const is_swap_shape = ref(false);
        const symrefAnimate = ref();
        const renderCard = ref(false);
        let event;
        function page_watcher() {
            var _a2;
            const selection = props.context.selection;
            const page = selection.selectedPage;
            if (!page) return cur_shape = [];
            if (!selection.selectedShapes.length) {
                const list = getFrameList(page);
                if (!list.length) return cur_shape = [];
                props.context.selection.selectShape(list[0]);
            }
            const shape2 = props.context.selection.selectedShapes[0];
            if (((_a2 = cur_shape[0]) == null ? void 0 : _a2.id) !== shape2.id) {
                cur_shape = toRaw([shape2]);
            }
            viewUpdater.atPage(page.data);
            viewUpdater.atTarget(shape2);
            const naviList = props.context.preview.naviShapeList;
            const frameList = naviList.length > 0 ? naviList : getFrameList(page);
            listLength.value = frameList.length;
            const index2 = frameList.findIndex((item) => item.id === shape2.id);
            curPage.value = index2 + 1;
            initMatrix();
            viewUpdater.overlayBox(shape2);
            if (event) search2(event);
        }
        function changePage() {
            const page = props.context.selection.selectedPage;
            if (!page) return;
            const naviList = props.context.preview.naviShapeList;
            const frameList = naviList.length > 0 ? naviList : getFrameList(page);
            const shape2 = props.context.selection.selectedShapes[0] || frameList[0];
            if (!shape2) {
                return cur_shape = [];
            }
            cur_shape = toRaw([shape2]);
            viewUpdater.atPage(page.data);
            viewUpdater.atTarget(shape2);
            listLength.value = frameList.length;
            const index2 = frameList.findIndex((item) => item.id === shape2.id);
            curPage.value = index2 + 1;
            nextTick(() => {
                viewUpdater.mount(preview2.value, props.context.selection.selectedPage.data, props.context.selection.selectedShapes[0], pageCard.value);
                initMatrix();
            });
        }
        const togglePage = (p2) => {
            const shape2 = props.context.selection.selectedShapes[0];
            const page = props.context.selection.selectedPage;
            if (!shape2 || !page) {
                return cur_shape = [];
            }
            cur_shape = toRaw([shape2]);
            const naviList = props.context.preview.naviShapeList;
            const frameList = naviList.length > 0 ? naviList : getFrameList(page);
            let index2 = frameList.findIndex((item) => item.id === shape2.id);
            if (index2 === -1) return;
            index2 += p2;
            if (index2 < 0 || index2 > frameList.length - 1) return;
            props.context.selection.selectShape(frameList[index2]);
            props.context.preview.setFromShapeAction(void 0);
        };
        const getEndElement = () => {
            let el2;
            if (target_shapes.length > 0) {
                const els = document.querySelectorAll(".dailogCard");
                el2 = els[els.length - 1];
            } else {
                el2 = pageCard.value.pageSvg;
            }
            return el2;
        };
        const previewWatcher = (t4, s, action_s) => {
            if (t4 === Preview.MENU_CHANGE) {
                const type = props.context.preview.scaleType;
                if (type === ScaleType.Actual) {
                    viewUpdater.modifyTransform();
                } else if (type === ScaleType.FillScreen) {
                    viewUpdater.modifyTransformToFill();
                } else if (type === ScaleType.FitScreen) {
                    viewUpdater.modifyTransformToFit();
                } else if (type === ScaleType.FitWidth) {
                    viewUpdater.modifyTransformToFillByWidth();
                }
                const shape2 = props.context.selection.selectedShapes[0];
                viewUpdater.overlayBox(shape2);
            } else if (t4 === Preview.NAVI_VISIBLE) {
                if (props.context.preview.naviState) {
                    viewUpdater.v_matrix.trans(-250, 0);
                    viewUpdater.setAttri(viewUpdater.v_matrix);
                } else {
                    viewUpdater.v_matrix.trans(250, 0);
                    viewUpdater.setAttri(viewUpdater.v_matrix);
                }
            } else if (t4 === Preview.BEFORE_PAGE) {
                togglePage(-1);
            } else if (t4 === Preview.NEXT_PAGE) {
                togglePage(1);
            } else if (t4 === Preview.SCALE_CHANGE) {
                if (s) {
                    viewUpdater.keyScale(-0.1);
                } else {
                    viewUpdater.keyScale(0.1);
                }
            } else if (t4 === Preview.ARTBOARD_SCROLL) {
                const el2 = getEndElement();
                const action = s;
                const selected_shape = props.context.selection.selectedShapes[0];
                const shape2 = target_shapes.length ? target_shapes[target_shapes.length - 1] : selected_shape;
                viewUpdater.artboardInnerScroll(action, el2, shape2);
                if (event) search2(event);
            } else if (t4 === Preview.MATRIX_CHANGE) {
                updateDialogMatrix();
                if (event) search2(event);
            } else if (t4 === Preview.INTERACTION_CHANGE) {
                s ? backTargetShape(s) : getTargetShapes();
            } else if (t4 === Preview.FLOW_CHANGE) {
                const shape2 = props.context.selection.selectedShapes[0];
                const page = props.context.selection.selectedPage;
                const naviList = props.context.preview.naviShapeList;
                const frameList = naviList.length > 0 ? naviList : getFrameList(page);
                listLength.value = frameList.length;
                const index2 = frameList.findIndex((item) => item.id === (shape2 == null ? void 0 : shape2.id));
                curPage.value = index2 + 1;
            } else if (t4 === Preview.SUPERNATANT_CLOSR) {
                const els = document.querySelectorAll(".dailogCard");
                const action = s;
                viewUpdater.dissolveAnimate(action, els, 0);
                const end_shape = target_shapes[target_shapes.length - 1];
                const m2 = viewUpdater.readyPosition(end_matrix.value, end_shape, action.transitionType);
                const el2 = els[els.length - 1];
                el2.style["transform"] = m2.toString();
                if (action.transitionType === Pt.INSTANTTRANSITION) {
                    getTargetShapes();
                } else {
                    const time = action.transitionDuration ?? 0.3;
                    const timer = setTimeout(() => {
                        getTargetShapes();
                    }, time * 1e3);
                    props.context.preview.addSetTimeout(timer);
                }
            } else if (t4 === Preview.SYMBOL_REF_SWITCH) {
                const m2 = new o();
                if (!s && symrefAnimate.value) {
                    symrefAnimate.value.style["transition"] = "";
                    symrefAnimate.value.style["transform"] = m2.toString();
                    symrefAnimate.value.style.opacity = "0";
                    return;
                }
                const action = s;
                const hover_shape = action_s || props.context.selection.hoveredShape;
                if (!action.targetNodeID || !hover_shape || !symrefAnimate.value) return;
                const matrix = isSuperposed.value ? end_matrix.value : viewUpdater.v_matrix;
                const box = viewBox(matrix, hover_shape);
                m2.scale(viewUpdater.v_matrix.m00);
                const domCtx = new DomCtx();
                initComsMap(domCtx.comsMap);
                const sym = props.context.data.symbolsMgr.get(action.targetNodeID);
                if (!sym) return;
                const cur_frame = sym.frame;
                const _m2 = sym.matrix2Parent();
                _m2.multiAtLeft(m2.clone());
                const points = [
                    _m2.computeCoord2(0, 0),
                    _m2.computeCoord2(cur_frame.width, 0),
                    _m2.computeCoord2(cur_frame.width, cur_frame.height),
                    _m2.computeCoord2(0, cur_frame.height)
                ];
                const sym_box = Rp(points);
                m2.trans(box.left - sym_box.left, box.top - sym_box.top);
                const view = new SymbolDom(domCtx, { data: sym });
                view.layout();
                view.render();
                const bezier2 = action.easingFunction ? action.easingFunction : [0, 0, 1, 1];
                const time = action.transitionDuration ?? 0.3;
                symrefAnimate.value.style["transition"] = `opacity ${time}s cubic-bezier(${bezier2[0]}, ${bezier2[1]}, ${bezier2[2]}, ${bezier2[3]}) 0s`;
                symrefAnimate.value.style["transform"] = m2.toString();
                if (view.el) {
                    symrefAnimate.value.appendChild(view.el);
                    symrefAnimate.value.style.opacity = "1";
                    const timer = setTimeout(() => {
                        var _a2;
                        view.el && ((_a2 = symrefAnimate.value) == null ? void 0 : _a2.removeChild(view.el));
                    }, time * 1e3);
                    props.context.preview.addSetTimeout(timer);
                }
            }
        };
        const removeChildSymrefAnimate = () => {
            if (!symrefAnimate.value) return;
            const els = symrefAnimate.value.childNodes;
            symrefAnimate.value.style["transition"] = "";
            symrefAnimate.value.style["transform"] = "";
            symrefAnimate.value.style.opacity = "0";
            if (els.length > 0) {
                for (let index2 = 0; index2 < els.length; index2++) {
                    const el2 = els[index2];
                    symrefAnimate.value.removeChild(el2);
                }
            }
        };
        const selectionWatcher = (v2) => {
            var _a2;
            if (v2 === Selection.CHANGE_PAGE) {
                changePage();
                props.context.preview.setFromShapeAction(void 0);
            } else if (v2 === Selection.CHANGE_SHAPE) {
                removeChildSymrefAnimate();
                props.context.preview.clearInnerTransform();
                const shapes = props.context.selection.selectedShapes;
                if (!shapes.length) {
                    props.context.selection.selectShape(void 0);
                }
                watch_shapes();
                if (!((_a2 = viewUpdater.pageCard) == null ? void 0 : _a2.pageSvg) || !viewUpdater.currentPage) {
                    changePage();
                    return;
                }
                page_watcher();
            }
        };
        const initMatrix = () => {
            viewUpdater.modifyTransformFixPrototype();
            if (is_overlay.value && pageCard.value) {
                is_overlay.value = false;
            }
        };
        let atrboard;
        function onMouseWheel(e) {
            e.preventDefault();
            const shape2 = props.context.selection.selectedShapes[0];
            if (!shape2) return;
            const { ctrlKey, metaKey } = e;
            if (ctrlKey || metaKey) ;
            else {
                let hover_shape = search22(e);
                hover_shape = getScrollShape(hover_shape);
                if (!hover_shape) {
                    viewUpdater.trans(e);
                } else {
                    atrboard = hover_shape;
                    const scale = viewUpdater.v_matrix.m00;
                    let stepx = Math.abs(e.deltaX) > 50 ? 50 * (e.deltaX / Math.abs(e.deltaX)) : e.deltaX;
                    let stepy = Math.abs(e.deltaY) > 50 ? 50 * (e.deltaY / Math.abs(e.deltaY)) : e.deltaY;
                    if (e.shiftKey && !is_mac() && e.deltaX < 1) {
                        stepx = stepy;
                        stepy = 0;
                    }
                    let scroll = scrollAtrboard(atrboard, { x: -stepx / scale, y: -stepy / scale });
                    let p_x = hover_shape.parent;
                    p_x = getScrollShape(p_x);
                    while (p_x && p_x.type !== Vt.Page && !scroll.x) {
                        scroll.x = scrollAtrboard(p_x, { x: -stepx / scale, y: 0 }).x;
                        p_x = p_x.parent;
                    }
                    let p_y = hover_shape.parent;
                    p_y = getScrollShape(p_y);
                    while (p_y && p_y.type !== Vt.Page && !scroll.y) {
                        scroll.y = scrollAtrboard(p_y, { x: 0, y: -stepy / scale }).y;
                        p_y = p_y.parent;
                    }
                    viewUpdater.trans(e, scroll);
                }
            }
        }
        const observer = new ResizeObserver(() => {
            initMatrix();
            viewUpdater.overlayBox();
            updateDialogMatrix();
        });
        const isMenu = ref(false);
        const top = ref(0);
        const left = ref(0);
        let downXY = { x: 0, y: 0 };
        let isDragging = false;
        const onMouseDown = (e) => {
            const shape2 = props.context.selection.selectedShapes[0];
            if (!shape2) return;
            e.stopPropagation();
            isMenu.value = false;
            if (e.button === 2) {
                if (!preview2.value) return;
                props.context.preview.notify(Preview.MENU_VISIBLE);
                top.value = e.y;
                left.value = e.x;
                const root = preview2.value.getBoundingClientRect();
                const downX = e.clientX - root.x;
                const downY = e.clientY - root.y;
                const box = viewBox(viewUpdater.v_matrix, shape2);
                if (downX < box.left || downX > box.right || downY < box.top || downY > box.bottom) {
                    nextTick(() => {
                        isMenu.value = true;
                    });
                }
            } else if (e.button === 0) {
                isDragging = false;
                downXY.x = e.clientX;
                downXY.y = e.clientY;
                if (preview2.value && spacePressed.value) {
                    preview2.value.style.cursor = "grabbing";
                }
            }
            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        function onMouseMove(e) {
            if (e.buttons == 1 && spacePressed.value) {
                pageViewDragging(e);
                if (preview2.value) {
                    preview2.value.style.cursor = "grabbing";
                }
            } else if (e.button === 0) {
                let hover_shape = search22(e);
                hover_shape = getScrollShape(hover_shape);
                if (!hover_shape) {
                    pageViewDragging(e);
                } else {
                    let dx = e.clientX - downXY.x;
                    let dy = e.clientY - downXY.y;
                    const diff = Math.hypot(dx, dy);
                    if (diff > 4) {
                        atrboard = hover_shape;
                        const scale = viewUpdater.v_matrix.m00;
                        let scroll = scrollAtrboard(atrboard, { x: e.movementX / scale, y: e.movementY / scale });
                        let p_x = hover_shape.parent;
                        p_x = getScrollShape(p_x);
                        while (p_x && p_x.type !== Vt.Page && !scroll.x) {
                            scroll.x = scrollAtrboard(p_x, { x: e.movementX / scale, y: 0 }).x;
                            p_x = p_x.parent;
                        }
                        let p_y = hover_shape.parent;
                        p_y = getScrollShape(p_y);
                        while (p_y && p_y.type !== Vt.Page && !scroll.y) {
                            scroll.y = scrollAtrboard(p_y, { x: 0, y: e.movementY / scale }).y;
                            p_y = p_y.parent;
                        }
                        pageViewDragging(e, scroll);
                    }
                }
            }
        }
        const pageViewDragging = (e, scroll) => {
            if (!preview2.value) return;
            const root = preview2.value.getBoundingClientRect();
            let dx = e.clientX - downXY.x;
            let dy = e.clientY - downXY.y;
            const bound = viewUpdater.getBoundingOnView();
            const left2 = bound.left;
            const top2 = bound.top;
            const right = bound.right;
            const bottom = bound.bottom;
            if (left2 < 0) {
                if (-left2 < dx) dx = -left2;
            }
            if (left2 >= 0 && dx > 0) dx = 0;
            if (top2 < 0) {
                if (-top2 < dy) dy = -top2;
            }
            if (top2 >= 0 && dy > 0) dy = 0;
            if (right > root.width) {
                if (root.width - right > dx) dx = root.width - right;
            }
            if (right <= root.width && dx < 0) dx = 0;
            if (bottom > root.height) {
                if (root.height - bottom > dy) dy = root.height - bottom;
            }
            if (bottom <= root.height && dy < 0) dy = 0;
            if (scroll) {
                if (scroll.x) dx = 0;
                if (scroll.y) dy = 0;
            }
            const matrix = viewUpdater.v_matrix;
            if (isDragging) {
                matrix.trans(dx, dy);
                downXY.x = e.clientX;
                downXY.y = e.clientY;
            } else {
                const diff = Math.hypot(dx, dy);
                if (diff > 4) {
                    isDragging = true;
                    matrix.trans(dx, dy);
                    downXY.x = e.clientX;
                    downXY.y = e.clientY;
                }
            }
            viewUpdater.setAttri(matrix);
        };
        const getCurLayerShape = (id) => {
            const page = props.context.selection.selectedPage;
            const shapes = getFrameList(page);
            return shapes.find((item) => item.id === id);
        };
        function onMouseUp(e) {
            if (e.button !== 0) {
                return;
            }
            if (e.button === 0 && !isDragging) {
                const dx = e.clientX - downXY.x;
                const dy = e.clientY - downXY.y;
                const diff = Math.hypot(dx, dy);
                const isHot = localStorage.getItem("proto_hot_zone") ?? "true";
                if (diff < 4 && isHot === "true") {
                    const select_shape = props.context.selection.selectedShapes[0];
                    isSuperposed.value ? end_matrix.value : viewUpdater.v_matrix;
                    const shape2 = isSuperposed.value ? target_shapes.at(-1) : select_shape;
                    if (!shape2) return;
                }
            }
            if (spacePressed.value) {
                isDragging = false;
                if (preview2.value) {
                    preview2.value.style.cursor = "grab";
                }
            } else if (isSuperposed.value) {
                const h_shape = search2(e);
                if (!h_shape) {
                    const shape2 = target_shapes[target_shapes.length - 1];
                    const end_action = props.context.preview.endAction;
                    const swap_end_action = props.context.preview.swapEndAction;
                    if (end_action.navigationType === Lt.SWAP) {
                        const s = getCurLayerShape(swap_end_action.targetNodeID);
                        if (s && s.overlayBackgroundInteraction === Tt.CLOSEONCLICKOUTSIDE) {
                            props.context.preview.deleteEndAction();
                        }
                    } else {
                        if (shape2.overlayBackgroundInteraction === Tt.CLOSEONCLICKOUTSIDE) {
                            props.context.preview.deleteEndAction();
                        }
                    }
                }
            }
            isDragging = false;
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
        }
        const isSpacePressed = () => {
            const shape2 = props.context.selection.selectedShapes[0];
            if (!preview2.value || !shape2) return;
            const root = preview2.value.getBoundingClientRect();
            const frame2 = shape2.frame;
            const matrix = viewUpdater.v_matrix;
            const points = [[0, 0], [frame2.width, 0], [frame2.width, frame2.height], [0, frame2.height]].map((p2) => matrix.computeCoord(p2[0], p2[1]));
            const box = Rp(points);
            const width = box.right - box.left;
            const height = box.bottom - box.top;
            return width > root.width || height > root.height;
        };
        function onKeyDown(e) {
            if (e.target instanceof HTMLInputElement) return;
            if (e.repeat || !preview2.value) return;
            if (e.code === "Space") {
                if (spacePressed.value || !isSpacePressed()) return;
                spacePressed.value = true;
                props.context.workspace.pageDragging(true);
                preview2.value.style.cursor = "grab";
            }
        }
        function onKeyUp(e) {
            if (e.target instanceof HTMLInputElement || !preview2.value) return;
            if (spacePressed.value && e.code === "Space") {
                spacePressed.value = false;
                props.context.workspace.pageDragging(false);
                preview2.value.style.cursor = "default";
            }
        }
        const onMouseMove_CV = (e) => {
            var _a2;
            if (e.buttons === 0 && !spacePressed.value) {
                event = e;
                search2(e);
                const h_shape = props.context.selection.hoveredShape;
                if (preview2.value && !spacePressed.value) {
                    if (h_shape && ((_a2 = h_shape.prototypeInterActions) == null ? void 0 : _a2.length)) {
                        preview2.value.style.cursor = "pointer";
                    } else {
                        preview2.value.style.cursor = "default";
                    }
                }
            }
        };
        function search2(e) {
            const shapes = props.context.selection.selectedShapes[0];
            const page = props.context.selection.selectedPage;
            if (!preview2.value || !shapes || !page) return;
            const scout2 = props.context.selection.scout;
            const { x: x2, y: y2 } = preview2.value.getBoundingClientRect();
            const xy = { x: e.clientX - x2, y: e.clientY - y2 };
            let hover_shape;
            if (isSuperposed.value) {
                if (target_shapes.length) {
                    const shape2 = target_shapes[target_shapes.length - 1];
                    const m2 = end_matrix.value;
                    if (m2) {
                        hover_shape = finderShape(m2, scout2, [shape2], xy);
                    }
                }
            } else {
                hover_shape = finderShape(viewUpdater.v_matrix, scout2, [shapes], xy);
            }
            const actions = hover_shape == null ? void 0 : hover_shape.prototypeInterActions;
            if (hover_shape && !actions || hover_shape && actions.length === 0) {
                let p2 = hover_shape.parent;
                while (p2 && p2.type !== Vt.Page) {
                    if (p2.prototypeInterActions && p2.prototypeInterActions.length) {
                        selectShapes(props.context, p2);
                        break;
                    } else {
                        p2 = p2.parent;
                    }
                }
                if (p2 && p2.type === Vt.Page) {
                    return selectShapes(props.context, void 0);
                }
            } else {
                selectShapes(props.context, hover_shape);
            }
            return hover_shape;
        }
        function search22(e) {
            const shapes = props.context.selection.selectedShapes[0];
            const page = props.context.selection.selectedPage;
            if (!preview2.value || !shapes || !page) return;
            const scout2 = props.context.selection.scout;
            const { x: x2, y: y2 } = preview2.value.getBoundingClientRect();
            const xy = { x: e.clientX - x2, y: e.clientY - y2 };
            let hover_shape;
            if (isSuperposed.value) {
                if (target_shapes.length) {
                    const shape2 = target_shapes[target_shapes.length - 1];
                    const m2 = end_matrix.value;
                    if (m2) {
                        hover_shape = finderShape(m2, scout2, [shape2], xy);
                    }
                }
            } else {
                hover_shape = finderShape(viewUpdater.v_matrix, scout2, [shapes], xy);
            }
            return hover_shape;
        }
        const updateSearch = (e) => {
            const hover_shape = search22(e || event);
            if (hover_shape) {
                const actions = hover_shape == null ? void 0 : hover_shape.prototypeInterActions;
                if (hover_shape && !actions || hover_shape && actions.length === 0) {
                    let p2 = hover_shape.parent;
                    if (p2 && p2.type === Vt.Page) {
                        return;
                    }
                    while (p2 && p2.type !== Vt.Page) {
                        if (p2.prototypeInterActions && p2.prototypeInterActions.length) {
                            props.context.selection.previewHoverShape(p2);
                            break;
                        } else {
                            p2 = p2.parent;
                        }
                    }
                } else {
                    props.context.selection.previewHoverShape(hover_shape);
                }
            }
        };
        const getTargetShapes = () => {
            target_shapes = [];
            renderCard.value = false;
            const page = props.context.selection.selectedPage;
            const shapes = getFrameList(page);
            const actions = props.context.preview.interactionAction;
            const selectShape = props.context.selection.selectedShapes[0];
            if (!selectShape) return;
            isSuperposed.value = false;
            is_swap_shape.value = false;
            props.context.preview.setSupernatantIsOpen(false);
            if (actions.size === 0) return;
            const render_shapes = [];
            actions.forEach((action) => {
                const shape2 = shapes.find((item) => item.id === action.targetNodeID);
                if (shape2) {
                    render_shapes.push(shape2);
                }
            });
            target_shapes = toRaw(render_shapes);
            renderCard.value = true;
            const box = viewBox(viewUpdater.v_matrix, selectShape);
            watch_shapes();
            nextTick(() => {
                const protoActions = Array.from(actions.values());
                const els = document.querySelectorAll(".dailogCard");
                for (let i = 0; i < protoActions.length; i++) {
                    const action = protoActions[i];
                    const shape2 = shapes.find((item) => item.id === action.targetNodeID);
                    if (shape2) {
                        if (action.navigationType === Lt.OVERLAY && viewBoxDialog.value) {
                            isSuperposed.value = true;
                            props.context.preview.setSupernatantIsOpen(true);
                            if (shape2.overlayBackgroundAppearance) {
                                if (shape2.overlayBackgroundAppearance.backgroundType === It.SOLIDCOLOR) {
                                    const color2 = shape2.overlayBackgroundAppearance.backgroundColor;
                                    if (viewBoxDialog.value[i]) {
                                        viewBoxDialog.value[i].style.backgroundColor = `rgba(${color2.red}, ${color2.green}, ${color2.blue}, ${color2.alpha})`;
                                    }
                                }
                            }
                        } else if (action.navigationType === Lt.SWAP && viewBoxDialog.value) {
                            isSuperposed.value = true;
                            is_swap_shape.value = true;
                            props.context.preview.setSupernatantIsOpen(true);
                            const before_action = props.context.preview.swapEndAction;
                            if (!before_action) continue;
                            const s = shapes.find((item) => item.id === before_action.targetNodeID);
                            if (!s) continue;
                            if (s.overlayBackgroundAppearance) {
                                if (s.overlayBackgroundAppearance.backgroundType === It.SOLIDCOLOR) {
                                    const color2 = s.overlayBackgroundAppearance.backgroundColor;
                                    if (viewBoxDialog.value[i]) {
                                        viewBoxDialog.value[i].style.backgroundColor = `rgba(${color2.red}, ${color2.green}, ${color2.blue}, ${color2.alpha})`;
                                    }
                                }
                            }
                        }
                        const m2 = viewUpdater.updateViewBox(props.context, shape2, action.navigationType, box);
                        const el2 = els[i];
                        if (m2) {
                            if (i === els.length - 1) {
                                viewUpdater.slideAndshiftOutAnimate(action);
                                viewUpdater.dissolveAnimate(action, els, 0);
                                viewUpdater.shiftInAnimate(action, els);
                                viewUpdater.pushAndslideInAnimate(action, els);
                                const ready_m = viewUpdater.readyPosition(m2, shape2, action.transitionType);
                                el2.style["transform"] = ready_m.toString();
                                end_matrix.value = m2;
                                setTimeout(() => {
                                    el2.style["transform"] = m2.toString();
                                    viewUpdater.pageSvgSlideAnimate(action);
                                    viewUpdater.pageSvgPushAnimate(action);
                                    viewUpdater.dissolveAnimate(action, els, 1);
                                    if (event) search2(event);
                                });
                            } else {
                                el2.style["transform"] = m2.toString();
                            }
                        }
                    }
                }
            });
        };
        const backTargetShape = (s) => {
            target_shapes = [];
            renderCard.value = false;
            const page = props.context.selection.selectedPage;
            const shapes = getFrameList(page);
            const actions = props.context.preview.interactionAction;
            const selectShape = props.context.selection.selectedShapes[0];
            if (!selectShape) return;
            isSuperposed.value = false;
            is_swap_shape.value = false;
            props.context.preview.setSupernatantIsOpen(false);
            const protoActions = Array.from(actions.values());
            if (actions.size === 0) return;
            const render_shapes = [];
            protoActions.forEach((action, index2) => {
                let shape2 = shapes.find((item) => item.id === action.targetNodeID);
                if (protoActions.length - 1 === index2) {
                    shape2 = shapes.find((item) => item.id === s);
                }
                if (shape2) {
                    render_shapes.push(shape2);
                }
            });
            target_shapes = toRaw(render_shapes);
            renderCard.value = true;
            const box = viewBox(viewUpdater.v_matrix, selectShape);
            watch_shapes();
            nextTick(() => {
                const els = document.querySelectorAll(".dailogCard");
                for (let i = 0; i < protoActions.length; i++) {
                    const action = protoActions[i];
                    const shape2 = target_shapes[i];
                    if (shape2) {
                        const m2 = viewUpdater.updateViewBox(props.context, shape2, action.navigationType, box);
                        const el2 = els[i];
                        if (m2) {
                            if (i === els.length - 1) {
                                viewUpdater.backShiftOutAnimate(action, els);
                                viewUpdater.backSlideInAnimate(action, els);
                                viewUpdater.backSlideOutAnimate(action, els);
                                const ready_m = viewUpdater.backReadyPosition(m2, shape2, action.transitionType);
                                el2.style["transform"] = ready_m.toString();
                                end_matrix.value = m2;
                                viewUpdater.backShiftInAnimate(action);
                                viewUpdater.backDissolveAnimate(action, els);
                                viewUpdater.backPushInAnimate(action, els);
                                setTimeout(() => {
                                    el2.style["transform"] = m2.toString();
                                    viewUpdater.backPushAnimate(action);
                                    if (event) search2(event);
                                });
                            } else {
                                el2.style["transform"] = m2.toString();
                            }
                        }
                    }
                }
            });
        };
        const onMouseEnter = () => {
            document.addEventListener("keydown", onKeyDown);
            document.addEventListener("keyup", onKeyUp);
        };
        const onMouseLeave = () => {
            document.removeEventListener("keydown", onKeyDown);
            document.removeEventListener("keyup", onKeyUp);
        };
        const viewUpdater = new ViewUpdater(props.context);
        const is_overlay = ref(true);
        function startLoop() {
            var _a2;
            const dom = props.context.getPageDom(props.page);
            if (dom && ((_a2 = pageCard.value) == null ? void 0 : _a2.pageSvg)) {
                dom.ctx.loop(window.requestAnimationFrame);
            }
        }
        const updateDialogMatrix = () => {
            const page = props.context.selection.selectedPage;
            const selectShape = props.context.selection.selectedShapes[0];
            if (!selectShape) return;
            const els = document.querySelectorAll(".dailogCard");
            const box = viewBox(viewUpdater.v_matrix, selectShape);
            const shapes = getFrameList(page);
            const protoActions = Array.from(props.context.preview.interactionAction.values());
            for (let i = 0; i < els.length; i++) {
                const action = protoActions[i];
                if (!action) continue;
                const shape2 = shapes.find((item) => item.id === action.targetNodeID);
                if (!shape2) continue;
                const el2 = els[i];
                const m2 = viewUpdater.updateViewBox(props.context, shape2, action.navigationType, box);
                if (m2) {
                    el2.style["transform"] = m2.toString();
                    if (i === els.length - 1) {
                        end_matrix.value = m2;
                    }
                }
            }
        };
        const shapeChange = (...args) => {
            if (args.includes("layout")) {
                page_watcher();
            }
        };
        const watchedShapes = /* @__PURE__ */ new Map();
        function watch_shapes() {
            watchedShapes.forEach((v2, k) => {
                v2.unwatch(shapeChange);
                watchedShapes.delete(k);
            });
            const selectedShapes = [...props.context.selection.selectedShapes, ...target_shapes];
            selectedShapes.forEach((v2) => {
                v2.watch(shapeChange);
                watchedShapes.set(v2.id, v2);
            });
        }
        onMounted(() => {
            var _a2;
            props.context.preview.watch(previewWatcher);
            props.context.selection.watch(selectionWatcher);
            watch_shapes();
            page_watcher();
            nextTick(() => {
                watch_shapes();
                viewUpdater.mount(preview2.value, props.context.selection.selectedPage.data, props.context.selection.selectedShapes[0], pageCard.value);
            });
            const dom = props.context.getPageDom(props.page);
            const svg = (_a2 = pageCard.value) == null ? void 0 : _a2.pageSvg;
            if (dom && svg) {
                dom.dom.bind(svg);
                dom.ctx.layoutAll();
                dom.dom.render();
                dom.ctx.loop(window.requestAnimationFrame);
            }
            if (preview2.value) observer.observe(preview2.value);
        });
        onUnmounted(() => {
            var _a2;
            observer.disconnect();
            (_a2 = props.context.selection.scout) == null ? void 0 : _a2.remove();
            props.context.preview.unwatch(previewWatcher);
            props.context.selection.unwatch(selectionWatcher);
            document.removeEventListener("keydown", onKeyDown);
            document.removeEventListener("keyup", onKeyUp);
            sessionStorage.removeItem(rc);
            viewUpdater.atTarget();
            viewUpdater.atPage();
            watchedShapes.forEach((v2) => {
                v2.unwatch(shapeChange);
            });
            const dom = props.context.getPageDom(props.page);
            if (dom) {
                dom.ctx.stopLoop();
                dom.ctx.updateFocusShape(void 0);
                dom.dom.unbind();
            }
        });
        return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
                class: "preview_container",
                ref_key: "preview",
                ref: preview2,
                onWheel: onMouseWheel,
                onMousedown: onMouseDown,
                onMouseenter: onMouseEnter,
                onMouseleave: onMouseLeave,
                onMousemove: onMouseMove_CV
            }, [
                createVNode(PageCard, {
                    class: "pageCard",
                    ref_key: "pageCard",
                    ref: pageCard,
                    "background-color": "transparent",
                    context: _ctx.context,
                    data: unref(cur_shape)[0],
                    shapes: unref(cur_shape),
                    onStartLoop: startLoop,
                    selected: true
                }, null, 8, ["context", "data", "shapes"]),
                renderCard.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(target_shapes), (item) => {
                    return openBlock(), createElementBlock("div", {
                        ref_for: true,
                        ref_key: "viewBoxDialog",
                        ref: viewBoxDialog,
                        id: "proto_overflow"
                    }, [
                        (openBlock(), createBlock(PageCard, {
                            key: item.id,
                            class: "dailogCard",
                            ref_for: true,
                            ref: "dailogCard",
                            "background-color": "transparent",
                            data: item,
                            context: _ctx.context,
                            shapes: unref(target_shapes)
                        }, null, 8, ["data", "context", "shapes"]))
                    ], 512);
                }), 256)) : createCommentVNode("", true),
                (openBlock(), createElementBlock("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    ref_key: "symrefAnimate",
                    ref: symrefAnimate,
                    class: "symref_animate",
                    preserveAspectRatio: "xMinYMin meet",
                    viewBox: "0 0 100 100",
                    width: "100",
                    height: "100"
                }, null, 512)),
                createVNode(_sfc_main$3, {
                    context: _ctx.context,
                    matrix: isSuperposed.value ? end_matrix.value : unref(viewUpdater).v_matrix,
                    onUpdateSearch: updateSearch
                }, null, 8, ["context", "matrix"]),
                is_overlay.value ? (openBlock(), createElementBlock("div", _hoisted_1$2)) : createCommentVNode("", true),
                unref(cur_shape) ? (openBlock(), createElementBlock("div", _hoisted_2)) : createCommentVNode("", true)
            ], 544);
        };
    }
});
const PreviewContent = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-d97f6210"]]);
const _hoisted_1$1 = {
    class: "main",
    style: { "height": "100vh" }
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
    __name: "App",
    setup(__props) {
        const context = shallowRef(void 0);
        const pageView = shallowRef(void 0);
        async function initContext() {
            await initpal();
            const __context = await parserDocument();
            if (__context) {
                const config = await fetchConfig();
                if (!config) return message$2("danger", "无法获取配置文件，请尝试重新打包下载");
                const page = await __context.data.pagesMgr.get(config.pageId);
                if (!page) return message$2("danger", "包异常，请尝试重新打包下载");
                pageView.value = __context.getPageDom(page).dom;
                __context.selection.selectPage(pageView.value);
                const home2 = pageView.value.getShape(config.boardId);
                if (!home2) return message$2("danger", "无法获取首页，请尝试重新打包下载");
                window.__home = () => {
                    __context.selection.selectShape(home2);
                };
                __context.selection.selectShape(home2);
                context.value = __context;
            } else {
                message$2("danger", "包解析失败，请尝试重新打包下载");
            }
        }
        onBeforeMount(initContext);
        return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$1, [
                context.value && pageView.value ? (openBlock(), createBlock(PreviewContent, {
                    key: 0,
                    id: "content",
                    context: context.value,
                    page: pageView.value
                }, null, 8, ["context", "page"])) : createCommentVNode("", true)
            ]);
        };
    }
});
const _hoisted_1 = ["xlink:href"];
const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "SvgIcon",
    props: {
        iconClass: {},
        className: {}
    },
    setup(__props) {
        const props = __props;
        const iconName = computed(() => {
            return `#icon-${props.iconClass}`;
        });
        const svgClass = computed(() => {
            if (props.className) {
                return "svg-icon " + props.className;
            } else {
                return "svg-icon";
            }
        });
        return (_ctx, _cache) => {
            return openBlock(), createElementBlock("svg", {
                class: normalizeClass(svgClass.value),
                "aria-hidden": "true"
            }, [
                createBaseVNode("use", { "xlink:href": iconName.value }, null, 8, _hoisted_1)
            ], 2);
        };
    }
});
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale2, key, source) => friendlyJSONstringify({ l: locale2, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {});
};
function escapeHtml(rawText) {
    return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
    return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
    if (!isObject$1(val))
        return false;
    const proto = Object.getPrototypeOf(val);
    return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
    return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
    return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
    let current = code2;
    return () => ++current;
}
function warn(msg, err) {
    if (typeof console !== "undefined") {
        console.warn(`[intlify] ` + msg);
        if (err) {
            console.warn(err.stack);
        }
    }
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
        throw new Error("Invalid value");
    }
    const stack2 = [{ src, des }];
    while (stack2.length) {
        const { src: src2, des: des2 } = stack2.pop();
        Object.keys(src2).forEach((key) => {
            if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
                des2[key] = src2[key];
            } else {
                stack2.push({ src: src2[key], des: des2[key] });
            }
        });
    }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
    return { line, column, offset };
}
function createLocation(start2, end2, source) {
    const loc = { start: start2, end: end2 };
    return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message2, ...args) {
    if (args.length === 1 && isObject(args[0])) {
        args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
        args = {};
    }
    return message2.replace(RE_ARGS, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : "";
    });
}
const assign = Object.assign;
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
    return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
};
const warnMessages = {
    [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
    const msg = format$1(warnMessages[code2], ...args || []);
    const message2 = { message: String(msg), code: code2 };
    if (loc) {
        message2.location = loc;
    }
    return message2;
}
const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // generator error codes
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    // minifier error codes
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 17
};
const errorMessages = {
    // tokenizer error messages
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    // parser error messages
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
    // generator error messages
    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
    // minimizer error messages
    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
    const { domain, messages, args } = options;
    const msg = format$1((messages || errorMessages)[code2] || "", ...args || []);
    const error = new SyntaxError(String(msg));
    error.code = code2;
    if (loc) {
        error.location = loc;
    }
    error.domain = domain;
    return error;
}
function defaultOnError(error) {
    throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
    const isLF = (index3) => _buf[index3] === CHAR_LF;
    const isPS = (index3) => _buf[index3] === CHAR_PS;
    const isLS = (index3) => _buf[index3] === CHAR_LS;
    const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
    const index2 = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
            _line++;
            _column = 0;
        }
        if (isCRLF(_index)) {
            _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
    }
    function peek() {
        if (isCRLF(_index + _peekOffset)) {
            _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
    }
    function reset() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
        _peekOffset = offset;
    }
    function skipToPeek() {
        const target = _index + _peekOffset;
        while (target !== _index) {
            next();
        }
        _peekOffset = 0;
    }
    return {
        index: index2,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset,
        resetPeek,
        skipToPeek
    };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
    const location = options.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
        currentType: 14,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ""
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code2, pos, offset, ...args) {
        const ctx = context();
        pos.column += offset;
        pos.offset += offset;
        if (onError) {
            const loc = location ? createLocation(ctx.startLoc, pos) : null;
            const err = createCompileError(code2, loc, {
                domain: ERROR_DOMAIN$3,
                args
            });
            onError(err);
        }
    }
    function getToken(context2, type, value) {
        context2.endLoc = currentPosition();
        context2.currentType = type;
        const token = { type };
        if (location) {
            token.loc = createLocation(context2.startLoc, context2.endLoc);
        }
        if (value != null) {
            token.value = value;
        }
        return token;
    }
    const getEndToken = (context2) => getToken(
        context2,
        14
        /* TokenTypes.EOF */
    );
    function eat(scnr, ch2) {
        if (scnr.currentChar() === ch2) {
            scnr.next();
            return ch2;
        } else {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
            return "";
        }
    }
    function peekSpaces(scnr) {
        let buf = "";
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
            buf += scnr.currentPeek();
            scnr.peek();
        }
        return buf;
    }
    function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
    }
    function isIdentifierStart(ch2) {
        if (ch2 === EOF) {
            return false;
        }
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 97 && cc2 <= 122 || // a-z
            cc2 >= 65 && cc2 <= 90 || // A-Z
            cc2 === 95;
    }
    function isNumberStart(ch2) {
        if (ch2 === EOF) {
            return false;
        }
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 48 && cc2 <= 57;
    }
    function isNamedIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isListIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
            return false;
        }
        peekSpaces(scnr);
        const ch2 = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch2);
        scnr.resetPeek();
        return ret;
    }
    function isLiteralStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDotStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 8) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ".";
        scnr.resetPeek();
        return ret;
    }
    function isLinkedModifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 9) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDelimiterStart(scnr, context2) {
        const { currentType } = context2;
        if (!(currentType === 8 || currentType === 12)) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":";
        scnr.resetPeek();
        return ret;
    }
    function isLinkedReferStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 10) {
            return false;
        }
        const fn2 = () => {
            const ch2 = scnr.currentPeek();
            if (ch2 === "{") {
                return isIdentifierStart(scnr.peek());
            } else if (ch2 === "@" || ch2 === "%" || ch2 === "|" || ch2 === ":" || ch2 === "." || ch2 === CHAR_SP || !ch2) {
                return false;
            } else if (ch2 === CHAR_LF) {
                scnr.peek();
                return fn2();
            } else {
                return isTextStart(scnr, false);
            }
        };
        const ret = fn2();
        scnr.resetPeek();
        return ret;
    }
    function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|";
        scnr.resetPeek();
        return ret;
    }
    function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
        scnr.resetPeek();
        return {
            isModulo: ret,
            hasSpace: spaces.length > 0
        };
    }
    function isTextStart(scnr, reset = true) {
        const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
            const ch2 = scnr.currentPeek();
            if (ch2 === "{") {
                return prev === "%" ? false : hasSpace;
            } else if (ch2 === "@" || !ch2) {
                return prev === "%" ? true : hasSpace;
            } else if (ch2 === "%") {
                scnr.peek();
                return fn2(hasSpace, "%", true);
            } else if (ch2 === "|") {
                return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
            } else if (ch2 === CHAR_SP) {
                scnr.peek();
                return fn2(true, CHAR_SP, detectModulo);
            } else if (ch2 === CHAR_LF) {
                scnr.peek();
                return fn2(true, CHAR_LF, detectModulo);
            } else {
                return true;
            }
        };
        const ret = fn2();
        reset && scnr.resetPeek();
        return ret;
    }
    function takeChar(scnr, fn2) {
        const ch2 = scnr.currentChar();
        if (ch2 === EOF) {
            return EOF;
        }
        if (fn2(ch2)) {
            scnr.next();
            return ch2;
        }
        return null;
    }
    function isIdentifier(ch2) {
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 97 && cc2 <= 122 || // a-z
            cc2 >= 65 && cc2 <= 90 || // A-Z
            cc2 >= 48 && cc2 <= 57 || // 0-9
            cc2 === 95 || // _
            cc2 === 36;
    }
    function takeIdentifierChar(scnr) {
        return takeChar(scnr, isIdentifier);
    }
    function isNamedIdentifier(ch2) {
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 97 && cc2 <= 122 || // a-z
            cc2 >= 65 && cc2 <= 90 || // A-Z
            cc2 >= 48 && cc2 <= 57 || // 0-9
            cc2 === 95 || // _
            cc2 === 36 || // $
            cc2 === 45;
    }
    function takeNamedIdentifierChar(scnr) {
        return takeChar(scnr, isNamedIdentifier);
    }
    function isDigit(ch2) {
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 48 && cc2 <= 57;
    }
    function takeDigit(scnr) {
        return takeChar(scnr, isDigit);
    }
    function isHexDigit(ch2) {
        const cc2 = ch2.charCodeAt(0);
        return cc2 >= 48 && cc2 <= 57 || // 0-9
            cc2 >= 65 && cc2 <= 70 || // A-F
            cc2 >= 97 && cc2 <= 102;
    }
    function takeHexDigit(scnr) {
        return takeChar(scnr, isHexDigit);
    }
    function getDigits(scnr) {
        let ch2 = "";
        let num = "";
        while (ch2 = takeDigit(scnr)) {
            num += ch2;
        }
        return num;
    }
    function readModulo(scnr) {
        skipSpaces(scnr);
        const ch2 = scnr.currentChar();
        if (ch2 !== "%") {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
        }
        scnr.next();
        return "%";
    }
    function readText(scnr) {
        let buf = "";
        while (true) {
            const ch2 = scnr.currentChar();
            if (ch2 === "{" || ch2 === "}" || ch2 === "@" || ch2 === "|" || !ch2) {
                break;
            } else if (ch2 === "%") {
                if (isTextStart(scnr)) {
                    buf += ch2;
                    scnr.next();
                } else {
                    break;
                }
            } else if (ch2 === CHAR_SP || ch2 === CHAR_LF) {
                if (isTextStart(scnr)) {
                    buf += ch2;
                    scnr.next();
                } else if (isPluralStart(scnr)) {
                    break;
                } else {
                    buf += ch2;
                    scnr.next();
                }
            } else {
                buf += ch2;
                scnr.next();
            }
        }
        return buf;
    }
    function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch2 = "";
        let name = "";
        while (ch2 = takeNamedIdentifierChar(scnr)) {
            name += ch2;
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
    }
    function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = "";
        if (scnr.currentChar() === "-") {
            scnr.next();
            value += `-${getDigits(scnr)}`;
        } else {
            value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
    }
    function isLiteral2(ch2) {
        return ch2 !== LITERAL_DELIMITER && ch2 !== CHAR_LF;
    }
    function readLiteral(scnr) {
        skipSpaces(scnr);
        eat(scnr, `'`);
        let ch2 = "";
        let literal = "";
        while (ch2 = takeChar(scnr, isLiteral2)) {
            if (ch2 === "\\") {
                literal += readEscapeSequence(scnr);
            } else {
                literal += ch2;
            }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
            if (current === CHAR_LF) {
                scnr.next();
                eat(scnr, `'`);
            }
            return literal;
        }
        eat(scnr, `'`);
        return literal;
    }
    function readEscapeSequence(scnr) {
        const ch2 = scnr.currentChar();
        switch (ch2) {
            case "\\":
            case `'`:
                scnr.next();
                return `\\${ch2}`;
            case "u":
                return readUnicodeEscapeSequence(scnr, ch2, 4);
            case "U":
                return readUnicodeEscapeSequence(scnr, ch2, 6);
            default:
                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch2);
                return "";
        }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = "";
        for (let i = 0; i < digits; i++) {
            const ch2 = takeHexDigit(scnr);
            if (!ch2) {
                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
                break;
            }
            sequence += ch2;
        }
        return `\\${unicode}${sequence}`;
    }
    function isInvalidIdentifier(ch2) {
        return ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
    }
    function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch2 = "";
        let identifiers = "";
        while (ch2 = takeChar(scnr, isInvalidIdentifier)) {
            identifiers += ch2;
        }
        return identifiers;
    }
    function readLinkedModifier(scnr) {
        let ch2 = "";
        let name = "";
        while (ch2 = takeIdentifierChar(scnr)) {
            name += ch2;
        }
        return name;
    }
    function readLinkedRefer(scnr) {
        const fn2 = (buf) => {
            const ch2 = scnr.currentChar();
            if (ch2 === "{" || ch2 === "%" || ch2 === "@" || ch2 === "|" || ch2 === "(" || ch2 === ")" || !ch2) {
                return buf;
            } else if (ch2 === CHAR_SP) {
                return buf;
            } else if (ch2 === CHAR_LF || ch2 === DOT) {
                buf += ch2;
                scnr.next();
                return fn2(buf);
            } else {
                buf += ch2;
                scnr.next();
                return fn2(buf);
            }
        };
        return fn2("");
    }
    function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(
            scnr,
            "|"
            /* TokenChars.Pipe */
        );
        skipSpaces(scnr);
        return plural;
    }
    function readTokenInPlaceholder(scnr, context2) {
        let token = null;
        const ch2 = scnr.currentChar();
        switch (ch2) {
            case "{":
                if (context2.braceNest >= 1) {
                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(
                    context2,
                    2,
                    "{"
                    /* TokenChars.BraceLeft */
                );
                skipSpaces(scnr);
                context2.braceNest++;
                return token;
            case "}":
                if (context2.braceNest > 0 && context2.currentType === 2) {
                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(
                    context2,
                    3,
                    "}"
                    /* TokenChars.BraceRight */
                );
                context2.braceNest--;
                context2.braceNest > 0 && skipSpaces(scnr);
                if (context2.inLinked && context2.braceNest === 0) {
                    context2.inLinked = false;
                }
                return token;
            case "@":
                if (context2.braceNest > 0) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = readTokenInLinked(scnr, context2) || getEndToken(context2);
                context2.braceNest = 0;
                return token;
            default: {
                let validNamedIdentifier = true;
                let validListIdentifier = true;
                let validLiteral = true;
                if (isPluralStart(scnr)) {
                    if (context2.braceNest > 0) {
                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    }
                    token = getToken(context2, 1, readPlural(scnr));
                    context2.braceNest = 0;
                    context2.inLinked = false;
                    return token;
                }
                if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    context2.braceNest = 0;
                    return readToken(scnr, context2);
                }
                if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
                    token = getToken(context2, 5, readNamedIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
                    token = getToken(context2, 6, readListIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (validLiteral = isLiteralStart(scnr, context2)) {
                    token = getToken(context2, 7, readLiteral(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                    token = getToken(context2, 13, readInvalidIdentifier(scnr));
                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                    skipSpaces(scnr);
                    return token;
                }
                break;
            }
        }
        return token;
    }
    function readTokenInLinked(scnr, context2) {
        const { currentType } = context2;
        let token = null;
        const ch2 = scnr.currentChar();
        if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch2 === CHAR_LF || ch2 === CHAR_SP)) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch2) {
            case "@":
                scnr.next();
                token = getToken(
                    context2,
                    8,
                    "@"
                    /* TokenChars.LinkedAlias */
                );
                context2.inLinked = true;
                return token;
            case ".":
                skipSpaces(scnr);
                scnr.next();
                return getToken(
                    context2,
                    9,
                    "."
                    /* TokenChars.LinkedDot */
                );
            case ":":
                skipSpaces(scnr);
                scnr.next();
                return getToken(
                    context2,
                    10,
                    ":"
                    /* TokenChars.LinkedDelimiter */
                );
            default:
                if (isPluralStart(scnr)) {
                    token = getToken(context2, 1, readPlural(scnr));
                    context2.braceNest = 0;
                    context2.inLinked = false;
                    return token;
                }
                if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
                    skipSpaces(scnr);
                    return readTokenInLinked(scnr, context2);
                }
                if (isLinkedModifierStart(scnr, context2)) {
                    skipSpaces(scnr);
                    return getToken(context2, 12, readLinkedModifier(scnr));
                }
                if (isLinkedReferStart(scnr, context2)) {
                    skipSpaces(scnr);
                    if (ch2 === "{") {
                        return readTokenInPlaceholder(scnr, context2) || token;
                    } else {
                        return getToken(context2, 11, readLinkedRefer(scnr));
                    }
                }
                if (currentType === 8) {
                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
                }
                context2.braceNest = 0;
                context2.inLinked = false;
                return readToken(scnr, context2);
        }
    }
    function readToken(scnr, context2) {
        let token = {
            type: 14
            /* TokenTypes.EOF */
        };
        if (context2.braceNest > 0) {
            return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        }
        if (context2.inLinked) {
            return readTokenInLinked(scnr, context2) || getEndToken(context2);
        }
        const ch2 = scnr.currentChar();
        switch (ch2) {
            case "{":
                return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
            case "}":
                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
                scnr.next();
                return getToken(
                    context2,
                    3,
                    "}"
                    /* TokenChars.BraceRight */
                );
            case "@":
                return readTokenInLinked(scnr, context2) || getEndToken(context2);
            default: {
                if (isPluralStart(scnr)) {
                    token = getToken(context2, 1, readPlural(scnr));
                    context2.braceNest = 0;
                    context2.inLinked = false;
                    return token;
                }
                const { isModulo, hasSpace } = detectModuloStart(scnr);
                if (isModulo) {
                    return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
                }
                if (isTextStart(scnr)) {
                    return getToken(context2, 0, readText(scnr));
                }
                break;
            }
        }
        return token;
    }
    function nextToken() {
        const { currentType, offset, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
            return getToken(
                _context,
                14
                /* TokenTypes.EOF */
            );
        }
        return readToken(_scnr, _context);
    }
    return {
        nextToken,
        currentOffset,
        currentPosition,
        context
    };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
        case `\\\\`:
            return `\\`;
        case `\\'`:
            return `'`;
        default: {
            const codePoint = parseInt(codePoint4 || codePoint6, 16);
            if (codePoint <= 55295 || codePoint >= 57344) {
                return String.fromCodePoint(codePoint);
            }
            return "�";
        }
    }
}
function createParser(options = {}) {
    const location = options.location !== false;
    const { onError, onWarn } = options;
    function emitError(tokenzer, code2, start2, offset, ...args) {
        const end2 = tokenzer.currentPosition();
        end2.offset += offset;
        end2.column += offset;
        if (onError) {
            const loc = location ? createLocation(start2, end2) : null;
            const err = createCompileError(code2, loc, {
                domain: ERROR_DOMAIN$2,
                args
            });
            onError(err);
        }
    }
    function emitWarn(tokenzer, code2, start2, offset, ...args) {
        const end2 = tokenzer.currentPosition();
        end2.offset += offset;
        end2.column += offset;
        if (onWarn) {
            const loc = location ? createLocation(start2, end2) : null;
            onWarn(createCompileWarn(code2, loc, args));
        }
    }
    function startNode(type, offset, loc) {
        const node = { type };
        if (location) {
            node.start = offset;
            node.end = offset;
            node.loc = { start: loc, end: loc };
        }
        return node;
    }
    function endNode(node, offset, pos, type) {
        if (location) {
            node.end = offset;
            if (node.loc) {
                node.loc.end = pos;
            }
        }
    }
    function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseList(tokenizer, index2) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context;
        const node = startNode(5, offset, loc);
        node.index = parseInt(index2, 10);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseNamed(tokenizer, key, modulo) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context;
        const node = startNode(4, offset, loc);
        node.key = key;
        if (modulo === true) {
            node.modulo = true;
        }
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context;
        const node = startNode(9, offset, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context;
        const node = startNode(8, offset, loc);
        if (token.type !== 12) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
            node.value = "";
            endNode(node, offset, loc);
            return {
                nextConsumeToken: token,
                node
            };
        }
        if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || "";
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node
        };
    }
    function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9) {
            const parsed = parseLinkedModifier(tokenizer);
            linkedNode.modifier = parsed.node;
            token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        if (token.type !== 10) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        if (token.type === 2) {
            token = tokenizer.nextToken();
        }
        switch (token.type) {
            case 11:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
                break;
            case 5:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseNamed(tokenizer, token.value || "");
                break;
            case 6:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseList(tokenizer, token.value || "");
                break;
            case 7:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLiteral(tokenizer, token.value || "");
                break;
            default: {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
                const nextContext = tokenizer.context();
                const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
                emptyLinkedKeyNode.value = "";
                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
                linkedNode.key = emptyLinkedKeyNode;
                endNode(linkedNode, nextContext.offset, nextContext.startLoc);
                return {
                    nextConsumeToken: token,
                    node: linkedNode
                };
            }
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node: linkedNode
        };
    }
    function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
        const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
        const node = startNode(2, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        let modulo = null;
        do {
            const token = nextToken || tokenizer.nextToken();
            nextToken = null;
            switch (token.type) {
                case 0:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseText(tokenizer, token.value || ""));
                    break;
                case 6:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseList(tokenizer, token.value || ""));
                    break;
                case 4:
                    modulo = true;
                    break;
                case 5:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
                    if (modulo) {
                        emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
                        modulo = null;
                    }
                    break;
                case 7:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseLiteral(tokenizer, token.value || ""));
                    break;
                case 8: {
                    const parsed = parseLinked(tokenizer);
                    node.items.push(parsed.node);
                    nextToken = parsed.nextConsumeToken || null;
                    break;
                }
            }
        } while (context.currentType !== 14 && context.currentType !== 1);
        const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1, offset, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
            const msg = parseMessage(tokenizer);
            if (!hasEmptyMessage) {
                hasEmptyMessage = msg.items.length === 0;
            }
            node.cases.push(msg);
        } while (context.currentType !== 14);
        if (hasEmptyMessage) {
            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14) {
            return msgNode;
        } else {
            return parsePlural(tokenizer, offset, startLoc, msgNode);
        }
    }
    function parse2(source) {
        const tokenizer = createTokenizer(source, assign({}, options));
        const context = tokenizer.context();
        const node = startNode(0, context.offset, context.startLoc);
        if (location && node.loc) {
            node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        if (options.onCacheKey) {
            node.cacheKey = options.onCacheKey(source);
        }
        if (context.currentType !== 14) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    return { parse: parse2 };
}
function getTokenCaption(token) {
    if (token.type === 14) {
        return "EOF";
    }
    const name = (token.value || "").replace(/\r?\n/gu, "\\n");
    return name.length > 10 ? name.slice(0, 9) + "…" : name;
}
function createTransformer(ast, options = {}) {
    const _context = {
        ast,
        helpers: /* @__PURE__ */ new Set()
    };
    const context = () => _context;
    const helper = (name) => {
        _context.helpers.add(name);
        return name;
    };
    return { context, helper };
}
function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
        traverseNode(nodes[i], transformer);
    }
}
function traverseNode(node, transformer) {
    switch (node.type) {
        case 1:
            traverseNodes(node.cases, transformer);
            transformer.helper(
                "plural"
                /* HelperNameMap.PLURAL */
            );
            break;
        case 2:
            traverseNodes(node.items, transformer);
            break;
        case 6: {
            const linked = node;
            traverseNode(linked.key, transformer);
            transformer.helper(
                "linked"
                /* HelperNameMap.LINKED */
            );
            transformer.helper(
                "type"
                /* HelperNameMap.TYPE */
            );
            break;
        }
        case 5:
            transformer.helper(
                "interpolate"
                /* HelperNameMap.INTERPOLATE */
            );
            transformer.helper(
                "list"
                /* HelperNameMap.LIST */
            );
            break;
        case 4:
            transformer.helper(
                "interpolate"
                /* HelperNameMap.INTERPOLATE */
            );
            transformer.helper(
                "named"
                /* HelperNameMap.NAMED */
            );
            break;
    }
}
function transform(ast, options = {}) {
    const transformer = createTransformer(ast);
    transformer.helper(
        "normalize"
        /* HelperNameMap.NORMALIZE */
    );
    ast.body && traverseNode(ast.body, transformer);
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
    const body = ast.body;
    if (body.type === 2) {
        optimizeMessageNode(body);
    } else {
        body.cases.forEach((c2) => optimizeMessageNode(c2));
    }
    return ast;
}
function optimizeMessageNode(message2) {
    if (message2.items.length === 1) {
        const item = message2.items[0];
        if (item.type === 3 || item.type === 9) {
            message2.static = item.value;
            delete item.value;
        }
    } else {
        const values = [];
        for (let i = 0; i < message2.items.length; i++) {
            const item = message2.items[i];
            if (!(item.type === 3 || item.type === 9)) {
                break;
            }
            if (item.value == null) {
                break;
            }
            values.push(item.value);
        }
        if (values.length === message2.items.length) {
            message2.static = join(values);
            for (let i = 0; i < message2.items.length; i++) {
                const item = message2.items[i];
                if (item.type === 3 || item.type === 9) {
                    delete item.value;
                }
            }
        }
    }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
    node.t = node.type;
    switch (node.type) {
        case 0: {
            const resource = node;
            minify(resource.body);
            resource.b = resource.body;
            delete resource.body;
            break;
        }
        case 1: {
            const plural = node;
            const cases = plural.cases;
            for (let i = 0; i < cases.length; i++) {
                minify(cases[i]);
            }
            plural.c = cases;
            delete plural.cases;
            break;
        }
        case 2: {
            const message2 = node;
            const items = message2.items;
            for (let i = 0; i < items.length; i++) {
                minify(items[i]);
            }
            message2.i = items;
            delete message2.items;
            if (message2.static) {
                message2.s = message2.static;
                delete message2.static;
            }
            break;
        }
        case 3:
        case 9:
        case 8:
        case 7: {
            const valueNode = node;
            if (valueNode.value) {
                valueNode.v = valueNode.value;
                delete valueNode.value;
            }
            break;
        }
        case 6: {
            const linked = node;
            minify(linked.key);
            linked.k = linked.key;
            delete linked.key;
            if (linked.modifier) {
                minify(linked.modifier);
                linked.m = linked.modifier;
                delete linked.modifier;
            }
            break;
        }
        case 5: {
            const list = node;
            list.i = list.index;
            delete list.index;
            break;
        }
        case 4: {
            const named = node;
            named.k = named.key;
            delete named.key;
            break;
        }
        default: {
            throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                domain: ERROR_DOMAIN$1,
                args: [node.type]
            });
        }
    }
    delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
    const location = options.location !== false;
    const _context = {
        filename,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
    };
    if (location && ast.loc) {
        _context.source = ast.loc.source;
    }
    const context = () => _context;
    function push(code2, node) {
        _context.code += code2;
    }
    function _newline(n2, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : "";
        push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
    }
    function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
    }
    function newline() {
        _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
    };
}
function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper(
        "linked"
        /* HelperNameMap.LINKED */
    )}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
    } else {
        generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
}
function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper(
        "normalize"
        /* HelperNameMap.NORMALIZE */
    )}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
        generateNode(generator, node.items[i]);
        if (i === length - 1) {
            break;
        }
        generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push("])");
}
function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
        generator.push(`${helper(
            "plural"
            /* HelperNameMap.PLURAL */
        )}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i = 0; i < length; i++) {
            generateNode(generator, node.cases[i]);
            if (i === length - 1) {
                break;
            }
            generator.push(", ");
        }
        generator.deindent(needIndent());
        generator.push(`])`);
    }
}
function generateResource(generator, node) {
    if (node.body) {
        generateNode(generator, node.body);
    } else {
        generator.push("null");
    }
}
function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
        case 0:
            generateResource(generator, node);
            break;
        case 1:
            generatePluralNode(generator, node);
            break;
        case 2:
            generateMessageNode(generator, node);
            break;
        case 6:
            generateLinkedNode(generator, node);
            break;
        case 8:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 7:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 5:
            generator.push(`${helper(
                "interpolate"
                /* HelperNameMap.INTERPOLATE */
            )}(${helper(
                "list"
                /* HelperNameMap.LIST */
            )}(${node.index}))`, node);
            break;
        case 4:
            generator.push(`${helper(
                "interpolate"
                /* HelperNameMap.INTERPOLATE */
            )}(${helper(
                "named"
                /* HelperNameMap.NAMED */
            )}(${JSON.stringify(node.key)}))`, node);
            break;
        case 9:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 3:
            generator.push(JSON.stringify(node.value), node);
            break;
        default: {
            throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                domain: ERROR_DOMAIN,
                args: [node.type]
            });
        }
    }
}
const generate = (ast, options = {}) => {
    const mode = isString(options.mode) ? options.mode : "normal";
    const filename = isString(options.filename) ? options.filename : "message.intl";
    const sourceMap = !!options.sourceMap;
    const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
    const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
        mode,
        filename,
        sourceMap,
        breakLineCode,
        needIndent
    });
    generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
        generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
        generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    delete ast.helpers;
    const { code: code2, map } = generator.context();
    return {
        ast,
        code: code2,
        map: map ? map.toJSON() : void 0
        // eslint-disable-line @typescript-eslint/no-explicit-any
    };
};
function baseCompile$1(source, options = {}) {
    const assignedOptions = assign({}, options);
    const jit = !!assignedOptions.jit;
    const enalbeMinify = !!assignedOptions.minify;
    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    if (!jit) {
        transform(ast, assignedOptions);
        return generate(ast, assignedOptions);
    } else {
        enambeOptimize && optimize(ast);
        enalbeMinify && minify(ast);
        return { ast, code: "" };
    }
}
var define_process_env_default$1 = { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\Zrx\\AppData\\Roaming", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133219334407372012", COLOR: "1", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-PQMEM4M", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EFC_6852: "1", FIG_JETBRAINS_SHELL_INTEGRATION: "1", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", HOME: "C:\\Users\\Zrx", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Zrx", IDEA_INITIAL_DIRECTORY: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin", INIT_CWD: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", LOCALAPPDATA: "C:\\Users\\Zrx\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-PQMEM4M", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\Zrx\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\Zrx\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", npm_config_node_gyp: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.7.0", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_registry: "https://packages.aliyun.com/6393d698d690c872dceedcc0/npm/npm-registry/", npm_config_userconfig: "C:\\Users\\Zrx\\.npmrc", npm_config_user_agent: "npm/10.7.0 node/v20.14.0 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_json: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\package.json", npm_package_name: "@kcdesign/editor", npm_package_version: "1.0.24", NPM_PREFIX_JS: "C:\\Program Files\\nodejs\\\\node_modules\\npm\\bin\\npm-prefix.js", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "16", NVM_HOME: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OneDrive: "C:\\Users\\Zrx\\OneDrive", OS: "Windows_NT", Path: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\node_modules\\.bin;C:\\Users\\Zrx\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Program Files\\Graphviz\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Zrx\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 154 Stepping 3, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9a03", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", SESSIONNAME: "Console", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", TERMINAL_EMULATOR: "JetBrains-JediTerm", TERM_SESSION_ID: "62b27859-8773-4ef0-b702-7493e22b8459", TMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-PQMEM4M", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-PQMEM4M", USERNAME: "Zrx", USERPROFILE: "C:\\Users\\Zrx", WebStorm: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
function initFeatureFlags$1() {
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
        getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
        getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
        getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
}
const pathStateMachine = [];
pathStateMachine[
    0
    /* States.BEFORE_PATH */
    ] = {
    [
        "w"
        /* PathCharTypes.WORKSPACE */
        ]: [
        0
        /* States.BEFORE_PATH */
    ],
    [
        "i"
        /* PathCharTypes.IDENT */
        ]: [
        3,
        0
        /* Actions.APPEND */
    ],
    [
        "["
        /* PathCharTypes.LEFT_BRACKET */
        ]: [
        4
        /* States.IN_SUB_PATH */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: [
        7
        /* States.AFTER_PATH */
    ]
};
pathStateMachine[
    1
    /* States.IN_PATH */
    ] = {
    [
        "w"
        /* PathCharTypes.WORKSPACE */
        ]: [
        1
        /* States.IN_PATH */
    ],
    [
        "."
        /* PathCharTypes.DOT */
        ]: [
        2
        /* States.BEFORE_IDENT */
    ],
    [
        "["
        /* PathCharTypes.LEFT_BRACKET */
        ]: [
        4
        /* States.IN_SUB_PATH */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: [
        7
        /* States.AFTER_PATH */
    ]
};
pathStateMachine[
    2
    /* States.BEFORE_IDENT */
    ] = {
    [
        "w"
        /* PathCharTypes.WORKSPACE */
        ]: [
        2
        /* States.BEFORE_IDENT */
    ],
    [
        "i"
        /* PathCharTypes.IDENT */
        ]: [
        3,
        0
        /* Actions.APPEND */
    ],
    [
        "0"
        /* PathCharTypes.ZERO */
        ]: [
        3,
        0
        /* Actions.APPEND */
    ]
};
pathStateMachine[
    3
    /* States.IN_IDENT */
    ] = {
    [
        "i"
        /* PathCharTypes.IDENT */
        ]: [
        3,
        0
        /* Actions.APPEND */
    ],
    [
        "0"
        /* PathCharTypes.ZERO */
        ]: [
        3,
        0
        /* Actions.APPEND */
    ],
    [
        "w"
        /* PathCharTypes.WORKSPACE */
        ]: [
        1,
        1
        /* Actions.PUSH */
    ],
    [
        "."
        /* PathCharTypes.DOT */
        ]: [
        2,
        1
        /* Actions.PUSH */
    ],
    [
        "["
        /* PathCharTypes.LEFT_BRACKET */
        ]: [
        4,
        1
        /* Actions.PUSH */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: [
        7,
        1
        /* Actions.PUSH */
    ]
};
pathStateMachine[
    4
    /* States.IN_SUB_PATH */
    ] = {
    [
        "'"
        /* PathCharTypes.SINGLE_QUOTE */
        ]: [
        5,
        0
        /* Actions.APPEND */
    ],
    [
        '"'
        /* PathCharTypes.DOUBLE_QUOTE */
        ]: [
        6,
        0
        /* Actions.APPEND */
    ],
    [
        "["
        /* PathCharTypes.LEFT_BRACKET */
        ]: [
        4,
        2
        /* Actions.INC_SUB_PATH_DEPTH */
    ],
    [
        "]"
        /* PathCharTypes.RIGHT_BRACKET */
        ]: [
        1,
        3
        /* Actions.PUSH_SUB_PATH */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: 8,
    [
        "l"
        /* PathCharTypes.ELSE */
        ]: [
        4,
        0
        /* Actions.APPEND */
    ]
};
pathStateMachine[
    5
    /* States.IN_SINGLE_QUOTE */
    ] = {
    [
        "'"
        /* PathCharTypes.SINGLE_QUOTE */
        ]: [
        4,
        0
        /* Actions.APPEND */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: 8,
    [
        "l"
        /* PathCharTypes.ELSE */
        ]: [
        5,
        0
        /* Actions.APPEND */
    ]
};
pathStateMachine[
    6
    /* States.IN_DOUBLE_QUOTE */
    ] = {
    [
        '"'
        /* PathCharTypes.DOUBLE_QUOTE */
        ]: [
        4,
        0
        /* Actions.APPEND */
    ],
    [
        "o"
        /* PathCharTypes.END_OF_FAIL */
        ]: 8,
    [
        "l"
        /* PathCharTypes.ELSE */
        ]: [
        6,
        0
        /* Actions.APPEND */
    ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
    return literalValueRE.test(exp);
}
function stripQuotes(str) {
    const a2 = str.charCodeAt(0);
    const b2 = str.charCodeAt(str.length - 1);
    return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch2) {
    if (ch2 === void 0 || ch2 === null) {
        return "o";
    }
    const code2 = ch2.charCodeAt(0);
    switch (code2) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return ch2;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w";
    }
    return "i";
}
function formatSubPath(path) {
    const trimmed = path.trim();
    if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
        return false;
    }
    return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
    const keys = [];
    let index2 = -1;
    let mode = 0;
    let subPathDepth = 0;
    let c2;
    let key;
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[
        0
        /* Actions.APPEND */
        ] = () => {
        if (key === void 0) {
            key = newChar;
        } else {
            key += newChar;
        }
    };
    actions[
        1
        /* Actions.PUSH */
        ] = () => {
        if (key !== void 0) {
            keys.push(key);
            key = void 0;
        }
    };
    actions[
        2
        /* Actions.INC_SUB_PATH_DEPTH */
        ] = () => {
        actions[
            0
            /* Actions.APPEND */
            ]();
        subPathDepth++;
    };
    actions[
        3
        /* Actions.PUSH_SUB_PATH */
        ] = () => {
        if (subPathDepth > 0) {
            subPathDepth--;
            mode = 4;
            actions[
                0
                /* Actions.APPEND */
                ]();
        } else {
            subPathDepth = 0;
            if (key === void 0) {
                return false;
            }
            key = formatSubPath(key);
            if (key === false) {
                return false;
            } else {
                actions[
                    1
                    /* Actions.PUSH */
                    ]();
            }
        }
    };
    function maybeUnescapeQuote() {
        const nextChar = path[index2 + 1];
        if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
            index2++;
            newChar = "\\" + nextChar;
            actions[
                0
                /* Actions.APPEND */
                ]();
            return true;
        }
    }
    while (mode !== null) {
        index2++;
        c2 = path[index2];
        if (c2 === "\\" && maybeUnescapeQuote()) {
            continue;
        }
        type = getPathCharType(c2);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap[
            "l"
            /* PathCharTypes.ELSE */
            ] || 8;
        if (transition === 8) {
            return;
        }
        mode = transition[0];
        if (transition[1] !== void 0) {
            action = actions[transition[1]];
            if (action) {
                newChar = c2;
                if (action() === false) {
                    return;
                }
            }
        }
        if (mode === 7) {
            return keys;
        }
    }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
    return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
    if (!isObject$1(obj)) {
        return null;
    }
    let hit = cache.get(path);
    if (!hit) {
        hit = parse(path);
        if (hit) {
            cache.set(path, hit);
        }
    }
    if (!hit) {
        return null;
    }
    const len = hit.length;
    let last = obj;
    let i = 0;
    while (i < len) {
        const val = last[hit[i]];
        if (val === void 0) {
            return null;
        }
        if (isFunction(last)) {
            return null;
        }
        last = val;
        i++;
    }
    return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
        return choice ? choice > 1 ? 1 : 0 : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
    const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
    return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
    if (!props.count) {
        props.count = pluralIndex;
    }
    if (!props.n) {
        props.n = pluralIndex;
    }
}
function createMessageContext(options = {}) {
    const locale2 = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = isObject$1(options.pluralRules) && isString$1(locale2) && isFunction(options.pluralRules[locale2]) ? options.pluralRules[locale2] : pluralDefault;
    const orgPluralRule = isObject$1(options.pluralRules) && isString$1(locale2) && isFunction(options.pluralRules[locale2]) ? pluralDefault : void 0;
    const plural = (messages) => {
        return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
    };
    const _list = options.list || [];
    const list = (index2) => _list[index2];
    const _named = options.named || {};
    isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message2(key) {
        const msg = isFunction(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
        return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
    }
    const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
    const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
    const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
    const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key, ...args) => {
        const [arg1, arg2] = args;
        let type2 = "text";
        let modifier = "";
        if (args.length === 1) {
            if (isObject$1(arg1)) {
                modifier = arg1.modifier || modifier;
                type2 = arg1.type || type2;
            } else if (isString$1(arg1)) {
                modifier = arg1 || modifier;
            }
        } else if (args.length === 2) {
            if (isString$1(arg1)) {
                modifier = arg1 || modifier;
            }
            if (isString$1(arg2)) {
                type2 = arg2 || type2;
            }
        }
        const ret = message2(key)(ctx);
        const msg = (
            // The message in vnode resolved with linked are returned as an array by processor.nomalize
            type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
        );
        return modifier ? _modifier(modifier)(msg, type2) : msg;
    };
    const ctx = {
        [
            "list"
            /* HelperNameMap.LIST */
            ]: list,
        [
            "named"
            /* HelperNameMap.NAMED */
            ]: named,
        [
            "plural"
            /* HelperNameMap.PLURAL */
            ]: plural,
        [
            "linked"
            /* HelperNameMap.LINKED */
            ]: linked,
        [
            "message"
            /* HelperNameMap.MESSAGE */
            ]: message2,
        [
            "type"
            /* HelperNameMap.TYPE */
            ]: type,
        [
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
            ]: interpolate,
        [
            "normalize"
            /* HelperNameMap.NORMALIZE */
            ]: normalize,
        [
            "values"
            /* HelperNameMap.VALUES */
            ]: assign$1({}, _list, _named)
    };
    return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
    devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
    devtools && devtools.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: i18n2,
        version: version2,
        meta
    });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
    "function:translate"
    /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
    NOT_FOUND_KEY: code$1$1,
    // 2
    FALLBACK_TO_TRANSLATE: inc$1$1(),
    // 3
    CANNOT_FORMAT_NUMBER: inc$1$1(),
    // 4
    FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
    // 5
    CANNOT_FORMAT_DATE: inc$1$1(),
    // 6
    FALLBACK_TO_DATE_FORMAT: inc$1$1(),
    // 7
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
    // 8
    __EXTEND_POINT__: inc$1$1()
    // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
    INVALID_ARGUMENT: code$2,
    // 17
    INVALID_DATE_ARGUMENT: inc$2(),
    // 18
    INVALID_ISO_DATE_ARGUMENT: inc$2(),
    // 19
    NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
    // 20
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
    // 21
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
    // 22
    NOT_SUPPORT_LOCALE_TYPE: inc$2(),
    // 23
    __EXTEND_POINT__: inc$2()
    // 24
};
function createCoreError(code2) {
    return createCompileError(code2, null, void 0);
}
function getLocale(context, options) {
    return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale2) {
    if (isString$1(locale2)) {
        return locale2;
    } else {
        if (isFunction(locale2)) {
            if (locale2.resolvedOnce && _resolveLocale != null) {
                return _resolveLocale;
            } else if (locale2.constructor.name === "Function") {
                const resolve = locale2();
                if (isPromise(resolve)) {
                    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
                }
                return _resolveLocale = resolve;
            } else {
                throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
            }
        } else {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
        }
    }
}
function fallbackWithSimple(ctx, fallback, start2) {
    return [.../* @__PURE__ */ new Set([
        start2,
        ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start2]
    ])];
}
function fallbackWithLocaleChain(ctx, fallback, start2) {
    const startLocale = isString$1(start2) ? start2 : DEFAULT_LOCALE;
    const context = ctx;
    if (!context.__localeChainCache) {
        context.__localeChainCache = /* @__PURE__ */ new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
        chain = [];
        let block = [start2];
        while (isArray(block)) {
            block = appendBlockToChain(chain, block, fallback);
        }
        const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
        block = isString$1(defaults) ? [defaults] : defaults;
        if (isArray(block)) {
            appendBlockToChain(chain, block, false);
        }
        context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
}
function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i = 0; i < block.length && isBoolean(follow); i++) {
        const locale2 = block[i];
        if (isString$1(locale2)) {
            follow = appendLocaleToChain(chain, block[i], blocks);
        }
    }
    return follow;
}
function appendLocaleToChain(chain, locale2, blocks) {
    let follow;
    const tokens = locale2.split("-");
    do {
        const target = tokens.join("-");
        follow = appendItemToChain(chain, target, blocks);
        tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
}
function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
        follow = true;
        if (target) {
            follow = target[target.length - 1] !== "!";
            const locale2 = target.replace(/!/g, "");
            chain.push(locale2);
            if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale2]) {
                follow = blocks[locale2];
            }
        }
    }
    return follow;
}
const VERSION$1 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
    return {
        upper: (val, type) => {
            return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
        },
        lower: (val, type) => {
            return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
        },
        capitalize: (val, type) => {
            return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
        }
    };
}
let _compiler;
function registerMessageCompiler(compiler) {
    _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
    _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
    _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
    _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
    const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
    const version2 = isString$1(options.version) ? options.version : VERSION$1;
    const locale2 = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
    const _locale = isFunction(locale2) ? DEFAULT_LOCALE : locale2;
    const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
    const messages = isPlainObject(options.messages) ? options.messages : { [_locale]: {} };
    const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
    const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
    const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = isFunction(options.missing) ? options.missing : null;
    const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
    const processor = isPlainObject(options.processor) ? options.processor : null;
    const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
    const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
    const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
    const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
    const internalOptions = options;
    const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
    const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
    const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
        version: version2,
        cid: _cid,
        locale: locale2,
        fallbackLocale,
        messages,
        modifiers,
        pluralRules,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackFormat,
        unresolving,
        postTranslation,
        processor,
        warnHtmlMessage,
        escapeParameter,
        messageCompiler,
        messageResolver,
        localeFallbacker,
        fallbackContext,
        onWarn,
        __meta
    };
    {
        context.datetimeFormats = datetimeFormats;
        context.numberFormats = numberFormats;
        context.__datetimeFormatters = __datetimeFormatters;
        context.__numberFormatters = __numberFormatters;
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
        initI18nDevTools(context, version2, __meta);
    }
    return context;
}
function handleMissing(context, key, locale2, missingWarn, type) {
    const { missing, onWarn } = context;
    if (missing !== null) {
        const ret = missing(context, locale2, key, type);
        return isString$1(ret) ? ret : key;
    } else {
        return key;
    }
}
function updateFallbackLocale(ctx, locale2, fallback) {
    const context = ctx;
    context.__localeChainCache = /* @__PURE__ */ new Map();
    ctx.localeFallbacker(ctx, fallback, locale2);
}
function isAlmostSameLocale(locale2, compareLocale) {
    if (locale2 === compareLocale)
        return false;
    return locale2.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
    const index2 = locales.indexOf(targetLocale);
    if (index2 === -1) {
        return false;
    }
    for (let i = index2 + 1; i < locales.length; i++) {
        if (isAlmostSameLocale(targetLocale, locales[i])) {
            return true;
        }
    }
    return false;
}
function format(ast) {
    const msg = (ctx) => formatParts(ctx, ast);
    return msg;
}
function formatParts(ctx, ast) {
    const body = ast.b || ast.body;
    if ((body.t || body.type) === 1) {
        const plural = body;
        const cases = plural.c || plural.cases;
        return ctx.plural(cases.reduce((messages, c2) => [
            ...messages,
            formatMessageParts(ctx, c2)
        ], []));
    } else {
        return formatMessageParts(ctx, body);
    }
}
function formatMessageParts(ctx, node) {
    const _static = node.s || node.static;
    if (_static) {
        return ctx.type === "text" ? _static : ctx.normalize([_static]);
    } else {
        const messages = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
        return ctx.normalize(messages);
    }
}
function formatMessagePart(ctx, node) {
    const type = node.t || node.type;
    switch (type) {
        case 3: {
            const text = node;
            return text.v || text.value;
        }
        case 9: {
            const literal = node;
            return literal.v || literal.value;
        }
        case 4: {
            const named = node;
            return ctx.interpolate(ctx.named(named.k || named.key));
        }
        case 5: {
            const list = node;
            return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
        }
        case 6: {
            const linked = node;
            const modifier = linked.m || linked.modifier;
            return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
        }
        case 7: {
            const linkedKey = node;
            return linkedKey.v || linkedKey.value;
        }
        case 8: {
            const linkedModifier = node;
            return linkedModifier.v || linkedModifier.value;
        }
        default:
            throw new Error(`unhandled node type on format message part: ${type}`);
    }
}
const defaultOnCacheKey = (message2) => message2;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$1(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message2, options = {}) {
    let detectError = false;
    const onError = options.onError || defaultOnError;
    options.onError = (err) => {
        detectError = true;
        onError(err);
    };
    return { ...baseCompile$1(message2, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message2, context) => {
    if (!isString$1(message2)) {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
    }
    {
        isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
        const onCacheKey = context.onCacheKey || defaultOnCacheKey;
        const cacheKey = onCacheKey(message2);
        const cached = compileCache[cacheKey];
        if (cached) {
            return cached;
        }
        const { code: code2, detectError } = baseCompile(message2, context);
        const msg = new Function(`return ${code2}`)();
        return !detectError ? compileCache[cacheKey] = msg : msg;
    }
};
function compile(message2, context) {
    if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message2)) {
        isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
        const onCacheKey = context.onCacheKey || defaultOnCacheKey;
        const cacheKey = onCacheKey(message2);
        const cached = compileCache[cacheKey];
        if (cached) {
            return cached;
        }
        const { ast, detectError } = baseCompile(message2, {
            ...context,
            location: define_process_env_default$1.NODE_ENV !== "production",
            jit: true
        });
        const msg = format(ast);
        return !detectError ? compileCache[cacheKey] = msg : msg;
    } else {
        const cacheKey = message2.cacheKey;
        if (cacheKey) {
            const cached = compileCache[cacheKey];
            if (cached) {
                return cached;
            }
            return compileCache[cacheKey] = format(message2);
        } else {
            return format(message2);
        }
    }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
    const locale2 = getLocale(context, options);
    escapeParameter && escapeParams(options);
    let [formatScope, targetLocale, message2] = !resolvedMessage ? resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) : [
        key,
        locale2,
        messages[locale2] || {}
    ];
    let format2 = formatScope;
    let cacheBaseKey = key;
    if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
        if (enableDefaultMsg) {
            format2 = defaultMsgOrKey;
            cacheBaseKey = format2;
        }
    }
    if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
        return unresolving ? NOT_REOSLVED : key;
    }
    let occurred = false;
    const onError = () => {
        occurred = true;
    };
    const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
    if (occurred) {
        return format2;
    }
    const ctxOptions = getMessageContextOptions(context, targetLocale, message2, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    const ret = postTranslation ? postTranslation(messaged, key) : messaged;
    if (__INTLIFY_PROD_DEVTOOLS__) {
        const payloads = {
            timestamp: Date.now(),
            key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
            locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
            format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
            message: ret
        };
        payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
        translateDevTools(payloads);
    }
    return ret;
}
function escapeParams(options) {
    if (isArray(options.list)) {
        options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
    } else if (isObject$1(options.named)) {
        Object.keys(options.named).forEach((key) => {
            if (isString$1(options.named[key])) {
                options.named[key] = escapeHtml(options.named[key]);
            }
        });
    }
}
function resolveMessageFormat(context, key, locale2, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale2);
    let message2 = {};
    let targetLocale;
    let format2 = null;
    const type = "translate";
    for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        message2 = messages[targetLocale] || {};
        if ((format2 = resolveValue2(message2, key)) === null) {
            format2 = message2[key];
        }
        if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
            break;
        }
        if (!isImplicitFallback(targetLocale, locales)) {
            const missingRet = handleMissing(
                context,
                // eslint-disable-line @typescript-eslint/no-explicit-any
                key,
                targetLocale,
                missingWarn,
                type
            );
            if (missingRet !== key) {
                format2 = missingRet;
            }
        }
    }
    return [format2, targetLocale, message2];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format2)) {
        const msg2 = format2;
        msg2.locale = msg2.locale || targetLocale;
        msg2.key = msg2.key || key;
        return msg2;
    }
    if (messageCompiler == null) {
        const msg2 = () => format2;
        msg2.locale = targetLocale;
        msg2.key = key;
        return msg2;
    }
    const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format2;
    return msg;
}
function evaluateMessage(context, msg, msgCtx) {
    const messaged = msg(msgCtx);
    return messaged;
}
function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
    if (isNumber(arg2)) {
        options.plural = arg2;
    } else if (isString$1(arg2)) {
        options.default = arg2;
    } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
        options.named = arg2;
    } else if (isArray(arg2)) {
        options.list = arg2;
    }
    if (isNumber(arg3)) {
        options.plural = arg3;
    } else if (isString$1(arg3)) {
        options.default = arg3;
    } else if (isPlainObject(arg3)) {
        assign$1(options, arg3);
    }
    return [key, options];
}
function getCompileContext(context, locale2, key, source, warnHtmlMessage, onError) {
    return {
        locale: locale2,
        key,
        warnHtmlMessage,
        onError: (err) => {
            onError && onError(err);
            {
                throw err;
            }
        },
        onCacheKey: (source2) => generateFormatCacheKey(locale2, key, source2)
    };
}
function getMessageContextOptions(context, locale2, message2, options) {
    const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key) => {
        let val = resolveValue2(message2, key);
        if (val == null && fallbackContext) {
            const [, , message22] = resolveMessageFormat(fallbackContext, key, locale2, fallbackLocale, fallbackWarn, missingWarn);
            val = resolveValue2(message22, key);
        }
        if (isString$1(val) || isMessageAST(val)) {
            let occurred = false;
            const onError = () => {
                occurred = true;
            };
            const msg = compileMessageFormat(context, key, locale2, val, key, onError);
            return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
        } else if (isMessageFunction(val)) {
            return val;
        } else {
            return NOOP_MESSAGE_FUNCTION;
        }
    };
    const ctxOptions = {
        locale: locale2,
        modifiers,
        pluralRules,
        messages: resolveMessage
    };
    if (context.processor) {
        ctxOptions.processor = context.processor;
    }
    if (options.list) {
        ctxOptions.list = options.list;
    }
    if (options.named) {
        ctxOptions.named = options.named;
    }
    if (isNumber(options.plural)) {
        ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
}
function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale2 = getLocale(context, options);
    const locales = localeFallbacker(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        fallbackLocale,
        locale2
    );
    if (!isString$1(key) || key === "") {
        return new Intl.DateTimeFormat(locale2, overrides).format(value);
    }
    let datetimeFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "datetime format";
    for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        datetimeFormat = datetimeFormats[targetLocale] || {};
        format2 = datetimeFormat[key];
        if (isPlainObject(format2))
            break;
        handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject(format2) || !isString$1(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
        id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
        __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    let value;
    if (isString$1(arg1)) {
        const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!matches) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
        const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
        value = new Date(dateTime);
        try {
            value.toISOString();
        } catch (e) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
    } else if (isDate(arg1)) {
        if (isNaN(arg1.getTime())) {
            throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
        }
        value = arg1;
    } else if (isNumber(arg1)) {
        value = arg1;
    } else {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if (isString$1(arg2)) {
        options.key = arg2;
    } else if (isPlainObject(arg2)) {
        Object.keys(arg2).forEach((key) => {
            if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
            } else {
                options[key] = arg2[key];
            }
        });
    }
    if (isString$1(arg3)) {
        options.locale = arg3;
    } else if (isPlainObject(arg3)) {
        overrides = arg3;
    }
    if (isPlainObject(arg4)) {
        overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key in format2) {
        const id = `${locale2}__${key}`;
        if (!context.__datetimeFormatters.has(id)) {
            continue;
        }
        context.__datetimeFormatters.delete(id);
    }
}
function number(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
    isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
    const part = !!options.part;
    const locale2 = getLocale(context, options);
    const locales = localeFallbacker(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        fallbackLocale,
        locale2
    );
    if (!isString$1(key) || key === "") {
        return new Intl.NumberFormat(locale2, overrides).format(value);
    }
    let numberFormat = {};
    let targetLocale;
    let format2 = null;
    const type = "number format";
    for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        numberFormat = numberFormats[targetLocale] || {};
        format2 = numberFormat[key];
        if (isPlainObject(format2))
            break;
        handleMissing(context, key, targetLocale, missingWarn, type);
    }
    if (!isPlainObject(format2) || !isString$1(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!isEmptyObject(overrides)) {
        id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
        formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
        __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    if (!isNumber(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if (isString$1(arg2)) {
        options.key = arg2;
    } else if (isPlainObject(arg2)) {
        Object.keys(arg2).forEach((key) => {
            if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
            } else {
                options[key] = arg2[key];
            }
        });
    }
    if (isString$1(arg3)) {
        options.locale = arg3;
    } else if (isPlainObject(arg3)) {
        overrides = arg3;
    }
    if (isPlainObject(arg4)) {
        overrides = arg4;
    }
    return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale2, format2) {
    const context = ctx;
    for (const key in format2) {
        const id = `${locale2}__${key}`;
        if (!context.__numberFormatters.has(id)) {
            continue;
        }
        context.__numberFormatters.delete(id);
    }
}
{
    initFeatureFlags$1();
}
var define_process_env_default = { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\Zrx\\AppData\\Roaming", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133219334407372012", COLOR: "1", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-PQMEM4M", ComSpec: "C:\\WINDOWS\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EFC_6852: "1", FIG_JETBRAINS_SHELL_INTEGRATION: "1", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", HOME: "C:\\Users\\Zrx", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Zrx", IDEA_INITIAL_DIRECTORY: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin", INIT_CWD: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", LOCALAPPDATA: "C:\\Users\\Zrx\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-PQMEM4M", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\Zrx\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\Zrx\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype", npm_config_node_gyp: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_npm_version: "10.7.0", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_registry: "https://packages.aliyun.com/6393d698d690c872dceedcc0/npm/npm-registry/", npm_config_userconfig: "C:\\Users\\Zrx\\.npmrc", npm_config_user_agent: "npm/10.7.0 node/v20.14.0 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build", npm_lifecycle_script: "vite build", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_json: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\package.json", npm_package_name: "@kcdesign/editor", npm_package_version: "1.0.24", NPM_PREFIX_JS: "C:\\Program Files\\nodejs\\\\node_modules\\npm\\bin\\npm-prefix.js", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "16", NVM_HOME: "C:\\Users\\Zrx\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OneDrive: "C:\\Users\\Zrx\\OneDrive", OS: "Windows_NT", Path: "C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\node_modules\\.bin;C:\\Users\\Zrx\\Desktop\\node_modules\\.bin;C:\\Users\\Zrx\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm\\v20.14.0\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet\\;C:\\Program Files\\Graphviz\\bin;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Zrx\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;;C:\\Users\\Zrx\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Zrx\\Desktop\\CODE-BETA\\kcdesign-prototype\\node_modules\\.bin", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 154 Stepping 3, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9a03", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", SESSIONNAME: "Console", SystemDrive: "C:", SystemRoot: "C:\\WINDOWS", TEMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", TERMINAL_EMULATOR: "JetBrains-JediTerm", TERM_SESSION_ID: "62b27859-8773-4ef0-b702-7493e22b8459", TMP: "C:\\Users\\Zrx\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-PQMEM4M", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-PQMEM4M", USERNAME: "Zrx", USERPROFILE: "C:\\Users\\Zrx", WebStorm: "C:\\Program Files\\JetBrains\\WebStorm 2023.2.2\\bin;", windir: "C:\\WINDOWS", ZES_ENABLE_SYSMAN: "1" };
const VERSION = "9.13.1";
function initFeatureFlags() {
    if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
        getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
        getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
        getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
    }
    if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
        getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
        getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
    FALLBACK_TO_ROOT: code$1,
    // 9
    NOT_SUPPORTED_PRESERVE: inc$1(),
    // 10
    NOT_SUPPORTED_FORMATTER: inc$1(),
    // 11
    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
    // 12
    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
    // 13
    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
    // 14
    NOT_FOUND_PARENT_SCOPE: inc$1(),
    // 15
    IGNORE_OBJ_FLATTEN: inc$1(),
    // 16
    NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
    // 17
    NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
    // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
    // composer module errors
    UNEXPECTED_RETURN_TYPE: code,
    // 24
    // legacy module errors
    INVALID_ARGUMENT: inc(),
    // 25
    // i18n module errors
    MUST_BE_CALL_SETUP_TOP: inc(),
    // 26
    NOT_INSTALLED: inc(),
    // 27
    NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
    // 28
    // directive module errors
    REQUIRED_VALUE: inc(),
    // 29
    INVALID_VALUE: inc(),
    // 30
    // vue-devtools errors
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
    // 31
    NOT_INSTALLED_WITH_PROVIDE: inc(),
    // 32
    // unexpected error
    UNEXPECTED_ERROR: inc(),
    // 33
    // not compatible legacy vue-i18n constructor
    NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
    // 34
    // bridge support vue 2.x only
    BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
    // 35
    // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
    // 36
    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
    // 37
    // for enhancement
    __EXTEND_POINT__: inc()
    // 38
};
function createI18nError(code2, ...args) {
    return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
    if (!isObject$1(obj)) {
        return obj;
    }
    for (const key in obj) {
        if (!hasOwn(obj, key)) {
            continue;
        }
        if (!key.includes(".")) {
            if (isObject$1(obj[key])) {
                handleFlatJson(obj[key]);
            }
        } else {
            const subKeys = key.split(".");
            const lastIndex = subKeys.length - 1;
            let currentObj = obj;
            let hasStringValue = false;
            for (let i = 0; i < lastIndex; i++) {
                if (!(subKeys[i] in currentObj)) {
                    currentObj[subKeys[i]] = {};
                }
                if (!isObject$1(currentObj[subKeys[i]])) {
                    hasStringValue = true;
                    break;
                }
                currentObj = currentObj[subKeys[i]];
            }
            if (!hasStringValue) {
                currentObj[subKeys[lastIndex]] = obj[key];
                delete obj[key];
            }
            if (isObject$1(currentObj[subKeys[lastIndex]])) {
                handleFlatJson(currentObj[subKeys[lastIndex]]);
            }
        }
    }
    return obj;
}
function getLocaleMessages(locale2, options) {
    const { messages, __i18n, messageResolver, flatJson } = options;
    const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? {} : { [locale2]: {} };
    if (isArray(__i18n)) {
        __i18n.forEach((custom) => {
            if ("locale" in custom && "resource" in custom) {
                const { locale: locale22, resource } = custom;
                if (locale22) {
                    ret[locale22] = ret[locale22] || {};
                    deepCopy(resource, ret[locale22]);
                } else {
                    deepCopy(resource, ret);
                }
            } else {
                isString$1(custom) && deepCopy(JSON.parse(custom), ret);
            }
        });
    }
    if (messageResolver == null && flatJson) {
        for (const key in ret) {
            if (hasOwn(ret, key)) {
                handleFlatJson(ret[key]);
            }
        }
    }
    return ret;
}
function getComponentOptions(instance) {
    return instance.type;
}
function adjustI18nResources(gl2, options, componentOptions) {
    let messages = isObject$1(options.messages) ? options.messages : {};
    if ("__i18nGlobal" in componentOptions) {
        messages = getLocaleMessages(gl2.locale.value, {
            messages,
            __i18n: componentOptions.__i18nGlobal
        });
    }
    const locales = Object.keys(messages);
    if (locales.length) {
        locales.forEach((locale2) => {
            gl2.mergeLocaleMessage(locale2, messages[locale2]);
        });
    }
    {
        if (isObject$1(options.datetimeFormats)) {
            const locales2 = Object.keys(options.datetimeFormats);
            if (locales2.length) {
                locales2.forEach((locale2) => {
                    gl2.mergeDateTimeFormat(locale2, options.datetimeFormats[locale2]);
                });
            }
        }
        if (isObject$1(options.numberFormats)) {
            const locales2 = Object.keys(options.numberFormats);
            if (locales2.length) {
                locales2.forEach((locale2) => {
                    gl2.mergeNumberFormat(locale2, options.numberFormats[locale2]);
                });
            }
        }
    }
}
function createTextNode(key) {
    return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
    return (ctx, locale2, key, type) => {
        return missing(locale2, key, getCurrentInstance() || void 0, type);
    };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
    const instance = getCurrentInstance();
    let meta = null;
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
    const { __root, __injectWithOption } = options;
    const _isGlobal = __root === void 0;
    const flatJson = options.flatJson;
    const _ref = inBrowser ? ref : shallowRef;
    const translateExistCompatible = !!options.translateExistCompatible;
    let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
    const _locale = _ref(
        // prettier-ignore
        __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
    );
    const _fallbackLocale = _ref(
        // prettier-ignore
        __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
    );
    const _messages = _ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    let _fallbackFormat = !!options.fallbackFormat;
    let _missing = isFunction(options.missing) ? options.missing : null;
    let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
    let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
    let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    let _escapeParameter = !!options.escapeParameter;
    const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
    let _pluralRules = options.pluralRules || __root && __root.pluralRules;
    let _context;
    const getCoreContext = () => {
        _isGlobal && setFallbackContext(null);
        const ctxOptions = {
            version: VERSION,
            locale: _locale.value,
            fallbackLocale: _fallbackLocale.value,
            messages: _messages.value,
            modifiers: _modifiers,
            pluralRules: _pluralRules,
            missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
            missingWarn: _missingWarn,
            fallbackWarn: _fallbackWarn,
            fallbackFormat: _fallbackFormat,
            unresolving: true,
            postTranslation: _postTranslation === null ? void 0 : _postTranslation,
            warnHtmlMessage: _warnHtmlMessage,
            escapeParameter: _escapeParameter,
            messageResolver: options.messageResolver,
            messageCompiler: options.messageCompiler,
            __meta: { framework: "vue" }
        };
        {
            ctxOptions.datetimeFormats = _datetimeFormats.value;
            ctxOptions.numberFormats = _numberFormats.value;
            ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
            ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
        }
        const ctx = createCoreContext(ctxOptions);
        _isGlobal && setFallbackContext(ctx);
        return ctx;
    };
    _context = getCoreContext();
    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
    function trackReactivityValues() {
        return [
            _locale.value,
            _fallbackLocale.value,
            _messages.value,
            _datetimeFormats.value,
            _numberFormats.value
        ];
    }
    const locale2 = computed({
        get: () => _locale.value,
        set: (val) => {
            _locale.value = val;
            _context.locale = _locale.value;
        }
    });
    const fallbackLocale = computed({
        get: () => _fallbackLocale.value,
        set: (val) => {
            _fallbackLocale.value = val;
            _context.fallbackLocale = _fallbackLocale.value;
            updateFallbackLocale(_context, _locale.value, val);
        }
    });
    const messages = computed(() => _messages.value);
    const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
    const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
        return isFunction(_postTranslation) ? _postTranslation : null;
    }
    function setPostTranslationHandler(handler) {
        _postTranslation = handler;
        _context.postTranslation = handler;
    }
    function getMissingHandler() {
        return _missing;
    }
    function setMissingHandler(handler) {
        if (handler !== null) {
            _runtimeMissing = defineCoreMissingHandler(handler);
        }
        _missing = handler;
        _context.missing = _runtimeMissing;
    }
    const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
        trackReactivityValues();
        let ret;
        try {
            if (define_process_env_default.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
                /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
            }
            if (!_isGlobal) {
                _context.fallbackContext = __root ? getFallbackContext() : void 0;
            }
            ret = fn2(_context);
        } finally {
            if (__INTLIFY_PROD_DEVTOOLS__) ;
            if (!_isGlobal) {
                _context.fallbackContext = void 0;
            }
        }
        if (warnType !== "translate exists" && // for not `te` (e.g `t`)
            isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
            const [key, arg2] = argumentParser();
            return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
        } else if (successCondition(ret)) {
            return ret;
        } else {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
        }
    };
    function t4(...args) {
        return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
    }
    function rt2(...args) {
        const [arg1, arg2, arg3] = args;
        if (arg3 && !isObject$1(arg3)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        return t4(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
    }
    function d2(...args) {
        return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
    }
    function n2(...args) {
        return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
    }
    function normalize(values) {
        return values.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
    }
    const interpolate = (val) => val;
    const processor = {
        normalize,
        interpolate,
        type: "vnode"
    };
    function translateVNode(...args) {
        return wrapWithDeps(
            (context) => {
                let ret;
                const _context2 = context;
                try {
                    _context2.processor = processor;
                    ret = Reflect.apply(translate, null, [_context2, ...args]);
                } finally {
                    _context2.processor = null;
                }
                return ret;
            },
            () => parseTranslateArgs(...args),
            "translate",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root) => root[TranslateVNodeSymbol](...args),
            (key) => [createTextNode(key)],
            (val) => isArray(val)
        );
    }
    function numberParts(...args) {
        return wrapWithDeps(
            (context) => Reflect.apply(number, null, [context, ...args]),
            () => parseNumberArgs(...args),
            "number format",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root) => root[NumberPartsSymbol](...args),
            NOOP_RETURN_ARRAY,
            (val) => isString$1(val) || isArray(val)
        );
    }
    function datetimeParts(...args) {
        return wrapWithDeps(
            (context) => Reflect.apply(datetime, null, [context, ...args]),
            () => parseDateTimeArgs(...args),
            "datetime format",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root) => root[DatetimePartsSymbol](...args),
            NOOP_RETURN_ARRAY,
            (val) => isString$1(val) || isArray(val)
        );
    }
    function setPluralRules(rules) {
        _pluralRules = rules;
        _context.pluralRules = _pluralRules;
    }
    function te2(key, locale22) {
        return wrapWithDeps(() => {
            if (!key) {
                return false;
            }
            const targetLocale = isString$1(locale22) ? locale22 : _locale.value;
            const message2 = getLocaleMessage(targetLocale);
            const resolved = _context.messageResolver(message2, key);
            return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
        }, () => [key], "translate exists", (root) => {
            return Reflect.apply(root.te, root, [key, locale22]);
        }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
    }
    function resolveMessages(key) {
        let messages2 = null;
        const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
        for (let i = 0; i < locales.length; i++) {
            const targetLocaleMessages = _messages.value[locales[i]] || {};
            const messageValue = _context.messageResolver(targetLocaleMessages, key);
            if (messageValue != null) {
                messages2 = messageValue;
                break;
            }
        }
        return messages2;
    }
    function tm2(key) {
        const messages2 = resolveMessages(key);
        return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
    }
    function getLocaleMessage(locale22) {
        return _messages.value[locale22] || {};
    }
    function setLocaleMessage(locale22, message2) {
        if (flatJson) {
            const _message = { [locale22]: message2 };
            for (const key in _message) {
                if (hasOwn(_message, key)) {
                    handleFlatJson(_message[key]);
                }
            }
            message2 = _message[locale22];
        }
        _messages.value[locale22] = message2;
        _context.messages = _messages.value;
    }
    function mergeLocaleMessage(locale22, message2) {
        _messages.value[locale22] = _messages.value[locale22] || {};
        const _message = { [locale22]: message2 };
        if (flatJson) {
            for (const key in _message) {
                if (hasOwn(_message, key)) {
                    handleFlatJson(_message[key]);
                }
            }
        }
        message2 = _message[locale22];
        deepCopy(message2, _messages.value[locale22]);
        _context.messages = _messages.value;
    }
    function getDateTimeFormat(locale22) {
        return _datetimeFormats.value[locale22] || {};
    }
    function setDateTimeFormat(locale22, format2) {
        _datetimeFormats.value[locale22] = format2;
        _context.datetimeFormats = _datetimeFormats.value;
        clearDateTimeFormat(_context, locale22, format2);
    }
    function mergeDateTimeFormat(locale22, format2) {
        _datetimeFormats.value[locale22] = assign$1(_datetimeFormats.value[locale22] || {}, format2);
        _context.datetimeFormats = _datetimeFormats.value;
        clearDateTimeFormat(_context, locale22, format2);
    }
    function getNumberFormat(locale22) {
        return _numberFormats.value[locale22] || {};
    }
    function setNumberFormat(locale22, format2) {
        _numberFormats.value[locale22] = format2;
        _context.numberFormats = _numberFormats.value;
        clearNumberFormat(_context, locale22, format2);
    }
    function mergeNumberFormat(locale22, format2) {
        _numberFormats.value[locale22] = assign$1(_numberFormats.value[locale22] || {}, format2);
        _context.numberFormats = _numberFormats.value;
        clearNumberFormat(_context, locale22, format2);
    }
    composerID++;
    if (__root && inBrowser) {
        watch(__root.locale, (val) => {
            if (_inheritLocale) {
                _locale.value = val;
                _context.locale = val;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
        });
        watch(__root.fallbackLocale, (val) => {
            if (_inheritLocale) {
                _fallbackLocale.value = val;
                _context.fallbackLocale = val;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
        });
    }
    const composer = {
        id: composerID,
        locale: locale2,
        fallbackLocale,
        get inheritLocale() {
            return _inheritLocale;
        },
        set inheritLocale(val) {
            _inheritLocale = val;
            if (val && __root) {
                _locale.value = __root.locale.value;
                _fallbackLocale.value = __root.fallbackLocale.value;
                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
        },
        get availableLocales() {
            return Object.keys(_messages.value).sort();
        },
        messages,
        get modifiers() {
            return _modifiers;
        },
        get pluralRules() {
            return _pluralRules || {};
        },
        get isGlobal() {
            return _isGlobal;
        },
        get missingWarn() {
            return _missingWarn;
        },
        set missingWarn(val) {
            _missingWarn = val;
            _context.missingWarn = _missingWarn;
        },
        get fallbackWarn() {
            return _fallbackWarn;
        },
        set fallbackWarn(val) {
            _fallbackWarn = val;
            _context.fallbackWarn = _fallbackWarn;
        },
        get fallbackRoot() {
            return _fallbackRoot;
        },
        set fallbackRoot(val) {
            _fallbackRoot = val;
        },
        get fallbackFormat() {
            return _fallbackFormat;
        },
        set fallbackFormat(val) {
            _fallbackFormat = val;
            _context.fallbackFormat = _fallbackFormat;
        },
        get warnHtmlMessage() {
            return _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
            _warnHtmlMessage = val;
            _context.warnHtmlMessage = val;
        },
        get escapeParameter() {
            return _escapeParameter;
        },
        set escapeParameter(val) {
            _escapeParameter = val;
            _context.escapeParameter = val;
        },
        t: t4,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        [SetPluralRulesSymbol]: setPluralRules
    };
    {
        composer.datetimeFormats = datetimeFormats;
        composer.numberFormats = numberFormats;
        composer.rt = rt2;
        composer.te = te2;
        composer.tm = tm2;
        composer.d = d2;
        composer.n = n2;
        composer.getDateTimeFormat = getDateTimeFormat;
        composer.setDateTimeFormat = setDateTimeFormat;
        composer.mergeDateTimeFormat = mergeDateTimeFormat;
        composer.getNumberFormat = getNumberFormat;
        composer.setNumberFormat = setNumberFormat;
        composer.mergeNumberFormat = mergeNumberFormat;
        composer[InejctWithOptionSymbol] = __injectWithOption;
        composer[TranslateVNodeSymbol] = translateVNode;
        composer[DatetimePartsSymbol] = datetimeParts;
        composer[NumberPartsSymbol] = numberParts;
    }
    return composer;
}
function convertComposerOptions(options) {
    const locale2 = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
    const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale2;
    const missing = isFunction(options.missing) ? options.missing : void 0;
    const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
    const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
    const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const fallbackFormat = !!options.formatFallbackMessages;
    const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
    const pluralizationRules = options.pluralizationRules;
    const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
    const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
    const escapeParameter = !!options.escapeParameterHtml;
    const inheritLocale = isBoolean(options.sync) ? options.sync : true;
    let messages = options.messages;
    if (isPlainObject(options.sharedMessages)) {
        const sharedMessages = options.sharedMessages;
        const locales = Object.keys(sharedMessages);
        messages = locales.reduce((messages2, locale22) => {
            const message2 = messages2[locale22] || (messages2[locale22] = {});
            assign$1(message2, sharedMessages[locale22]);
            return messages2;
        }, messages || {});
    }
    const { __i18n, __root, __injectWithOption } = options;
    const datetimeFormats = options.datetimeFormats;
    const numberFormats = options.numberFormats;
    const flatJson = options.flatJson;
    const translateExistCompatible = options.translateExistCompatible;
    return {
        locale: locale2,
        fallbackLocale,
        messages,
        flatJson,
        datetimeFormats,
        numberFormats,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackRoot,
        fallbackFormat,
        modifiers,
        pluralRules: pluralizationRules,
        postTranslation,
        warnHtmlMessage,
        escapeParameter,
        messageResolver: options.messageResolver,
        inheritLocale,
        translateExistCompatible,
        __i18n,
        __root,
        __injectWithOption
    };
}
function createVueI18n(options = {}, VueI18nLegacy) {
    {
        const composer = createComposer(convertComposerOptions(options));
        const { __extender } = options;
        const vueI18n = {
            // id
            id: composer.id,
            // locale
            get locale() {
                return composer.locale.value;
            },
            set locale(val) {
                composer.locale.value = val;
            },
            // fallbackLocale
            get fallbackLocale() {
                return composer.fallbackLocale.value;
            },
            set fallbackLocale(val) {
                composer.fallbackLocale.value = val;
            },
            // messages
            get messages() {
                return composer.messages.value;
            },
            // datetimeFormats
            get datetimeFormats() {
                return composer.datetimeFormats.value;
            },
            // numberFormats
            get numberFormats() {
                return composer.numberFormats.value;
            },
            // availableLocales
            get availableLocales() {
                return composer.availableLocales;
            },
            // formatter
            get formatter() {
                return {
                    interpolate() {
                        return [];
                    }
                };
            },
            set formatter(val) {
            },
            // missing
            get missing() {
                return composer.getMissingHandler();
            },
            set missing(handler) {
                composer.setMissingHandler(handler);
            },
            // silentTranslationWarn
            get silentTranslationWarn() {
                return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
            },
            set silentTranslationWarn(val) {
                composer.missingWarn = isBoolean(val) ? !val : val;
            },
            // silentFallbackWarn
            get silentFallbackWarn() {
                return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
            },
            set silentFallbackWarn(val) {
                composer.fallbackWarn = isBoolean(val) ? !val : val;
            },
            // modifiers
            get modifiers() {
                return composer.modifiers;
            },
            // formatFallbackMessages
            get formatFallbackMessages() {
                return composer.fallbackFormat;
            },
            set formatFallbackMessages(val) {
                composer.fallbackFormat = val;
            },
            // postTranslation
            get postTranslation() {
                return composer.getPostTranslationHandler();
            },
            set postTranslation(handler) {
                composer.setPostTranslationHandler(handler);
            },
            // sync
            get sync() {
                return composer.inheritLocale;
            },
            set sync(val) {
                composer.inheritLocale = val;
            },
            // warnInHtmlMessage
            get warnHtmlInMessage() {
                return composer.warnHtmlMessage ? "warn" : "off";
            },
            set warnHtmlInMessage(val) {
                composer.warnHtmlMessage = val !== "off";
            },
            // escapeParameterHtml
            get escapeParameterHtml() {
                return composer.escapeParameter;
            },
            set escapeParameterHtml(val) {
                composer.escapeParameter = val;
            },
            // preserveDirectiveContent
            get preserveDirectiveContent() {
                return true;
            },
            set preserveDirectiveContent(val) {
            },
            // pluralizationRules
            get pluralizationRules() {
                return composer.pluralRules || {};
            },
            // for internal
            __composer: composer,
            // t
            t(...args) {
                const [arg1, arg2, arg3] = args;
                const options2 = {};
                let list = null;
                let named = null;
                if (!isString$1(arg1)) {
                    throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
                }
                const key = arg1;
                if (isString$1(arg2)) {
                    options2.locale = arg2;
                } else if (isArray(arg2)) {
                    list = arg2;
                } else if (isPlainObject(arg2)) {
                    named = arg2;
                }
                if (isArray(arg3)) {
                    list = arg3;
                } else if (isPlainObject(arg3)) {
                    named = arg3;
                }
                return Reflect.apply(composer.t, composer, [
                    key,
                    list || named || {},
                    options2
                ]);
            },
            rt(...args) {
                return Reflect.apply(composer.rt, composer, [...args]);
            },
            // tc
            tc(...args) {
                const [arg1, arg2, arg3] = args;
                const options2 = { plural: 1 };
                let list = null;
                let named = null;
                if (!isString$1(arg1)) {
                    throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
                }
                const key = arg1;
                if (isString$1(arg2)) {
                    options2.locale = arg2;
                } else if (isNumber(arg2)) {
                    options2.plural = arg2;
                } else if (isArray(arg2)) {
                    list = arg2;
                } else if (isPlainObject(arg2)) {
                    named = arg2;
                }
                if (isString$1(arg3)) {
                    options2.locale = arg3;
                } else if (isArray(arg3)) {
                    list = arg3;
                } else if (isPlainObject(arg3)) {
                    named = arg3;
                }
                return Reflect.apply(composer.t, composer, [
                    key,
                    list || named || {},
                    options2
                ]);
            },
            // te
            te(key, locale2) {
                return composer.te(key, locale2);
            },
            // tm
            tm(key) {
                return composer.tm(key);
            },
            // getLocaleMessage
            getLocaleMessage(locale2) {
                return composer.getLocaleMessage(locale2);
            },
            // setLocaleMessage
            setLocaleMessage(locale2, message2) {
                composer.setLocaleMessage(locale2, message2);
            },
            // mergeLocaleMessage
            mergeLocaleMessage(locale2, message2) {
                composer.mergeLocaleMessage(locale2, message2);
            },
            // d
            d(...args) {
                return Reflect.apply(composer.d, composer, [...args]);
            },
            // getDateTimeFormat
            getDateTimeFormat(locale2) {
                return composer.getDateTimeFormat(locale2);
            },
            // setDateTimeFormat
            setDateTimeFormat(locale2, format2) {
                composer.setDateTimeFormat(locale2, format2);
            },
            // mergeDateTimeFormat
            mergeDateTimeFormat(locale2, format2) {
                composer.mergeDateTimeFormat(locale2, format2);
            },
            // n
            n(...args) {
                return Reflect.apply(composer.n, composer, [...args]);
            },
            // getNumberFormat
            getNumberFormat(locale2) {
                return composer.getNumberFormat(locale2);
            },
            // setNumberFormat
            setNumberFormat(locale2, format2) {
                composer.setNumberFormat(locale2, format2);
            },
            // mergeNumberFormat
            mergeNumberFormat(locale2, format2) {
                composer.mergeNumberFormat(locale2, format2);
            },
            // getChoiceIndex
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            getChoiceIndex(choice, choicesLength) {
                return -1;
            }
        };
        vueI18n.__extender = __extender;
        return vueI18n;
    }
}
const baseFormatProps = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
        validator: (val) => val === "parent" || val === "global",
        default: "parent"
        /* ComponentI18nScope */
    },
    i18n: {
        type: Object
    }
};
function getInterpolateArg({ slots }, keys) {
    if (keys.length === 1 && keys[0] === "default") {
        const ret = slots.default ? slots.default() : [];
        return ret.reduce((slot, current) => {
            return [
                ...slot,
                // prettier-ignore
                ...current.type === Fragment ? current.children : [current]
            ];
        }, []);
    } else {
        return keys.reduce((arg, key) => {
            const slot = slots[key];
            if (slot) {
                arg[key] = slot();
            }
            return arg;
        }, {});
    }
}
function getFragmentableTag(tag) {
    return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-t",
    props: assign$1({
        keypath: {
            type: String,
            required: true
        },
        plural: {
            type: [Number, String],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            validator: (val) => isNumber(val) || !isNaN(val)
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const { slots, attrs } = context;
        const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
        });
        return () => {
            const keys = Object.keys(slots).filter((key) => key !== "_");
            const options = {};
            if (props.locale) {
                options.locale = props.locale;
            }
            if (props.plural !== void 0) {
                options.plural = isString$1(props.plural) ? +props.plural : props.plural;
            }
            const arg = getInterpolateArg(context, keys);
            const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
            const assignedAttrs = assign$1({}, attrs);
            const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
            return h$1(tag, assignedAttrs, children);
        };
    }
});
const Translation = TranslationImpl;
function isVNode(target) {
    return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
        const options = { part: true };
        let overrides = {};
        if (props.locale) {
            options.locale = props.locale;
        }
        if (isString$1(props.format)) {
            options.key = props.format;
        } else if (isObject$1(props.format)) {
            if (isString$1(props.format.key)) {
                options.key = props.format.key;
            }
            overrides = Object.keys(props.format).reduce((options2, prop) => {
                return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props.format[prop] }) : options2;
            }, {});
        }
        const parts = partFormatter(...[props.value, options, overrides]);
        let children = [options.key];
        if (isArray(parts)) {
            children = parts.map((part, index2) => {
                const slot = slots[part.type];
                const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
                if (isVNode(node)) {
                    node[0].key = `${part.type}-${index2}`;
                }
                return node;
            });
        } else if (isString$1(parts)) {
            children = [parts];
        }
        const assignedAttrs = assign$1({}, attrs);
        const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
        return h$1(tag, assignedAttrs, children);
    };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-n",
    props: assign$1({
        value: {
            type: Number,
            required: true
        },
        format: {
            type: [String, Object]
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
        });
        return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            i18n2[NumberPartsSymbol](...args)
        ));
    }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
    /* eslint-disable */
    name: "i18n-d",
    props: assign$1({
        value: {
            type: [Number, Date],
            required: true
        },
        format: {
            type: [String, Object]
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
        });
        return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            i18n2[DatetimePartsSymbol](...args)
        ));
    }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
        return i18nInternal.__getInstance(instance) || i18n2.global;
    } else {
        const vueI18n = i18nInternal.__getInstance(instance);
        return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
    }
}
function vTDirective(i18n2) {
    const _process = (binding) => {
        const { instance, modifiers, value } = binding;
        if (!instance || !instance.$) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const composer = getComposer$2(i18n2, instance.$);
        const parsedValue = parseValue(value);
        return [
            Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
            composer
        ];
    };
    const register = (el2, binding) => {
        const [textContent, composer] = _process(binding);
        if (inBrowser && i18n2.global === composer) {
            el2.__i18nWatcher = watch(composer.locale, () => {
                binding.instance && binding.instance.$forceUpdate();
            });
        }
        el2.__composer = composer;
        el2.textContent = textContent;
    };
    const unregister = (el2) => {
        if (inBrowser && el2.__i18nWatcher) {
            el2.__i18nWatcher();
            el2.__i18nWatcher = void 0;
            delete el2.__i18nWatcher;
        }
        if (el2.__composer) {
            el2.__composer = void 0;
            delete el2.__composer;
        }
    };
    const update = (el2, { value }) => {
        if (el2.__composer) {
            const composer = el2.__composer;
            const parsedValue = parseValue(value);
            el2.textContent = Reflect.apply(composer.t, composer, [
                ...makeParams(parsedValue)
            ]);
        }
    };
    const getSSRProps = (binding) => {
        const [textContent] = _process(binding);
        return { textContent };
    };
    return {
        created: register,
        unmounted: unregister,
        beforeUpdate: update,
        getSSRProps
    };
}
function parseValue(value) {
    if (isString$1(value)) {
        return { path: value };
    } else if (isPlainObject(value)) {
        if (!("path" in value)) {
            throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
        }
        return value;
    } else {
        throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
}
function makeParams(value) {
    const { path, locale: locale2, args, choice, plural } = value;
    const options = {};
    const named = args || {};
    if (isString$1(locale2)) {
        options.locale = locale2;
    }
    if (isNumber(choice)) {
        options.plural = choice;
    }
    if (isNumber(plural)) {
        options.plural = plural;
    }
    return [path, named, options];
}
function apply$2(app2, i18n2, ...options) {
    const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
    const useI18nComponentName = !!pluginOptions.useI18nComponentName;
    const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
    if (globalInstall) {
        [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
        [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
        [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
    }
    {
        app2.directive("t", vTDirective(i18n2));
    }
}
function defineMixin(vuei18n, composer, i18n2) {
    return {
        beforeCreate() {
            const instance = getCurrentInstance();
            if (!instance) {
                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
            }
            const options = this.$options;
            if (options.i18n) {
                const optionsI18n = options.i18n;
                if (options.__i18n) {
                    optionsI18n.__i18n = options.__i18n;
                }
                optionsI18n.__root = composer;
                if (this === this.$root) {
                    this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
                } else {
                    optionsI18n.__injectWithOption = true;
                    optionsI18n.__extender = i18n2.__vueI18nExtend;
                    this.$i18n = createVueI18n(optionsI18n);
                    const _vueI18n = this.$i18n;
                    if (_vueI18n.__extender) {
                        _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
                    }
                }
            } else if (options.__i18n) {
                if (this === this.$root) {
                    this.$i18n = mergeToGlobal(vuei18n, options);
                } else {
                    this.$i18n = createVueI18n({
                        __i18n: options.__i18n,
                        __injectWithOption: true,
                        __extender: i18n2.__vueI18nExtend,
                        __root: composer
                    });
                    const _vueI18n = this.$i18n;
                    if (_vueI18n.__extender) {
                        _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
                    }
                }
            } else {
                this.$i18n = vuei18n;
            }
            if (options.__i18nGlobal) {
                adjustI18nResources(composer, options, options);
            }
            this.$t = (...args) => this.$i18n.t(...args);
            this.$rt = (...args) => this.$i18n.rt(...args);
            this.$tc = (...args) => this.$i18n.tc(...args);
            this.$te = (key, locale2) => this.$i18n.te(key, locale2);
            this.$d = (...args) => this.$i18n.d(...args);
            this.$n = (...args) => this.$i18n.n(...args);
            this.$tm = (key) => this.$i18n.tm(key);
            i18n2.__setInstance(instance, this.$i18n);
        },
        mounted() {
        },
        unmounted() {
            const instance = getCurrentInstance();
            if (!instance) {
                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
            }
            const _vueI18n = this.$i18n;
            delete this.$t;
            delete this.$rt;
            delete this.$tc;
            delete this.$te;
            delete this.$d;
            delete this.$n;
            delete this.$tm;
            if (_vueI18n.__disposer) {
                _vueI18n.__disposer();
                delete _vueI18n.__disposer;
                delete _vueI18n.__extender;
            }
            i18n2.__deleteInstance(instance);
            delete this.$i18n;
        }
    };
}
function mergeToGlobal(g2, options) {
    g2.locale = options.locale || g2.locale;
    g2.fallbackLocale = options.fallbackLocale || g2.fallbackLocale;
    g2.missing = options.missing || g2.missing;
    g2.silentTranslationWarn = options.silentTranslationWarn || g2.silentFallbackWarn;
    g2.silentFallbackWarn = options.silentFallbackWarn || g2.silentFallbackWarn;
    g2.formatFallbackMessages = options.formatFallbackMessages || g2.formatFallbackMessages;
    g2.postTranslation = options.postTranslation || g2.postTranslation;
    g2.warnHtmlInMessage = options.warnHtmlInMessage || g2.warnHtmlInMessage;
    g2.escapeParameterHtml = options.escapeParameterHtml || g2.escapeParameterHtml;
    g2.sync = options.sync || g2.sync;
    g2.__composer[SetPluralRulesSymbol](options.pluralizationRules || g2.pluralizationRules);
    const messages = getLocaleMessages(g2.locale, {
        messages: options.messages,
        __i18n: options.__i18n
    });
    Object.keys(messages).forEach((locale2) => g2.mergeLocaleMessage(locale2, messages[locale2]));
    if (options.datetimeFormats) {
        Object.keys(options.datetimeFormats).forEach((locale2) => g2.mergeDateTimeFormat(locale2, options.datetimeFormats[locale2]));
    }
    if (options.numberFormats) {
        Object.keys(options.numberFormats).forEach((locale2) => g2.mergeNumberFormat(locale2, options.numberFormats[locale2]));
    }
    return g2;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
    const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
    const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
    const __instances = /* @__PURE__ */ new Map();
    const [globalScope, __global] = createGlobal(options, __legacyMode);
    const symbol = /* @__PURE__ */ makeSymbol("");
    function __getInstance(component) {
        return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
        __instances.set(component, instance);
    }
    function __deleteInstance(component) {
        __instances.delete(component);
    }
    {
        const i18n2 = {
            // mode
            get mode() {
                return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
            },
            // allowComposition
            get allowComposition() {
                return __allowComposition;
            },
            // install plugin
            async install(app2, ...options2) {
                app2.__VUE_I18N_SYMBOL__ = symbol;
                app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
                if (isPlainObject(options2[0])) {
                    const opts = options2[0];
                    i18n2.__composerExtend = opts.__composerExtend;
                    i18n2.__vueI18nExtend = opts.__vueI18nExtend;
                }
                let globalReleaseHandler = null;
                if (!__legacyMode && __globalInjection) {
                    globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
                }
                if (__VUE_I18N_FULL_INSTALL__) {
                    apply$2(app2, i18n2, ...options2);
                }
                if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
                    app2.mixin(defineMixin(__global, __global.__composer, i18n2));
                }
                const unmountApp = app2.unmount;
                app2.unmount = () => {
                    globalReleaseHandler && globalReleaseHandler();
                    i18n2.dispose();
                    unmountApp();
                };
            },
            // global accessor
            get global() {
                return __global;
            },
            dispose() {
                globalScope.stop();
            },
            // @internal
            __instances,
            // @internal
            __getInstance,
            // @internal
            __setInstance,
            // @internal
            __deleteInstance
        };
        return i18n2;
    }
}
function useI18n(options = {}) {
    const instance = getCurrentInstance();
    if (instance == null) {
        throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
        throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
    }
    const i18n2 = getI18nInstance(instance);
    const gl2 = getGlobalComposer(i18n2);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options, componentOptions);
    if (__VUE_I18N_LEGACY_API__) {
        if (i18n2.mode === "legacy" && !options.__useComponent) {
            if (!i18n2.allowComposition) {
                throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
            }
            return useI18nForLegacy(instance, scope, gl2, options);
        }
    }
    if (scope === "global") {
        adjustI18nResources(gl2, options, componentOptions);
        return gl2;
    }
    if (scope === "parent") {
        let composer2 = getComposer(i18n2, instance, options.__useComponent);
        if (composer2 == null) {
            composer2 = gl2;
        }
        return composer2;
    }
    const i18nInternal = i18n2;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
        const composerOptions = assign$1({}, options);
        if ("__i18n" in componentOptions) {
            composerOptions.__i18n = componentOptions.__i18n;
        }
        if (gl2) {
            composerOptions.__root = gl2;
        }
        composer = createComposer(composerOptions);
        if (i18nInternal.__composerExtend) {
            composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
        }
        setupLifeCycle(i18nInternal, instance, composer);
        i18nInternal.__setInstance(instance, composer);
    }
    return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
    const scope = effectScope();
    {
        const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
        if (obj == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        return [scope, obj];
    }
}
function getI18nInstance(instance) {
    {
        const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
        if (!i18n2) {
            throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
        }
        return i18n2;
    }
}
function getScope(options, componentOptions) {
    return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
    return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
    let composer = null;
    const root = target.root;
    let current = getParentComponentInstance(target, useComponent);
    while (current != null) {
        const i18nInternal = i18n2;
        if (i18n2.mode === "composition") {
            composer = i18nInternal.__getInstance(current);
        } else {
            if (__VUE_I18N_LEGACY_API__) {
                const vueI18n = i18nInternal.__getInstance(current);
                if (vueI18n != null) {
                    composer = vueI18n.__composer;
                    if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
                        composer = null;
                    }
                }
            }
        }
        if (composer != null) {
            break;
        }
        if (root === current) {
            break;
        }
        current = current.parent;
    }
    return composer;
}
function getParentComponentInstance(target, useComponent = false) {
    if (target == null) {
        return null;
    }
    {
        return !useComponent ? target.parent : target.vnode.ctx || target.parent;
    }
}
function setupLifeCycle(i18n2, target, composer) {
    {
        onMounted(() => {
        }, target);
        onUnmounted(() => {
            const _composer = composer;
            i18n2.__deleteInstance(target);
            const dispose = _composer[DisposeSymbol];
            if (dispose) {
                dispose();
                delete _composer[DisposeSymbol];
            }
        }, target);
    }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
    const isLocalScope = scope === "local";
    const _composer = shallowRef(null);
    if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
        throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    }
    const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
    const _locale = ref(
        // prettier-ignore
        !isLocalScope || _inheritLocale ? root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
    );
    const _fallbackLocale = ref(
        // prettier-ignore
        !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
    );
    const _messages = ref(getLocaleMessages(_locale.value, options));
    const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
    const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
    const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
    const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
    const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
    const _fallbackFormat = !!options.fallbackFormat;
    const _missing = isFunction(options.missing) ? options.missing : null;
    const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
    const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
    const _escapeParameter = !!options.escapeParameter;
    const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
    const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
    function trackReactivityValues() {
        return [
            _locale.value,
            _fallbackLocale.value,
            _messages.value,
            _datetimeFormats.value,
            _numberFormats.value
        ];
    }
    const locale2 = computed({
        get: () => {
            return _composer.value ? _composer.value.locale.value : _locale.value;
        },
        set: (val) => {
            if (_composer.value) {
                _composer.value.locale.value = val;
            }
            _locale.value = val;
        }
    });
    const fallbackLocale = computed({
        get: () => {
            return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
        },
        set: (val) => {
            if (_composer.value) {
                _composer.value.fallbackLocale.value = val;
            }
            _fallbackLocale.value = val;
        }
    });
    const messages = computed(() => {
        if (_composer.value) {
            return _composer.value.messages.value;
        } else {
            return _messages.value;
        }
    });
    const datetimeFormats = computed(() => _datetimeFormats.value);
    const numberFormats = computed(() => _numberFormats.value);
    function getPostTranslationHandler() {
        return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
    }
    function setPostTranslationHandler(handler) {
        if (_composer.value) {
            _composer.value.setPostTranslationHandler(handler);
        }
    }
    function getMissingHandler() {
        return _composer.value ? _composer.value.getMissingHandler() : _missing;
    }
    function setMissingHandler(handler) {
        if (_composer.value) {
            _composer.value.setMissingHandler(handler);
        }
    }
    function warpWithDeps(fn2) {
        trackReactivityValues();
        return fn2();
    }
    function t4(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
    }
    function rt2(...args) {
        return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
    }
    function d2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
    }
    function n2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
    }
    function tm2(key) {
        return _composer.value ? _composer.value.tm(key) : {};
    }
    function te2(key, locale22) {
        return _composer.value ? _composer.value.te(key, locale22) : false;
    }
    function getLocaleMessage(locale22) {
        return _composer.value ? _composer.value.getLocaleMessage(locale22) : {};
    }
    function setLocaleMessage(locale22, message2) {
        if (_composer.value) {
            _composer.value.setLocaleMessage(locale22, message2);
            _messages.value[locale22] = message2;
        }
    }
    function mergeLocaleMessage(locale22, message2) {
        if (_composer.value) {
            _composer.value.mergeLocaleMessage(locale22, message2);
        }
    }
    function getDateTimeFormat(locale22) {
        return _composer.value ? _composer.value.getDateTimeFormat(locale22) : {};
    }
    function setDateTimeFormat(locale22, format2) {
        if (_composer.value) {
            _composer.value.setDateTimeFormat(locale22, format2);
            _datetimeFormats.value[locale22] = format2;
        }
    }
    function mergeDateTimeFormat(locale22, format2) {
        if (_composer.value) {
            _composer.value.mergeDateTimeFormat(locale22, format2);
        }
    }
    function getNumberFormat(locale22) {
        return _composer.value ? _composer.value.getNumberFormat(locale22) : {};
    }
    function setNumberFormat(locale22, format2) {
        if (_composer.value) {
            _composer.value.setNumberFormat(locale22, format2);
            _numberFormats.value[locale22] = format2;
        }
    }
    function mergeNumberFormat(locale22, format2) {
        if (_composer.value) {
            _composer.value.mergeNumberFormat(locale22, format2);
        }
    }
    const wrapper = {
        get id() {
            return _composer.value ? _composer.value.id : -1;
        },
        locale: locale2,
        fallbackLocale,
        messages,
        datetimeFormats,
        numberFormats,
        get inheritLocale() {
            return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
        },
        set inheritLocale(val) {
            if (_composer.value) {
                _composer.value.inheritLocale = val;
            }
        },
        get availableLocales() {
            return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
        },
        get modifiers() {
            return _composer.value ? _composer.value.modifiers : _modifiers;
        },
        get pluralRules() {
            return _composer.value ? _composer.value.pluralRules : _pluralRules;
        },
        get isGlobal() {
            return _composer.value ? _composer.value.isGlobal : false;
        },
        get missingWarn() {
            return _composer.value ? _composer.value.missingWarn : _missingWarn;
        },
        set missingWarn(val) {
            if (_composer.value) {
                _composer.value.missingWarn = val;
            }
        },
        get fallbackWarn() {
            return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
        },
        set fallbackWarn(val) {
            if (_composer.value) {
                _composer.value.missingWarn = val;
            }
        },
        get fallbackRoot() {
            return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
        },
        set fallbackRoot(val) {
            if (_composer.value) {
                _composer.value.fallbackRoot = val;
            }
        },
        get fallbackFormat() {
            return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
        },
        set fallbackFormat(val) {
            if (_composer.value) {
                _composer.value.fallbackFormat = val;
            }
        },
        get warnHtmlMessage() {
            return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
            if (_composer.value) {
                _composer.value.warnHtmlMessage = val;
            }
        },
        get escapeParameter() {
            return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
        },
        set escapeParameter(val) {
            if (_composer.value) {
                _composer.value.escapeParameter = val;
            }
        },
        t: t4,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        rt: rt2,
        d: d2,
        n: n2,
        tm: tm2,
        te: te2,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getDateTimeFormat,
        setDateTimeFormat,
        mergeDateTimeFormat,
        getNumberFormat,
        setNumberFormat,
        mergeNumberFormat
    };
    function sync(composer) {
        composer.locale.value = _locale.value;
        composer.fallbackLocale.value = _fallbackLocale.value;
        Object.keys(_messages.value).forEach((locale22) => {
            composer.mergeLocaleMessage(locale22, _messages.value[locale22]);
        });
        Object.keys(_datetimeFormats.value).forEach((locale22) => {
            composer.mergeDateTimeFormat(locale22, _datetimeFormats.value[locale22]);
        });
        Object.keys(_numberFormats.value).forEach((locale22) => {
            composer.mergeNumberFormat(locale22, _numberFormats.value[locale22]);
        });
        composer.escapeParameter = _escapeParameter;
        composer.fallbackFormat = _fallbackFormat;
        composer.fallbackRoot = _fallbackRoot;
        composer.fallbackWarn = _fallbackWarn;
        composer.missingWarn = _missingWarn;
        composer.warnHtmlMessage = _warnHtmlMessage;
    }
    onBeforeMount(() => {
        if (instance.proxy == null || instance.proxy.$i18n == null) {
            throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        }
        const composer = _composer.value = instance.proxy.$i18n.__composer;
        if (scope === "global") {
            _locale.value = composer.locale.value;
            _fallbackLocale.value = composer.fallbackLocale.value;
            _messages.value = composer.messages.value;
            _datetimeFormats.value = composer.datetimeFormats.value;
            _numberFormats.value = composer.numberFormats.value;
        } else if (isLocalScope) {
            sync(composer);
        }
    });
    return wrapper;
}
const globalExportProps = [
    "locale",
    "fallbackLocale",
    "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
    const i18n2 = /* @__PURE__ */ Object.create(null);
    globalExportProps.forEach((prop) => {
        const desc = Object.getOwnPropertyDescriptor(composer, prop);
        if (!desc) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const wrap = isRef(desc.value) ? {
            get() {
                return desc.value.value;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            set(val) {
                desc.value.value = val;
            }
        } : {
            get() {
                return desc.get && desc.get();
            }
        };
        Object.defineProperty(i18n2, prop, wrap);
    });
    app2.config.globalProperties.$i18n = i18n2;
    globalExportMethods.forEach((method) => {
        const desc = Object.getOwnPropertyDescriptor(composer, method);
        if (!desc || !desc.value) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
    });
    const dispose = () => {
        delete app2.config.globalProperties.$i18n;
        globalExportMethods.forEach((method) => {
            delete app2.config.globalProperties[`$${method}`];
        });
    };
    return dispose;
}
{
    initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
    registerMessageCompiler(compile);
} else {
    registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
    const target = getGlobalThis();
    target.__INTLIFY__ = true;
    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
function fixLocale(locale2) {
    locale2 = locale2.toLowerCase();
    if (locale2.startsWith("zh")) return "zh";
    return "en";
}
const locale = fixLocale(localStorage.getItem("locale") || navigator.language || "en");
const system$1 = {
    incorrect_input: "输入有误！",
    "illegal_input": "输入不合法！",
    select: "请选择！",
    space: "...",
    empty: "暂无数据",
    paste: "粘贴",
    "paste_here": "粘贴在这里",
    "only_text": "只粘贴文本",
    copy: "复制",
    copyAs: "复制/粘贴为",
    cut: "剪切",
    replace: "替换",
    failed: "操作失败",
    "null_file_name": "文件名不能为空",
    "replace_failed": "替换失败，请使用粘贴功能",
    "select_layer": "图层选择",
    "bring_forward": "上移一层",
    "send_backward": "下移一层",
    "bring_to_top": "置于顶层",
    "send_to_bottom": "置于底层",
    "visible": "显示/隐藏",
    "hidden": "隐藏",
    "Lock": "锁定/解锁",
    "select_all": "选择全部",
    "fit_canvas": "适应画布",
    "show_many_cursor": "显示多人光标",
    "show_comment": "显示评论",
    "show_cutout": "显示切图",
    "show_ruler": "显示标尺",
    "show_pixel_network": "显示像素网络",
    "hide_operation_interface": "隐藏操作界面",
    "creating_groups": "创建编组",
    "create_container": "创建容器",
    "un_group": "取消编组",
    "create_component": "创建组件",
    "unbind_instance": "解绑实例",
    "reset_instance_roperties": "重置实例属性",
    "edit_component": "编辑组件",
    "wx_login": "微信扫码登录",
    "login_read": "扫码表示已阅读并同意",
    "read_TOS": "服务协议",
    "read_Privacy": "隐私协议",
    "product_description": "一款支持原型设计、文档演示以及审批管理的高效率RPD书写工具。",
    "login_footer": "©2024 珠海市旷才科技有限公司",
    "placeholder": "搜索文件",
    "about": "关于",
    "help_manual": "帮助手册",
    "about_software": "关于软件",
    "personal_center": "个人中心",
    "login_out": "退出登录",
    "new_file": "新文件",
    "page1": "页面 1",
    "dissolution": "取消容器",
    "content_includes": "文本包含",
    "title_includes": "标题包含",
    "license_key": "粤ICP备2023042416号",
    "phonetips": "移动端暂不支持登录，请在电脑端进行登录！",
    "btn_login": "登录",
    "artboart_title_visible": "显示容器标题",
    sensitive_reminder: "含有敏感信息，请重新输入。",
    sensitive_reminder2: "含有敏感信息，无法分享。",
    sensitive_reminder3: "含有敏感信息，无法访问。",
    pixel: "对齐像素",
    grid: "像素网格",
    rule: "显示标尺",
    uploadMediaFail: "图片资源上传失败",
    internet: "进入官网"
};
const home$1 = {
    open_local_file: "打开文件",
    open_remote_file: "打开远程文件",
    new_file: "新建文档",
    object_selector: "选择对象",
    scale: "等比缩放",
    automatically_open: "自动打开",
    search_file: "搜索文件",
    about: "关于",
    help_manual: "帮助手册",
    about_software: "关于软件",
    New_file: "新建文件",
    recently_opened: "最近打开",
    star_file: "标星文件",
    file_shared: "我的文件",
    shared_file_received: "收到的共享文件",
    file_shared_with_me: "共享给我的文件",
    recycling_station: "回收站",
    file_name: "文件名称",
    modification_time: "最近访问",
    Creation_time: "创建时间",
    delete_file_time: "删除时间",
    size: "大小",
    operation: "操作",
    filelocation: "文件位置",
    creator: "创建者",
    deleter: "删除人",
    star_marking: "标星",
    share: "分享",
    delete: "删除",
    delete_ok_tips: "文件已移至回收站",
    delete_no_tips: "移除失败",
    test: "测试",
    file_star_marking: "文件已被标星，可在标星列表中查看！",
    rect: "矩形",
    picture: "图片",
    comment: "评论",
    groups: "编组",
    ungroup: "解组",
    search_layer: "搜索图层",
    prompt: "创建者变更了文档权限，文档即将刷新",
    visit: "创建者取消了文件的访问权限，文档即将退出",
    delete_file: "创建者删除了该文档，文档即将退出",
    star: "标星",
    de_star: "取消标星",
    star_ok: "已设为星标文档",
    star_cancel: "已取消星标文档",
    de_access_record: "移除记录",
    access_record_ok: "移除成功",
    access_record_no: "移除失败",
    exit_share: "退出共享",
    exit_share_success: "退出成功",
    exit_share_fail: "退出失败",
    restore: "还原",
    completely_delete: "彻底删除",
    delete_tips: "删除执行后，文件将无法恢复找回，确认要删除吗？",
    delete_ok: "确定删除",
    cancel: "取消",
    failed_list_tips: "文件列表获取失败",
    restore_ok: "还原成功",
    restore_no: "还原失败",
    delete_file_ok: "删除成功",
    delete_file_no: "删除失败",
    other_tips: "请确保网络连接正常",
    addComment: "添加评论",
    rename: "重命名",
    rename_ok: "确定",
    page_sort: "按页面排序",
    login_failed: "登录失败",
    login_refresh: "点击刷新二维码",
    invitation_code_tips: "请输入试用邀请码",
    table_empty_tips: "当前列表没有文件",
    "align_left": "左对齐",
    "align_h_c": "左右居中对齐",
    "align_right": "右对齐",
    "align_top": "顶对齐",
    "align_v_c": "上下居中对齐",
    "align_bottom": "底对齐",
    "distribute_h": "左右等距分布",
    "distribute_v": "上下等距分布",
    people_are_visiting: "正在访问的人:",
    permissions: "权限:",
    contact: "连接线",
    full: "进入全屏",
    exit_full: "退出全屏",
    not_preview_frame: "没有可演示的容器"
};
const search$1 = {
    search_results: "未搜索到相关组件",
    search_history: "没有搜索记录",
    search_history_title: "历史记录",
    search_history_clear: "清除",
    result_count: "共xx条结果"
};
const navi$1 = {
    shape: "图层",
    comps: "组件",
    resource: "资源库",
    page: "页面",
    add_page: "添加新页面",
    copy: "副本",
    development: "功能开发中…",
    overname: "文件名最大长度50字符"
};
const frame$1 = {
    custom: "自定义",
    phone: "手机",
    pad: "平板",
    deskdop: "桌面",
    presentation: "预览",
    watch: "手表",
    paper: "纸张",
    social_media: "社交媒体",
    slide: "幻灯片"
};
const fileMenu$1 = {
    create_new: "新建文件",
    create_copy: "创建文件副本",
    save: "保存",
    rename: "重命名",
    view: "视图",
    guide: "快捷键指南"
};
const pageMenu$1 = {
    copy_link: "复制页面链接",
    duplicate: "创建页面副本",
    rename: "重命名",
    delete: "删除页面"
};
const attr$1 = {
    design: "设计",
    prototype: "原型",
    inspect: "标注",
    constraints: "约束",
    groupings: "相对位置及大小",
    border: "边框",
    opacity: "不透明度",
    fill: "填充",
    text: "文本",
    table_text: "表格文本",
    "follow_container_scaling": "跟随缩放",
    "advanced_stroke": "边框设置",
    position: "位置",
    "corner_smoothing": "平滑圆角",
    vertical: "垂直：",
    horizontal: "水平：",
    fixedWidth: "固定宽度",
    fixedHeight: "固定高度",
    fixedLeft: "左部固定",
    fixedRight: "右部固定",
    withContainer: "跟随缩放",
    fixedTop: "顶部固定",
    fixedBottom: "底部固定",
    thickness: "厚度",
    borderStyle: "样式",
    dash: "虚线",
    solid: "实线",
    startMarkerType: "起点样式",
    endMarkerType: "终点样式",
    background: "画布背景",
    color: "颜色",
    alpha: "不透明度",
    "fixed_left": "靠左固定",
    "fixed_right": "靠右固定",
    "fixed_left_right": "左右固定",
    "center": "居中",
    "follow_container": "跟随缩放",
    "fixed_bottom": "底部固定",
    "fixed_top": "顶部固定",
    "fixed_top_bottom": "上下固定",
    "adapt": "适应容器大小",
    "mixed": "多值",
    "mixed_lang": "存在对象设置不同，可点击 + 号统一设置",
    "mixed_cell_lang": "存在单元格设置不同，点击 + 进行统一设置",
    text_advanced_settings: "文本高级设置",
    word_space: "字间距",
    row_height: "行高",
    paragraph_space: "段落间距",
    id_style: "编号样式",
    letter_case: "字母大小写",
    text_style: "文本样式",
    auto: "自动",
    search_for_fonts: "搜索字体…",
    bold: "加粗",
    tilt: "倾斜",
    underline: "下划线",
    deleteline: "删除线",
    align_left: "左对齐",
    align_center: "居中对齐",
    align_right: "右对齐",
    align_the_sides: "两边对齐",
    align_top: "顶对齐",
    align_middle: "居中对齐",
    align_bottom: "底对齐",
    none_list: "无",
    unordered_list: "无序列表",
    ordered_list: "有序列表",
    as_typed: "无",
    uppercase: "全大写",
    lowercase: "全小写",
    titlecase: "首字母大写",
    autowidth: "单行模式",
    autoheight: "自动高度",
    fixedsize: "固定宽高",
    more_value: "多值",
    used_font: "已使用字体",
    no_font_is_currently_in_use: "当前无已使用字体",
    chinese_font: "中文字体",
    english_font: "英文字体",
    find_the_fonts: "查找不到相关字体",
    font_is_not: "本地不存在该字体，使用默认字体效果替代显示",
    font_color: "字体颜色",
    highlight_color: "高亮颜色",
    multiple_colors: "存在多种颜色值，点击+可统一设置",
    unfold: "展开",
    packup: "收起",
    "flip_v": "垂直翻转",
    "flip_h": "水平翻转",
    full_border: "全边框",
    outer_border: "外边框",
    inner_border: "内边框",
    exit_path_edit: "结束编辑",
    close_path: "闭合路径",
    de_close_path: "打开路径",
    right_angle: "直角",
    completely_symmetrical: "完全对称",
    angular_symmetry: "不对称",
    asymmetric: "角度对称",
    path: "路径",
    corner: "边角",
    unilateral: "单边",
    independentCorners: "展开圆角",
    constrainProportions: "锁定比例",
    frameSize: "容器尺寸"
};
const login$1 = {
    login_failure: "登录失效，请重新登录",
    welcome: "欢迎登录使用",
    name: "墨师设计",
    describe: "在线协作专业产品设计软件",
    miniprogram: "微信小程序",
    scan_code: "微信扫一扫"
};
const comment$1 = {
    reply: "回复",
    delete: "删除",
    settled: "解决",
    edit_content: "编辑内容",
    quick_reply: "快速回复",
    last: "上一条",
    next: "下一条",
    sort: "按页面排序",
    show_about_me: "仅显示关于我的",
    show_resolved_comments: "显示已解决评论",
    comment_area: "评论区",
    input_comments: "输入评论",
    reply_comment: "回复评论",
    check: "查看",
    a_few_reply: "条回复",
    month: "月",
    day: "日",
    no_comment: "当前无评论",
    comments_hide: "评论已设置隐藏",
    show_comments: "显示评论",
    input_no_perm: "无评论权限"
};
const clipboard$1 = {
    "invalid_data": "该内容无法解析",
    "not_supported1": "当前浏览器不支持，请使用Ctrl C复制",
    "not_supported2": "当前浏览器不支持，请使用Ctrl X剪切",
    "copyAsPNGSuccess": "复制成功",
    "copyAsPNGFailed": "复制失败",
    "copyAsPNG": "复制PNG图片"
};
const opacity$1 = {};
const message$1 = {
    doc_notopen: "网络异常，文档无法打开，请检查网络后重试。",
    list_for_failure: "网络异常，文件列表获取失败，请检查网络后重试。",
    retry: "重试",
    leave: "您的更改尚未保存，确定要离开吗？",
    network_error: "网络异常，请勿刷新页面或关闭文档，以免内容丢失，文档尝试保存中…",
    network_anomaly: "网络异常",
    link_success: "网络连接成功",
    autosave: "文档自动保存成功",
    cancel: "取消",
    exit_document: "退出文档",
    back_home: "返回首页",
    unuploaded_msg: "文档存在未上传资源，退出会造成内容丢失，是否退出?"
};
const bool$1 = {
    union: "联集",
    subtract: "减去顶层",
    intersection: "交集",
    difference: "差集",
    cohere: "路径拼合"
};
const date$1 = {
    just_now: "刚刚",
    s: "秒前"
};
const preview$1 = {
    actual_size: "实际尺寸",
    previous_page: "上一页",
    next_page: "下一页",
    first_page: "第一页",
    preview: "预览",
    open: "在设计模式中打开",
    fill_screen: "充满屏幕",
    fit_width: "适应宽度",
    fit_screen: "适应屏幕"
};
attr$1[ht.Inner] = "内部";
attr$1[ht.Center] = "居中";
attr$1[ht.Outer] = "外部";
opacity$1[nt.Normal] = "正常";
opacity$1[nt.Darken] = "变暗";
opacity$1[nt.Multiply] = "正片叠底";
opacity$1[nt.ColorBurn] = "颜色加深";
opacity$1[nt.Lighten] = "变亮";
opacity$1[nt.Screen] = "滤色";
opacity$1[nt.ColorDodge] = "颜色减淡";
opacity$1[nt.Overlay] = "叠加";
opacity$1[nt.SoftLight] = "柔光";
opacity$1[nt.HardLight] = "强光";
opacity$1[nt.Difference] = "差值";
opacity$1[nt.Exclusion] = "排除";
opacity$1[nt.Hue] = "色相";
opacity$1[nt.Saturation] = "饱和度";
opacity$1[nt.Color] = "颜色";
opacity$1[nt.Luminosity] = "明度";
opacity$1[nt.PlusDarker] = "加暗";
opacity$1[nt.PlusLighter] = "提亮";
const shape$1 = {
    group: "编组",
    page: "页面",
    line: "直线",
    oval: "圆形",
    rect: "矩形",
    path: "路径",
    artboard: "容器",
    arrow: "箭头",
    text: "文字",
    image: "图片",
    input_text: "输入文本",
    table: "表格",
    contact: "连接线",
    cutout: "切图",
    shape_tool: "形状工具",
    symbol: "组件",
    curve: "曲线工具",
    clip: "裁剪工具",
    default: "默认",
    pen: "钢笔",
    pencil: "铅笔",
    polygon: "多边形",
    star: "星形"
};
shape$1[Vt.Rectangle] = "矩形";
const color$1 = {
    solid: "纯色",
    linear: "线性渐变",
    radial: "径向渐变",
    angular: "旋转渐变",
    esc: "按ESC退出",
    recently: "最近使用",
    documentc: "文档使用",
    times: "使用xx次",
    rotate: "旋转90度",
    reverse: "翻转渐变"
};
color$1[wt.Linear] = "线性渐变";
color$1[wt.Radial] = "径向渐变";
color$1[wt.Angular] = "旋转渐变";
const share$1 = {
    need_to_apply_for_confirmation: "需申请确认",
    editable: "编辑",
    readOnly: "只读",
    remove: "移除",
    anyone_can_read_it: "任何人均可阅读",
    anyone_can_edit_it: "任何人均可编辑",
    anyone_can_comment: "任何人均可评论",
    shareable: "已关闭分享",
    no_authority: "无权限",
    copy_success: "复制成功",
    copy_failure: "复制失败",
    file_sharing: "文件分享",
    share_switch: "分享开关",
    file_name: "文件名",
    page_order_adjustment: "页面顺序调整",
    permission_setting: "权限设置",
    copy_link: "复制链接",
    people_who_have_joined_the_share: "已加入分享的人",
    share_limit: "分享限制人数",
    founder: "创建者",
    document_permission: "文档权限",
    reviewable: "评论",
    no_document: "没有该文档"
};
const permission$1 = {
    no_authority_to_rename: "没有对当前文档进行重命名的权限"
};
const apply$1 = {
    file_access_request: "文件访问申请",
    applicant: "申请人",
    access_file: "访问文件",
    authority: "权限",
    remarks: "备注",
    agree: "同意",
    refuse: "拒绝",
    maximum_share: "该文件已达最大分享人数，请联系创建者处理",
    request_access: "您已多次申请访问权限，请等待创建者处理",
    no_file_access_permission: "无文件访问权限",
    file_attribution: "文件归属",
    apply_for_permission: "申请权限",
    read_only: "仅阅读",
    apply_for_edit: "申请编辑",
    please_remarks: "请输入申请备注",
    file_deleted: "文件已被删除，或创建者已关闭分享",
    authorization_failure: "授权失败",
    notification_message: "通知消息",
    application_documents: "申请文件",
    have_agreed: "已同意",
    rejected: "已拒绝",
    no_message_received: "未收到任何消息",
    link_not: "链接不存在",
    not_passed: "申请未通过，请修改信息或联系创建者后重新申请",
    project_apply: "加入项目申请",
    project: "项目",
    team: "团队",
    team_apply: "加入团队申请",
    file: "文件",
    apply_team: "申请加入团队：",
    apply_project: "申请加入项目："
};
const percenter$1 = {
    return_home: "返回首页",
    personal_center: "个人中心",
    essential_information: "基本信息",
    head_portrait: "头像",
    avatar_restriction: "上传5M以内PNG或JPG格式图片",
    modify_profile_picture: "更换",
    username: "用户名",
    edit_user_name: "编辑",
    affirm: "确认",
    cancel: "取消",
    userID: "用户ID",
    successtips: "更改成功",
    errortips1: "更改失败",
    errortips: "图片大小或格式不符",
    usernametips_null: "用户名不能为空",
    usernametips_length: "用户名不能超过20个字符",
    nicknametips_length: "昵称不能为空且不超过20个字符",
    error_occurred: "发生错误"
};
const homerightmenu$1 = {
    open: "打开",
    newtabopen: "在新标签页打开",
    share: "分享",
    exit_share: "退出共享",
    target_star: "标星",
    unstar: "取消标星",
    rename: "重命名",
    copyfile: "创建文件副本",
    removed_record: "从打开记录移除",
    deletefile: "删除文件",
    restore: "还原",
    completely_delete: "彻底删除",
    copyfile_ok: "复制成功",
    copyfile_no: "复制失败",
    "unable_lower": "无法再向下移动",
    "unable_upper": "无法再向上移动"
};
const table$1 = {
    table: "表格",
    table_style: "表格样式",
    del_column: "删除行列",
    del_select_row: "删除选中行",
    del_select_col: "删除选中列",
    del_table: "删除整个表格",
    split_cell: "拆分单元格",
    split_towrow: "拆分为两行",
    split_towcol: "拆分为两列",
    insert_column: "插入行列",
    merge_cell: "合并单元格",
    top_insert: "上方插入行",
    bottom_insert: "下方插入行",
    left_insert: "左侧插入列",
    right_insert: "右侧插入列",
    confirm: "确定",
    row: "行",
    col: "列",
    insert_table: "插入表格",
    row_num: "行数",
    col_num: "列数",
    column_table: "指定行列表格"
};
const Createteam$1 = {
    add_team: "创建团队",
    add_project: "新建项目",
    team_name: "团队名称",
    project_name: "项目名称",
    team_name_tips: "输入团队名称",
    project_name_tips: "输入项目名称",
    team_description: "团队描述",
    project_description: "项目描述",
    team_description_tips: "输入团队描述",
    project_description_tips: "输入项目描述",
    team_avatar: "团队头像",
    required: "（必填）",
    optional: "（选填）",
    avatar_restriction: "选择2M以内的JPG、PNG格式图片作为头像显示",
    movetip: "移动文件位置",
    move: "移动",
    description: "你还没有填写团队描述，快去填写吧。",
    sharetip: "收到的共享项目",
    fixed: "固定项目",
    cancelFixed: "取消固定",
    projectdeltitle: "删除项目",
    projectexittitle: "退出项目",
    projectexitcontext: "退出项目后，无法再访问项目中的文件，或使用项目中的资源。",
    projectdelcontext: "删除项目后，将删除项目及项目中所有文件、资料。",
    ok_exit: "仍然退出",
    ok_delete: "仍然删除",
    membertip: "邀请项目成员",
    projectsetting: "项目访问设置",
    membersetting: "成员权限设置",
    projectfilenull: "当前项目没有文件",
    projectfilesearchtips: "没有匹配的文件",
    projectOptionsA: "公开: 团队全部成员可访问",
    projectOptionsB: "非公开: 仅通过链接申请访问",
    projectPermsA: "仅阅读",
    projectPermsB: "可评论",
    projectPermsC: "可编辑",
    projecttype: "项目类型",
    jurisdiction: "权限",
    jointips: "点击链接或扫描二维码申请加入",
    invitation_switch: "邀请链接：",
    copylink: "复制链接",
    confirm: "确定",
    cancel: "取消",
    joinprojecttipsA: "申请加入项目",
    joinprojecttipsB: "加入项目后，可访问该项目中的所有文件、资源",
    joinprojecttipsC: "已发送申请，",
    joinprojecttipsC1: "即将进入应用首页，待审批通过后，可查看该项目内容",
    joinprojecttipsD: "项目邀请已关闭，如需加入项目，请联系项目管理员处理。",
    joinprojecttipsE: "返回首页",
    joinprojecttipsF: "申请加入",
    all: "全部",
    creator: "创建者",
    manager: "管理员",
    editable: "可编辑",
    reviewed: "可评论",
    Readonly: "仅阅读",
    transferor: "转让创建者",
    moveoutproject: "移出项目组",
    membersed: "已加入项目成员",
    username: "用户名",
    pertipsA: "项目权限: 公开，所有团队成员均可访问",
    pertipsB: "项目权限: 非公开，仅通过链接邀请成员可访问",
    Transfertips: "转让创建者权限后，您将不再拥有该项目，后续作为管理员留在项目中。",
    confirmTransfer: "确定转让",
    project: "项目组",
    team: "团队",
    welcome: "欢迎加入",
    rejectprompt1: "拒绝了",
    rejectprompt2: "如有疑问，请联系团队管理员。",
    rejectprompt3: "如有疑问，请联系项目管理员。",
    shareprojecttips: "项目中所有成员均可访问"
};
const inviteMember$1 = {
    title: "邀请同事加入团队",
    permission_set: "权限设置",
    permission_tips: "发送链接或二维码给同事申请加入",
    permission_switch: "邀请链接开关：",
    permission_tipsA: "同事申请后，需管理员确认后才能加入",
    copy_success: "复制成功",
    copy_failure: "复制失败"
};
const joinTeam$1 = {
    jointeamtipsA: "申请加入团队：",
    jurisdiction: "加入团队后，可访问该团队中的项目、文件、资源",
    jointeamtipsB: "申请加入",
    jointeamtipsC: "已发送申请，",
    jointeamtipsC1: "即将进入应用首页，待审批通过后，可查看该团队内容",
    jointeamtipsD: "团队邀请已关闭，如需加入团队，请联系团队管理员处理。",
    read: "阅读",
    edit: "编辑"
};
const moveprojectfill$1 = {
    name: "文件名称：",
    location: "当前位置：",
    my_file: "我的文件",
    move_to: "移动文件至：",
    private_file: "设为私有文件",
    share_Project: "收到的共享项目",
    cancel: "取消"
};
const projectlist$1 = {
    datanull: "未加入任何项目",
    datanull2: "没有匹配的项目",
    addproject: "新建项目",
    project_name: "项目名称",
    project_description: "项目描述",
    creator: "创建者",
    operation: "操作",
    enterproject: "进入项目",
    confirm1: "新建项目"
};
const projectpage$1 = {
    menu: "项目菜单",
    back: "回到上一级",
    input_tips: "点击输入项目描述…",
    unpin: "取消固定",
    fixed_items: "固定项目",
    member: "邀请项目成员",
    permission: "成员权限",
    file: "文件",
    recycle_bin: "回收站"
};
const teammember$1 = {
    transferCreator_context: "转让创建者权限后，您将不再拥有该团队，后续作为管理员留在团队中。",
    transferCreator_title: "转移创建者权限",
    transferCreator_confirm: "确定转移",
    outTeamDialog_context: "移出团队后，该成员无法再访问团中的项目及资源。",
    outTeamDialog_title: "移出团队",
    outTeamDialog_confirm: "确认移出",
    exitTeamDialog_context: "退出团队后，团队中的所有项目，文件及资源，将无法再进行访问。",
    modifyNickname_title: "仅针对当前团队修改，不影响在其他团队的姓名",
    exitTeamDialog_title: "离开团队",
    exitTeamDialog_confirm: "确认离开",
    name: "姓名",
    modify: "修改",
    change_teamname: "更改团队姓名",
    change_name: "修改姓名",
    team_permission: "团队权限",
    all: "全部",
    creator: "创建者",
    manager: "管理员",
    editable: "可编辑",
    Readonly: "仅阅读",
    leave_team: "离开团队",
    move_team: "移出团队",
    transfer_creator: "转移创建者",
    permission_tips: "已设为：",
    transfer_tips: "已转让给："
};
const teampage$1 = {
    addproject: "新建项目",
    addmember: "邀请成员",
    search_default_tipsA: "搜索项目/创建者",
    search_default_tipsB: "搜索成员",
    project: "项目",
    members: "成员",
    team_set: "团队设置"
};
const teamprojectmenu$1 = {
    rename: "重命名",
    projectsetting: "项目访问设置",
    membersetting: "成员权限设置",
    fixed: "固定项目",
    cancelFixed: "取消固定",
    projectexittitle: "退出项目",
    projectdeltitle: "删除项目"
};
const teamsetting$1 = {
    team_name: "团队名称",
    edit_name: " 修改名称",
    team_description: "团队描述",
    edit_description: "修改描述",
    team_avatar: "团队头像",
    edit_avatar: "修改头像",
    avatar_restriction: "选择2M以内的JPG、PNG格式图片作为头像显示",
    disband_team: "解散团队",
    disband_team_tips: "解散团队，删除团队文件，不可恢复",
    leave_team: "离开团队",
    leave_team_tips: "离开团队后，将无法再查看团队项目及资源",
    disband_team_tipsB: "解散团队后，将彻底删除团队中包含的全部项目资料，且不可恢复。",
    leave: "离开",
    disband: "解散",
    confirm: "确定",
    cancel: "取消",
    title_name1: "修改团队名称",
    title_name2: "修改团队描述",
    title_name3: "解散团队",
    title_name4: "离开团队"
};
const compos$1 = {
    duplicate_name: "名称重复，请重新输入",
    default_text_input: "请输入默认文本",
    attr_name_input: "请输入属性名称",
    place_select_instance: "请选择组件实例",
    place_select_layer: "请选择图层",
    compos_instance: "组件实例",
    select_layer: "选择图层",
    show: "显示",
    hidden: "隐藏",
    text_layer_null: "文本图层为空",
    instance_null: "组件实例为空",
    text_content: "文本内容",
    layer_isShow: "图层是否显示",
    instance_attr: "实例属性",
    untie: "解绑",
    reset_all_attr: "重置全部属性",
    layer_show: "图层显示",
    close_icon: "关闭图标",
    compos_state: "组件状态",
    toggle_instance: "切换实例",
    instance_toggle: "实例切换",
    compos_attr: "组件属性",
    delect_attr_type: "选择新建属性类型",
    display_state: "显示状态",
    search_compos: "搜索组件",
    compos: "组件",
    attr_name: "属性名称",
    state: "状态",
    lib_local: "本地",
    lib_line: "线框图组件",
    gocomp: "转到主组件",
    datail: "查看详情",
    attri_1: "属性 1",
    dlt: "默认",
    dltv: "默认值",
    attri: "属性",
    add_new: "添加新值",
    error_1: "新的组件不能包含已有组件图层的组成图层",
    error_2: "新的组件不能包含组件实例的组成图层",
    error_3: "组件内部不能包含连接线",
    validate_info_1: "请选择图层",
    validate_info_2: "属性名不能为空",
    validate_info_3: "默认值不能为空",
    conflict: "存在状态相同的可变组件，需要修改状态以解决冲突",
    conflict_2: "此可变组件存在相同状态，需要修改状态以解决冲突",
    confirm: "确认",
    circle_warning: "存在循环引用",
    invalid_compos: "无效组件",
    toggle_list_style: "切换列表"
};
const lable$1 = {
    development: "开发模式",
    selectLayer: "请选择图层",
    copyfailure: "复制失败",
    border: "边框",
    position: "位置",
    pure_color: "纯色",
    thickness: "粗细",
    style: "样式",
    dotted_line: "虚线",
    solid_line: "实线",
    code: "代码",
    copy_all: "复制全部",
    copy: "复制",
    fill: "填充",
    layer_info: "图层信息",
    name: "名称",
    posi: "位置",
    size: "大小",
    rotate: "角度",
    raduis: "圆角",
    opacity: "不透明度",
    select_multiple_layers: "已选择多个图层",
    development_platform: "开发平台",
    applet_of_WeChat: "微信小程序",
    pixel: "像素",
    copied: "已复制",
    click_copy: "点击复制",
    text: "文本",
    content: "内容",
    font: "字体",
    type_size: "字号",
    word_weight: "字重",
    word_space: "字间距",
    line_height: "行高",
    para_spacing: "段间距"
};
const shadow$1 = {
    shadow_stting: "阴影",
    only_used: "仅矩形、圆形以及容器可以使用",
    shadow_setting: "阴影设置",
    position: "位置",
    color: "颜色",
    effect: "效果",
    blur: "模糊",
    extend: "扩展",
    fill_is_visible: "容器的填充可见时可使用"
};
shadow$1[zt.Inner] = "内阴影";
shadow$1[zt.Outer] = "外阴影";
const blur$1 = {
    blur: "模糊",
    blur_setting: "模糊设置"
};
blur$1[ot.Gaussian] = "高斯模糊";
blur$1[ot.Background] = "背景模糊";
blur$1[ot.Zoom] = "缩放模糊";
blur$1[ot.Motion] = "动感模糊";
const cutoutExport$1 = {
    cutoutNotBool: "切图图层不支持布尔操作",
    cutout: "切图",
    create_cut_chart_and_export: "创建切图与导出",
    trim_transparent_pixels: "修剪透明像素",
    canvas_background_color: "画布背景色",
    export: "导出",
    preview: "预览",
    default: "默认",
    ios_presets: "iOS预设",
    android_presets: "Android预设",
    export_cutout: "导出切图",
    repeat: "与其他切图重名"
};
cutoutExport$1[mt.Prefix] = "前缀";
cutoutExport$1[mt.Suffix] = "后缀";
const report$1 = {
    title: "举报",
    tips: "请选择要举报的问题类型，并填写详细举报内容。",
    type: "举报类型",
    type_normal: "请选择类型",
    type_value1: "欺诈",
    type_value2: "色情低俗",
    type_value3: "不当言论",
    type_value4: "其他",
    report_content: "举报内容",
    report_normal: "请填写详细内容",
    upload_img: "上传截图",
    select_img: "添加文件",
    img_tips: "添加png、jpg格式文件，最多可上传5张",
    filet_ips: "允许使用当前文档用于确定举报证明使用",
    submit: "提交举报",
    cancel: "取消"
};
const setting$1 = {
    pixelAlignMentOn: "对齐像素已开启",
    pixelAlignMentOff: "对齐像素已关闭",
    pixelGridOn: "像素网格已开启",
    pixelGridOff: "像素网格已关闭"
};
const miniprogram$1 = {
    home: "首页",
    my_file: "我的文件",
    team: "团队",
    about: "我的",
    privacy: "隐私政策",
    serve: "在线服务协议",
    search: "没有匹配的文件",
    listnull: "当前列表没有文件",
    flushed: "刷新",
    recent: "最近",
    share: "收到的共享",
    star: "标星",
    projectnull: "还未加入项目",
    share_title: "分享",
    permissions: "权限设置",
    myself: "仅自己",
    confirm: "需要确认",
    share_users: "已加入分享的人",
    share_to: "分享到",
    copy_link: "复制链接",
    share_users_null: "没有加入的成员",
    team_jion_null: "还未加入团队"
};
const product$1 = {
    name: "墨师设计",
    subtitle: "在线协作专业产品设计软件",
    description: "墨师设计是一款专业产品设计软件，支持产品文稿写作、UI设计、设计演示、切图标注交付，为产品研发团队提供一站式协同设计新体验",
    keywords: "墨师设计,产品设计,协同设计,UI设计,Moss Design"
};
const pattern$1 = {
    image: "图片"
};
pattern$1[Mt.Fill] = "填充";
pattern$1[Mt.Stretch] = "拉伸";
pattern$1[Mt.Fit] = "适应";
pattern$1[Mt.Tile] = "平铺";
const start$1 = {
    title: "一起来设计吧",
    description_1: "专业产品设计软件，支持产品文稿写作、UI设计、设计演示、切图标注交付，",
    description_2: "为产品研发团队提供一站式协同设计新体验"
};
const moss$1 = {};
const design$1 = {
    title: "专业UI设计功能",
    description_1: "专业的矢量编辑工具，满足精细化编辑；高效的组件功能，",
    description_2a: " 并且兼容Sketch、Figma(",
    description_2b: "开发中，敬请期待",
    description_2c: ")等主流文件格式",
    description_3: "无缝进行文件迁移"
};
const cooperation$1 = {
    title: "团队实时协作",
    description_1: "链接邀请，在线实时协同，随时都能获取最新稿件；",
    description_2: "文档定点评论，高效沟通，让思维随时碰撞出新的火花；",
    description_3: "设计师轻松交付，切图资源、布局参数，工程师信手拈来"
};
const platform$1 = {
    title: "跨终端 无缝衔接",
    description: "多端数据实时同步，随时随地编辑创作"
};
const end$1 = {
    title: "每个参与者都能高效参与的设计工具"
};
const pub$1 = {
    login_1: "开始设计",
    login_2: "立即免费体验"
};
const lang_zh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Createteam: Createteam$1,
    apply: apply$1,
    attr: attr$1,
    blur: blur$1,
    bool: bool$1,
    clipboard: clipboard$1,
    color: color$1,
    comment: comment$1,
    compos: compos$1,
    cooperation: cooperation$1,
    cutoutExport: cutoutExport$1,
    date: date$1,
    design: design$1,
    end: end$1,
    fileMenu: fileMenu$1,
    frame: frame$1,
    home: home$1,
    homerightmenu: homerightmenu$1,
    inviteMember: inviteMember$1,
    joinTeam: joinTeam$1,
    lable: lable$1,
    login: login$1,
    message: message$1,
    miniprogram: miniprogram$1,
    moss: moss$1,
    moveprojectfill: moveprojectfill$1,
    navi: navi$1,
    opacity: opacity$1,
    pageMenu: pageMenu$1,
    pattern: pattern$1,
    percenter: percenter$1,
    permission: permission$1,
    platform: platform$1,
    preview: preview$1,
    product: product$1,
    projectlist: projectlist$1,
    projectpage: projectpage$1,
    pub: pub$1,
    report: report$1,
    search: search$1,
    setting: setting$1,
    shadow: shadow$1,
    shape: shape$1,
    share: share$1,
    start: start$1,
    system: system$1,
    table: table$1,
    teammember: teammember$1,
    teampage: teampage$1,
    teamprojectmenu: teamprojectmenu$1,
    teamsetting: teamsetting$1
}, Symbol.toStringTag, { value: "Module" }));
const system = {
    incorrect_input: "Incorrect input!",
    "illegal_input": "illegal input!",
    select: "Select",
    space: "...",
    empty: "No data",
    paste: "Paste",
    "paste_here": "Paste Here",
    "only_text": "Paste text",
    copy: "Copy",
    copyAs: "Copy/Paste as",
    cut: "Cut",
    replace: "Replace",
    failed: "Failed",
    "null_file_name": "The file name cannot be empty",
    "replace_failed": "Replacement failed, please try pasting",
    "select_layer": "Select layer",
    "bring_forward": "Bring forward",
    "send_backward": "Send backward",
    "bring_to_top": "Bring to top",
    "send_to_bottom": "Send to bottom",
    "visible": "Visible/Hidden",
    "hidden": "Hidden",
    "Lock": "Lock/Unlock",
    "select_all": "Select all",
    "fit_canvas": "Adapt to artboard",
    "show_many_cursor": "Show others cursor",
    "show_comment": "Show Cutout",
    "show_ruler": "show ruler",
    "show_pixel_network": "Show grid",
    "hide_operation_interface": "Hide UI",
    "creating_groups": "Create group",
    "create_container": "Create artboard",
    "un_group": "Dissolve the group",
    "create_component": "Create component",
    "unbind_instance": "Unbind",
    "reset_instance_roperties": "Reset",
    "edit_component": "Edit component",
    "wx_login": "Wechat scan code login",
    "login_read": "Scanning code indicates that you have read and agreed",
    "read_TOS": "Service Agreement",
    "read_Privacy": "Privacy Agreement",
    "product_description": "An efficient RPD writing tool that supports prototyping, document presentation, and approval management.",
    "login_footer": "Zhuhai Kuangcai Technology Co., Ltd",
    "placeholder": "Search file",
    "about": "About",
    "help_manual": "Help manual",
    "about_software": "About Software",
    "personal_center": "Personal center",
    "login_out": "Login out",
    "new_file": "New file",
    "page1": "Page 1",
    "dissolution": "Dissolution",
    "content_includes": "Content includes",
    "title_includes": "Title includes",
    "license_key": "粤ICP备2023042416号",
    "phonetips": "Mobile terminal does not support login, please login on the computer side!",
    "btn_login": "Login",
    "artboart_title_visible": "Show artboard title",
    sensitive_reminder: "Contains sensitive information, please re-enter.",
    sensitive_reminder2: "Contains sensitive information and cannot be shared.",
    sensitive_reminder3: "Contains sensitive information and cannot be accessed.",
    pixel: "Pixel Round",
    grid: "Pixel grid",
    rule: "Rule",
    uploadMediaFail: "Image upload failed",
    internet: "Go Home"
};
const home = {
    open_local_file: "Open file",
    open_remote_file: "Open remote file",
    new_file: "New file",
    object_selector: "Move",
    scale: "Scale",
    automatically_open: "Automatically open",
    search_file: "Search file",
    about: "About",
    help_manual: "Help manual",
    about_software: "About software",
    New_file: "New file",
    recently_opened: "Recently opened",
    star_file: "Star file",
    file_shared: "My files",
    shared_file_received: "Shared file received",
    file_shared_with_me: "File shared with me",
    recycling_station: "Recycling station",
    file_name: "File name",
    modification_time: "Recently visited",
    Creation_time: "Creation time",
    delete_file_time: "Deletion time",
    size: "Size",
    operation: "Operation",
    filelocation: "File location",
    creator: "Creator",
    deleter: "Deleter",
    star_marking: "Star marking",
    share: "Share",
    delete: "Delete",
    delete_ok_tips: "File moved to trash",
    delete_no_tips: "Removal failed",
    test: "Test",
    file_star_marking: "File has been marked star, can be viewed in the star list!",
    rect: "Rectangle",
    picture: "Picture",
    comment: "Comments",
    groups: "Group up",
    ungroup: "Ungroup",
    search_layer: "Search layer",
    prompt: "Founder change the file permissions, document is refreshed",
    visit: "Founder cancelled file access, document will exit",
    delete_file: "The creator deleted the document and it is about to exit",
    star: "Star",
    de_star: "Delete star",
    star_ok: "Starred document",
    star_cancel: "Document unstarred",
    de_access_record: "Delete access record",
    access_record_ok: "Removed successfully",
    access_record_no: "Removal failed",
    exit_share: "Exit share",
    exit_share_success: "Exit share success",
    exit_share_fail: "Exit share failed",
    restore: "Restore",
    completely_delete: "Completely delete",
    delete_tips: "After deleting, the file cannot be recovered. Are you sure you want to delete it?",
    delete_ok: "confirm delete",
    cancel: "cancel",
    failed_list_tips: "Failed to get file list",
    restore_ok: "Restored successfully",
    restore_no: "Restore failed",
    delete_file_ok: "Successfully deleted",
    delete_file_no: "Failed to delete",
    other_tips: "Please make sure the network connection is normal",
    addComment: "Add comment",
    rename: "Rename",
    rename_ok: "OK",
    page_sort: "Sort by page",
    login_failed: "Login failure",
    login_refresh: "Click refresh QR code",
    invitation_code_tips: "Please enter the trial invitation code",
    table_empty_tips: "No content",
    "align_left": "Align left",
    "align_h_c": "Align horizontal centers",
    "align_right": "Align right",
    "align_top": "Align top",
    "align_v_c": "Align vertical centers",
    "align_bottom": "Align bottom",
    "distribute_h": "Distribute horizontal spacing",
    "distribute_v": "Distribute vertical spacing",
    people_are_visiting: "People are visiting:",
    permissions: "Permissions:",
    contact: "Contact",
    full: "Full screen",
    exit_full: "Exit full screen",
    not_preview_frame: "There is no demonstrable container"
};
const search = {
    search_results: "No matching results",
    search_history: "No search history",
    search_history_title: "Historical record",
    search_history_clear: "Clear",
    result_count: "xx results"
};
const navi = {
    shape: "Shapes",
    comps: "Compnents",
    resource: "Resource",
    page: "Page",
    add_page: "Add new page",
    copy: "copy",
    development: "Functional development…",
    overname: "The maximum length of filenames is 50 characters"
};
const frame = {
    custom: "Custom",
    phone: "Phone",
    pad: "Pad",
    deskdop: "Deskdop",
    presentation: "Presentation",
    watch: "Watch",
    paper: "Paper",
    social_media: "Social media",
    slide: "Slide"
};
const fileMenu = {
    create_new: "Create new file",
    create_copy: "Create copy of file",
    save: "Save file",
    rename: "Rename file",
    view: "View",
    guide: "Shortcut key guide"
};
const pageMenu = {
    copy_link: "Copy link to page",
    duplicate: "Duplicate page",
    rename: "Rename page",
    delete: "Delete page"
};
const attr = {
    design: "Design",
    prototype: "Prototype",
    inspect: "Inspect",
    constraints: "Constraints",
    groupings: "Groupings",
    border: "Border",
    opacity: "Opacity",
    fill: "Fill",
    text: "Text",
    table_text: "Table Text",
    "follow_container_scaling": "Follow container scaling",
    "advanced_stroke": "Advanced stroke",
    position: "Position",
    "corner_smoothing": "Cornor smoothing",
    vertical: "Vertical",
    horizontal: "Horizontal",
    fixedWidth: "FixedWidth",
    fixedHeight: "FixedHeight",
    fixedLeft: "Left fixed",
    fixedRight: "Right fixed",
    withContainer: "Follow container scaling",
    fixedTop: "Top fixed",
    fixedBottom: "Bottom fixed",
    thickness: "Thickness",
    borderStyle: "Border style",
    dash: "Dash",
    solid: "Solid",
    startMarkerType: "Start Marker Type",
    endMarkerType: "End Marker Type",
    background: "Background",
    color: "Color",
    alpha: "Alpha",
    "fixed_left": "Left fixed",
    "fixed_right": "Right fixed",
    "fixed_left_right": "Fixed left and right",
    "center": "Center",
    "follow_container": "Follow container",
    "fixed_bottom": "Bottom fixed",
    "fixed_top": "Top fixed",
    "fixed_top_bottom": "Fixed top and bottom",
    "adapt": "Resize to fit",
    "mixed": "Mixed",
    "mixed_lang": "Click + to replace mixed content.",
    "mixed_cell_lang": "There are cell Settings, click + set centrally",
    text_advanced_settings: "Text Advanced Settings",
    word_space: "Word space",
    row_height: "Line height",
    paragraph_space: "Paragraph spacing",
    id_style: "Numbering style",
    letter_case: "Letter case",
    text_style: "Text style",
    auto: "Auto",
    search_for_fonts: "Search for fonts…",
    bold: "Bold",
    tilt: "Tilt",
    underline: "Underline",
    deleteline: "Delete line",
    align_left: "Text align left",
    align_center: "Text align center",
    align_right: "Text align right",
    align_the_sides: "Text align justified",
    align_top: "Align top",
    align_middle: "Align middle",
    align_bottom: "Align bottom",
    none_list: "No list",
    unordered_list: "Bulleted list",
    ordered_list: "Unmbered list",
    as_typed: "As typed",
    uppercase: "Uppercase",
    lowercase: "Lowercase",
    titlecase: "Title case",
    autowidth: "Auto width",
    autoheight: "Auto height",
    fixedsize: "Fixed size",
    more_value: "More value",
    used_font: "Used font",
    no_font_is_currently_in_use: "No font is currently in use",
    chinese_font: "Chinese font",
    english_font: "English font",
    find_the_fonts: "Can't find the fonts",
    font_is_not: "The font is not present locally. Use the default font effect instead",
    font_color: "Font color",
    highlight_color: "Highlight color",
    multiple_colors: "There are many color values, click + can be unified set",
    unfold: "Unfold",
    packup: "Pack up",
    "flip_v": "Flip Vertical",
    "flip_h": "Flip Horizontal",
    full_border: "Full border",
    outer_border: "border",
    inner_border: "Inner border",
    exit_path_edit: "Exit",
    close_path: "Close",
    de_close_path: "Open",
    right_angle: "Right Angle",
    completely_symmetrical: "Completely Symmetrical",
    angular_symmetry: "Angular Symmetry",
    asymmetric: "Asymmetric",
    path: "Path",
    corner: "corner",
    unilateral: "unilateral",
    independentCorners: "Independent corners",
    constrainProportions: "Constrain proportions",
    frameSize: "Frame"
};
const login = {
    login_failure: "Login failure",
    welcome: "Welcome",
    name: "MossDesign",
    describe: "Online collaborative professional product design software",
    miniprogram: "MiniProgram",
    scan_code: "Scan wechat"
};
const comment = {
    reply: "Reply",
    delete: "Delete",
    settled: "solve",
    edit_content: "Edit content",
    quick_reply: "Quick reply",
    last: "Last",
    next: "Next",
    sort: "Sort by page",
    show_about_me: "Show about me",
    show_resolved_comments: "Show resolved comments",
    comment_area: "Comment section",
    input_comments: "Input comments",
    reply_comment: "Reply to comment",
    check: "check",
    a_few_reply: "reply",
    month: "month",
    day: "day",
    no_comment: "No comments",
    comments_hide: "Comments are set to hide",
    show_comments: "Show comments",
    input_no_perm: "No permission to comment"
};
const clipboard = {
    "invalid_data": "invalid data",
    "not_supported1": "The current browser does not support it, please use Ctrl C to copy",
    "not_supported2": "The current browser does not support it, please use ctrl X to cut",
    "copyAsPNGSuccess": "copied as PNG",
    "copyAsPNGFailed": "Failed",
    "copyAsPNG": "copy as PNG"
};
const opacity = {};
const message = {
    doc_notopen: "Network anomalies, the document can't open, please try again after checking the network.",
    list_for_failure: "Network exception, file list acquisition failed, please check the network and try again.",
    retry: "Retry",
    leave: "Your changes have not been saved, are you sure you want to leave?",
    network_error: "Please do not refresh the page or close the document to avoid content loss. The document is trying to save...",
    network_anomaly: "Network anomaly",
    link_success: "Network connection successful",
    autosave: "Automatic document saving",
    cancel: "Cancel",
    exit_document: "Exit",
    back_home: "Back to home",
    unuploaded_msg: "The document has unuploaded resources. If you exit, content will be lost. Do you want to exit?"
};
const bool = {
    union: "Union",
    subtract: "Subtract",
    intersection: "Intersect",
    difference: "Exclude",
    cohere: "Vector"
};
const date = {
    just_now: "Just now",
    s: "s"
};
const preview = {
    actual_size: "Actual size",
    previous_page: "Previous page",
    next_page: "Next page",
    first_page: "First page",
    preview: "Preview",
    open: "Opens in Design mode",
    fill_screen: "Fill screen",
    fit_width: "Fit width",
    fit_screen: "Fit screen"
};
attr[ht.Inner] = "Inner";
attr[ht.Center] = "Center";
attr[ht.Outer] = "Outer";
opacity[nt.Normal] = "Normal";
opacity[nt.Darken] = "Become dark";
opacity[nt.Multiply] = "Multiply";
opacity[nt.ColorBurn] = "Color deepening";
opacity[nt.Lighten] = "Become bright";
opacity[nt.Screen] = "Filter";
opacity[nt.ColorDodge] = "Color dodge";
opacity[nt.Overlay] = "Superpose";
opacity[nt.SoftLight] = "Soft light";
opacity[nt.HardLight] = "Strong light";
opacity[nt.Difference] = "Difference";
opacity[nt.Exclusion] = "Exclude";
opacity[nt.Hue] = "Hue";
opacity[nt.Saturation] = "Saturation";
opacity[nt.Color] = "Color";
opacity[nt.Luminosity] = "Lightness";
opacity[nt.PlusDarker] = "Plus darker";
opacity[nt.PlusLighter] = "Plus lighter";
const shape = {
    group: "Group",
    page: "Page",
    line: "Line",
    oval: "Oval",
    rect: "Rect",
    path: "Vector",
    artboard: "Artboard",
    arrow: "Arrow",
    text: "text",
    image: "image",
    input_text: "Input text",
    table: "Table",
    contact: "Contact",
    cutout: "Cutout",
    shape_tool: "Shape tool",
    symbol: "Symbol",
    curve: "Curve",
    clip: "Clip",
    default: "Default",
    pen: "Pen",
    pencil: "Pencil",
    polygon: "Polygon",
    star: "Star"
};
shape[Vt.Rectangle] = "Rectangle";
const color = {
    solid: "Solid",
    linear: "Liner",
    radial: "Radial",
    angular: "Angular",
    esc: "Press ESC to exit",
    recently: "Recently used",
    documentc: "Document colors",
    times: "Used xx times",
    rotate: "Rotate",
    reverse: "Reverse"
};
color[wt.Linear] = "Linear gradient";
color[wt.Radial] = "Radial gradient";
color[wt.Angular] = "Angular gradient";
const share = {
    need_to_apply_for_confirmation: "Need to apply for confirmation",
    editable: "Editable",
    readOnly: "ReadOnly",
    remove: "Remove",
    anyone_can_read_it: "Anyone can read it",
    anyone_can_edit_it: "Anyone can edit it",
    anyone_can_comment: "Anyone can comment",
    shareable: "Shareable",
    no_authority: "No authority",
    copy_success: "Copy success",
    copy_failure: "Copy failure",
    file_sharing: "File sharing",
    share_switch: "Share switch",
    file_name: "File name",
    page_order_adjustment: "Page order adjustment",
    permission_setting: "Permission setting",
    copy_link: "Copy link",
    people_who_have_joined_the_share: "People who have joined the share",
    share_limit: "Share limit",
    founder: "Founder",
    document_permission: "Document permission",
    reviewable: "Reviewable",
    no_document: "No such document"
};
const permission = {
    no_authority_to_rename: "当前没有重命名的权限"
};
const apply = {
    file_access_request: "File access request",
    applicant: "Applicant",
    access_file: "Access file",
    authority: "Authority",
    remarks: "Remarks",
    agree: "Agree",
    refuse: "Refuse",
    maximum_share: "The file has reached the maximum number of shares. Contact the creator",
    request_access: "You have applied for access several times, please wait for the creator to process",
    no_file_access_permission: "No file access permission",
    file_attribution: "File attribution",
    apply_for_permission: "Apply for permission",
    read_only: "Read only",
    apply_for_edit: "Apply for edit",
    please_remarks: "Please enter application remarks",
    file_deleted: "The file has been deleted, or the creator has closed the share",
    authorization_failure: "Authorization failure",
    notification_message: "Notification message",
    application_documents: "Application documents",
    have_agreed: "Have agreed",
    rejected: "Rejected",
    no_message_received: "No message received",
    link_not: "Link does not exist",
    not_passed: "The application failed, please modify the information or contact the creator and re-apply",
    project_apply: "Application to join project",
    project: "project",
    team: "Team",
    team_apply: "Join team application",
    file: "File"
};
const percenter = {
    return_home: "return home",
    personal_center: "personal center",
    essential_information: "essential information",
    head_portrait: "head portrait",
    avatar_restriction: "Upload images in PNG or JPG format less than 5M",
    modify_profile_picture: "Change",
    username: "Username",
    edit_user_name: "Edit",
    affirm: "Affirm",
    cancel: "Cancel",
    userID: "UserID",
    successtips: "Successfully",
    errortips1: "Failed",
    errortips: "The file size or format is out of limit",
    usernametips_null: "The user name cannot be empty",
    usernametips_length: "The user name cannot exceed 20 characters",
    nicknametips_length: "Nickname cannot be empty and cannot exceed 20 characters",
    error_occurred: "error occurred"
};
const homerightmenu = {
    open: "Open",
    newtabopen: "Opens in a new TAB",
    share: "Share",
    exit_share: "Exit share",
    target_star: "Target star",
    unstar: "Unstar",
    rename: "Rename",
    copyfile: "Create a copy of a file",
    removed_record: "Removed from open record",
    deletefile: "Delete file",
    restore: "Restore",
    completely_delete: "Completely delete",
    copyfile_ok: "Successful replication",
    copyfile_no: "Replication failure",
    "unable_lower": "Unable to move down again",
    "unable_upper": "Unable to move up again"
};
const table = {
    table: "Table",
    table_style: "Table style",
    del_column: "Delete column",
    del_select_row: "Delete selected row",
    del_select_col: "Delete selected col",
    del_table: "Delete table",
    split_cell: "Split cell",
    split_towrow: "Split two rows",
    split_towcol: "Split two cols",
    insert_column: "Insert column",
    merge_cell: "Merge cells",
    top_insert: "Top insert row",
    bottom_insert: "Insert row below",
    left_insert: "Left insert column",
    right_insert: "Right insert column",
    confirm: "Confirm",
    row: "row",
    col: "col",
    insert_table: "Insert table",
    row_num: "Number of rows",
    col_num: "Number of columns",
    column_table: "Designated column table"
};
const Createteam = {
    add_team: "Create a team",
    add_project: "Create a project",
    team_name: "Team name",
    project_name: "Project name",
    team_name_tips: "Enter team name",
    project_name_tips: "Enter project name",
    team_description: "Team description",
    project_description: "Project description",
    team_description_tips: "Enter team description",
    project_description_tips: "Enter project description",
    team_avatar: "Team avatar",
    required: "(Required)",
    optional: "(Optional)",
    avatar_restriction: "Upload images in PNG or JPG format less than 2M",
    movetip: "Move file location",
    move: "move",
    description: "You haven't filled out the team description yet, so go ahead.",
    sharetip: "Shared items received",
    fixed: "Fixed",
    cancelFixed: "Cancel fixed",
    projectdeltitle: "Delete project",
    projectexittitle: "Exit project",
    projectexitcontext: "After exiting the project, you can no longer access the files in the project or use the resources in the project.",
    projectdelcontext: "After deleting a project, the project and all files and data in the project will be deleted.",
    ok_exit: "Still quit",
    ok_delete: "Still delete",
    membertip: "Invite project members",
    projectsetting: "Project access settings",
    membersetting: "Member permission setting",
    projectfilenull: "The project does not have any files",
    projectfilesearchtips: "No matching files",
    projectOptionsA: "Public: Accessible to all team members",
    projectOptionsB: "Non-public: Request access via link only",
    projectPermsA: "Read only",
    projectPermsB: "Can be reviewed",
    projectPermsC: "Editable",
    projecttype: "Project type",
    jurisdiction: "jurisdiction",
    jointips: "Click the link or scan the QR code to join",
    invitation_switch: "Invite link switch",
    copylink: "copylink",
    confirm: "confirm",
    cancel: "cancel",
    joinprojecttipsA: "Apply for a project",
    joinprojecttipsB: "After you join a project, you can access all files and resources in the project",
    joinprojecttipsC: "Application has been sent,",
    joinprojecttipsC1: "You are about to enter the home page of the application. After approval, you can view the contents of the project",
    joinprojecttipsD: "The project invitation has been closed. If you want to join the project, contact the project administrator.",
    joinprojecttipsE: "Back home",
    joinprojecttipsF: "Apply to join",
    all: "All",
    creator: "Creator",
    manager: "Manager",
    editable: "Editable",
    reviewed: "reviewed",
    Readonly: "Read only",
    transferor: "Transferor",
    moveoutproject: "Move out of project",
    membersed: "members",
    username: "User name",
    pertipsA: "Project permissions: Public, accessible to all team members",
    pertipsB: "Project permissions: Non-public, accessible only by inviting members via link",
    Transfertips: "After you transfer Creator rights, you no longer own the project and remain in the project as an administrator.",
    confirmTransfer: "Confirm transfer",
    project: "Project",
    team: "Team",
    welcome: "Welcome to",
    rejectprompt1: "The application to join",
    rejectprompt2: "If you have any questions, please contact the team administrator.",
    rejectprompt3: "If you have any questions, please contact the project administrator.",
    shareprojecttips: "Accessible to all members of the project"
};
const inviteMember = {
    title: "Invite colleagues to join the team",
    permission_set: "Permission settings",
    permission_tips: "Send a link or QR code to colleagues to apply to join",
    permission_switch: "Invitation link switch: ",
    permission_tipsA: "After colleagues apply, they need to be confirmed by the administrator before they can join.",
    copy_success: "Copy Success",
    copy_failure: "Copy Failure"
};
const joinTeam = {
    jointeamtipsA: "Apply to join the team: ",
    jurisdiction: "After joining a team, you can access the projects, files, and resources in the team",
    jointeamtipsB: "Applications for Membership",
    jointeamtipsC: "Application has been sent,",
    jointeamtipsC1: "You will soon enter the application homepage. After approval, you can view the team's content.",
    jointeamtipsD: "Team invitation has been closed. If you want to join the team, please contact the team administrator.",
    read: "Read",
    edit: "Edit"
};
const moveprojectfill = {
    name: "File name: ",
    location: "Current position: ",
    my_file: "My file",
    move_to: "Move files to: ",
    private_file: "Set to private file",
    share_Project: "Shared items received",
    cancel: "cancel"
};
const projectlist = {
    datanull: "No project is added",
    datanull2: "No matching items",
    addproject: "New project",
    project_name: "Project name",
    project_description: "Project description",
    creator: "Creator",
    operation: "Operation",
    enterproject: "Enter project",
    confirm1: "Confirm"
};
const projectpage = {
    menu: "Project menu",
    back: "Return to previous level",
    input_tips: "Click to enter a project description…",
    unpin: "Unpin",
    fixed_items: "Fixed items",
    member: "Invite project members",
    permission: "Member permissions",
    file: "Flie",
    recycle_bin: "recycle bin"
};
const teammember = {
    transferCreator_context: "After transferring creator rights, you will no longer own the team and will remain in the project as an administrator.",
    transferCreator_title: "Transfer creator rights",
    transferCreator_confirm: "Confirm transfer",
    outTeamDialog_context: "After being removed from the team, the member can no longer access the projects and resources in the team.",
    outTeamDialog_title: "Move out of team",
    outTeamDialog_confirm: "Confirm removal",
    exitTeamDialog_context: "After leaving the team, all projects, files and resources in the team will no longer be accessible.",
    modifyNickname_title: "Modifications only for the current team and do not affect names in other teams",
    exitTeamDialog_title: "Leave the team",
    exitTeamDialog_confirm: "Confirm to leave",
    name: "Name",
    modify: "Modify",
    change_teamname: "Change teamname",
    change_name: "Change name",
    team_permission: "Team permissions",
    all: "All",
    creator: "Creator",
    manager: "Manager",
    editable: "Editable",
    Readonly: "Read only",
    leave_team: "Leave the team",
    move_team: "Move out of team",
    transfer_creator: "Transfer creator",
    permission_tips: "Already set to: ",
    transfer_tips: "Transferred to: "
};
const teampage = {
    addproject: "New Project",
    addmember: "Invite members",
    search_default_tipsA: "Search projects/creators",
    search_default_tipsB: "Search members",
    project: "Project",
    members: "Members",
    team_set: "Team settings"
};
const teamprojectmenu = {
    rename: "Rename",
    projectsetting: "Project access settings",
    membersetting: "Member permission settings",
    fixed: "Fixed",
    cancelFixed: "Cancel fixed",
    projectexittitle: "Exit project",
    projectdeltitle: "Delete project"
};
const teamsetting = {
    team_name: "Team name",
    edit_name: "Edit name",
    team_description: "Team description",
    edit_description: "Edit description",
    team_avatar: "Team avatar",
    edit_avatar: "Edit avatar",
    avatar_restriction: "Upload images in PNG or JPG format less than 2M",
    disband_team: "Disband the team",
    disband_team_tips: "Disband the team and delete team files, which cannot be recovered.",
    leave_team: "Leave the team",
    leave_team_tips: "After leaving the team, you will no longer be able to view team projects and resources",
    disband_team_tipsB: "After the team is disbanded, all project data contained in the team will be completely deleted and cannot be recovered.",
    leave: "Leave",
    disband: "Disband",
    confirm: "Confirm",
    cancel: "Cancel",
    title_name1: "Change team name",
    title_name2: "Modify team description",
    title_name3: "Dissolve the team",
    title_name4: "Leaving the team"
};
const shadow = {
    shadow_stting: "Shadow",
    only_used: "Only rectangles, circles and containers can be used",
    shadow_setting: "Shadow setting",
    position: "position",
    color: "colour",
    effect: "effect",
    blur: "Blur",
    extend: "spread",
    fill_is_visible: "Used when the container's fill is visible"
};
shadow[zt.Inner] = "Inner shadow";
shadow[zt.Outer] = "Outer shadow";
const blur = {
    blur: "Blur",
    blur_setting: "Blur setting"
};
blur[ot.Gaussian] = "Gaussian blur";
blur[ot.Background] = "Background blur";
blur[ot.Zoom] = "Zoom blur";
blur[ot.Motion] = "Motion blur";
const cutoutExport = {
    cutoutNotBool: "The cutmap layer does not support Boolean operations",
    cutout: "Cutout",
    create_cut_chart_and_export: "Create cut chart and export",
    trim_transparent_pixels: "Trim transparent pixels",
    canvas_background_color: "Canvas background color",
    export: "Export",
    preview: "Preview",
    default: "Default",
    ios_presets: "iOS presets",
    android_presets: "Android presets",
    export_cutout: "Export cutout",
    repeat: "Same name as other slices"
};
cutoutExport[mt.Prefix] = "Prefix";
cutoutExport[mt.Suffix] = "Suffix";
const compos = {
    duplicate_name: "Name duplicate, please reenter",
    default_text_input: "Please enter the default text",
    attr_name_input: "Please enter the attribute name",
    place_select_instance: "Select a component instance",
    place_select_layer: "Please select layer",
    compos_instance: "Component instance",
    select_layer: "Select layer",
    show: "show",
    hidden: "Hidden",
    text_layer_null: "The text layer is empty",
    instance_null: "A component instance is empty",
    text_content: "Text content",
    layer_isShow: "Layer display or not",
    instance_attr: "Instance attribute",
    untie: "untie",
    reset_all_attr: "Reset all properties",
    layer_show: "Layer display",
    close_icon: "Close icon",
    compos_state: "Component state",
    toggle_instance: "Switch instance",
    instance_toggle: "Instance switch",
    compos_attr: "Component attribute",
    delect_attr_type: "Select the attribute type",
    display_state: "Display status",
    search_compos: "Search component",
    compos: "Component",
    attr_name: "Attribute name",
    state: "State",
    lib_local: "Local",
    lib_line: "Path",
    gocomp: "Go to main component",
    datail: "View details",
    attri_1: "Attribute 1",
    dlt: "Default",
    dltv: "Default Value",
    attri: "Attribute",
    add_new: "Add new",
    error_1: "Wrong Selection",
    error_2: "Wrong Selection",
    error_3: "Wrong Selection",
    validate_info_1: "Null Layer",
    validate_info_2: "Invalid Name",
    validate_info_3: "Invalid Default Value",
    conflict: "Conflict",
    conflict_2: "Conflict",
    confirm: "Confirm",
    circle_warning: "Wrong reference",
    invalid_compos: "Invalid Symbol",
    toggle_list_style: "list style"
};
const lable = {
    development: "Development mode",
    selectLayer: "Please select layer",
    copyfailure: "Copy the failure",
    border: "border",
    position: "position",
    pure_color: "Pure color",
    thickness: "thickness",
    style: "style",
    dotted_line: "Dotted line",
    solid_line: "Solid line",
    code: "Code",
    copy_all: "Copy all",
    copy: "Copy",
    fill: "Fill",
    layer_info: "Layer information",
    name: "name",
    posi: "position",
    size: "size",
    rotate: "rotate",
    raduis: "raduis",
    opacity: "opacity",
    select_multiple_layers: "Already select multiple layers",
    development_platform: "Development platform",
    applet_of_WeChat: "Applet of WeChat",
    pixel: "pixel",
    copied: "copied",
    click_copy: "Click copy",
    text: "text",
    content: "content",
    font: "font",
    type_size: "Type size",
    word_weight: "Word weight",
    word_space: "LineSpacing",
    line_height: "Line height",
    para_spacing: "Paragraph spacing"
};
const report = {
    title: "Report",
    tips: "Please select the type of problem you want to report and fill in the detailed report content. ",
    type: "report type",
    type_normal: "Please select the type",
    type_value1: "Fraud",
    type_value2: "Pornographic and vulgar",
    type_value3: "Inappropriate speech",
    type_value4: "other",
    report_content: "Report content",
    report_normal: "Please fill in the details",
    upload_img: "Upload screenshot",
    select_img: "Add file",
    img_tips: "Add png, jpg format files, up to 5 can be uploaded",
    filet_ips: "Allow the use of the current document to determine the use of reported evidence",
    submit: "Submit",
    cancel: "cancel"
};
const setting = {
    pixelAlignMentOn: "Pixel Align On",
    pixelAlignMentOff: "Pixel Align Off",
    pixelGridOn: "Pixel grid visible",
    pixelGridOff: "Pixel grid hidden"
};
const miniprogram = {
    home: "Home",
    my_file: "My File",
    team: "Team",
    about: "About",
    privacy: "Privacy Policy",
    serve: "Online Services Agreement",
    search: "There are no matching files",
    listnull: "There are no files in the current list",
    flushed: "flushed",
    recent: "Recent",
    share: "Shares received",
    star: "Started",
    projectnull: "Not yet part of the project",
    share_title: "Share",
    permissions: "Permission settings",
    myself: "Myself",
    confirm: "Application required",
    share_users: "People who have joined the sharing",
    share_to: "Share To",
    copy_link: "Copy Link",
    share_users_null: "Members who did not join",
    team_jion_null: "Haven't joined the team yet"
};
const product = {
    name: "Moss Design",
    subtitle: "Collaborative professional product design software",
    description: "Moss Design is a professional product design software that supports online collaboration. It supports product manuscript writing, professional UI design, and obtaining design annotations, providing a one-stop collaborative design experience for product development teams.",
    keywords: "Moss Design, Product Design, Collaborative Design, UI Design"
};
const pattern = {
    image: "image"
};
pattern[Mt.Fill] = "Fill";
pattern[Mt.Stretch] = "Stretch";
pattern[Mt.Fit] = "Fit";
pattern[Mt.Tile] = "Tile";
const start = {
    title: "Write anytime and Drawing anything",
    description_1: "Professional product design software, support product document writing, UI design, design presentation, marking delivery,",
    description_2: "Provide one-stop collaborative design experience for product development team"
};
const moss = {};
const design = {
    title: "Professional design",
    description_1: "Professional vector editing tools to meet the fine editing; Efficient component functionality, ",
    description_2a: "and compatible with Sketch, Figma(",
    description_2b: "in development, stay tuned",
    description_2c: ") and other major file formats",
    description_3: "for seamless file migration"
};
const cooperation = {
    title: "Collaboration",
    description_1: "Link invitation, online real-time collaboration, access to the latest manuscripts at any time.",
    description_2: "Document fixed comment, efficient communication, so that thinking at any time collision new sparks.",
    description_3: "Designers easily deliver, map resources, layout parameters, engineers at their fingertips."
};
const platform = {
    title: "Seamless across terminals",
    description: "Real-time synchronization of multi-end data, editing and creation anytime and anywhere"
};
const end = {
    title: "Design tools that each participant can participate in efficiently"
};
const pub = {
    login_1: "Free experience",
    login_2: "Experience now for free"
};
const lang_en = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Createteam,
    apply,
    attr,
    blur,
    bool,
    clipboard,
    color,
    comment,
    compos,
    cooperation,
    cutoutExport,
    date,
    design,
    end,
    fileMenu,
    frame,
    home,
    homerightmenu,
    inviteMember,
    joinTeam,
    lable,
    login,
    message,
    miniprogram,
    moss,
    moveprojectfill,
    navi,
    opacity,
    pageMenu,
    pattern,
    percenter,
    permission,
    platform,
    preview,
    product,
    projectlist,
    projectpage,
    pub,
    report,
    search,
    setting,
    shadow,
    shape,
    share,
    start,
    system,
    table,
    teammember,
    teampage,
    teamprojectmenu,
    teamsetting
}, Symbol.toStringTag, { value: "Module" }));
const i18n = createI18n({
    locale,
    legacy: false,
    //this.$i18n.locale // 通过切换locale的值来实现语言切换
    messages: {
        //引入语言包
        "zh": lang_zh,
        // 中文语言包
        "en": lang_en
        // 英文语言包
    }
});
const app = createApp(_sfc_main$1);
app.use(i18n);
app.component("svg-icon", _sfc_main);
app.mount("#app");