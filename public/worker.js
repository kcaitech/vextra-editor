!function(){"use strict";var e={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let t;const n=new Uint8Array(16);function s(){if(!t&&(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!t))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(n)}const i=[];for(let e=0;e<256;++e)i.push((e+256).toString(16).slice(1));var o,a,r,d,c,l=function(t,n,o){if(e.randomUUID&&!n&&!t)return e.randomUUID();const a=(t=t||{}).random||(t.rng||s)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,n){o=o||0;for(let e=0;e<16;++e)n[o+e]=a[e];return n}return function(e,t=0){return(i[e[t+0]]+i[e[t+1]]+i[e[t+2]]+i[e[t+3]]+"-"+i[e[t+4]]+i[e[t+5]]+"-"+i[e[t+6]]+i[e[t+7]]+"-"+i[e[t+8]]+i[e[t+9]]+"-"+i[e[t+10]]+i[e[t+11]]+i[e[t+12]]+i[e[t+13]]+i[e[t+14]]+i[e[t+15]]).toLowerCase()}(a)};!function(e){e[e.DocOp=0]="DocOp",e[e.DocResourceUpload=1]="DocResourceUpload"}(o||(o={})),function(e){e[e.Return=0]="Return",e[e.OpenTunnel=1]="OpenTunnel",e[e.CloseTunnel=2]="CloseTunnel",e[e.TunnelData=3]="TunnelData"}(a||(a={})),function(e){e[e.InitResult=0]="InitResult",e[e.CmdReturn=1]="CmdReturn",e[e.CloseTunnel=2]="CloseTunnel",e[e.TunnelData=3]="TunnelData"}(r||(r={})),function(e){e.Success="success",e.Fail="fail"}(d||(d={})),function(e){e[e.Text=1]="Text",e[e.Binary=2]="Binary"}(c||(c={}));class u{port;server;info;tunnelId="";tunnelType;pendingCmdList=new Map;sendToServerHandler;receivingData=void 0;constructor(e,t,n){this.port=e,this.server=t,this.info=n,this.tunnelType=n.tunnelType}async start(){const e=await this.sendToServer(a.OpenTunnel,{data:this.info.data},!0),t=await this.getCmdResult(e);return!(!t||"string"!=typeof t.data.tunnel_id||""===t.data.tunnel_id||(this.tunnelId=t.data.tunnel_id,0))}async receiveFromClient(e){const t=e.data;if(console.log("receiveFromClient",this.tunnelId,t),t.close)return void this.close(!0);const n=t instanceof ArrayBuffer;if(n&&void 0===this.receivingData)return void console.log("数据传输错误：缺少数据头");if(n||void 0===this.receivingData||(console.log("数据传输错误：缺少数据段"),this.receivingData=void 0),n)return this.server.send(t),void(this.receivingData=void 0);t.dataType===c.Binary&&(this.receivingData=t);const s=await this.sendToServer(a.TunnelData,t,t.isListened,t.cmdId);if(t.isListened){if(!t.cmdId)return void console.log("数据传输错误：data.isListened=true时cmdId不能为空");const e=await this.getCmdResult(s);if(!e)return;this.sendToClient({cmdId:t.cmdId,isListened:!0,data:e})}}sendToClient(e){if(e.isListened&&!e.cmdId)return void console.log("数据传输错误：data.isListened=false时cmdId不能为空");const t=e.data,n=t instanceof ArrayBuffer;n&&(e.data=void 0),e.dataType=n?c.Binary:c.Text,this.port.postMessage(e),n&&this.port.postMessage(t,[t])}receiveFromServer(e){switch(e.cmd_type){case r.CmdReturn:const t=e.data?.cmd_id;if("string"!=typeof t||""===t)return;if(!this.pendingCmdList.has(t))return;this.pendingCmdList.get(t).resolve({status:e.status??d.Fail,message:e.message,data:e.data});break;case r.CloseTunnel:this.close();break;case r.TunnelData:const n=e.data?.data_type;if(n!==c.Text&&n!==c.Binary){console.log("不支持的数据类型",n);break}if(n===c.Binary&&!(e.data.data instanceof ArrayBuffer)){console.log("数据类型错误：非二进制数据");break}this.sendToClient({data:e.data.data});break;default:console.log("不支持的cmd_type",e.cmd_type)}}async sendToServer(e,t,n=!1,s){"string"==typeof s&&""!==s||(s=l());const i={cmd_id:t?.cmdId,tunnel_id:this.tunnelId?this.tunnelId:void 0,data_type:t?.dataType,data:t?.data},o={cmd_type:e,cmd_id:s,tunnel_type:this.tunnelType,data:i};if(n){let e=()=>{};const t=new Promise((t=>e=t));this.pendingCmdList.set(s,{cmd:o,promise:t,resolve:e}),this.sendToServerHandler?.(s,o)}return await this.server.send(JSON.stringify(o)),s}async getCmdResult(e){if(!this.pendingCmdList.has(e))return;const t=this.pendingCmdList.get(e),n=await t.promise;return this.pendingCmdList.delete(e),n}setSendToServerHandler(e){this.sendToServerHandler=e}close(e=!1){e&&this.sendToServer(a.CloseTunnel,{tunnel_id:this.tunnelId}),this.port.close()}}function m(e){return new Promise((t=>setTimeout(t,e)))}class h{token;ws=void 0;isConnected=!1;isConnecting=!1;connectPromise=void 0;onmessage;id="";constructor(e,t){this.token=e,this.onmessage=t}async connect(){if(this.isConnected)return!0;if(this.isConnecting&&this.connectPromise)return await this.connectPromise;this.isConnecting=!0;let e=()=>{};this.connectPromise=new Promise((t=>e=t));try{this.ws=new WebSocket("wss://protodesign.cn/api_test/v1/communication"),this.ws.binaryType="arraybuffer"}catch(t){return console.log(t),this.ws=void 0,e(!1),this.isConnecting=!1,!1}return await new Promise((e=>this.ws.onopen=t=>e())),this.ws.send(JSON.stringify({token:this.token})),await new Promise((e=>{this.ws.onmessage=t=>{try{const n=JSON.parse(t.data);if(n.cmd_type!==r.InitResult||"string"!=typeof n.cmd_id||""===n.cmd_id||n.status!==d.Success||!n.data?.communication_id)return void e(!1);this.id=n.data.communication_id,e(!0)}catch(t){console.log(t),e(!1)}}}))?(this.ws.onmessage=this.onmessage.bind(this),e(!0),this.isConnecting=!1,this.isConnected=!0,this.ws.onclose=e=>{this.isConnected=!1},!0):(this.ws=void 0,e(!1),this.isConnecting=!1,!1)}async send(e){if(!this.isConnected)for(;!await this.connect();)await m(1e3);this.ws.send(e)}}const p=self;let f;const g=new Map,v=new Map;let y,T;function w(e){const t=e.data instanceof ArrayBuffer,n=t?e.data:JSON.parse(e.data);if(t&&(void 0===y||void 0===T))return void console.log("数据传输错误：缺少数据头");if(t||void 0===y&&void 0===T||(console.log("数据传输错误：缺少数据段"),y=void 0,T=void 0),t)return T.data.data=n,y.receiveFromServer(T),y=void 0,void(T=void 0);const s=n.cmd_id;if("string"!=typeof s||""===s)return void console.log("cmd_id参数错误",s);const i=n.data?.cmd_id,o=n.data?.tunnel_id,a=n.cmd_type===r.TunnelData,d=a?g.get(o):v.get(i);if(d){if(a&&n.data?.data_type===c.Binary)return y=d,void(T=n);d.receiveFromServer(n),console.log("receiveFromServer",n)}}p.onconnect=e=>{const t=e.ports[0];t.onmessage=async e=>{const n=e.data,s={name:n.name,id:""};if(!n.name)return console.log("name参数错误",n.name),void t.postMessage(s);void 0===f&&(f=new h(n.token,w),f.connect()),n.id=l();const i=new u(t,f,n);i.setSendToServerHandler(((e,t)=>v.set(e,i))),await i.start()&&(console.log("tunnel创建成功",i.tunnelId),s.id=i.tunnelId,g.set(i.tunnelId,i),t.onmessage=i.receiveFromClient.bind(i)),t.postMessage(s)}}}();