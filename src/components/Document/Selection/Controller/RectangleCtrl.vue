<script setup lang='ts'>
import { defineProps, computed, onMounted, onUnmounted, watchEffect, ref } from "vue";
import { Context } from "@/context";
import { Matrix } from '@kcdesign/data/basic/matrix';
import { Action, CtrlElementType, WorkSpace } from "@/context/workspace";
import { XY, ClientXY, PageXY } from "@/context/selection";
import { translate, adjustLT2, adjustLB2, adjustRT2, adjustRB2, translateTo } from "@kcdesign/data/editor/frame";
import CtrlBar from "./Bars/CtrlBar.vue";
import CtrlPoint from "./Points/CtrlPoint.vue";
import { Point, Bar } from "../SelectionView.vue";
import { GroupShape, Shape, ShapeType } from "@kcdesign/data/data/shape";
import { createRect, getAxle, getRectWH } from "@/utils/common";
import { fourWayWheel, Wheel, forCtrlRect } from "@/utils/wheel";
import { keyboardHandle as handle } from "@/utils/controllerFn";
import { Selection } from "@/context/selection";
import { groupPassthrough, forGroupHover } from "@/utils/scout";
interface Props {
    context: Context,
    isController: boolean
    controllerFrame: Point[],
    rotate: number
}
const props = defineProps<Props>();
const workspace = computed(() => props.context.workspace);
const matrix = new Matrix();
const dragActiveDis = 3;
const offset = 16;
const visible = ref<boolean>(true);
let timer: any;
const duration: number = 250; // 双击判定时长 ms
let isDragging = false;
let startPosition: ClientXY = { x: 0, y: 0 };
let startPositionOnPage: PageXY = { x: 0, y: 0 };
let root: ClientXY = { x: 0, y: 0 };
let shapes: Shape[] = [];
let controllerStyle: string;
let wheel: Wheel | undefined = undefined;
const editing = ref<boolean>(false); // 是否进入路径编辑状态
const points = computed<Point[]>(() => {
    const [lt, rt, rb] = props.controllerFrame;
    const { width, height } = getRectWH(lt.x, lt.y, rt.x, rt.y, rb.x, rb.y);
    const p1: Point = { x: 0, y: 0, type: CtrlElementType.RectLT };
    const p2: Point = { x: width, y: 0, type: CtrlElementType.RectRT };
    const p3: Point = { x: width, y: height, type: CtrlElementType.RectRB };
    const p4: Point = { x: 0, y: height, type: CtrlElementType.RectLB };
    const ps: Point[] = [p1, p2, p4, p3];
    ps.forEach(p => {
        p.x -= offset;
        p.y -= offset;
    })
    return ps;
});
const bars = computed<Bar[]>(() => {
    const [lt, rt, rb] = props.controllerFrame;
    const { width, height } = getRectWH(lt.x, lt.y, rt.x, rt.y, rb.x, rb.y);
    const b1: Bar = { width, height, type: CtrlElementType.RectTop };
    const b2: Bar = { width, height, type: CtrlElementType.RectRight };
    const b3: Bar = { width, height, type: CtrlElementType.RectBottom };
    const b4: Bar = { width, height, type: CtrlElementType.RectLeft };
    const bs: Bar[] = [b1, b2, b3, b4];
    return bs;
});
const axle = computed<ClientXY>(() => {
    const [lt, rt, rb, lb] = props.controllerFrame;
    return getAxle(lt.x, lt.y, rt.x, rt.y, rb.x, rb.y, lb.x, lb.y);
});
function updater(t?: number) {
    getRect(props.controllerFrame);
    if (t === Selection.CHANGE_SHAPE) { // 选中的图形发生改变，初始化控件
        initController();
    }
}
function workspaceUpdate(t?: number) {
    if (t === WorkSpace.TRANSLATING) {
        visible.value = !workspace.value.isTranslating;
    } else if (t === WorkSpace.CHECKSTATUS) {
        checkStatus();
    }
}

function preTodo(e: MouseEvent) { // 移动之前做的准备
    if (e.button === 0) { // 当前组件只处理左键事件，右键事件冒泡出去由父节点处理
        workspace.value.menuMount(false); // 取消右键事件
        wheel = fourWayWheel(props.context, { rolling: forCtrlRect });
        const action = workspace.value.action;
        if (action === Action.AutoV && props.isController) {
            e.stopPropagation(); // props.isController 当控制权在selection时，不要冒泡出去, 否则父节点也会被控制
            shapes = props.context.selection.selectedShapes;
            if (!shapes.length) return;
            root = workspace.value.root;
            document.addEventListener('mousemove', mousemove);
            document.addEventListener('mouseup', mouseup);
        }
    }
}
function handleDblClick() {
    matrix.reset(workspace.value.matrix);
    const selected = props.context.selection.selectedShapes;
    if (selected.length === 1) {
        const item = selected[0];
        if (item.type === ShapeType.Group) {
            const scope = (item as GroupShape).childs;
            const scout = props.context.selection.scout;
            const target = groupPassthrough(scout!, scope, startPositionOnPage);
            if (target) {
                props.context.selection.selectShape(target);
            }
        } else {
            editing.value = !editing.value;
        }
        timerClear();
    }
}
function pickerFromSelectedShapes() {
    const selected = props.context.selection.selectedShapes;
    if (selected.length > 1) {
        const target: Shape | undefined = props.context.selection.getShapesByXY_beta(startPositionOnPage, false, selected).reverse()[0];
        props.context.selection.selectShape(target);
    } else if (selected.length === 1 && selected[0].type === ShapeType.Group) {
        const isHasTarget = forGroupHover(props.context.selection.scout!, (selected[0] as GroupShape).childs, startPositionOnPage);
        if (!isHasTarget) props.context.selection.selectShape();
    }
    if (props.context.selection.hoveredShape) {
        props.context.selection.selectShape(props.context.selection.hoveredShape);
    }
}
function mousedown(e: MouseEvent) {
    setPosition(e);
    if (timer) { // 双击预定时间还没过，再次mousedown，则判定为双击
        handleDblClick();
    }
    initTimer(); // 每次点击都应该开始预定下一次可以形成双击的点击
    preTodo(e);
}
function mousemove(e: MouseEvent) {
    if (e.button === 0) { //只处理鼠标左键按下时的移动
        const { clientX, clientY } = e;
        if (wheel) {
            wheel.moving(e);
        }
        const mousePosition: ClientXY = { x: clientX - root.x, y: clientY - root.y };
        if (isDragging) {
            workspace.value.translating(true); // 编辑器开始处于transforming状态 ---start transforming---
            props.context.selection.unHoverShape(); // 当编辑器处于transforming状态时, 此时的编辑器焦点为选中的图层, 应该取消被hover图层的hover状态, 同时不再给其他图层赋予hover状态
            transform(shapes, startPosition, mousePosition);
            startPosition = { ...mousePosition };
        } else {
            if (Math.hypot(mousePosition.x - startPosition.x, mousePosition.y - startPosition.y) > dragActiveDis) { // 是否开始移动的判定条件
                isDragging = true;
                props.context.repo.start('transform', {}); // 开启当前事务,事务在结束(commit/rollback)之前只能开启一次!!! ---begin transaction---
            }
        }
    }
}
function transform(shapes: Shape[], start: ClientXY, end: ClientXY) {
    const ps = matrix.inverseCoord(start.x, start.y);
    const pe = matrix.inverseCoord(end.x, end.y);
    const selection = props.context.selection;
    let targetParent;
    const artboardOnStart = selection.getClosetArtboard(ps, undefined, shapes); // 点击位置存在容器
    if (artboardOnStart && artboardOnStart.type != ShapeType.Page) {
        targetParent = props.context.selection.getClosetArtboard(pe, artboardOnStart);
    } else {
        targetParent = props.context.selection.getClosetArtboard(pe);
    }
    // 对选中的每个图层进行变换
    for (let i = 0; i < shapes.length; i++) {
        if (shapes[i].isLocked) continue; // 🔒住不让动
        translate(shapes[i], pe.x - ps.x, pe.y - ps.y);
        if (shapes[i].parent?.id !== targetParent.id) {
            shapeMoveNoTransaction(shapes[i], targetParent);
        }
    }
    props.context.repo.transactCtx.fireNotify(); // 通常情况下,当事务结束(commit),系统会根据事务中的改动更新视图. 而移动的过程中,整个移动(transform)的事务并未结束,即尚未commit,此时视图无法得到更新, 可以用此方法更新事务过程中的视图 ---before end transaction---
}
// 自身不带事务的图形移动, 只能在事务开启之后调用
function shapeMoveNoTransaction(shape: Shape, targetParent: Shape) {
    const origin: GroupShape = ((shape.parent || props.context.selection.selectedPage) as GroupShape);
    origin.removeChild(shape);
    const { x, y } = shape.frame2Page();
    targetParent.addChild(shape);
    translateTo(shape, x, y);
}
function mouseup(e: MouseEvent) {
    if (e.button === 0) { // 只处理鼠标左键按下时的抬起
        if (isDragging) {
            props.context.repo.commit({}); // 如果触发了拖拽状态,必定开启了事务 ---end transaction---
            isDragging = false;
            workspace.value.translating(false); // 编辑器关闭transforming状态  ---end transforming---
        } else {
            pickerFromSelectedShapes(); // 多选时的单纯点击则取消多选
        }
        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
        if (wheel) wheel = wheel.remove(); // 卸载滚轮
        if (workspace.value.isPreToTranslating) workspace.value.preToTranslating(); // 取消移动准备
    }
}
function handlePointAction(type: CtrlElementType, p1: XY, p2: XY, deg?: number, aType?: 'rotate' | 'scale') {
    matrix.reset(workspace.value.matrix);
    const shapes = props.context.selection.selectedShapes;
    for (let i = 0; i < shapes.length; i++) {
        let item = shapes[i];
        if (item.isLocked) continue; // 🔒住不让动
        if (aType === 'rotate') {
            const newDeg = (item.rotation || 0) + (deg || 0);
            item.rotate(newDeg);
        } else {
            const p1OnPage = matrix.inverseCoord(p1.x, p1.y); // page
            const p2Onpage = matrix.inverseCoord(p2.x, p2.y);
            if (type === CtrlElementType.RectLT) {
                adjustLT2(item, p2Onpage.x, p2Onpage.y);
            } else if (type === CtrlElementType.RectRT) {
                adjustRT2(item, p2Onpage.x, p2Onpage.y);
            } else if (type === CtrlElementType.RectRB) {
                adjustRB2(item, p2Onpage.x, p2Onpage.y);
            } else if (type === CtrlElementType.RectLB) {
                adjustLB2(item, p2Onpage.x, p2Onpage.y);
            } else if (type === CtrlElementType.RectTop) {
                const m = item.matrix2Page();
                const p1 = m.inverseCoord(p1OnPage.x, p1OnPage.y);
                const p2 = m.inverseCoord(p2Onpage.x, p2Onpage.y);
                const dy = p2.y - p1.y;
                const { x, y } = m.computeCoord(0, dy);
                adjustLT2(item, x, y);
            } else if (type === CtrlElementType.RectRight) {
                const m = item.matrix2Page();
                const p1 = m.inverseCoord(p1OnPage.x, p1OnPage.y);
                const p2 = m.inverseCoord(p2Onpage.x, p2Onpage.y);
                const dx = p2.x - p1.x;
                const { x, y } = m.computeCoord(item.frame.width + dx, 0);
                adjustRT2(item, x, y);
            } else if (type === CtrlElementType.RectBottom) {
                const m = item.matrix2Page();
                const p1 = m.inverseCoord(p1OnPage.x, p1OnPage.y);
                const p2 = m.inverseCoord(p2Onpage.x, p2Onpage.y);
                const dy = p2.y - p1.y;
                const { x, y } = m.computeCoord(item.frame.width, item.frame.height + dy);
                adjustRB2(item, x, y);
            } else if (type === CtrlElementType.RectLeft) {
                const m = item.matrix2Page();
                const p1 = m.inverseCoord(p1OnPage.x, p1OnPage.y);
                const p2 = m.inverseCoord(p2Onpage.x, p2Onpage.y);
                const dx = p2.x - p1.x;
                const { x, y } = m.computeCoord(dx, item.frame.height);
                adjustLB2(item, x, y);
            }
        }
    }
}
function checkStatus() { // 检查是否可以直接开始移动
    if (workspace.value.isPreToTranslating) { // 可以开始移动，该状态开启之后将跳过mousedown事件
        const start = workspace.value.startPoint;
        setPosition(start!);
        preTodo(start!);
    }
}
function setPosition(e: MouseEvent) {
    const { clientX, clientY } = e;
    matrix.reset(workspace.value.matrix);
    root = workspace.value.root;
    startPosition = { x: clientX - root.x, y: clientY - root.y };
    startPositionOnPage = matrix.inverseCoord(startPosition.x, startPosition.y);
}
function keyboardHandle(e: KeyboardEvent) {
    handle(e, props.context);
}
function getRect(points: Point[]) {
    controllerStyle = createRect(points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y);
}
function initController() {
    editing.value = false; // 初始状态不为编辑状态
    initTimer(); // 控件生成之后立马开始进行双击预定，该预定将在duration(ms)之后取消
}
function initTimer() {
    clearTimeout(timer); // 先取消原有的预定
    timer = setTimeout(() => { // 设置新的预定
        clearTimeout(timer); // 取消预定
        timer = null;
    }, duration)
}
function timerClear() {
    if (timer) {
        clearTimeout(timer);
        timer = null;
    }
}
function windowBlur() {
    if (isDragging) { // 窗口失焦,此时鼠标事件(up,move)不再受系统管理, 此时需要手动关闭已开启的状态
        workspace.value.translating(false);
        props.context.repo.commit({});
        isDragging = false;
        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
    }
    if (wheel) wheel = wheel.remove(); // 卸载滚轮
    if (workspace.value.isPreToTranslating) workspace.value.preToTranslating();  // 取消移动准备
    timerClear();
}
onMounted(() => {
    props.context.selection.watch(updater);
    props.context.workspace.watch(workspaceUpdate);
    window.addEventListener('blur', windowBlur);
    document.addEventListener('keydown', keyboardHandle);
    checkStatus();
    initController();
})

onUnmounted(() => {
    props.context.selection.unwatch(updater);
    props.context.workspace.unwatch(workspaceUpdate);
    shapes.length = 0;
    window.removeEventListener('blur', windowBlur);
    document.removeEventListener('keydown', keyboardHandle);
    timerClear();
})

watchEffect(() => { updater() })
</script>
<template>
    <div :class="{ 'ctrl-rect': true, 'un-visible': !visible, editing }" @mousedown="mousedown" :style="controllerStyle">
        <CtrlBar v-for="(bar, index) in  bars" :key="index" :context="props.context" :width="bar.width" :height="bar.height"
            :ctrl-type="bar.type" :rotate="props.rotate" @transform="handlePointAction"></CtrlBar>
        <CtrlPoint v-for="(point, index) in points" :key="index" :context="props.context" :axle="axle" :point="point"
            :rotate="props.rotate" @transform="handlePointAction" :controller-frame="props.controllerFrame"></CtrlPoint>
    </div>
</template>
<style lang='scss' scoped>
.ctrl-rect {
    position: absolute;
    box-sizing: border-box;
    background-color: transparent;
}

.un-visible {
    opacity: 0;
}

.editing {
    background-color: rgba($color: #2561D9, $alpha: 0.15);
}
</style>